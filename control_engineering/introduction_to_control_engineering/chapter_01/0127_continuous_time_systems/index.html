<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/control_engineering/introduction_to_control_engineering/chapter_01/0127_continuous_time_systems/" rel="canonical"/>
<link href="../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>연속 시간 시스템 (Continuous-Time Systems) - 소프트웨어 융합</title>
<link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc5f0\uc18d \uc2dc\uac04 \uc2dc\uc2a4\ud15c\uc758 \uc815\uc758", url: "#_top", children: [
          ]},
          {title: "\uc5f0\uc18d \uc2dc\uac04 \uc2dc\uc2a4\ud15c\uc758 \uc218\ud559\uc801 \ubaa8\ub378\ub9c1", url: "#_2", children: [
          ]},
          {title: "\uc0c1\ud0dc \uacf5\uac04 \ubaa8\ub378\uc758 \ud574\uc11d", url: "#_3", children: [
          ]},
          {title: "\uc804\ub2ec \ud568\uc218\uc640 \ub77c\ud50c\ub77c\uc2a4 \ubcc0\ud658", url: "#_4", children: [
          ]},
          {title: "\uc5f0\uc18d \uc2dc\uac04 \uc2dc\uc2a4\ud15c\uc758 \uc548\uc815\uc131", url: "#_5", children: [
          ]},
          {title: "\uc5f0\uc18d \uc2dc\uac04 \uc2dc\uc2a4\ud15c\uc758 \uc751\ub2f5 \ubd84\uc11d", url: "#_6", children: [
              {title: "\uc2dc\uac04 \uc751\ub2f5 (Time Response)", url: "#time-response" },
              {title: "\uc815\uc0c1 \uc0c1\ud0dc \uc751\ub2f5 (Steady-State Response)", url: "#steady-state-response" },
          ]},
          {title: "\uc8fc\ud30c\uc218 \uc751\ub2f5 (Frequency Response)", url: "#frequency-response", children: [
          ]},
          {title: "\uc5f0\uc18d \uc2dc\uac04 \uc2dc\uc2a4\ud15c\uc758 \uc0c1\ud0dc \uac00\ubcc0\uc131 (Controllability)\uc640 \uad00\uce21 \uac00\ub2a5\uc131 (Observability)", url: "#controllability-observability", children: [
              {title: "\uc81c\uc5b4 \uac00\ub2a5\uc131 (Controllability)", url: "#controllability" },
              {title: "\uad00\uce21 \uac00\ub2a5\uc131 (Observability)", url: "#observability" },
          ]},
          {title: "\uc5f0\uc18d \uc2dc\uac04 \uc2dc\uc2a4\ud15c\uc758 \uc0c1\ud0dc \ud53c\ub4dc\ubc31 \uc81c\uc5b4", url: "#_7", children: [
          ]},
          {title: "\uc5f0\uc18d \uc2dc\uac04 \uc2dc\uc2a4\ud15c\uc5d0\uc11c\uc758 \uad00\uce21\uae30 \uc124\uacc4", url: "#_8", children: [
          ]},
          {title: "\uc5f0\uc18d \uc2dc\uac04 \uc2dc\uc2a4\ud15c\uc758 \ud3f4-\uc601(Poles and Zeros)", url: "#-poles-and-zeros", children: [
              {title: "\ud3f4 (Poles)", url: "#poles" },
              {title: "\uc601 (Zeros)", url: "#zeros" },
              {title: "\ud3f4-\uc601 \ub3c4\ud45c (Pole-Zero Plot)", url: "#-pole-zero-plot" },
          ]},
          {title: "\uc0c1\ud0dc \uc804\uc774 \ud589\ub82c (State Transition Matrix)", url: "#state-transition-matrix", children: [
          ]},
          {title: "\uc0c1\ud0dc \ud53c\ub4dc\ubc31\uacfc \ud3f4 \ubc30\uce58 (Pole Placement)", url: "#pole-placement", children: [
          ]},
          {title: "\ub9ac\uc544\ud478\ub178\ud504 \uc548\uc815\uc131 (Lyapunov Stability)", url: "#lyapunov-stability", children: [
              {title: "\ub9ac\uc544\ud478\ub178\ud504 \ud568\uc218 (Lyapunov Function)", url: "#lyapunov-function" },
              {title: "\ub9ac\uc544\ud478\ub178\ud504 \ubc29\uc815\uc2dd (Lyapunov Equation)", url: "#lyapunov-equation" },
          ]},
          {title: "\ub9ac\uc544\ud478\ub178\ud504 \uc9c1\uc811 \ubc29\ubc95 (Lyapunov Direct Method)", url: "#lyapunov-direct-method", children: [
          ]},
          {title: "\uc0c1\ud0dc \uada4\uc801 (State Trajectory)", url: "#state-trajectory", children: [
          ]},
          {title: "\uc120\ud615 \uc5f0\uc18d \uc2dc\uac04 \uc2dc\uc2a4\ud15c\uc758 \uc81c\uc5b4\uae30 \uc124\uacc4", url: "#_9", children: [
          ]},
        ];

    </script>
<script src="../../../../js/base.js"></script>
<script src="../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0128_discrete_time_system/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0128_discrete_time_system/">
        제어시스템에서 이산 시간 시스템
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0126_probabilistic_systems/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0126_probabilistic_systems/">
        제어시스템에서 확률적 시스템
      </a>
</div>
</div>
<h3 id="_1">연속 시간 시스템의 정의</h3>
<p>연속 시간 시스템(Continuous-Time System)은 시간 변수가 연속적으로 변화하는 시스템을 의미한다. 이러한 시스템은 입력과 출력 신호가 시간에 대해 연속적인 값을 가지며, 시스템의 상태 변화는 미분 방정식으로 나타낼 수 있다. 연속 시간 시스템은 제어 이론의 기초로서 다양한 물리적 시스템을 모델링하는 데 사용된다.</p>
<h3 id="_2">연속 시간 시스템의 수학적 모델링</h3>
<p>연속 시간 시스템은 주로 상태 공간 표현(State Space Representation)이나 전달 함수(Transfer Function)로 모델링된다. 상태 공간 표현은 시스템의 동적 특성을 상태 변수로 표현하는 방식이며, 미분 방정식으로 나타낼 수 있다. </p>
<p>연속 시간 시스템의 대표적인 상태 공간 표현은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\dot{\mathbf{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\dot{\mathbf{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}(t) = \mathbf{C} \mathbf{x}(t) + \mathbf{D} \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{y}(t) = \mathbf{C} \mathbf{x}(t) + \mathbf{D} \mathbf{u}(t)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 상태 변수 벡터(State Variable Vector)
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>는 입력 벡터(Input Vector)
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}(t)</span><script type="math/tex">\mathbf{y}(t)</script></span>는 출력 벡터(Output Vector)
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}, \mathbf{B}, \mathbf{C}, \mathbf{D}</span><script type="math/tex">\mathbf{A}, \mathbf{B}, \mathbf{C}, \mathbf{D}</script></span>는 시스템 행렬(System Matrices)</p>
<p>각 행렬은 시스템의 특성을 정의하는데, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 상태 행렬(State Matrix), <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 입력 행렬(Input Matrix), <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 출력 행렬(Output Matrix), <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>는 전달 행렬(Feedforward Matrix)을 의미한다.</p>
<h3 id="_3">상태 공간 모델의 해석</h3>
<p>상태 공간 모델은 시스템의 동작을 시간에 따라 기술하는 데 유용하다. 미분 방정식으로 표현된 시스템의 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 초기 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(0)</span><script type="math/tex">\mathbf{x}(0)</script></span>와 입력 함수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>에 의해 결정된다. 선형 연속 시간 시스템의 경우, 시스템의 해는 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = e^{\mathbf{A}t} \mathbf{x}(0) + \int_{0}^{t} e^{\mathbf{A}(t-\tau)} \mathbf{B} \mathbf{u}(\tau) d\tau
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = e^{\mathbf{A}t} \mathbf{x}(0) + \int_{0}^{t} e^{\mathbf{A}(t-\tau)} \mathbf{B} \mathbf{u}(\tau) d\tau
</script>
</div>
<p>이 식에서 <span class="arithmatex"><span class="MathJax_Preview">e^{\mathbf{A}t}</span><script type="math/tex">e^{\mathbf{A}t}</script></span>는 상태 전이 행렬(State Transition Matrix)로, 시스템의 자연적인 시간 변화를 설명한다. </p>
<h3 id="_4">전달 함수와 라플라스 변환</h3>
<p>연속 시간 시스템을 주파수 영역에서 분석할 때는 라플라스 변환(Laplace Transform)을 사용하여 전달 함수로 변환할 수 있다. 시스템의 전달 함수는 입력과 출력의 비율로 정의되며, 다음과 같이 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
G(s) = \frac{Y(s)}{U(s)} = \mathbf{C}(s\mathbf{I} - \mathbf{A})^{-1} \mathbf{B} + \mathbf{D}
</div>
<script type="math/tex; mode=display">
G(s) = \frac{Y(s)}{U(s)} = \mathbf{C}(s\mathbf{I} - \mathbf{A})^{-1} \mathbf{B} + \mathbf{D}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>는 시스템의 전달 함수(Transfer Function)
- <span class="arithmatex"><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>는 복소수 영역에서의 라플라스 변수(Laplace Variable)</p>
<p>연속 시간 시스템의 전달 함수는 시스템이 시간 영역에서 어떻게 반응하는지를 주파수 영역에서 분석할 수 있는 도구를 제공한다.</p>
<h3 id="_5">연속 시간 시스템의 안정성</h3>
<p>연속 시간 시스템에서 중요한 분석 요소 중 하나는 시스템의 안정성(Stability)이다. 시스템이 안정하다는 것은, 입력이 없는 상태에서 시간이 지남에 따라 시스템의 출력이 0으로 수렴한다는 의미이다. 이를 해석하기 위해서, 시스템의 고유값(Eigenvalue)을 통해 안정성을 평가할 수 있다.</p>
<p>연속 시간 선형 시스템의 안정성은 상태 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 고유값을 통해 결정되며, 고유값이 모두 실수부가 음수일 경우 시스템은 안정하다고 판단된다. 이를 수식으로 표현하면 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(s\mathbf{I} - \mathbf{A}) = 0
</div>
<script type="math/tex; mode=display">
\text{det}(s\mathbf{I} - \mathbf{A}) = 0
</script>
</div>
<p>위 방정식에서 도출된 <span class="arithmatex"><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span> 값들이 시스템의 고유값인데, 이 고유값들의 실수부가 음수이면 시스템은 안정적이다. 구체적으로, 고유값 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>의 조건은 다음과 같다:
- <span class="arithmatex"><span class="MathJax_Preview">\Re(\lambda) &lt; 0</span><script type="math/tex">\Re(\lambda) < 0</script></span>: 시스템은 안정적(Stable)
- <span class="arithmatex"><span class="MathJax_Preview">\Re(\lambda) = 0</span><script type="math/tex">\Re(\lambda) = 0</script></span>: 시스템은 한계 안정(Marginally Stable)
- <span class="arithmatex"><span class="MathJax_Preview">\Re(\lambda) &gt; 0</span><script type="math/tex">\Re(\lambda) > 0</script></span>: 시스템은 불안정(Unstable)</p>
<h3 id="_6">연속 시간 시스템의 응답 분석</h3>
<p>연속 시간 시스템의 동작을 분석하기 위해서는 시스템의 응답을 살펴볼 필요가 있다. 대표적으로 시간 응답(Time Response)과 주파수 응답(Frequency Response)으로 나누어 분석할 수 있다.</p>
<h4 id="time-response">시간 응답 (Time Response)</h4>
<p>시간 응답은 입력에 대한 시스템의 시간에 따른 출력을 나타낸다. 주요 응답 특성으로는 과도 응답(Transient Response)과 정상 상태 응답(Steady-State Response)이 있다.</p>
<p>과도 응답은 초기 상태에서 시스템이 입력에 대해 반응하는 과정을 설명하며, 다음과 같은 지표로 평가된다:
- 상승 시간(Rise Time): 출력이 처음으로 목표값에 도달하는 시간
- 정착 시간(Settling Time): 출력이 목표값 근처의 허용 오차 범위 내에 들어가는 시간
- 오버슈트(Overshoot): 출력이 목표값을 초과하는 정도</p>
<h4 id="steady-state-response">정상 상태 응답 (Steady-State Response)</h4>
<p>정상 상태 응답은 시간이 충분히 지났을 때, 시스템이 일정한 입력에 대해 얼마나 정확하게 응답하는지를 설명한다. 이는 시스템의 오차 특성을 평가하는 데 중요한 역할을 하며, 정상 상태 오차(Steady-State Error)는 다음과 같은 방식으로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
e_{\text{ss}} = \lim_{t \to \infty} [r(t) - y(t)]
</div>
<script type="math/tex; mode=display">
e_{\text{ss}} = \lim_{t \to \infty} [r(t) - y(t)]
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">r(t)</span><script type="math/tex">r(t)</script></span>는 참조 입력(Reference Input)이고, <span class="arithmatex"><span class="MathJax_Preview">y(t)</span><script type="math/tex">y(t)</script></span>는 시스템의 출력이다. 정상 상태 오차는 주로 비례 제어기(Proportional Controller)나 PID 제어기에서 튜닝 요소로 사용된다.</p>
<h3 id="frequency-response">주파수 응답 (Frequency Response)</h3>
<p>주파수 응답은 입력 신호의 주파수 변화에 따라 시스템의 출력이 어떻게 변화하는지를 설명한다. 이를 분석하기 위한 대표적인 도구로 보드선도(Bode Plot)와 나이퀴스트 선도(Nyquist Plot)가 있다. 보드선도는 주파수에 따른 이득(Gain)과 위상(Phase)의 변화를 나타내며, 나이퀴스트 선도는 주파수 응답을 복소평면에서 시각적으로 표현한다.</p>
<p>보드선도에서 시스템의 전달 함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>를 주파수 영역에서 분석할 때는 <span class="arithmatex"><span class="MathJax_Preview">s = j\omega</span><script type="math/tex">s = j\omega</script></span>로 대체하여 주파수 응답 함수 <span class="arithmatex"><span class="MathJax_Preview">G(j\omega)</span><script type="math/tex">G(j\omega)</script></span>를 얻는다. 이를 통해 시스템의 이득 및 위상 마진을 확인하고, 안정성을 분석할 수 있다.</p>
<p>주파수 응답에서 주요한 분석 지표는 다음과 같다:
- 이득 마진(Gain Margin): 시스템이 불안정해지기 전까지의 허용 가능한 이득 변화
- 위상 마진(Phase Margin): 시스템이 불안정해지기 전까지의 허용 가능한 위상 변화</p>
<h3 id="controllability-observability">연속 시간 시스템의 상태 가변성 (Controllability)와 관측 가능성 (Observability)</h3>
<p>연속 시간 시스템에서 제어 가능성(Controllability)과 관측 가능성(Observability)은 시스템의 동작을 분석하고 설계할 때 중요한 개념이다. 상태 공간 모델에서 각각의 성질은 시스템의 모든 상태를 제어하거나 관측할 수 있는지를 나타낸다.</p>
<h4 id="controllability">제어 가능성 (Controllability)</h4>
<p>제어 가능성은 시스템의 초기 상태를 원하는 상태로 이동시킬 수 있는 능력을 의미한다. 연속 시간 시스템이 제어 가능한지 여부를 판단하기 위해서는 제어 가능성 행렬(Controllability Matrix)을 확인해야 한다. </p>
<p>상태 공간 표현에서 제어 가능성 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{W}_c</span><script type="math/tex">\mathbf{W}_c</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{W}_c = \begin{bmatrix} \mathbf{B} &amp; \mathbf{A}\mathbf{B} &amp; \mathbf{A}^2\mathbf{B} &amp; \cdots &amp; \mathbf{A}^{n-1}\mathbf{B} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{W}_c = \begin{bmatrix} \mathbf{B} & \mathbf{A}\mathbf{B} & \mathbf{A}^2\mathbf{B} & \cdots & \mathbf{A}^{n-1}\mathbf{B} \end{bmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>은 시스템의 상태 변수의 개수이다. 제어 가능성 행렬의 계수가 최대 계수를 가지면 시스템은 제어 가능하다고 판단된다. 즉, 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{W}_c</span><script type="math/tex">\mathbf{W}_c</script></span>가 전 계수(Full Rank)를 가지면, 시스템의 모든 상태를 제어할 수 있다.</p>
<h4 id="observability">관측 가능성 (Observability)</h4>
<p>관측 가능성은 시스템의 출력 신호로부터 시스템의 모든 상태를 추정할 수 있는지를 나타낸다. 관측 가능성을 평가하기 위해서는 관측 가능성 행렬(Observability Matrix)을 사용한다. 관측 가능성 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{W}_o</span><script type="math/tex">\mathbf{W}_o</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{W}_o = \begin{bmatrix} \mathbf{C} \\ \mathbf{C}\mathbf{A} \\ \mathbf{C}\mathbf{A}^2 \\ \vdots \\ \mathbf{C}\mathbf{A}^{n-1} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{W}_o = \begin{bmatrix} \mathbf{C} \\ \mathbf{C}\mathbf{A} \\ \mathbf{C}\mathbf{A}^2 \\ \vdots \\ \mathbf{C}\mathbf{A}^{n-1} \end{bmatrix}
</script>
</div>
<p>관측 가능성 행렬이 전 계수를 가지면, 시스템은 관측 가능하다고 판단된다. 즉, 시스템의 출력 신호를 통해 모든 상태를 관측할 수 있다.</p>
<p>제어 가능성과 관측 가능성은 시스템의 설계와 분석에 매우 중요한 요소로, 시스템이 안정적으로 작동하기 위해서는 두 조건을 모두 만족해야 한다. 특히, 제어기를 설계하거나 관측기를 설계할 때 제어 가능성과 관측 가능성을 확인하는 것이 필수적이다.</p>
<h3 id="_7">연속 시간 시스템의 상태 피드백 제어</h3>
<p>연속 시간 시스템에서 상태 피드백 제어(State Feedback Control)는 시스템의 상태 변수를 피드백하여 제어 신호를 생성하는 방식이다. 상태 피드백은 시스템의 안정성 향상 및 성능 개선을 위한 핵심 기법이다. </p>
<p>상태 피드백 제어기의 기본 구조는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(t) = -\mathbf{K} \mathbf{x}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{u}(t) = -\mathbf{K} \mathbf{x}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>는 상태 피드백 이득 행렬(State Feedback Gain Matrix)이다. 상태 피드백 제어를 사용하면 시스템의 고유값을 원하는 위치로 배치할 수 있으며, 이를 고유값 배치법(Eigenvalue Placement Method)이라고 한다. 이 방법을 통해 시스템의 안정성을 보장하고, 원하는 동적 성능을 달성할 수 있다.</p>
<p>상태 피드백 제어기의 설계는 다음과 같은 절차로 이루어진다:
1. 시스템의 상태 공간 모델을 작성한다.
2. 제어 가능성 행렬을 확인하여 시스템이 제어 가능한지 평가한다.
3. 상태 피드백 이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>를 설계하여 고유값을 원하는 위치에 배치한다.</p>
<h3 id="_8">연속 시간 시스템에서의 관측기 설계</h3>
<p>관측기(Observer)는 시스템의 출력을 기반으로 내부 상태 변수를 추정하는 장치이다. 상태 변수를 직접 측정할 수 없는 경우, 관측기를 사용하여 상태를 추정할 수 있다. 연속 시간 시스템에서 관측기는 다음과 같은 형태로 설계된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\dot{\hat{\mathbf{x}}}(t) = \mathbf{A} \hat{\mathbf{x}}(t) + \mathbf{B} \mathbf{u}(t) + \mathbf{L}(\mathbf{y}(t) - \hat{\mathbf{y}}(t))
</div>
<script type="math/tex; mode=display">
\dot{\hat{\mathbf{x}}}(t) = \mathbf{A} \hat{\mathbf{x}}(t) + \mathbf{B} \mathbf{u}(t) + \mathbf{L}(\mathbf{y}(t) - \hat{\mathbf{y}}(t))
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{x}}(t)</span><script type="math/tex">\hat{\mathbf{x}}(t)</script></span>는 추정된 상태 벡터이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>은 관측기 이득(Observer Gain)이다. 관측기 설계를 통해 시스템의 상태를 정확하게 추정할 수 있으며, 이를 상태 피드백 제어와 결합하여 시스템 성능을 극대화할 수 있다.</p>
<h3 id="-poles-and-zeros">연속 시간 시스템의 폴-영(Poles and Zeros)</h3>
<p>연속 시간 시스템에서 폴(Poles)과 영(Zeros)은 시스템의 동작 특성을 결정하는 중요한 요소이다. 시스템의 전달 함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>는 입력과 출력의 관계를 나타내며, 그 안에서 폴과 영은 시스템의 특성 방정식에서 결정된다.</p>
<h4 id="poles">폴 (Poles)</h4>
<p>폴은 전달 함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>의 분모가 0이 되는 값으로, 시스템의 자연 응답(Natural Response)을 결정하는 요소이다. 폴은 주로 시스템의 안정성과 과도 응답을 평가하는 데 사용된다. </p>
<p>전달 함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>는 다음과 같이 표현될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
G(s) = \frac{N(s)}{D(s)}
</div>
<script type="math/tex; mode=display">
G(s) = \frac{N(s)}{D(s)}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">D(s) = 0</span><script type="math/tex">D(s) = 0</script></span>인 <span class="arithmatex"><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span> 값들이 폴이다. 폴의 위치는 시스템의 안정성과 관련이 있으며, 앞서 설명한 바와 같이 폴의 실수부가 음수일 경우 시스템은 안정적이다.</p>
<h4 id="zeros">영 (Zeros)</h4>
<p>영은 전달 함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>의 분자가 0이 되는 값으로, 시스템의 입력에 대한 출력의 반응을 결정한다. 영은 시스템의 주파수 응답에 중요한 영향을 미치며, 영의 위치에 따라 특정 주파수에서의 응답이 크게 달라질 수 있다.</p>
<p>전달 함수에서 <span class="arithmatex"><span class="MathJax_Preview">N(s) = 0</span><script type="math/tex">N(s) = 0</script></span>이 되는 <span class="arithmatex"><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span> 값들이 영이다. 영은 시스템의 제어기 설계 시 이득 마진과 위상 마진을 고려하는 데 중요한 역할을 한다.</p>
<h4 id="-pole-zero-plot">폴-영 도표 (Pole-Zero Plot)</h4>
<p>폴과 영의 위치는 복소 평면에서 시각적으로 표현할 수 있다. 폴은 "X"로, 영은 "O"로 표시되며, 복소 평면에서 폴과 영의 분포는 시스템의 시간 응답과 주파수 응답을 분석하는 데 중요한 도구가 된다. 아래는 폴-영 도표를 시각화한 예시이다:</p>
<div class="mermaid">graph LR
    subgraph Pole-Zero Plot
    P1[폴] --&gt; Z1[영]
    P2[폴] --&gt; Z2[영]
    P3[폴] --&gt; Z3[영]
    end
</div>
<h3 id="state-transition-matrix">상태 전이 행렬 (State Transition Matrix)</h3>
<p>연속 시간 시스템의 상태 공간 모델에서 상태 전이 행렬(State Transition Matrix)은 시스템의 자연 응답을 설명하는 중요한 행렬이다. 상태 전이 행렬은 시스템의 초기 상태가 시간에 따라 어떻게 변하는지를 나타낸다.</p>
<p>상태 전이 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Phi}(t)</span><script type="math/tex">\mathbf{\Phi}(t)</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\Phi}(t) = e^{\mathbf{A}t}
</div>
<script type="math/tex; mode=display">
\mathbf{\Phi}(t) = e^{\mathbf{A}t}
</script>
</div>
<p>이때, <span class="arithmatex"><span class="MathJax_Preview">e^{\mathbf{A}t}</span><script type="math/tex">e^{\mathbf{A}t}</script></span>는 매트릭스 지수(Matrix Exponential)로 계산된다. 상태 전이 행렬을 사용하면 초기 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(0)</span><script type="math/tex">\mathbf{x}(0)</script></span>로부터 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 이후의 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>를 계산할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = \mathbf{\Phi}(t) \mathbf{x}(0)
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = \mathbf{\Phi}(t) \mathbf{x}(0)
</script>
</div>
<p>상태 전이 행렬은 시스템의 안정성 분석, 시간 응답 계산, 관측기 설계 등에 필수적으로 사용된다. 매트릭스 지수를 직접 계산하기 위해서는 행렬 대각화 또는 조단 행렬(Jordan Matrix)을 사용할 수 있다.</p>
<h3 id="pole-placement">상태 피드백과 폴 배치 (Pole Placement)</h3>
<p>상태 피드백 제어에서 폴 배치(Pole Placement)는 시스템의 고유값을 원하는 위치에 배치하는 기법이다. 상태 피드백 제어는 다음과 같이 설계된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(t) = -\mathbf{K} \mathbf{x}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{u}(t) = -\mathbf{K} \mathbf{x}(t)
</script>
</div>
<p>이때, 상태 피드백 이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>를 설계하여 시스템의 닫힌 고리(Closed-Loop)의 고유값을 원하는 위치로 배치할 수 있다. 폴 배치를 통해 시스템의 과도 응답을 제어할 수 있으며, 이 방법은 특히 연속 시간 시스템의 안정성 및 성능을 최적화하는 데 사용된다.</p>
<p>폴 배치를 위한 방법 중 하나는 선형 대수학적 방식으로, 시스템의 제어 가능성 행렬이 전 계수(Full Rank)를 가질 때 폴 배치를 통해 원하는 동작을 달성할 수 있다.</p>
<h3 id="lyapunov-stability">리아푸노프 안정성 (Lyapunov Stability)</h3>
<p>연속 시간 시스템에서 안정성을 평가하는 방법 중 하나는 리아푸노프(Lyapunov) 방법을 사용하는 것이다. 리아푸노프 안정성 이론은 선형 및 비선형 시스템의 안정성을 분석하는 강력한 도구로, 상태 공간에서 시스템의 안정성을 직접 평가할 수 있는 방법을 제공한다.</p>
<h4 id="lyapunov-function">리아푸노프 함수 (Lyapunov Function)</h4>
<p>리아푸노프 안정성의 핵심 개념은 리아푸노프 함수(Lyapunov Function)이다. 리아푸노프 함수 <span class="arithmatex"><span class="MathJax_Preview">V(\mathbf{x})</span><script type="math/tex">V(\mathbf{x})</script></span>는 시스템 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>에 대한 스칼라 함수로, 상태의 크기가 커질수록 값이 증가하는 특성을 가진다. 리아푸노프 함수는 시스템의 안정성을 확인하는데 사용되며, 일반적으로 다음 두 가지 조건을 만족해야 한다:
1. <span class="arithmatex"><span class="MathJax_Preview">V(\mathbf{x}) &gt; 0</span><script type="math/tex">V(\mathbf{x}) > 0</script></span> for all <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x} \neq 0</span><script type="math/tex">\mathbf{x} \neq 0</script></span> (양의 정부호, Positive Definite)
2. <span class="arithmatex"><span class="MathJax_Preview">\dot{V}(\mathbf{x}) = \frac{d}{dt} V(\mathbf{x}) &lt; 0</span><script type="math/tex">\dot{V}(\mathbf{x}) = \frac{d}{dt} V(\mathbf{x}) < 0</script></span> for all <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x} \neq 0</span><script type="math/tex">\mathbf{x} \neq 0</script></span> (함수의 시간에 따른 변화율이 음수, 즉 함수 값이 감소)</p>
<p>이 조건을 만족할 때, 시스템은 리아푸노프 안정성을 가진다고 말한다. 이러한 함수가 존재하면 시스템은 점근적으로 안정(Asymptotically Stable)하다고 평가된다.</p>
<h4 id="lyapunov-equation">리아푸노프 방정식 (Lyapunov Equation)</h4>
<p>선형 연속 시간 시스템에서 리아푸노프 안정성을 분석하기 위해 리아푸노프 방정식을 사용할 수 있다. 선형 시스템의 상태 공간 모델이 다음과 같을 때:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\dot{\mathbf{x}}(t) = \mathbf{A} \mathbf{x}(t)
</div>
<script type="math/tex; mode=display">
\dot{\mathbf{x}}(t) = \mathbf{A} \mathbf{x}(t)
</script>
</div>
<p>리아푸노프 방정식은 다음과 같이 주어진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}^{T} \mathbf{P} + \mathbf{P} \mathbf{A} = -\mathbf{Q}
</div>
<script type="math/tex; mode=display">
\mathbf{A}^{T} \mathbf{P} + \mathbf{P} \mathbf{A} = -\mathbf{Q}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>는 대칭 행렬(Symmetric Matrices)이며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>는 양의 정부호 행렬(Positive Definite Matrix)로 선택된다. 이때, 리아푸노프 방정식의 해가 양의 정부호 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>라면 시스템은 안정하다고 판단된다.</p>
<h3 id="lyapunov-direct-method">리아푸노프 직접 방법 (Lyapunov Direct Method)</h3>
<p>리아푸노프 직접 방법은 비선형 연속 시간 시스템의 안정성을 평가하는 데 유용하다. 이 방법에서는 시스템의 모델을 사용하지 않고 리아푸노프 함수를 정의하여 안정성을 직접 평가한다. 리아푸노프 함수의 시간에 따른 변화율을 계산함으로써 시스템이 안정한지, 불안정한지 또는 한계 안정한지를 확인할 수 있다.</p>
<p>이 방법은 비선형 시스템에서도 적용 가능하며, 선형 시스템에 비해 더 일반적인 안정성 평가 방법이다.</p>
<h3 id="state-trajectory">상태 궤적 (State Trajectory)</h3>
<p>연속 시간 시스템에서 상태 궤적(State Trajectory)은 시간에 따라 상태 공간에서 시스템의 상태가 어떻게 변화하는지를 보여준다. 상태 궤적은 상태 변수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>가 시간에 따라 이동하는 경로를 나타내며, 시스템의 과도 응답 및 안정성을 시각적으로 분석할 수 있다. </p>
<p>상태 궤적은 다음과 같은 상태 전이 행렬을 통해 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = \mathbf{\Phi}(t) \mathbf{x}(0)
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = \mathbf{\Phi}(t) \mathbf{x}(0)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(0)</span><script type="math/tex">\mathbf{x}(0)</script></span>는 초기 상태이며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Phi}(t)</span><script type="math/tex">\mathbf{\Phi}(t)</script></span>는 상태 전이 행렬이다. 상태 궤적을 분석하면 시스템이 시간이 지남에 따라 안정적인 상태로 수렴하는지, 혹은 불안정한 상태로 발산하는지를 알 수 있다.</p>
<h3 id="_9">선형 연속 시간 시스템의 제어기 설계</h3>
<p>연속 시간 시스템에서 제어기를 설계하는 기본적인 방법은 폴 배치(Pole Placement) 기법을 사용하는 것이다. 제어기의 목적은 시스템의 동작을 원하는 대로 조정하는 것이며, 이를 위해 상태 피드백 제어(State Feedback Control)를 사용할 수 있다. 상태 피드백 제어는 상태 변수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>에 기반하여 제어 입력을 생성하는 방식이다.</p>
<p>제어기의 설계는 주로 다음 단계로 이루어진다:
1. 시스템의 상태 공간 모델을 확인한다.
2. 제어 가능성(Controllability)을 평가하여 시스템이 제어 가능한지 판단한다.
3. 상태 피드백 이득 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>를 설계하여 원하는 고유값을 시스템에 배치한다.</p>
<p>제어기의 성능은 시스템의 고유값에 따라 결정되며, 고유값을 적절하게 배치함으로써 시스템의 안정성 및 응답 속도를 조절할 수 있다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0128_discrete_time_system/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0128_discrete_time_system/">
        제어시스템에서 이산 시간 시스템
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0126_probabilistic_systems/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0126_probabilistic_systems/">
        제어시스템에서 확률적 시스템
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>