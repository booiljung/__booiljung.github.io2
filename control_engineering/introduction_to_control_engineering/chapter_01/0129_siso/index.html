<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/control_engineering/introduction_to_control_engineering/chapter_01/0129_siso/" rel="canonical"/>
<link href="../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>제어시스템에서 단일 입력 단일 출력 시스템 (SISO Single Input Single Output System) - 소프트웨어 융합</title>
<link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ub2e8\uc77c \uc785\ub825 \ub2e8\uc77c \ucd9c\ub825 \uc2dc\uc2a4\ud15c\uc758 \uac1c\ub150", url: "#_top", children: [
          ]},
          {title: "\uc218\ud559\uc801 \ubaa8\ub378\ub9c1", url: "#_2", children: [
          ]},
          {title: "\uc0c1\ud0dc \uacf5\uac04 \ud45c\ud604", url: "#_3", children: [
          ]},
          {title: "\uc804\ub2ec\ud568\uc218\uc640 \uc0c1\ud0dc \uacf5\uac04 \ud45c\ud604\uc758 \uad00\uacc4", url: "#_4", children: [
          ]},
          {title: "\ube14\ub85d \ub2e4\uc774\uc5b4\uadf8\ub7a8 \ud45c\ud604", url: "#_5", children: [
          ]},
          {title: "\uc2dc\uac04 \uc601\uc5ed\uc5d0\uc11c\uc758 SISO \uc2dc\uc2a4\ud15c", url: "#siso", children: [
              {title: "\uacfc\ub3c4 \uc751\ub2f5 (Transient Response)", url: "#transient-response" },
              {title: "\uc815\uc0c1 \uc0c1\ud0dc \uc751\ub2f5 (Steady-State Response)", url: "#steady-state-response" },
          ]},
          {title: "\uc8fc\ud30c\uc218 \uc601\uc5ed\uc5d0\uc11c\uc758 SISO \uc2dc\uc2a4\ud15c", url: "#siso_1", children: [
              {title: "\uc8fc\ud30c\uc218 \uc751\ub2f5 (Frequency Response)", url: "#frequency-response" },
          ]},
          {title: "\uc548\uc815\uc131 \ubd84\uc11d (Stability Analysis)", url: "#stability-analysis", children: [
              {title: "\uadf9\uc810\uacfc \uc601\uc810 (Poles and Zeros)", url: "#poles-and-zeros" },
              {title: "\ub77c\uc6b0\uc2a4-\ud6c4\ub974\ube44\uce20 \uc548\uc815\uc131 \uae30\uc900 (Routh-Hurwitz Stability Criterion)", url: "#-routh-hurwitz-stability-criterion" },
              {title: "\ub8e8\ud2b8 \uada4\uc801\ubc95 (Root Locus Method)", url: "#root-locus-method" },
          ]},
          {title: "\uc81c\uc5b4\uae30 \uc124\uacc4\uc5d0\uc11c\uc758 SISO \uc2dc\uc2a4\ud15c", url: "#siso_2", children: [
              {title: "\ud53c\ub4dc\ubc31 \uc81c\uc5b4 (Feedback Control)", url: "#feedback-control" },
              {title: "PID \uc81c\uc5b4\uae30 (PID Controller)", url: "#pid-pid-controller" },
          ]},
          {title: "SISO \uc2dc\uc2a4\ud15c\uc758 \uc8fc\ud30c\uc218 \uc751\ub2f5 \ud574\uc11d", url: "#siso_3", children: [
              {title: "\ubcf4\ub4dc \ud50c\ub86f (Bode Plot)", url: "#bode-plot" },
              {title: "\ub098\uc774\ud034\uc2a4\ud2b8 \ud50c\ub86f (Nyquist Plot)", url: "#nyquist-plot" },
          ]},
          {title: "\uc8fc\ud30c\uc218 \uc751\ub2f5\uc5d0\uc11c\uc758 \uc131\ub2a5 \uc9c0\ud45c", url: "#_6", children: [
          ]},
          {title: "\uc2dc\uac04 \uc751\ub2f5\uacfc \uc8fc\ud30c\uc218 \uc751\ub2f5\uc758 \uad00\uacc4", url: "#_7", children: [
          ]},
          {title: "\uc2dc\uc2a4\ud15c\uc758 \ubaa8\ub378\ub9c1 \uae30\ubc95", url: "#_8", children: [
              {title: "\ubbf8\ubd84 \ubc29\uc815\uc2dd \ubaa8\ub378 (Differential Equation Model)", url: "#differential-equation-model" },
              {title: "\uc804\ub2ec\ud568\uc218 \ubaa8\ub378 (Transfer Function Model)", url: "#transfer-function-model" },
              {title: "\uc0c1\ud0dc \uacf5\uac04 \ubaa8\ub378 (State-Space Model)", url: "#state-space-model" },
          ]},
          {title: "\uc81c\uc5b4\uae30 \uc124\uacc4 \uae30\ubc95", url: "#_9", children: [
              {title: "PID \uc81c\uc5b4\uae30 \uc124\uacc4", url: "#pid" },
              {title: "\ub8e8\ud504 \ubcf4\uc0c1 \uc124\uacc4 (Loop Compensation Design)", url: "#loop-compensation-design" },
          ]},
          {title: "\ud53c\ub4dc\ubc31 \uc81c\uc5b4 \uc2dc\uc2a4\ud15c (Feedback Control System)", url: "#feedback-control-system", children: [
              {title: "\ud53c\ub4dc\ubc31 \uc81c\uc5b4\uc758 \uae30\ubcf8 \uac1c\ub150", url: "#_10" },
              {title: "\ud3d0\ub8e8\ud504 \uc804\ub2ec\ud568\uc218 (Closed-Loop Transfer Function)", url: "#closed-loop-transfer-function" },
              {title: "\ud53c\ub4dc\ubc31 \uc81c\uc5b4\uc758 \uc7a5\uc810", url: "#_11" },
              {title: "\ud53c\ub4dc\ubc31 \uc81c\uc5b4\uc758 \ub2e8\uc810", url: "#_12" },
          ]},
          {title: "\uc81c\uc5b4 \uc131\ub2a5 \ud3c9\uac00 \uc9c0\ud45c", url: "#_13", children: [
              {title: "\uacfc\ub3c4 \uc751\ub2f5 \uc9c0\ud45c (Transient Response Metrics)", url: "#transient-response-metrics" },
              {title: "\uc815\uc0c1 \uc0c1\ud0dc \uc131\ub2a5 \uc9c0\ud45c (Steady-State Performance Metrics)", url: "#steady-state-performance-metrics" },
          ]},
        ];

    </script>
<script src="../../../../js/base.js"></script>
<script src="../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0130_mimo_/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0130_mimo_/">
        다중 입력 다중 출력 시스템 (Multiple Input Multiple Output System, MIMO)
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0128_discrete_time_system/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0128_discrete_time_system/">
        제어시스템에서 이산 시간 시스템
      </a>
</div>
</div>
<h3 id="_1">단일 입력 단일 출력 시스템의 개념</h3>
<p>단일 입력 단일 출력 시스템(SISO 시스템)은 제어공학에서 가장 기본적인 구조로, 하나의 입력과 하나의 출력으로 구성된 시스템을 말한다. 입력 신호는 제어하고자 하는 변수에 영향을 미치며, 출력 신호는 시스템이 응답하는 변수이다. 예를 들어, 온도 제어 시스템에서 히터의 입력 전력(입력 신호)에 따라 온도(출력 신호)가 변한다.</p>
<p>SISO 시스템은 상대적으로 분석과 설계가 간단하여 제어 시스템을 학습하거나 연구할 때 가장 기본적인 모델로 사용된다. 이 시스템에서는 상태 변수를 하나로 정의할 수 있고, 제어 이론에서 자주 사용되는 모델링 및 해석 기법을 적용할 수 있다.</p>
<h3 id="_2">수학적 모델링</h3>
<p>SISO 시스템의 수학적 모델은 일반적으로 선형 미분 방정식으로 표현된다. 연속 시간 시스템에서 시스템의 동작은 다음과 같은 입력과 출력 사이의 관계로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
y(t) = G(s) u(t)
</div>
<script type="math/tex; mode=display">
y(t) = G(s) u(t)
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">y(t)</span><script type="math/tex">y(t)</script></span>는 출력 변수
- <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>는 입력 변수
- <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>는 시스템의 전달함수(Transfer Function)로, 시스템의 특성을 나타낸다.</p>
<p>전달함수는 시스템의 입력과 출력의 관계를 나타내며, 다음과 같은 일반적인 형태를 갖는다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
G(s) = \frac{b_0 s^m + b_1 s^{m-1} + \dots + b_m}{a_0 s^n + a_1 s^{n-1} + \dots + a_n}
</div>
<script type="math/tex; mode=display">
G(s) = \frac{b_0 s^m + b_1 s^{m-1} + \dots + b_m}{a_0 s^n + a_1 s^{n-1} + \dots + a_n}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>는 라플라스 변환에서의 복소변수이며, <span class="arithmatex"><span class="MathJax_Preview">b_i</span><script type="math/tex">b_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span>는 시스템의 계수이다. 전달함수의 차수는 입력 신호와 출력 신호 사이의 동적 관계를 결정하며, <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 시스템의 차수를 나타낸다.</p>
<h3 id="_3">상태 공간 표현</h3>
<p>SISO 시스템은 상태 공간(State Space) 표현으로도 나타낼 수 있다. 상태 공간 모델은 시스템의 동적 동작을 더 구체적으로 분석할 수 있는 방법이다. 상태 공간 표현은 다음과 같은 일반적인 형태를 갖는다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} u(t)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} u(t)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
y(t) = \mathbf{C} \mathbf{x}(t) + \mathbf{D} u(t)
</div>
<script type="math/tex; mode=display">
y(t) = \mathbf{C} \mathbf{x}(t) + \mathbf{D} u(t)
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 상태 변수 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 시스템 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 입력 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 출력 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>는 직접 전달 행렬이다.</p>
<p>이 상태 공간 표현은 시스템의 다변량 해석 및 제어기를 설계할 때 유용하며, 특히 시스템의 동적 특성을 시간에 따라 분석하는 데 적합하다. SISO 시스템에서는 <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">y(t)</span><script type="math/tex">y(t)</script></span>는 각각 스칼라 값이며, 상태 공간 모델에서 사용되는 행렬은 일반적으로 다음과 같은 차원을 가진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \in \mathbb{R}^{n \times n}, \quad \mathbf{B} \in \mathbb{R}^{n \times 1}, \quad \mathbf{C} \in \mathbb{R}^{1 \times n}, \quad \mathbf{D} \in \mathbb{R}^{1 \times 1}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \in \mathbb{R}^{n \times n}, \quad \mathbf{B} \in \mathbb{R}^{n \times 1}, \quad \mathbf{C} \in \mathbb{R}^{1 \times n}, \quad \mathbf{D} \in \mathbb{R}^{1 \times 1}
</script>
</div>
<h3 id="_4">전달함수와 상태 공간 표현의 관계</h3>
<p>SISO 시스템의 전달함수와 상태 공간 표현은 서로 변환할 수 있다. 상태 공간 표현에서 전달함수로 변환하는 과정은 다음과 같다. 시스템의 전달함수는 상태 공간 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}, \mathbf{B}, \mathbf{C}, \mathbf{D}</span><script type="math/tex">\mathbf{A}, \mathbf{B}, \mathbf{C}, \mathbf{D}</script></span>로부터 다음과 같이 유도된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
G(s) = \mathbf{C} (s \mathbf{I} - \mathbf{A})^{-1} \mathbf{B} + \mathbf{D}
</div>
<script type="math/tex; mode=display">
G(s) = \mathbf{C} (s \mathbf{I} - \mathbf{A})^{-1} \mathbf{B} + \mathbf{D}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">s \mathbf{I} - \mathbf{A}</span><script type="math/tex">s \mathbf{I} - \mathbf{A}</script></span>는 상태 행렬의 라플라스 변환이고, 이를 역행렬로 처리하여 전달함수를 구할 수 있다.</p>
<h3 id="_5">블록 다이어그램 표현</h3>
<p>SISO 시스템은 블록 다이어그램(Block Diagram)으로 표현할 수 있으며, 이는 시스템의 구조와 동작을 시각적으로 나타내는 데 매우 유용하다. 아래는 SISO 시스템의 일반적인 블록 다이어그램 구조이다.</p>
<div class="mermaid">graph TD;
    U["입력 u(t)"] --&gt;|"전달함수 G(s)"| Y["출력 y(t)"];
</div>
<p>블록 다이어그램은 전달함수와 시스템의 동작을 직관적으로 보여주며, 제어기 설계 시 피드백 루프(Feedback Loop)를 추가하여 제어 시스템을 설계할 때 유용하다.</p>
<h3 id="siso">시간 영역에서의 SISO 시스템</h3>
<p>SISO 시스템을 시간 영역(Time Domain)에서 분석할 때, 시스템의 동적 거동을 나타내는 주요 요소는 시간 응답(Time Response)이다. 시간 응답은 시스템이 특정 입력에 대해 시간에 따라 출력이 어떻게 변화하는지 보여준다. 일반적으로 SISO 시스템의 시간 응답은 두 가지로 나눌 수 있다: <strong>과도 응답(Transient Response)</strong>과 <strong>정상 상태 응답(Steady-State Response)</strong>이다.</p>
<h4 id="transient-response">과도 응답 (Transient Response)</h4>
<p>과도 응답은 시스템이 안정된 상태로 도달하기 전, 입력 신호에 대한 출력의 초기 반응을 설명한다. 예를 들어, 단위 계단 입력(Unit Step Input)이 주어졌을 때, 시스템은 즉시 출력 값을 도출하지 않고 일정한 과도 시간을 거쳐 천천히 목표 값에 도달한다.</p>
<p>과도 응답은 일반적으로 다음과 같은 특성으로 설명된다:
- <strong>상승 시간 (Rise Time, <span class="arithmatex"><span class="MathJax_Preview">t_r</span><script type="math/tex">t_r</script></span>)</strong>: 출력이 처음으로 목표값의 10%에서 90% 사이에 도달하는 데 걸리는 시간.
- <strong>최대 오버슈트 (Maximum Overshoot, <span class="arithmatex"><span class="MathJax_Preview">M_p</span><script type="math/tex">M_p</script></span>)</strong>: 출력이 목표값을 초과하여 최대치에 도달하는 정도.
- <strong>정착 시간 (Settling Time, <span class="arithmatex"><span class="MathJax_Preview">t_s</span><script type="math/tex">t_s</script></span>)</strong>: 출력이 목표값의 일정한 허용 범위(일반적으로 2% 또는 5%) 내로 안정되기까지 걸리는 시간.
- <strong>감쇠 비율 (Damping Ratio, <span class="arithmatex"><span class="MathJax_Preview">\zeta</span><script type="math/tex">\zeta</script></span>)</strong>: 진동 시스템에서 진동의 감소 정도를 나타내는 척도.</p>
<p>과도 응답은 시스템의 안정성, 빠른 응답성, 그리고 제어기의 성능을 평가하는 데 중요한 지표이다.</p>
<h4 id="steady-state-response">정상 상태 응답 (Steady-State Response)</h4>
<p>정상 상태 응답은 시스템이 과도 응답을 마친 후, 출력이 안정화되어 일정한 값에 도달하는 부분을 말한다. 정상 상태에서 출력은 더 이상 시간에 따라 크게 변하지 않으며, 입력에 대한 최종 출력 값을 유지한다.</p>
<p>정상 상태 응답의 주요 특성은 <strong>정상 상태 오차(Steady-State Error)</strong>이다. 정상 상태 오차는 목표 출력 값과 실제 출력 값 사이의 차이를 나타낸다. 제어 시스템에서 이 오차를 줄이는 것이 매우 중요한데, 이를 위해 비례(P), 적분(I), 미분(D) 제어와 같은 피드백 제어기법을 적용한다.</p>
<p>정상 상태 오차는 시스템 유형에 따라 다르게 계산되며, 이를 계산하기 위해 <strong>오차 계수(Error Constants)</strong>가 사용된다. 다음은 일반적인 오차 계수들이다:
- <strong>위치 오차 계수 (Position Error Constant, <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>)</strong>
- <strong>속도 오차 계수 (Velocity Error Constant, <span class="arithmatex"><span class="MathJax_Preview">K_v</span><script type="math/tex">K_v</script></span>)</strong>
- <strong>가속도 오차 계수 (Acceleration Error Constant, <span class="arithmatex"><span class="MathJax_Preview">K_a</span><script type="math/tex">K_a</script></span>)</strong></p>
<p>이 계수들은 입력 신호가 계단 입력, 램프 입력, 패러볼릭 입력인 경우 각각의 정상 상태 오차를 결정하는 데 사용된다.</p>
<h3 id="siso_1">주파수 영역에서의 SISO 시스템</h3>
<p>SISO 시스템은 주파수 영역(Frequency Domain)에서도 분석할 수 있으며, 이는 시스템의 응답을 주파수 특성으로 평가하는 방법이다. 주파수 영역 분석에서는 시스템의 <strong>이득(Gain)</strong>과 <strong>위상(Phase)</strong> 특성을 평가하여 시스템의 안정성 및 성능을 파악할 수 있다.</p>
<h4 id="frequency-response">주파수 응답 (Frequency Response)</h4>
<p>주파수 응답은 시스템이 주파수가 다른 다양한 입력에 대해 어떻게 응답하는지를 설명하는 것으로, 시스템의 전달함수를 주파수 영역에서 분석한 결과로 나타난다. 주파수 응답은 일반적으로 <strong>보드 플롯(Bode Plot)</strong>이나 <strong>나이퀴스트 플롯(Nyquist Plot)</strong>과 같은 그래픽 도구를 통해 분석한다.</p>
<ul>
<li><strong>보드 플롯 (Bode Plot)</strong>: 주파수에 따른 이득과 위상 변화를 로그 스케일로 표현한 그래프이다.</li>
<li><strong>나이퀴스트 플롯 (Nyquist Plot)</strong>: 복소 평면 상에서 주파수에 따른 시스템의 응답을 나타낸다.</li>
</ul>
<p>보드 플롯과 나이퀴스트 플롯은 시스템의 안정성, 특히 피드백 제어 시스템에서 중요한 <strong>안정 여유(Gain Margin)</strong>와 <strong>위상 여유(Phase Margin)</strong>를 분석하는 데 사용된다.</p>
<p>주파수 응답은 다음과 같이 수학적으로 표현될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
G(j\omega) = \frac{b_0 (j\omega)^m + b_1 (j\omega)^{m-1} + \dots + b_m}{a_0 (j\omega)^n + a_1 (j\omega)^{n-1} + \dots + a_n}
</div>
<script type="math/tex; mode=display">
G(j\omega) = \frac{b_0 (j\omega)^m + b_1 (j\omega)^{m-1} + \dots + b_m}{a_0 (j\omega)^n + a_1 (j\omega)^{n-1} + \dots + a_n}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span>는 각속도(주파수)이며, <span class="arithmatex"><span class="MathJax_Preview">G(j\omega)</span><script type="math/tex">G(j\omega)</script></span>는 주파수 영역에서 시스템의 응답을 나타낸다.</p>
<h3 id="stability-analysis">안정성 분석 (Stability Analysis)</h3>
<p>SISO 시스템에서 가장 중요한 요소 중 하나는 <strong>안정성(Stability)</strong>이다. 시스템이 안정적이지 않으면, 입력에 대해 과도한 반응을 하거나 출력을 통제할 수 없게 된다. 안정성은 일반적으로 시스템의 특성 방정식에 의해 결정된다. </p>
<h4 id="poles-and-zeros">극점과 영점 (Poles and Zeros)</h4>
<p>시스템의 전달함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>에서, <strong>극점(Poles)</strong>과 <strong>영점(Zeros)</strong>은 시스템의 동적 성질을 결정하는 중요한 요소이다. 전달함수의 분모에 해당하는 식의 해가 극점이며, 분자에 해당하는 식의 해가 영점이다. SISO 시스템에서의 극점과 영점은 다음과 같이 정의된다:</p>
<ul>
<li><strong>극점(Poles)</strong>: 전달함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>의 분모 <span class="arithmatex"><span class="MathJax_Preview">a_0 s^n + a_1 s^{n-1} + \dots + a_n</span><script type="math/tex">a_0 s^n + a_1 s^{n-1} + \dots + a_n</script></span>의 해.</li>
<li><strong>영점(Zeros)</strong>: 전달함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>의 분자 <span class="arithmatex"><span class="MathJax_Preview">b_0 s^m + b_1 s^{m-1} + \dots + b_m</span><script type="math/tex">b_0 s^m + b_1 s^{m-1} + \dots + b_m</script></span>의 해.</li>
</ul>
<p>극점은 시스템의 안정성과 직접적으로 관련이 있다. 시스템이 안정적이기 위해서는 모든 극점이 복소평면의 왼쪽 절반에 위치해야 한다. 극점이 오른쪽 절반에 있으면 시스템은 불안정해지고, 주기적인 진동이 발생할 수 있다.</p>
<h4 id="-routh-hurwitz-stability-criterion">라우스-후르비츠 안정성 기준 (Routh-Hurwitz Stability Criterion)</h4>
<p>SISO 시스템의 안정성은 <strong>라우스-후르비츠 안정성 기준</strong>을 통해 분석할 수 있다. 이 방법은 전달함수의 특성 방정식을 사용하여 시스템이 안정적인지를 평가하는 기법이다. 안정성 조건을 만족하기 위해서는 특성 방정식의 모든 극점이 실수부가 음수이어야 한다.</p>
<p>특성 방정식이 다음과 같다고 가정하자:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
a_0 s^n + a_1 s^{n-1} + \dots + a_n = 0
</div>
<script type="math/tex; mode=display">
a_0 s^n + a_1 s^{n-1} + \dots + a_n = 0
</script>
</div>
<p>이때, 라우스 배열을 작성하여, 첫 번째 열의 모든 요소가 양수이면 시스템은 안정적이라고 판단할 수 있다. 그렇지 않으면 시스템은 불안정하다. 라우스-후르비츠 기준은 SISO 시스템의 안정성을 간단하게 판별할 수 있는 도구로 자주 사용된다.</p>
<h4 id="root-locus-method">루트 궤적법 (Root Locus Method)</h4>
<p>루트 궤적법은 <strong>제어기 설계</strong>와 안정성 분석에 널리 사용되는 도구이다. 이 방법은 시스템의 전달함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>에서 제어기 이득(K)을 변화시켰을 때, 극점의 위치가 어떻게 변하는지를 시각적으로 보여준다. 루트 궤적을 그리면 제어기 설계 시 시스템의 안정성을 직관적으로 파악할 수 있다.</p>
<p>루트 궤적은 극점이 복소 평면 상에서 어떻게 움직이는지를 나타내는 그래프이다. 주어진 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>에 대해, 이득 <span class="arithmatex"><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>를 변화시키면 극점들이 변하는 경로를 따라 그려지게 된다. 루트 궤적이 실수부 음수 방향으로 완전히 위치하면 시스템은 안정적이지만, 실수부가 양수인 극점이 존재하면 불안정하다고 할 수 있다.</p>
<p>루트 궤적법을 이용하여 제어기를 설계할 때, 시스템의 안정성과 응답 특성을 동시에 고려할 수 있어 매우 유용하다.</p>
<h3 id="siso_2">제어기 설계에서의 SISO 시스템</h3>
<p>SISO 시스템에서 제어기 설계는 시스템의 성능을 최적화하고, 안정성을 보장하는 데 중요한 역할을 한다. 가장 널리 사용되는 제어기는 <strong>비례-적분-미분 제어기(PID Control)</strong>이다. 제어기는 주로 시스템의 과도 응답과 정상 상태 응답을 개선하는 데 사용되며, 아래와 같은 방법으로 제어기의 매개변수를 조정할 수 있다.</p>
<h4 id="feedback-control">피드백 제어 (Feedback Control)</h4>
<p>피드백 제어는 SISO 시스템에서 매우 중요한 역할을 한다. 피드백은 출력 <span class="arithmatex"><span class="MathJax_Preview">y(t)</span><script type="math/tex">y(t)</script></span>를 측정하고, 이를 입력 신호와 비교하여 오차 <span class="arithmatex"><span class="MathJax_Preview">e(t)</span><script type="math/tex">e(t)</script></span>를 기반으로 제어 신호를 생성한다. 이때 피드백 제어기는 주어진 제어 목표에 따라 입력 신호를 조정하여 시스템의 동작을 제어한다.</p>
<p>피드백 루프는 아래와 같이 블록 다이어그램으로 표현할 수 있다.</p>
<div class="mermaid">graph TD;
    R["참조 입력 r(t)"] --&gt;|"오차 e(t)"| C[제어기] --&gt;|"제어 입력 u(t)"| G["시스템 G(s)"] --&gt; Y["출력 y(t)"];
    Y --&gt;|피드백| R;
</div>
<p>피드백 제어는 오차 신호를 최소화하고, 시스템이 원하는 출력을 유지하도록 한다. 특히 PID 제어기는 SISO 시스템에서 가장 널리 사용되는 피드백 제어 기법이다.</p>
<h4 id="pid-pid-controller">PID 제어기 (PID Controller)</h4>
<p>PID 제어기는 비례(Proportional), 적분(Integral), 미분(Derivative) 요소를 결합하여 시스템의 성능을 개선하는 제어기이다. PID 제어기는 다음과 같은 수식을 따른다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
u(t) = K_p e(t) + K_i \int e(t) dt + K_d \frac{de(t)}{dt}
</div>
<script type="math/tex; mode=display">
u(t) = K_p e(t) + K_i \int e(t) dt + K_d \frac{de(t)}{dt}
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>: 비례 이득 (Proportional Gain)
- <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>: 적분 이득 (Integral Gain)
- <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span>: 미분 이득 (Derivative Gain)
- <span class="arithmatex"><span class="MathJax_Preview">e(t)</span><script type="math/tex">e(t)</script></span>: 오차 신호 (Error Signal)</p>
<p>비례 제어는 시스템의 과도 응답을 조정하는 데 사용되며, 적분 제어는 정상 상태 오차를 줄이는 데 기여한다. 미분 제어는 시스템의 과도 응답에서 진동을 줄이는 데 도움을 준다.</p>
<h3 id="siso_3">SISO 시스템의 주파수 응답 해석</h3>
<p>SISO 시스템에서 주파수 응답 해석(Frequency Response Analysis)은 매우 중요한 분석 도구로, 주파수 영역에서 시스템의 특성을 파악하는 데 사용된다. 이 방법은 시스템이 다양한 주파수의 입력에 어떻게 응답하는지 분석하여 시스템의 안정성과 성능을 평가할 수 있다. 주파수 응답 해석에서 가장 널리 사용되는 도구로는 <strong>보드 플롯(Bode Plot)</strong>과 <strong>나이퀴스트 플롯(Nyquist Plot)</strong>이 있다.</p>
<h4 id="bode-plot">보드 플롯 (Bode Plot)</h4>
<p>보드 플롯은 주파수 영역에서 시스템의 이득(Gain)과 위상(Phase)을 로그 스케일로 표현한 그래프이다. SISO 시스템의 전달함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>는 다음과 같이 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
G(s) = \frac{b_0 s^m + b_1 s^{m-1} + \dots + b_m}{a_0 s^n + a_1 s^{n-1} + \dots + a_n}
</div>
<script type="math/tex; mode=display">
G(s) = \frac{b_0 s^m + b_1 s^{m-1} + \dots + b_m}{a_0 s^n + a_1 s^{n-1} + \dots + a_n}
</script>
</div>
<p>이때 <span class="arithmatex"><span class="MathJax_Preview">s = j\omega</span><script type="math/tex">s = j\omega</script></span>로 대체하여 주파수 영역에서의 전달함수를 얻는다. 주파수 응답은 <span class="arithmatex"><span class="MathJax_Preview">G(j\omega)</span><script type="math/tex">G(j\omega)</script></span>의 크기와 위상을 분석하는 과정으로, 보드 플롯은 두 개의 그래프로 구성된다:
- <strong>이득 플롯(Gain Plot)</strong>: 주파수에 따른 시스템의 이득을 로그 스케일로 나타낸다.
- <strong>위상 플롯(Phase Plot)</strong>: 주파수에 따른 시스템의 위상을 나타낸다.</p>
<p>보드 플롯을 통해 시스템의 주파수 응답을 쉽게 파악할 수 있으며, 시스템의 안정성을 평가하는 데 유용하다. 특히 <strong>안정 여유(Gain Margin)</strong>와 <strong>위상 여유(Phase Margin)</strong>를 확인하여 시스템의 안정성을 판단할 수 있다.</p>
<h4 id="nyquist-plot">나이퀴스트 플롯 (Nyquist Plot)</h4>
<p>나이퀴스트 플롯은 SISO 시스템의 주파수 응답을 복소평면 상에 나타낸 그래프이다. 나이퀴스트 플롯은 시스템의 전달함수 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>의 주파수 응답을 실수부와 허수부로 나타내며, 주파수가 증가함에 따라 궤적이 복소평면 상에서 어떻게 이동하는지를 보여준다.</p>
<p>나이퀴스트 플롯은 피드백 제어 시스템의 안정성을 평가하는 데 매우 중요한 도구로 사용된다. 특히 <strong>나이퀴스트 안정성 기준(Nyquist Stability Criterion)</strong>을 적용하여 시스템의 폐루프 안정성을 평가할 수 있다. 이 기준에 따르면, 폐루프 시스템이 안정적이기 위해서는 나이퀴스트 궤적이 <span class="arithmatex"><span class="MathJax_Preview">(-1, 0)</span><script type="math/tex">(-1, 0)</script></span> 점을 통과하지 않거나 이를 최소한 시계 방향으로 한 번만 돌아야 한다.</p>
<h3 id="_6">주파수 응답에서의 성능 지표</h3>
<p>SISO 시스템의 주파수 응답 해석에서는 몇 가지 성능 지표를 사용하여 시스템의 성능을 평가한다. 주요 성능 지표는 다음과 같다:</p>
<ul>
<li><strong>대역폭(Bandwidth)</strong>: 시스템이 유효하게 응답할 수 있는 주파수 범위이다. 대역폭이 넓을수록 시스템이 빠른 입력에 대해 적절하게 응답할 수 있음을 나타낸다.</li>
<li><strong>안정 여유(Gain Margin, <span class="arithmatex"><span class="MathJax_Preview">GM</span><script type="math/tex">GM</script></span>)</strong>: 시스템이 불안정해지기 직전까지 제어기의 이득을 얼마나 증가시킬 수 있는지를 나타낸다. 안정 여유는 보드 플롯에서 주파수가 180도 위상 변화에 도달하는 지점에서 이득이 1(0dB)이 되는 주파수와 관련이 있다.</li>
<li><strong>위상 여유(Phase Margin, <span class="arithmatex"><span class="MathJax_Preview">PM</span><script type="math/tex">PM</script></span>)</strong>: 시스템이 불안정해지기 직전까지 제어기의 위상 변화를 얼마나 허용할 수 있는지를 나타낸다. 위상 여유는 이득이 1(0dB)이 되는 지점에서의 위상 차이를 나타낸다.</li>
</ul>
<p>이 성능 지표들을 통해 SISO 시스템의 안정성 및 성능을 주파수 영역에서 평가할 수 있다.</p>
<h3 id="_7">시간 응답과 주파수 응답의 관계</h3>
<p>SISO 시스템에서 시간 응답(Time Response)과 주파수 응답(Frequency Response)은 서로 밀접한 관계가 있다. 시간 응답은 주어진 입력에 대해 시스템이 시간에 따라 어떻게 반응하는지를 보여주는 반면, 주파수 응답은 시스템이 다양한 주파수의 입력에 대해 어떻게 반응하는지를 보여준다. 두 응답 사이에는 수학적 관계가 존재하며, 주파수 응답에서 얻은 정보를 통해 시간 응답을 예측할 수 있다.</p>
<p>예를 들어, 주파수 응답 해석을 통해 시스템의 대역폭이나 안정 여유를 알 수 있으면, 이를 바탕으로 시스템의 과도 응답을 예측할 수 있다. 대역폭이 넓을수록 시스템의 상승 시간이 짧아지고, 안정 여유가 충분하면 과도 응답에서 진동이 적어진다.</p>
<p>또한, 주파수 응답 해석에서의 <strong>보드 플롯</strong>이나 <strong>나이퀴스트 플롯</strong>은 시간 응답의 과도 특성과도 관련이 있다. 보드 플롯에서 이득이 높으면 시스템의 응답 속도가 빨라지지만, 동시에 과도 응답에서 진동이 발생할 가능성도 증가한다.</p>
<h3 id="_8">시스템의 모델링 기법</h3>
<p>SISO 시스템의 동적 특성을 이해하고 제어하기 위해서는 <strong>모델링(Modeling)</strong>이 필수적이다. 시스템의 모델링은 시스템의 입력과 출력 사이의 관계를 수학적으로 나타내는 과정이다. 모델링 기법은 시스템이 선형인지 비선형인지, 연속 시간인지 이산 시간인지에 따라 달라지며, 여기에서는 <strong>선형 연속 시간 시스템</strong>에 중점을 두고 설명한다.</p>
<h4 id="differential-equation-model">미분 방정식 모델 (Differential Equation Model)</h4>
<p>SISO 시스템의 동작을 가장 직접적으로 나타낼 수 있는 방법 중 하나는 미분 방정식을 사용하는 것이다. 시스템의 동적 특성은 입력과 출력의 관계를 나타내는 미분 방정식으로 설명되며, 이 방정식은 시스템의 물리적 특성을 반영한다. 일반적인 SISO 시스템의 미분 방정식은 다음과 같이 표현될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
a_n \frac{d^n y(t)}{dt^n} + a_{n-1} \frac{d^{n-1} y(t)}{dt^{n-1}} + \dots + a_1 \frac{dy(t)}{dt} + a_0 y(t) = b_m \frac{d^m u(t)}{dt^m} + b_{m-1} \frac{d^{m-1} u(t)}{dt^{m-1}} + \dots + b_1 \frac{du(t)}{dt} + b_0 u(t)
</div>
<script type="math/tex; mode=display">
a_n \frac{d^n y(t)}{dt^n} + a_{n-1} \frac{d^{n-1} y(t)}{dt^{n-1}} + \dots + a_1 \frac{dy(t)}{dt} + a_0 y(t) = b_m \frac{d^m u(t)}{dt^m} + b_{m-1} \frac{d^{m-1} u(t)}{dt^{m-1}} + \dots + b_1 \frac{du(t)}{dt} + b_0 u(t)
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">y(t)</span><script type="math/tex">y(t)</script></span>는 출력,
- <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>는 입력,
- <span class="arithmatex"><span class="MathJax_Preview">a_n, a_{n-1}, \dots, a_0</span><script type="math/tex">a_n, a_{n-1}, \dots, a_0</script></span>는 출력에 대한 계수,
- <span class="arithmatex"><span class="MathJax_Preview">b_m, b_{m-1}, \dots, b_0</span><script type="math/tex">b_m, b_{m-1}, \dots, b_0</script></span>는 입력에 대한 계수이다.</p>
<p>이 미분 방정식은 시스템의 동작을 수학적으로 설명하는 데 매우 유용하다. 그러나 이 방정식을 직접적으로 사용하는 것은 복잡할 수 있으므로, 라플라스 변환을 통해 <strong>전달함수(Transfer Function)</strong>로 변환하여 해석하는 것이 일반적이다.</p>
<h4 id="transfer-function-model">전달함수 모델 (Transfer Function Model)</h4>
<p>미분 방정식 모델을 라플라스 변환하면, 시스템의 전달함수를 얻을 수 있다. 전달함수는 입력과 출력의 라플라스 변환 사이의 관계를 나타내는 함수로, 시스템의 동적 특성을 주파수 영역에서 분석하는 데 사용된다. SISO 시스템의 전달함수는 일반적으로 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
G(s) = \frac{Y(s)}{U(s)} = \frac{b_0 s^m + b_1 s^{m-1} + \dots + b_m}{a_0 s^n + a_1 s^{n-1} + \dots + a_n}
</div>
<script type="math/tex; mode=display">
G(s) = \frac{Y(s)}{U(s)} = \frac{b_0 s^m + b_1 s^{m-1} + \dots + b_m}{a_0 s^n + a_1 s^{n-1} + \dots + a_n}
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>는 시스템의 전달함수,
- <span class="arithmatex"><span class="MathJax_Preview">Y(s)</span><script type="math/tex">Y(s)</script></span>는 출력의 라플라스 변환,
- <span class="arithmatex"><span class="MathJax_Preview">U(s)</span><script type="math/tex">U(s)</script></span>는 입력의 라플라스 변환이다.</p>
<p>전달함수는 시스템의 극점과 영점을 시각적으로 분석하는 데 유용하며, 시스템의 안정성, 응답 속도, 감쇠 비율 등을 평가할 수 있다.</p>
<h4 id="state-space-model">상태 공간 모델 (State-Space Model)</h4>
<p>전달함수 모델이 주로 시스템의 주파수 특성을 분석하는 데 사용된다면, <strong>상태 공간 모델(State-Space Model)</strong>은 시스템의 시간 영역 특성을 분석하는 데 유용하다. 상태 공간 모델은 시스템을 상태 변수로 표현하며, 다음과 같은 상태 방정식으로 나타낸다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} u(t)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} u(t)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
y(t) = \mathbf{C} \mathbf{x}(t) + \mathbf{D} u(t)
</div>
<script type="math/tex; mode=display">
y(t) = \mathbf{C} \mathbf{x}(t) + \mathbf{D} u(t)
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 시스템의 상태 변수 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 상태 행렬(State Matrix),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 입력 행렬(Input Matrix),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 출력 행렬(Output Matrix),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>는 직접 전달 행렬(Direct Transmission Matrix)이다.</p>
<p>상태 공간 모델은 시스템의 다변량 해석과 제어기 설계에 매우 유용하며, 특히 다중 입력 다중 출력(MIMO) 시스템에서도 효과적으로 사용될 수 있다. SISO 시스템에서는 상태 변수의 차원이 작으므로, 상대적으로 간단하게 해석할 수 있다.</p>
<h3 id="_9">제어기 설계 기법</h3>
<p>SISO 시스템의 성능을 개선하기 위해 제어기를 설계하는 다양한 방법들이 있다. 제어기는 시스템이 원하는 동작을 하도록 입력을 조정하는 역할을 하며, 가장 일반적인 제어기 설계 기법으로는 <strong>비례-적분-미분 제어기(PID Control)</strong>와 <strong>루프 보상(Loop Compensation)</strong>이 있다.</p>
<h4 id="pid">PID 제어기 설계</h4>
<p>PID 제어기(PID Controller)는 SISO 시스템에서 가장 널리 사용되는 제어기 중 하나로, 비례(Proportional), 적분(Integral), 미분(Derivative) 제어 요소를 결합하여 시스템의 응답을 개선한다. PID 제어기는 다음과 같은 수식을 따른다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
u(t) = K_p e(t) + K_i \int e(t) dt + K_d \frac{de(t)}{dt}
</div>
<script type="math/tex; mode=display">
u(t) = K_p e(t) + K_i \int e(t) dt + K_d \frac{de(t)}{dt}
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>는 비례 이득 (Proportional Gain),
- <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>는 적분 이득 (Integral Gain),
- <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span>는 미분 이득 (Derivative Gain),
- <span class="arithmatex"><span class="MathJax_Preview">e(t)</span><script type="math/tex">e(t)</script></span>는 오차 신호 (Error Signal)이다.</p>
<p>PID 제어기의 각 요소는 시스템의 과도 응답과 정상 상태 응답을 조정하는 데 중요한 역할을 하며, 각 이득을 적절히 조정하여 시스템 성능을 최적화할 수 있다.</p>
<h4 id="loop-compensation-design">루프 보상 설계 (Loop Compensation Design)</h4>
<p>루프 보상(Loop Compensation)은 시스템의 주파수 응답 특성을 개선하기 위한 방법으로, 주로 피드백 루프 내에 보상기(Compensator)를 추가하여 시스템의 성능을 개선한다. 보상기의 주된 목표는 시스템의 안정성을 향상시키고, 주파수 응답에서 원하는 대역폭과 감쇠 비율을 얻는 것이다.</p>
<p>대표적인 보상 설계 기법에는 <strong>리드 보상(Lead Compensation)</strong>과 <strong>래그 보상(Lag Compensation)</strong>이 있으며, 이 기법들은 각각 주파수 영역에서 시스템의 위상 및 이득 특성을 조정하여 응답을 개선하는 역할을 한다.</p>
<ul>
<li><strong>리드 보상기(Lead Compensator)</strong>: 주파수 응답에서 시스템의 위상을 앞당기고, 과도 응답을 빠르게 한다.</li>
<li><strong>래그 보상기(Lag Compensator)</strong>: 주파수 응답에서 시스템의 이득을 낮추고, 정상 상태 오차를 줄인다.</li>
</ul>
<p>루프 보상 설계는 주파수 응답 해석 도구인 보드 플롯을 이용하여 설계되며, 원하는 성능 목표를 달성하기 위해 각 보상기의 파라미터를 조정한다.</p>
<h3 id="feedback-control-system">피드백 제어 시스템 (Feedback Control System)</h3>
<p>SISO 시스템에서 가장 기본적인 제어 구조 중 하나는 <strong>피드백 제어 시스템</strong>이다. 피드백 제어는 출력 값을 측정하여 이를 입력 값과 비교하고, 그 차이를 기반으로 시스템을 제어하는 방법이다. 피드백 제어의 목표는 시스템이 원하는 목표 상태에 도달하도록 입력 신호를 지속적으로 조정하는 것이다.</p>
<h4 id="_10">피드백 제어의 기본 개념</h4>
<p>피드백 제어는 시스템 출력 <span class="arithmatex"><span class="MathJax_Preview">y(t)</span><script type="math/tex">y(t)</script></span>를 측정하고, 이를 목표 출력 또는 참조 신호 <span class="arithmatex"><span class="MathJax_Preview">r(t)</span><script type="math/tex">r(t)</script></span>와 비교하여 오차 <span class="arithmatex"><span class="MathJax_Preview">e(t) = r(t) - y(t)</span><script type="math/tex">e(t) = r(t) - y(t)</script></span>를 계산하는 방식이다. 그 후, 제어기 <span class="arithmatex"><span class="MathJax_Preview">C(s)</span><script type="math/tex">C(s)</script></span>는 이 오차 신호를 기반으로 제어 신호 <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>를 생성하여 시스템에 입력을 제공한다.</p>
<p>피드백 제어 시스템의 블록 다이어그램은 다음과 같이 나타낼 수 있다:</p>
<div class="mermaid">graph TD;
    R["참조 입력 r(t)"] --&gt;|"오차 e(t)"| C["제어기 C(s)"] --&gt;|"제어 입력 u(t)"| G["시스템 G(s)"] --&gt; Y["출력 y(t)"];
    Y --&gt;|피드백| R;
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">G(s)</span><script type="math/tex">G(s)</script></span>는 시스템의 전달함수이고, <span class="arithmatex"><span class="MathJax_Preview">C(s)</span><script type="math/tex">C(s)</script></span>는 제어기의 전달함수이다. 피드백 루프가 존재하기 때문에 시스템은 외부의 간섭이나 모델링 불확실성에도 강건한 성능을 발휘할 수 있다.</p>
<h4 id="closed-loop-transfer-function">폐루프 전달함수 (Closed-Loop Transfer Function)</h4>
<p>피드백 제어 시스템에서 전체 시스템의 동작을 설명하기 위해 <strong>폐루프 전달함수</strong>를 구할 수 있다. 폐루프 전달함수는 다음과 같은 형태로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T(s) = \frac{Y(s)}{R(s)} = \frac{C(s) G(s)}{1 + C(s) G(s)}
</div>
<script type="math/tex; mode=display">
T(s) = \frac{Y(s)}{R(s)} = \frac{C(s) G(s)}{1 + C(s) G(s)}
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">T(s)</span><script type="math/tex">T(s)</script></span>는 폐루프 시스템의 전달함수이다.
- <span class="arithmatex"><span class="MathJax_Preview">C(s) G(s)</span><script type="math/tex">C(s) G(s)</script></span>는 제어기와 시스템의 개루프(Open-Loop) 전달함수이다.</p>
<p>이 폐루프 전달함수는 시스템의 응답 특성을 분석하는 데 매우 중요하며, 피드백 제어기 설계 시 성능 목표를 평가하는 데 사용된다.</p>
<h4 id="_11">피드백 제어의 장점</h4>
<p>피드백 제어 시스템은 여러 가지 장점을 제공한다. 주요 장점으로는 다음과 같은 것들이 있다:
- <strong>강건성 (Robustness)</strong>: 외부 간섭이나 시스템 파라미터 변화에 대해 제어 성능을 유지할 수 있다.
- <strong>정상 상태 오차 감소</strong>: 피드백 제어를 사용하면 정상 상태에서의 오차를 줄일 수 있다. 특히 적분 제어를 추가하면 정상 상태 오차를 없앨 수 있다.
- <strong>안정성 향상</strong>: 피드백 루프를 통해 시스템의 안정성을 강화할 수 있으며, 제어기의 적절한 설계를 통해 폐루프 시스템의 안정성을 보장할 수 있다.</p>
<h4 id="_12">피드백 제어의 단점</h4>
<p>피드백 제어는 장점이 많지만, 몇 가지 단점도 존재한다:
- <strong>진동 및 오버슈트</strong>: 피드백 제어 시스템이 과도하게 빠른 응답을 추구할 경우, 진동이나 오버슈트(Overshoot)가 발생할 수 있다.
- <strong>복잡한 설계</strong>: 시스템의 동적 특성이 복잡할 경우, 피드백 제어기의 설계가 어려워질 수 있다. 특히 고차 시스템이나 비선형 시스템에서는 설계 및 튜닝이 복잡하다.
- <strong>불안정성</strong>: 적절한 제어기 설계가 이루어지지 않으면 피드백 시스템이 불안정해질 수 있다.</p>
<h3 id="_13">제어 성능 평가 지표</h3>
<p>SISO 시스템에서 제어기의 성능을 평가하기 위한 몇 가지 중요한 지표들이 있다. 이러한 지표들은 시스템이 입력에 대해 어떻게 반응하는지에 대한 정량적 평가를 제공하며, 제어기 설계와 튜닝 과정에서 매우 유용하다.</p>
<h4 id="transient-response-metrics">과도 응답 지표 (Transient Response Metrics)</h4>
<p>과도 응답(Transient Response)은 시스템이 목표 값에 도달하기 전에 나타나는 일시적인 동작이다. 과도 응답의 성능은 제어기 설계에서 매우 중요한 요소로, 주요 지표는 다음과 같다:</p>
<ul>
<li><strong>상승 시간 (Rise Time, <span class="arithmatex"><span class="MathJax_Preview">t_r</span><script type="math/tex">t_r</script></span>)</strong>: 출력이 처음으로 목표값의 10%에서 90% 사이에 도달하는 데 걸리는 시간.</li>
<li><strong>최대 오버슈트 (Maximum Overshoot, <span class="arithmatex"><span class="MathJax_Preview">M_p</span><script type="math/tex">M_p</script></span>)</strong>: 출력이 목표값을 초과하여 도달하는 최대치. 오버슈트는 진동이 발생할 가능성을 나타낸다.</li>
<li><strong>정착 시간 (Settling Time, <span class="arithmatex"><span class="MathJax_Preview">t_s</span><script type="math/tex">t_s</script></span>)</strong>: 출력이 목표값의 2% 또는 5% 이내로 안정되기까지 걸리는 시간.</li>
<li><strong>감쇠 비율 (Damping Ratio, <span class="arithmatex"><span class="MathJax_Preview">\zeta</span><script type="math/tex">\zeta</script></span>)</strong>: 시스템이 진동을 얼마나 빨리 감쇠시키는지에 대한 척도. 감쇠 비율이 높을수록 진동이 적다.</li>
</ul>
<p>이 지표들은 과도 응답에서의 성능을 평가하는 데 사용되며, 제어기를 튜닝할 때 매우 중요한 역할을 한다.</p>
<h4 id="steady-state-performance-metrics">정상 상태 성능 지표 (Steady-State Performance Metrics)</h4>
<p>정상 상태 성능(Steady-State Performance)은 시스템이 과도 응답을 끝내고 목표 값에 도달한 후의 성능을 나타낸다. 주요 정상 상태 성능 지표는 <strong>정상 상태 오차(Steady-State Error)</strong>이다. 이 오차는 시스템이 목표 값에 얼마나 가까운지, 즉 시스템이 얼마나 정확하게 제어되는지를 나타낸다.</p>
<p>정상 상태 오차는 제어기의 적분 요소가 이를 없애는 데 매우 효과적이며, 오차 계수(Error Constants)로 측정된다:
- <strong>위치 오차 계수 (Position Error Constant, <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>)</strong>: 계단 입력에 대한 정상 상태 오차를 평가.
- <strong>속도 오차 계수 (Velocity Error Constant, <span class="arithmatex"><span class="MathJax_Preview">K_v</span><script type="math/tex">K_v</script></span>)</strong>: 램프 입력에 대한 정상 상태 오차를 평가.
- <strong>가속도 오차 계수 (Acceleration Error Constant, <span class="arithmatex"><span class="MathJax_Preview">K_a</span><script type="math/tex">K_a</script></span>)</strong>: 패러볼릭(parabolic) 입력에 대한 정상 상태 오차를 평가.</p>
<p>이 성능 지표들은 시스템의 목표 값 도달 능력을 평가하는 데 사용되며, 제어기 설계 시 매우 중요한 역할을 한다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0130_mimo_/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0130_mimo_/">
        다중 입력 다중 출력 시스템 (Multiple Input Multiple Output System, MIMO)
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0128_discrete_time_system/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0128_discrete_time_system/">
        제어시스템에서 이산 시간 시스템
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>