<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/control_engineering/introduction_to_control_engineering/chapter_01/0119_state_space_representation/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>상태 공간 표현 - 소프트웨어 융합</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc0c1\ud0dc \uacf5\uac04 \ud45c\ud604\uc758 \uae30\ubcf8 \uac1c\ub150", url: "#_top", children: [
          ]},
          {title: "\uc120\ud615 \uc2dc\uc2a4\ud15c\uc758 \uc0c1\ud0dc \uacf5\uac04 \ud45c\ud604", url: "#_2", children: [
          ]},
          {title: "\uc0c1\ud0dc \ubca1\ud130", url: "#_3", children: [
          ]},
          {title: "\uc0c1\ud0dc \uacf5\uac04 \ud45c\ud604\uc758 \uc7a5\uc810", url: "#_4", children: [
          ]},
          {title: "\uc608\uc2dc: 1\ucc28 \uc2dc\uc2a4\ud15c\uc758 \uc0c1\ud0dc \uacf5\uac04 \ubaa8\ub378", url: "#1", children: [
          ]},
          {title: "\uc0c1\ud0dc \uacf5\uac04 \ud45c\ud604\uc758 \uc2dc\uac04 \uc751\ub2f5", url: "#_5", children: [
              {title: "\uc81c\ub85c \uc785\ub825 \uc751\ub2f5 (Zero Input Response)", url: "#zero-input-response" },
              {title: "\uc81c\ub85c \uc0c1\ud0dc \uc751\ub2f5 (Zero State Response)", url: "#zero-state-response" },
              {title: "\uc804\uccb4 \uc2dc\uac04 \uc751\ub2f5", url: "#_6" },
          ]},
          {title: "\uc0c1\ud0dc \uc804\uc774 \ud589\ub82c", url: "#_7", children: [
          ]},
          {title: "\uc0c1\ud0dc \uac00\ubcc0 \uc2dc\uc2a4\ud15c (Time-Varying Systems)", url: "#time-varying-systems", children: [
          ]},
          {title: "\uc0c1\ud0dc \uacf5\uac04\uc5d0\uc11c\uc758 \uc548\uc815\uc131", url: "#_8", children: [
          ]},
          {title: "\uc81c\uc5b4 \uac00\ub2a5\uc131 (Controllability)", url: "#controllability", children: [
          ]},
          {title: "\uc81c\uc5b4 \uac00\ub2a5\uc131\uc758 \ud14c\uc2a4\ud2b8", url: "#_9", children: [
              {title: "\uc608\uc2dc: 2\ucc28 \uc2dc\uc2a4\ud15c\uc5d0\uc11c\uc758 \uc81c\uc5b4 \uac00\ub2a5\uc131", url: "#2" },
          ]},
          {title: "\uad00\uce21 \uac00\ub2a5\uc131 (Observability)", url: "#observability", children: [
          ]},
          {title: "\uad00\uce21 \uac00\ub2a5\uc131\uc758 \ud14c\uc2a4\ud2b8", url: "#_10", children: [
              {title: "\uc608\uc2dc: 2\ucc28 \uc2dc\uc2a4\ud15c\uc5d0\uc11c\uc758 \uad00\uce21 \uac00\ub2a5\uc131", url: "#2_1" },
          ]},
          {title: "\uc81c\uc5b4 \uac00\ub2a5\uc131\uacfc \uad00\uce21 \uac00\ub2a5\uc131\uc758 \uad00\uacc4", url: "#_11", children: [
          ]},
          {title: "\uc0c1\ud0dc \ud53c\ub4dc\ubc31 \uc81c\uc5b4", url: "#_12", children: [
          ]},
          {title: "\uc774\ub4dd \ubc30\uce58 (Pole Placement)", url: "#pole-placement", children: [
              {title: "\uc608\uc2dc: 2\ucc28 \uc2dc\uc2a4\ud15c\uc758 \uc774\ub4dd \ubc30\uce58", url: "#2_2" },
          ]},
          {title: "\uad00\uce21\uae30 \uc124\uacc4 (Observer Design)", url: "#observer-design", children: [
          ]},
          {title: "\uad00\uce21\uae30\uc640 \uc0c1\ud0dc \ud53c\ub4dc\ubc31 \uc81c\uc5b4\uc758 \uacb0\ud569", url: "#_13", children: [
          ]},
          {title: "\uc0c1\ud0dc \uacf5\uac04\uc5d0\uc11c\uc758 \ubd84\ub9ac \uc6d0\ub9ac", url: "#_14", children: [
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0120_tf_and_gain/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0120_tf_and_gain/" class="btn btn-xs btn-link">
        제어시스템에서 전달함수와 이득의 관계
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0118_transfer_function/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0118_transfer_function/" class="btn btn-xs btn-link">
        전달함수
      </a>
    </div>
    
  </div>

    

    <h3 id="_1">상태 공간 표현의 기본 개념</h3>
<p>상태 공간 표현(State Space Representation)은 제어 시스템을 다루는 데 있어서 시간에 따른 동적 시스템의 상태 변화를 설명하는 방식 중 하나이다. 이 방식은 시스템의 입력과 출력뿐만 아니라 내부 상태 변수를 이용하여 시스템을 표현한다. 상태 공간 모델은 일반적으로 <strong>연립 1차 미분 방정식</strong>으로 나타내며, 시스템의 동적인 특성을 보다 직관적이고 체계적으로 다룰 수 있게 해준다.</p>
<p>동적 시스템에서 상태 공간 표현을 사용하면 시스템의 각 상태 변수들이 어떻게 변화하는지 시간에 따라 추적할 수 있다. 이 상태 변수들은 시스템의 과거 이력에 대한 정보를 담고 있으며, 시스템의 현재 입력과 상태에 의해 결정된다. 상태 공간 표현은 <strong>선형 시스템</strong>뿐만 아니라 <strong>비선형 시스템</strong>에도 적용할 수 있다.</p>
<h3 id="_2">선형 시스템의 상태 공간 표현</h3>
<p>선형 시간 불변 시스템(LTI: Linear Time-Invariant System)의 경우 상태 공간 표현은 다음과 같은 두 개의 기본 방정식으로 표현된다:</p>
<ol>
<li><strong>상태 방정식 (State Equation)</strong>:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{x}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
   \mathbf{x}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</script>
</div>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-차원의 상태 벡터이다.
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 시스템 행렬 (State Transition Matrix)로, 크기는 <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span>이다.
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 입력 행렬 (Input Matrix)로, 크기는 <span class="arithmatex"><span class="MathJax_Preview">n \times m</span><script type="math/tex">n \times m</script></span>이다.
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>-차원의 입력 벡터이다.</p>
<ol>
<li><strong>출력 방정식 (Output Equation)</strong>:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{y}(t) = \mathbf{C} \mathbf{x}(t) + \mathbf{D} \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
   \mathbf{y}(t) = \mathbf{C} \mathbf{x}(t) + \mathbf{D} \mathbf{u}(t)
</script>
</div>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}(t)</span><script type="math/tex">\mathbf{y}(t)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>-차원의 출력 벡터이다.
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 출력 행렬 (Output Matrix)로, 크기는 <span class="arithmatex"><span class="MathJax_Preview">p \times n</span><script type="math/tex">p \times n</script></span>이다.
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>는 전달 행렬 (Feedthrough Matrix)로, 크기는 <span class="arithmatex"><span class="MathJax_Preview">p \times m</span><script type="math/tex">p \times m</script></span>이다.</p>
<p>상태 방정식은 시스템의 현재 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>와 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>를 바탕으로 다음 상태를 예측하며, 출력 방정식은 현재 상태와 입력으로부터 출력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}(t)</span><script type="math/tex">\mathbf{y}(t)</script></span>를 계산한다.</p>
<h3 id="_3">상태 벡터</h3>
<p>상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 시스템의 동작을 완전히 설명하는 변수들의 집합이다. 이 벡터는 시스템의 동적 변화를 설명하기 위한 모든 필요한 정보를 포함하고 있어, 시스템의 미래 상태를 예측하는 데 필요한 모든 데이터를 담고 있다.</p>
<p>상태 벡터의 일반적인 예로는 다음과 같은 물리량들이 포함될 수 있다:
- 위치(Position)
- 속도(Velocity)
- 가속도(Acceleration)
- 각도(Angle)</p>
<p>예를 들어, 2차 시스템에서는 다음과 같은 형태의 상태 벡터를 사용할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = \begin{bmatrix} x_1(t) \\ x_2(t) \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = \begin{bmatrix} x_1(t) \\ x_2(t) \end{bmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">x_1(t)</span><script type="math/tex">x_1(t)</script></span>는 위치, <span class="arithmatex"><span class="MathJax_Preview">x_2(t)</span><script type="math/tex">x_2(t)</script></span>는 속도일 수 있다.</p>
<h3 id="_4">상태 공간 표현의 장점</h3>
<p>상태 공간 표현의 가장 큰 장점 중 하나는 <strong>다중 입력 다중 출력 시스템</strong>(MIMO: Multi-Input Multi-Output)을 쉽게 다룰 수 있다는 점이다. 이전의 전달 함수 방식은 단일 입력 단일 출력 시스템(SISO)에서만 사용하기 편리하지만, 상태 공간 모델은 다중 변수를 동시에 처리하는 데 유리한다.</p>
<p>또한, 비선형 시스템이나 시간 변수가 포함된 시스템에도 상태 공간 모델은 유연하게 적용할 수 있다. 전달 함수로는 표현하기 어려운 복잡한 시스템도 상태 공간 표현으로는 상대적으로 간단하게 모델링할 수 있다.</p>
<h3 id="1">예시: 1차 시스템의 상태 공간 모델</h3>
<p>간단한 1차 저역통과 필터 시스템을 상태 공간 표현으로 나타내면 다음과 같은 수식이 나온다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = -a \mathbf{x}(t) + b \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = -a \mathbf{x}(t) + b \mathbf{u}(t)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}(t) = c \mathbf{x}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{y}(t) = c \mathbf{x}(t)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 시스템의 상태(출력),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>는 입력 신호,
- <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>, <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>, <span class="arithmatex"><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span>는 시스템의 고정 상수들이다.</p>
<p>이와 같이 상태 공간 모델은 미분 방정식을 행렬 형태로 변환하여 계산의 효율성을 높이고, 다차원 시스템을 더욱 체계적으로 다룰 수 있게 한다.</p>
<h3 id="_5">상태 공간 표현의 시간 응답</h3>
<p>상태 공간 표현에서 시스템의 시간 응답을 구하는 것은 매우 중요한 작업이다. 주어진 입력에 대해 시스템이 시간이 지남에 따라 어떻게 반응하는지를 이해하기 위해서는 <strong>상태 방정식</strong>을 해석해야 한다. 선형 시간 불변 시스템(LTI)의 경우, 시간 응답은 상태 방정식의 해를 통해 구할 수 있다.</p>
<p>상태 방정식:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</script>
</div>
<h4 id="zero-input-response">제로 입력 응답 (Zero Input Response)</h4>
<p>입력 신호가 없을 때, 즉 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t) = 0</span><script type="math/tex">\mathbf{u}(t) = 0</script></span>인 경우, 상태 방정식은 다음과 같이 단순화된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t)
</script>
</div>
<p>이 경우 시스템의 시간 응답은 <strong>자연 응답</strong>(Natural Response)이라고 하며, 초기 조건에 의해 결정된다. 이 미분 방정식을 풀면 다음과 같은 해를 얻을 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = e^{\mathbf{A}t} \mathbf{x}(0)
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = e^{\mathbf{A}t} \mathbf{x}(0)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">e^{\mathbf{A}t}</span><script type="math/tex">e^{\mathbf{A}t}</script></span>는 행렬 지수 함수로 계산된다. 따라서 시스템의 상태는 시간에 따라 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 의해 변화하며, 이때 초기 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(0)</span><script type="math/tex">\mathbf{x}(0)</script></span>가 중요하게 작용한다.</p>
<h4 id="zero-state-response">제로 상태 응답 (Zero State Response)</h4>
<p>초기 상태가 0인 경우, 즉 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(0) = 0</span><script type="math/tex">\mathbf{x}(0) = 0</script></span>일 때의 시간 응답을 <strong>제로 상태 응답</strong>(Zero State Response)이라고 한다. 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>가 주어진다면, 상태 방정식은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</script>
</div>
<p>이 미분 방정식의 해는 입력 함수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>에 따라 달라지며, 적분을 통해 구할 수 있다. 제로 상태 응답은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = \int_0^t e^{\mathbf{A}(t-\tau)} \mathbf{B} \mathbf{u}(\tau) d\tau
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = \int_0^t e^{\mathbf{A}(t-\tau)} \mathbf{B} \mathbf{u}(\tau) d\tau
</script>
</div>
<p>이 식은 행렬 지수 함수와 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>의 곱을 적분한 결과로, 입력에 의한 상태 변화를 설명한다.</p>
<h4 id="_6">전체 시간 응답</h4>
<p>전체 시간 응답은 <strong>제로 입력 응답</strong>과 <strong>제로 상태 응답</strong>을 더한 것으로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = e^{\mathbf{A}t} \mathbf{x}(0) + \int_0^t e^{\mathbf{A}(t-\tau)} \mathbf{B} \mathbf{u}(\tau) d\tau
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = e^{\mathbf{A}t} \mathbf{x}(0) + \int_0^t e^{\mathbf{A}(t-\tau)} \mathbf{B} \mathbf{u}(\tau) d\tau
</script>
</div>
<p>이 식은 초기 상태와 입력에 의한 상태 변화를 모두 포함한 상태 공간 표현에서의 시간 응답을 의미한다.</p>
<h3 id="_7">상태 전이 행렬</h3>
<p>상태 공간 표현에서 중요한 개념 중 하나는 <strong>상태 전이 행렬</strong>(State Transition Matrix)이다. 이는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서 시스템 상태가 어떻게 변화하는지를 설명하는 행렬이다. 상태 전이 행렬은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\Phi}(t) = e^{\mathbf{A}t}
</div>
<script type="math/tex; mode=display">
\mathbf{\Phi}(t) = e^{\mathbf{A}t}
</script>
</div>
<p>상태 전이 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Phi}(t)</span><script type="math/tex">\mathbf{\Phi}(t)</script></span>는 시스템 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 의해 결정되며, 시간에 따른 시스템의 상태 변화를 나타낸다. 이 행렬을 사용하면 시스템의 상태를 간단히 다음과 같이 표현할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = \mathbf{\Phi}(t) \mathbf{x}(0) + \int_0^t \mathbf{\Phi}(t-\tau) \mathbf{B} \mathbf{u}(\tau) d\tau
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = \mathbf{\Phi}(t) \mathbf{x}(0) + \int_0^t \mathbf{\Phi}(t-\tau) \mathbf{B} \mathbf{u}(\tau) d\tau
</script>
</div>
<p>이 방정식은 시스템의 초기 상태와 입력을 모두 고려한 상태 벡터의 변화를 나타낸다. 상태 전이 행렬은 특히 선형 시스템에서 시간 응답을 해석할 때 매우 유용하다.</p>
<h3 id="time-varying-systems">상태 가변 시스템 (Time-Varying Systems)</h3>
<p>지금까지 설명한 상태 공간 표현은 시간 불변 시스템에 관한 것이었다. 그러나 많은 실제 시스템은 시간이 지남에 따라 시스템 매개변수나 상태가 변하는 <strong>시간 가변 시스템</strong>(Time-Varying Systems)이다. 이러한 경우, 상태 공간 표현은 여전히 유효하지만, 시스템 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}(t)</span><script type="math/tex">\mathbf{A}(t)</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}(t)</span><script type="math/tex">\mathbf{B}(t)</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}(t)</span><script type="math/tex">\mathbf{C}(t)</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}(t)</span><script type="math/tex">\mathbf{D}(t)</script></span>이 시간에 따라 변하게 된다.</p>
<p>시간 가변 시스템의 상태 방정식은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{x}}(t) = \mathbf{A}(t) \mathbf{x}(t) + \mathbf{B}(t) \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{x}}(t) = \mathbf{A}(t) \mathbf{x}(t) + \mathbf{B}(t) \mathbf{u}(t)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}(t) = \mathbf{C}(t) \mathbf{x}(t) + \mathbf{D}(t) \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{y}(t) = \mathbf{C}(t) \mathbf{x}(t) + \mathbf{D}(t) \mathbf{u}(t)
</script>
</div>
<p>시간 가변 시스템에서는 상태 전이 행렬이 더 복잡하게 계산되며, 시스템의 시간에 따른 동작을 분석하는 것이 더 어렵다. 그러나 상태 공간 표현의 기본 원리는 시간 가변 시스템에서도 동일하게 적용된다.</p>
<h3 id="_8">상태 공간에서의 안정성</h3>
<p>상태 공간 표현에서 <strong>시스템의 안정성</strong>은 시스템 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 고유값에 의해 결정된다. 만약 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 모든 고유값의 실수부가 음수라면, 시스템은 안정적이다. 고유값의 실수부가 양수인 경우 시스템은 불안정하고, 0인 경우는 경계적 안정성을 갖는다.</p>
<p>이를 구체적으로 표현하면, 시스템의 고유값 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>가 다음 조건을 만족해야 한다:
- 안정적일 때: <span class="arithmatex"><span class="MathJax_Preview">\text{Re}(\lambda) &lt; 0</span><script type="math/tex">\text{Re}(\lambda) < 0</script></span>
- 불안정할 때: <span class="arithmatex"><span class="MathJax_Preview">\text{Re}(\lambda) &gt; 0</span><script type="math/tex">\text{Re}(\lambda) > 0</script></span>
- 경계적 안정성일 때: <span class="arithmatex"><span class="MathJax_Preview">\text{Re}(\lambda) = 0</span><script type="math/tex">\text{Re}(\lambda) = 0</script></span></p>
<p>고유값 분석은 시스템이 시간이 지남에 따라 발산하는지, 수렴하는지, 또는 일정한 값을 유지하는지를 결정하는 데 매우 중요한 도구이다.</p>
<h3 id="controllability">제어 가능성 (Controllability)</h3>
<p>상태 공간 표현에서 중요한 성질 중 하나는 <strong>제어 가능성</strong>(Controllability)이다. 제어 가능성은 시스템에 적절한 입력을 가했을 때, 시스템의 모든 상태 변수를 원하는 값으로 만들 수 있는 능력을 의미한다. 즉, 초기 상태에서 시작해 입력을 조정하여 시스템을 원하는 최종 상태로 이동시킬 수 있는지를 결정한다.</p>
<p>제어 가능성의 수학적 정의는 <strong>제어 가능 행렬</strong>(Controllability Matrix)을 통해 확인할 수 있다. 제어 가능 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \begin{bmatrix} \mathbf{B} &amp; \mathbf{A}\mathbf{B} &amp; \mathbf{A}^2 \mathbf{B} &amp; \dots &amp; \mathbf{A}^{n-1} \mathbf{B} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \begin{bmatrix} \mathbf{B} & \mathbf{A}\mathbf{B} & \mathbf{A}^2 \mathbf{B} & \dots & \mathbf{A}^{n-1} \mathbf{B} \end{bmatrix}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 시스템 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 입력 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>은 상태 변수의 개수이다.</p>
<p>시스템이 <strong>제어 가능</strong>하려면, 제어 가능 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>의 행렬식이 0이 아니어야 한다. 즉, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>가 풀랭크(Full Rank)일 때 시스템은 제어 가능하다고 말할 수 있다. 만약 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>가 풀랭크가 아니라면, 일부 상태 변수는 입력에 의해 제어할 수 없다는 것을 의미한다.</p>
<h3 id="_9">제어 가능성의 테스트</h3>
<p>제어 가능성을 확인하는 방법으로는 <strong>칼만의 제어 가능성 테스트</strong>(Kalman Controllability Test)가 있다. 이 테스트에서는 제어 가능 행렬의 랭크를 구하여 시스템이 제어 가능한지 판단한다. 구체적으로, 제어 가능 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>의 랭크가 상태 변수의 차원 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>과 같으면, 시스템은 완전 제어 가능한다.</p>
<h4 id="2">예시: 2차 시스템에서의 제어 가능성</h4>
<p>2차 시스템을 예로 들어 보겠다. 시스템의 상태 방정식이 다음과 같다고 가정하자:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \begin{bmatrix} 0 &amp; 1 \\ -2 &amp; -3 \end{bmatrix}, \quad \mathbf{B} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \begin{bmatrix} 0 & 1 \\ -2 & -3 \end{bmatrix}, \quad \mathbf{B} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}
</script>
</div>
<p>이 시스템의 제어 가능 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \begin{bmatrix} \mathbf{B} &amp; \mathbf{A} \mathbf{B} \end{bmatrix} = \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; -3 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \begin{bmatrix} \mathbf{B} & \mathbf{A} \mathbf{B} \end{bmatrix} = \begin{bmatrix} 0 & 1 \\ 1 & -3 \end{bmatrix}
</script>
</div>
<p>이제 이 행렬의 랭크를 계산하면, 랭크는 2이다. 따라서 이 시스템은 제어 가능한 시스템이다.</p>
<h3 id="observability">관측 가능성 (Observability)</h3>
<p>제어 가능성과 함께 상태 공간 표현에서 중요한 또 다른 개념은 <strong>관측 가능성</strong>(Observability)이다. 관측 가능성은 시스템의 출력 값을 통해 모든 상태 변수를 정확하게 추정할 수 있는 능력을 의미한다. 즉, 시스템의 상태를 알지 못하는 상황에서 출력 데이터를 사용해 상태를 복원할 수 있는지 여부를 결정한다.</p>
<p>관측 가능성은 <strong>관측 가능 행렬</strong>(Observability Matrix)을 통해 수학적으로 정의된다. 관측 가능 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}</span><script type="math/tex">\mathbf{O}</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{O} = \begin{bmatrix} \mathbf{C} \\ \mathbf{C} \mathbf{A} \\ \mathbf{C} \mathbf{A}^2 \\ \dots \\ \mathbf{C} \mathbf{A}^{n-1} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{O} = \begin{bmatrix} \mathbf{C} \\ \mathbf{C} \mathbf{A} \\ \mathbf{C} \mathbf{A}^2 \\ \dots \\ \mathbf{C} \mathbf{A}^{n-1} \end{bmatrix}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 출력 행렬이다.</p>
<p>시스템이 <strong>관측 가능</strong>하려면, 관측 가능 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}</span><script type="math/tex">\mathbf{O}</script></span>의 행렬식이 0이 아니어야 한다. 즉, 관측 가능 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}</span><script type="math/tex">\mathbf{O}</script></span>가 풀랭크(Full Rank)일 때 시스템은 완전 관측 가능하다고 할 수 있다.</p>
<h3 id="_10">관측 가능성의 테스트</h3>
<p>관측 가능성을 확인하는 방법으로 <strong>칼만의 관측 가능성 테스트</strong>(Kalman Observability Test)가 있다. 제어 가능성 테스트와 마찬가지로, 관측 가능 행렬의 랭크를 구하여 시스템이 관측 가능한지 판단한다. 관측 가능 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}</span><script type="math/tex">\mathbf{O}</script></span>의 랭크가 상태 변수의 차원 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>과 같으면, 시스템은 완전 관측 가능하다고 할 수 있다.</p>
<h4 id="2_1">예시: 2차 시스템에서의 관측 가능성</h4>
<p>이제 같은 2차 시스템의 경우, 출력 방정식이 다음과 같다고 가정하자:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}(t) = \mathbf{C} \mathbf{x}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{y}(t) = \mathbf{C} \mathbf{x}(t)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \begin{bmatrix} 1 &amp; 0 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \begin{bmatrix} 1 & 0 \end{bmatrix}
</script>
</div>
<p>이 경우 관측 가능 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}</span><script type="math/tex">\mathbf{O}</script></span>는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{O} = \begin{bmatrix} \mathbf{C} \\ \mathbf{C} \mathbf{A} \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{O} = \begin{bmatrix} \mathbf{C} \\ \mathbf{C} \mathbf{A} \end{bmatrix} = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}
</script>
</div>
<p>이 행렬의 랭크는 2이므로, 이 시스템은 완전 관측 가능한 시스템이다.</p>
<h3 id="_11">제어 가능성과 관측 가능성의 관계</h3>
<p>제어 가능성과 관측 가능성은 서로 밀접하게 관련되어 있지만, 상호 독립적인 개념이다. 시스템이 제어 가능하더라도 관측 가능하지 않을 수 있으며, 그 반대의 경우도 성립할 수 있다. 따라서 두 가지 성질을 모두 고려하여 시스템을 설계하고 분석하는 것이 중요하다.</p>
<p>특히 <strong>이중성 원리</strong>(Duality Principle)에 따르면, 제어 가능성과 관측 가능성은 서로 대칭적인 관계를 가진다. 제어 가능 행렬과 관측 가능 행렬을 서로 대칭적으로 변환할 수 있으며, 이로 인해 한 시스템의 제어 가능성과 관측 가능성 분석이 동일한 수학적 구조를 가질 수 있다.</p>
<h3 id="_12">상태 피드백 제어</h3>
<p>상태 공간 표현에서 <strong>상태 피드백 제어</strong>(State Feedback Control)는 시스템의 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>를 피드백하여 제어 입력을 결정하는 방법이다. 이를 통해 시스템의 동적 거동을 원하는 대로 조정할 수 있다. 상태 피드백 제어는 시스템의 모든 상태 변수를 실시간으로 측정할 수 있다는 가정 하에, 입력을 상태 벡터의 선형 결합으로 나타낸다.</p>
<p>상태 피드백 제어는 다음과 같은 형태로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(t) = -\mathbf{K} \mathbf{x}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{u}(t) = -\mathbf{K} \mathbf{x}(t)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>는 <strong>이득 행렬</strong>(Gain Matrix)로, 제어기의 성능을 결정하는 중요한 요소이다. 크기는 <span class="arithmatex"><span class="MathJax_Preview">m \times n</span><script type="math/tex">m \times n</script></span>이며, <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 입력의 차원, <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>은 상태 벡터의 차원이다.</p>
<p>상태 피드백 제어를 시스템에 적용하면, 상태 방정식은 다음과 같이 변경된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{x}}(t) = (\mathbf{A} - \mathbf{B} \mathbf{K}) \mathbf{x}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{x}}(t) = (\mathbf{A} - \mathbf{B} \mathbf{K}) \mathbf{x}(t)
</script>
</div>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} - \mathbf{B} \mathbf{K}</span><script type="math/tex">\mathbf{A} - \mathbf{B} \mathbf{K}</script></span>는 <strong>폐루프 시스템 행렬</strong>(Closed-Loop System Matrix)이라고 하며, 이 행렬의 고유값에 의해 시스템의 안정성이 결정된다. 상태 피드백 제어를 통해 이 고유값들을 원하는 위치로 배치하여 시스템의 안정성과 응답 속도를 제어할 수 있다.</p>
<h3 id="pole-placement">이득 배치 (Pole Placement)</h3>
<p>상태 피드백 제어의 중요한 설계 방법 중 하나는 <strong>이득 배치</strong>(Pole Placement)이다. 이 기법은 시스템의 폐루프 고유값을 원하는 위치에 배치하기 위해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span> 행렬을 설계하는 과정이다. 고유값은 시스템의 동적 거동, 특히 안정성과 응답 속도를 결정하므로, 이를 적절히 설계하는 것이 매우 중요하다.</p>
<p>이득 배치는 시스템이 제어 가능할 때 가능하며, 제어 가능하지 않은 시스템에서는 이 기법을 사용할 수 없다. 이득 배치를 통해 시스템의 특성 방정식이 원하는 고유값을 갖도록 설계할 수 있다.</p>
<h4 id="2_2">예시: 2차 시스템의 이득 배치</h4>
<p>2차 시스템을 고려해 보자. 시스템의 상태 방정식이 다음과 같다고 가정한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{x}}(t) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \begin{bmatrix} 0 &amp; 1 \\ -2 &amp; -3 \end{bmatrix}, \quad \mathbf{B} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \begin{bmatrix} 0 & 1 \\ -2 & -3 \end{bmatrix}, \quad \mathbf{B} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}
</script>
</div>
<p>이 시스템에 상태 피드백을 적용한다고 가정하고, 원하는 폐루프 고유값이 <span class="arithmatex"><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">-2</span><script type="math/tex">-2</script></span>라고 설정하겠다. 먼저, 특성 방정식은 다음과 같이 설정된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
(s + 1)(s + 2) = s^2 + 3s + 2
</div>
<script type="math/tex; mode=display">
(s + 1)(s + 2) = s^2 + 3s + 2
</script>
</div>
<p>상태 피드백 제어를 통해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} - \mathbf{B} \mathbf{K}</span><script type="math/tex">\mathbf{A} - \mathbf{B} \mathbf{K}</script></span> 행렬의 고유값이 이 특성 방정식의 근과 같도록 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>를 설계한다. 이를 통해 시스템의 동적 거동을 원하는 대로 조정할 수 있다.</p>
<h3 id="observer-design">관측기 설계 (Observer Design)</h3>
<p>실제 시스템에서는 모든 상태 변수를 측정할 수 없는 경우가 많다. 이러한 경우 <strong>관측기</strong>(Observer)를 사용하여 상태 변수를 추정할 수 있다. 관측기는 시스템의 출력과 입력을 사용해 상태 변수를 실시간으로 추정하며, 이 추정된 상태 값을 바탕으로 제어를 수행할 수 있다.</p>
<p><strong>루엔버거 관측기</strong>(Luenberger Observer)는 가장 널리 사용되는 관측기 설계 방법 중 하나이다. 루엔버거 관측기는 다음과 같은 형태로 상태를 추정한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{\hat{x}}}(t) = \mathbf{A} \mathbf{\hat{x}}(t) + \mathbf{B} \mathbf{u}(t) + \mathbf{L} \left( \mathbf{y}(t) - \mathbf{C} \mathbf{\hat{x}}(t) \right)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{\hat{x}}}(t) = \mathbf{A} \mathbf{\hat{x}}(t) + \mathbf{B} \mathbf{u}(t) + \mathbf{L} \left( \mathbf{y}(t) - \mathbf{C} \mathbf{\hat{x}}(t) \right)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\hat{x}}(t)</span><script type="math/tex">\mathbf{\hat{x}}(t)</script></span>는 추정된 상태 벡터이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>은 <strong>관측기 이득 행렬</strong>(Observer Gain Matrix)로, 추정된 상태와 실제 출력을 비교하여 오차를 보정한다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}(t) - \mathbf{C} \mathbf{\hat{x}}(t)</span><script type="math/tex">\mathbf{y}(t) - \mathbf{C} \mathbf{\hat{x}}(t)</script></span>는 <strong>추정 오차</strong>로, 관측기는 이 오차를 줄이기 위해 동작한다.</p>
<p>관측기 이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>을 적절히 설계하면 추정된 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\hat{x}}(t)</span><script type="math/tex">\mathbf{\hat{x}}(t)</script></span>는 실제 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>로 수렴하게 된다. 이때 관측기 이득을 설계하는 방법은 이득 배치와 유사하게 <strong>폴 배치</strong>(Pole Placement)를 사용할 수 있다.</p>
<h3 id="_13">관측기와 상태 피드백 제어의 결합</h3>
<p>상태 피드백 제어와 관측기를 결합하면 <strong>출력 피드백 제어</strong>(Output Feedback Control)를 구현할 수 있다. 이 방식은 시스템의 출력을 사용하여 상태를 추정하고, 이 추정된 상태를 기반으로 상태 피드백 제어를 적용하는 구조이다.</p>
<p>이 결합된 시스템은 다음과 같이 표현된다:</p>
<ol>
<li>관측기를 통해 상태 추정:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{\dot{\hat{x}}}(t) = \mathbf{A} \mathbf{\hat{x}}(t) + \mathbf{B} \mathbf{u}(t) + \mathbf{L} \left( \mathbf{y}(t) - \mathbf{C} \mathbf{\hat{x}}(t) \right)
</div>
<script type="math/tex; mode=display">
   \mathbf{\dot{\hat{x}}}(t) = \mathbf{A} \mathbf{\hat{x}}(t) + \mathbf{B} \mathbf{u}(t) + \mathbf{L} \left( \mathbf{y}(t) - \mathbf{C} \mathbf{\hat{x}}(t) \right)
</script>
</div>
<ol>
<li>상태 피드백 제어:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{u}(t) = -\mathbf{K} \mathbf{\hat{x}}(t)
</div>
<script type="math/tex; mode=display">
   \mathbf{u}(t) = -\mathbf{K} \mathbf{\hat{x}}(t)
</script>
</div>
<p>이와 같은 구조에서, 관측기를 통해 추정된 상태 값이 상태 피드백 제어의 입력으로 사용되며, 시스템의 제어와 상태 추정이 동시에 이루어진다. 관측기와 상태 피드백 제어의 결합은 특히 실질적인 시스템에서 중요한 방법이다. 시스템의 모든 상태를 측정할 수 없더라도 관측기를 통해 상태 변수를 추정하고, 이 정보를 바탕으로 효율적인 제어를 수행할 수 있다.</p>
<h3 id="_14">상태 공간에서의 분리 원리</h3>
<p>상태 피드백 제어와 관측기 설계는 <strong>분리 원리</strong>(Separation Principle)에 따라 독립적으로 설계할 수 있다. 즉, 상태 피드백 제어기의 설계와 관측기의 설계는 상호 독립적이며, 각각의 성능에 영향을 미치지 않는다. 이로 인해 시스템의 제어 성능과 상태 추정 성능을 별도로 최적화할 수 있다.</p>
<p>따라서 제어기 이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>와 관측기 이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>을 설계하는 과정은 서로 독립적으로 수행할 수 있으며, 각각의 설계를 통해 원하는 제어 성능과 상태 추정 성능을 달성할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0120_tf_and_gain/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0120_tf_and_gain/" class="btn btn-xs btn-link">
        제어시스템에서 전달함수와 이득의 관계
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0118_transfer_function/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0118_transfer_function/" class="btn btn-xs btn-link">
        전달함수
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>