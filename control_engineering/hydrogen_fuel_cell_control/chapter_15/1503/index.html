<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/control_engineering/hydrogen_fuel_cell_control/chapter_15/1503/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>슬라이딩 모드 제어 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc2ac\ub77c\uc774\ub529 \ud45c\uba74 \uc815\uc758", url: "#_top", children: [
          ]},
          {title: "\uc2ac\ub77c\uc774\ub529 \ubaa8\ub4dc\uc758 \uc874\uc7ac \uc870\uac74", url: "#_2", children: [
          ]},
          {title: "\uc81c\uc5b4 \ubc95\uce59", url: "#_3", children: [
          ]},
          {title: "\ucc44\ud130\ub9c1 \ubb38\uc81c", url: "#_4", children: [
          ]},
          {title: "\uc2ac\ub77c\uc774\ub529 \ubaa8\ub4dc \uc81c\uc5b4\uc758 \uac15\uac74\uc131", url: "#_5", children: [
              {title: "\ubaa8\ub378\ub9c1 \ubd88\ud655\uc2e4\uc131\uc5d0 \ub300\ud55c \uac15\uac74\uc131", url: "#_6" },
              {title: "\uc678\ub780\uc5d0 \ub300\ud55c \uac15\uac74\uc131", url: "#_7" },
          ]},
          {title: "\uc2ac\ub77c\uc774\ub529 \ubaa8\ub4dc \uc81c\uc5b4\uc758 \uc801\uc6a9 \uc0ac\ub840", url: "#_8", children: [
              {title: "\ub85c\ubd07 \uc81c\uc5b4 \uc2dc\uc2a4\ud15c", url: "#_9" },
              {title: "\uc804\ub825 \ubcc0\ud658 \uc7a5\uce58", url: "#_10" },
          ]},
          {title: "\uc2ac\ub77c\uc774\ub529 \ubaa8\ub4dc \uc81c\uc5b4\uc758 \uc124\uacc4 \uc808\ucc28", url: "#_11", children: [
              {title: "1. \uc2dc\uc2a4\ud15c \ubaa8\ub378 \uc815\uc758", url: "#1" },
              {title: "2. \uc2ac\ub77c\uc774\ub529 \ud45c\uba74 \uc124\uacc4", url: "#2" },
              {title: "3. \uc2ac\ub77c\uc774\ub529 \ubaa8\ub4dc \uc874\uc7ac \uc870\uac74 \ud655\uc778", url: "#3" },
              {title: "4. \uc2a4\uc704\uce6d \uc81c\uc5b4 \ubc95\uce59 \uc124\uacc4", url: "#4" },
              {title: "5. \ucc44\ud130\ub9c1 \ubc29\uc9c0", url: "#5" },
          ]},
          {title: "\uc2ac\ub77c\uc774\ub529 \ubaa8\ub4dc \uc81c\uc5b4\uc758 \uc7a5\ub2e8\uc810", url: "#_12", children: [
              {title: "\uc7a5\uc810", url: "#_13" },
              {title: "\ub2e8\uc810", url: "#_14" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1504/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1504/" class="btn btn-xs btn-link">
        비선형 제어
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1502/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1502/" class="btn btn-xs btn-link">
        강건 제어
      </a>
    </div>
    
  </div>

    

    <p>슬라이딩 모드 제어(Sliding Mode Control, SMC)는 비선형 시스템의 제어 문제를 해결하기 위한 강력한 제어 기법이다. 이 제어 방식은 시스템 상태를 선형 혹은 비선형 경계를 정의하는 슬라이딩 표면(sliding surface)으로 강제하여, 그 표면에서 시스템의 동작을 유지시키는 특징을 가진다. 슬라이딩 모드 제어는 비선형성, 모델링 불확실성, 외란 등에 대해 높은 강건성을 가지며, 비교적 간단한 구조를 가진다는 장점이 있다.</p>
<h2 id="_1">슬라이딩 표면 정의</h2>
<p>슬라이딩 모드 제어는 슬라이딩 표면을 정의하는 것으로 시작된다. 주어진 시스템의 상태 벡터를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>라고 하고, 제어 목표가 해당 상태를 슬라이딩 표면 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{s}(\mathbf{x})</span><script type="math/tex">\mathbf{s}(\mathbf{x})</script></span>로 수렴시키는 것이라고 가정한다. 슬라이딩 표면은 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{s}(\mathbf{x}) = \mathbf{C} \mathbf{x} - \mathbf{x}_d
</div>
<script type="math/tex; mode=display">
\mathbf{s}(\mathbf{x}) = \mathbf{C} \mathbf{x} - \mathbf{x}_d
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 슬라이딩 표면을 정의하는 행렬이며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_d</span><script type="math/tex">\mathbf{x}_d</script></span>는 목표 상태를 나타낸다. 슬라이딩 표면은 상태가 목표 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_d</span><script type="math/tex">\mathbf{x}_d</script></span>에 접근할 때 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{s}(\mathbf{x}) = 0</span><script type="math/tex">\mathbf{s}(\mathbf{x}) = 0</script></span>이 되도록 설계된다.</p>
<h2 id="_2">슬라이딩 모드의 존재 조건</h2>
<p>슬라이딩 모드 제어는 시스템이 슬라이딩 표면에 도달하도록 강제하고, 일단 표면에 도달하면 그 위에서 시스템이 유지되도록 해야 한다. 이를 위해 슬라이딩 모드의 존재 조건을 만족해야 한다. 슬라이딩 모드의 존재 조건은 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\dot{\mathbf{s}}(\mathbf{x}) = \frac{d}{dt} \mathbf{s}(\mathbf{x}) = 0
</div>
<script type="math/tex; mode=display">
\dot{\mathbf{s}}(\mathbf{x}) = \frac{d}{dt} \mathbf{s}(\mathbf{x}) = 0
</script>
</div>
<p>즉, 슬라이딩 표면에서의 시간에 대한 변화율이 0이 되어야 시스템이 그 위에서 유지될 수 있다.</p>
<h2 id="_3">제어 법칙</h2>
<p>슬라이딩 모드 제어에서 사용되는 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>는 시스템을 슬라이딩 표면으로 빠르게 수렴시키는 역할을 한다. 이때, 시스템의 모델링 오차나 외란을 고려하여 비연속적인 제어 법칙을 사용한다. 일반적인 제어 법칙은 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(t) = \mathbf{u}_{eq} + \mathbf{u}_{sw}
</div>
<script type="math/tex; mode=display">
\mathbf{u}(t) = \mathbf{u}_{eq} + \mathbf{u}_{sw}
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{eq}</span><script type="math/tex">\mathbf{u}_{eq}</script></span>는 슬라이딩 모드에 도달한 이후의 평형 제어 입력을 나타내며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{sw}</span><script type="math/tex">\mathbf{u}_{sw}</script></span>는 시스템을 슬라이딩 표면으로 강제하는 스위칭(switching) 제어 입력이다.</p>
<p>평형 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{eq}</span><script type="math/tex">\mathbf{u}_{eq}</script></span>는 슬라이딩 표면에서의 시스템 동역학을 유지하기 위해 설계되며, 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{eq} = - \mathbf{A}^{-1} \mathbf{B} \mathbf{s}(\mathbf{x})
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{eq} = - \mathbf{A}^{-1} \mathbf{B} \mathbf{s}(\mathbf{x})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 시스템의 동역학 행렬이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 제어 입력에 해당하는 행렬이다. 스위칭 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{sw}</span><script type="math/tex">\mathbf{u}_{sw}</script></span>는 슬라이딩 표면으로 수렴하기 위한 비연속 제어 입력으로, 보통 다음과 같은 형태로 주어진다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{sw} = -k \text{sign}(\mathbf{s}(\mathbf{x}))
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{sw} = -k \text{sign}(\mathbf{s}(\mathbf{x}))
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>는 스위칭 이득이며, <span class="arithmatex"><span class="MathJax_Preview">\text{sign}(\mathbf{s}(\mathbf{x}))</span><script type="math/tex">\text{sign}(\mathbf{s}(\mathbf{x}))</script></span>은 슬라이딩 표면의 부호를 결정하는 함수이다.</p>
<h2 id="_4">채터링 문제</h2>
<p>슬라이딩 모드 제어의 대표적인 문제 중 하나는 채터링(chattering) 현상이다. 채터링은 제어 입력이 무한히 빠른 속도로 변동하는 현상으로, 이는 이상적인 슬라이딩 표면 근처에서 발생한다. 실질적으로 제어 입력의 불연속성이 시스템에 고주파 진동을 유발하여, 기계적 시스템에서는 물리적인 손상이나 성능 저하를 야기할 수 있다.</p>
<p>이를 방지하기 위한 방법으로는 제어 입력을 부드럽게 만드는 방법이나, 슬라이딩 표면 근처에서 연속적인 제어법을 적용하는 방법이 있다. 이러한 방법 중 하나는 경계층(boundary layer)을 설정하여 슬라이딩 표면 근처에서 제어 입력을 연속적으로 변화시키는 것이다. 경계층 제어는 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{sw} = -k \frac{\mathbf{s}(\mathbf{x})}{|\mathbf{s}(\mathbf{x})| + \epsilon}
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{sw} = -k \frac{\mathbf{s}(\mathbf{x})}{|\mathbf{s}(\mathbf{x})| + \epsilon}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>은 경계층의 폭을 나타내며, 이를 통해 채터링을 줄일 수 있다.</p>
<h2 id="_5">슬라이딩 모드 제어의 강건성</h2>
<p>슬라이딩 모드 제어는 시스템의 모델링 불확실성 및 외란에 대한 강건성을 제공하는 특징이 있다. 이는 슬라이딩 표면 위에 있는 동안 시스템이 외부의 영향이나 시스템 모델의 변화에 크게 영향을 받지 않기 때문이다. 슬라이딩 모드 제어의 강건성은 다음과 같은 원리로 설명할 수 있다.</p>
<h3 id="_6">모델링 불확실성에 대한 강건성</h3>
<p>슬라이딩 모드 제어에서는 시스템이 슬라이딩 표면으로 강제된 후, 슬라이딩 표면 위에서 시스템의 동작이 제어된다. 이때, 모델링 불확실성이나 외란이 있을 경우에도 슬라이딩 표면을 유지하는 한 시스템의 동작은 크게 영향을 받지 않는다. 이는 슬라이딩 모드 제어의 스위칭 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{sw}</span><script type="math/tex">\mathbf{u}_{sw}</script></span>가 이러한 불확실성을 보상해주기 때문이다. </p>
<p>구체적으로, 시스템 동역학이 다음과 같이 주어진다고 가정한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\dot{x}} = \mathbf{A} \mathbf{x} + \mathbf{B} \mathbf{u} + \mathbf{d}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{\dot{x}} = \mathbf{A} \mathbf{x} + \mathbf{B} \mathbf{u} + \mathbf{d}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}(t)</span><script type="math/tex">\mathbf{d}(t)</script></span>는 시간에 따라 변화하는 외란 또는 모델링 오차이다. 슬라이딩 표면 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{s}(\mathbf{x}) = 0</span><script type="math/tex">\mathbf{s}(\mathbf{x}) = 0</script></span> 위에서는 다음의 조건을 만족하게 된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\dot{\mathbf{s}}(\mathbf{x}) = \mathbf{C} \mathbf{A} \mathbf{x} + \mathbf{C} \mathbf{B} \mathbf{u} + \mathbf{C} \mathbf{d}(t) = 0
</div>
<script type="math/tex; mode=display">
\dot{\mathbf{s}}(\mathbf{x}) = \mathbf{C} \mathbf{A} \mathbf{x} + \mathbf{C} \mathbf{B} \mathbf{u} + \mathbf{C} \mathbf{d}(t) = 0
</script>
</div>
<p>제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{eq}</span><script type="math/tex">\mathbf{u}_{eq}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{sw}</span><script type="math/tex">\mathbf{u}_{sw}</script></span>로 구성되며, 스위칭 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{sw}</span><script type="math/tex">\mathbf{u}_{sw}</script></span>가 외란 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}(t)</span><script type="math/tex">\mathbf{d}(t)</script></span>를 보상하기 때문에 시스템은 슬라이딩 표면 위에서 외란의 영향을 최소화할 수 있다.</p>
<h3 id="_7">외란에 대한 강건성</h3>
<p>슬라이딩 모드 제어의 또 다른 장점은 외란에 대한 강건성이다. 스위칭 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{sw}</span><script type="math/tex">\mathbf{u}_{sw}</script></span>는 시스템을 슬라이딩 표면으로 강제로 유도하고, 이 과정에서 외란이 시스템에 영향을 주더라도 슬라이딩 모드 제어는 외란을 보상하려는 성질을 갖는다. 예를 들어, 일정한 외란이 존재할 경우 스위칭 제어 입력은 이를 상쇄하도록 설계될 수 있다.</p>
<p>이를 수식으로 표현하면, 외란 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}(t)</span><script type="math/tex">\mathbf{d}(t)</script></span>가 존재할 때 슬라이딩 표면에서의 조건은 다음과 같이 쓸 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} \mathbf{B} \mathbf{u}_{sw} = -\mathbf{C} \mathbf{d}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{C} \mathbf{B} \mathbf{u}_{sw} = -\mathbf{C} \mathbf{d}(t)
</script>
</div>
<p>즉, 스위칭 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{sw}</span><script type="math/tex">\mathbf{u}_{sw}</script></span>는 외란 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}(t)</span><script type="math/tex">\mathbf{d}(t)</script></span>를 상쇄하는 역할을 하며, 이를 통해 슬라이딩 표면에서의 외란을 효과적으로 제거할 수 있다.</p>
<h2 id="_8">슬라이딩 모드 제어의 적용 사례</h2>
<p>슬라이딩 모드 제어는 다양한 분야에서 그 강력한 성능으로 인해 널리 사용된다. 그 중에서도 특히 비선형 시스템, 로봇 제어, 전력 변환 장치, 항공기 제어, 자동차 시스템 등에서 효과적인 성능을 보인다. 예를 들어, 슬라이딩 모드 제어는 로봇 팔과 같은 비선형 멀티 조인트 시스템의 위치 및 속도 제어에 유용하며, 외란이나 모델링 불확실성이 존재하는 환경에서도 안정적인 제어 성능을 유지할 수 있다.</p>
<h3 id="_9">로봇 제어 시스템</h3>
<p>로봇 제어에서 슬라이딩 모드 제어는 높은 강건성과 응답 속도를 제공하여, 멀티 조인트 로봇의 제어에 널리 적용된다. 멀티 조인트 로봇은 비선형성을 가지며, 외란과 모델링 오차에 민감하다. 슬라이딩 모드 제어는 이러한 비선형 시스템에서도 모델링 오차나 외란을 보상하면서 안정적인 제어를 가능하게 한다.</p>
<h3 id="_10">전력 변환 장치</h3>
<p>슬라이딩 모드 제어는 전력 변환 장치에서도 효과적으로 사용된다. 예를 들어, DC-DC 변환기와 같은 시스템은 슬라이딩 모드 제어를 통해 입력 전압의 변화나 부하 변화에 강건하게 동작할 수 있다. 슬라이딩 모드 제어의 스위칭 특성은 변환기의 동작을 빠르고 정확하게 제어할 수 있게 해준다.</p>
<h2 id="_11">슬라이딩 모드 제어의 설계 절차</h2>
<p>슬라이딩 모드 제어 시스템을 설계할 때는 시스템 모델을 정의하고, 슬라이딩 표면을 설계한 후, 스위칭 제어 법칙을 적용하여 시스템을 슬라이딩 표면으로 수렴시키는 일련의 단계가 필요하다. 슬라이딩 모드 제어의 설계 절차는 다음과 같이 요약된다.</p>
<h3 id="1">1. 시스템 모델 정의</h3>
<p>먼저 슬라이딩 모드 제어를 적용할 시스템의 수학적 모델을 정의해야 한다. 시스템이 다음과 같은 상태 방정식으로 표현된다고 가정하자.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\dot{\mathbf{x}} = \mathbf{A} \mathbf{x} + \mathbf{B} \mathbf{u} + \mathbf{d}(t)
</div>
<script type="math/tex; mode=display">
\dot{\mathbf{x}} = \mathbf{A} \mathbf{x} + \mathbf{B} \mathbf{u} + \mathbf{d}(t)
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 상태 벡터, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>는 제어 입력, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 시스템 동역학 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 제어 입력에 대한 영향 행렬, 그리고 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}(t)</span><script type="math/tex">\mathbf{d}(t)</script></span>는 외란을 나타낸다.</p>
<h3 id="2">2. 슬라이딩 표면 설계</h3>
<p>슬라이딩 표면은 시스템이 강제로 수렴해야 하는 목표 상태를 정의하는 중요한 역할을 한다. 슬라이딩 표면 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{s}(\mathbf{x})</span><script type="math/tex">\mathbf{s}(\mathbf{x})</script></span>는 다음과 같이 설정된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{s}(\mathbf{x}) = \mathbf{C} \mathbf{x} - \mathbf{x}_d
</div>
<script type="math/tex; mode=display">
\mathbf{s}(\mathbf{x}) = \mathbf{C} \mathbf{x} - \mathbf{x}_d
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 설계자가 정의하는 행렬이며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_d</span><script type="math/tex">\mathbf{x}_d</script></span>는 목표 상태이다. 슬라이딩 표면의 설계는 시스템이 원하는 동작을 하도록 하기 위한 중요한 단계이다.</p>
<h3 id="3">3. 슬라이딩 모드 존재 조건 확인</h3>
<p>다음으로, 슬라이딩 모드가 존재할 수 있는지를 확인해야 한다. 슬라이딩 표면에서 상태 변화의 시간에 대한 변화율이 0이 되도록 하기 위해 다음 조건을 충족해야 한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\dot{\mathbf{s}}(\mathbf{x}) = \frac{d}{dt} \mathbf{s}(\mathbf{x}) = 0
</div>
<script type="math/tex; mode=display">
\dot{\mathbf{s}}(\mathbf{x}) = \frac{d}{dt} \mathbf{s}(\mathbf{x}) = 0
</script>
</div>
<p>이를 통해 시스템이 슬라이딩 표면을 따라 동작할 수 있는지 여부를 판단할 수 있다.</p>
<h3 id="4">4. 스위칭 제어 법칙 설계</h3>
<p>슬라이딩 모드 제어는 시스템을 슬라이딩 표면으로 빠르게 수렴시키기 위해 스위칭 제어 법칙을 사용한다. 스위칭 제어 법칙은 다음과 같이 설정된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(t) = \mathbf{u}_{eq} + \mathbf{u}_{sw}
</div>
<script type="math/tex; mode=display">
\mathbf{u}(t) = \mathbf{u}_{eq} + \mathbf{u}_{sw}
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{eq}</span><script type="math/tex">\mathbf{u}_{eq}</script></span>는 슬라이딩 표면을 유지하는 평형 제어 입력이며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{sw}</span><script type="math/tex">\mathbf{u}_{sw}</script></span>는 스위칭 제어 입력이다. 스위칭 제어 입력은 슬라이딩 표면으로 시스템을 유도하는 중요한 역할을 하며, 다음과 같은 형태로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{sw} = -k \text{sign}(\mathbf{s}(\mathbf{x}))
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{sw} = -k \text{sign}(\mathbf{s}(\mathbf{x}))
</script>
</div>
<p>스위칭 이득 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>는 시스템의 응답 속도와 강건성에 중요한 영향을 미치며, 적절히 설계되어야 한다.</p>
<h3 id="5">5. 채터링 방지</h3>
<p>스위칭 제어 방식은 이론적으로는 강력한 제어 성능을 제공하지만, 실제 시스템에서는 채터링(Chattering) 현상이 발생할 수 있다. 이를 해결하기 위해 경계층(boundary layer)을 설정하거나, 연속적인 제어 법칙을 적용하여 채터링을 줄일 수 있다.</p>
<p>경계층 제어 법칙은 다음과 같은 형태로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{sw} = -k \frac{\mathbf{s}(\mathbf{x})}{|\mathbf{s}(\mathbf{x})| + \epsilon}
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{sw} = -k \frac{\mathbf{s}(\mathbf{x})}{|\mathbf{s}(\mathbf{x})| + \epsilon}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>은 경계층의 폭을 나타내며, 이를 통해 스위칭 제어를 연속적인 제어로 변환하여 채터링을 줄일 수 있다.</p>
<h2 id="_12">슬라이딩 모드 제어의 장단점</h2>
<h3 id="_13">장점</h3>
<ol>
<li><strong>강건성</strong>: 슬라이딩 모드 제어는 외란이나 모델링 오차에 강건한 제어 성능을 제공한다. 슬라이딩 표면 위에서 시스템은 외부 영향에 크게 영향을 받지 않고 목표 상태를 유지할 수 있다.</li>
<li><strong>빠른 응답</strong>: 슬라이딩 모드 제어는 빠르게 시스템을 슬라이딩 표면으로 수렴시키므로 제어 응답 속도가 빠르다. 이는 실시간 제어가 중요한 응용 분야에서 매우 유리하다.</li>
</ol>
<h3 id="_14">단점</h3>
<ol>
<li><strong>채터링 문제</strong>: 스위칭 제어 입력의 비연속성으로 인해 실제 시스템에서 고주파 진동이 발생하는 채터링 문제가 생길 수 있다. 채터링은 시스템 성능을 저하시킬 수 있으므로 이를 해결하기 위한 추가적인 기법이 필요하다.</li>
<li><strong>설계 복잡성</strong>: 슬라이딩 표면의 설계와 스위칭 제어 법칙의 설정은 시스템의 동역학과 제어 요구 사항을 정확히 반영해야 하므로 설계 과정이 복잡할 수 있다.</li>
</ol>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1504/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1504/" class="btn btn-xs btn-link">
        비선형 제어
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1502/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1502/" class="btn btn-xs btn-link">
        강건 제어
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>