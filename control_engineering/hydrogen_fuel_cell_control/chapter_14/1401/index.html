<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/control_engineering/hydrogen_fuel_cell_control/chapter_14/1401/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>모델 기반 제어의 개념 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ubaa8\ub378 \uae30\ubc18 \uc81c\uc5b4\uc758 \uae30\ubcf8 \uc6d0\ub9ac", url: "#_top", children: [
          ]},
          {title: "\uc81c\uc5b4 \ubaa9\uc801", url: "#_2", children: [
          ]},
          {title: "\uc608\uce21 \ubc0f \ucd5c\uc801\ud654", url: "#_3", children: [
          ]},
          {title: "\uc81c\uc57d \uc870\uac74\uacfc \uc2dc\uc2a4\ud15c\uc758 \uc548\uc815\uc131", url: "#_4", children: [
              {title: "\uc2dc\uc2a4\ud15c\uc758 \uc548\uc815\uc131", url: "#_5" },
          ]},
          {title: "\uc608\uce21 \ubaa8\ub378\uc758 \uc120\ud0dd", url: "#_6", children: [
          ]},
          {title: "\uc608\uce21 \uc2dc\uac04 \uad6c\uac04\uacfc \uc81c\uc5b4 \uc8fc\uae30\uc758 \uc124\uc815", url: "#_7", children: [
              {title: "\uc608\uce21 \uc2dc\uac04 \uad6c\uac04", url: "#_8" },
              {title: "\uc81c\uc5b4 \uc8fc\uae30", url: "#_9" },
          ]},
          {title: "\ucd5c\uc801\ud654 \ubb38\uc81c\uc758 \ud574\uacb0", url: "#_10", children: [
              {title: "\uc120\ud615 \uacc4\ud68d\ubc95", url: "#_11" },
              {title: "\ube44\uc120\ud615 \uacc4\ud68d\ubc95", url: "#_12" },
          ]},
          {title: "\ube44\uc6a9 \ud568\uc218\uc758 \uad6c\uc131\uacfc \uac00\uc911\uce58 \uc120\ud0dd", url: "#_13", children: [
              {title: "\uc0c1\ud0dc \uc624\ucc28 \uac00\uc911\uce58 \\mathbf{Q}\\mathbf{Q}", url: "#mathbfqmathbfq" },
              {title: "\uc81c\uc5b4 \uc785\ub825 \uac00\uc911\uce58 \\mathbf{R}\\mathbf{R}", url: "#mathbfrmathbfr" },
              {title: "\uac00\uc911\uce58 \uc120\ud0dd\uc758 \uc911\uc694\uc131", url: "#_14" },
          ]},
          {title: "\uc2e4\uc2dc\uac04 \uc801\uc6a9\uc744 \uc704\ud55c \uacc4\uc0b0 \ucd5c\uc801\ud654", url: "#_15", children: [
              {title: "\ucd95\uc18c\ub41c \uc608\uce21 \ubaa8\ub378 \uc0ac\uc6a9", url: "#_16" },
              {title: "\ubcd1\ub82c \ucc98\ub9ac \uae30\ubc95", url: "#_17" },
          ]},
          {title: "\ud558\uc704 \ucd5c\uc801\ud654 \ubb38\uc81c \ubd84\ud560", url: "#_18", children: [
              {title: "\uc774\ub3d9 \uad6c\uac04 \ucd5c\uc801\ud654 (Receding Horizon Optimization)", url: "#receding-horizon-optimization" },
              {title: "\ubd84\uc0b0 \ubaa8\ub378 \uae30\ubc18 \uc81c\uc5b4 (Distributed Model Predictive Control, DMPC)", url: "#distributed-model-predictive-control-dmpc" },
          ]},
          {title: "\uc0c1\ud0dc \uc608\uce21\uacfc \uc2dc\uc2a4\ud15c \ubaa8\ub378\uc758 \uc815\ud655\uc131", url: "#_19", children: [
              {title: "\ubaa8\ub378 \ubd88\ud655\uc2e4\uc131", url: "#_20" },
              {title: "\uc678\ub780\uacfc \uc7a1\uc74c \ucc98\ub9ac", url: "#_21" },
          ]},
          {title: "\ubaa8\ub378 \uae30\ubc18 \uc81c\uc5b4\uc758 \uc751\uc6a9 \ubd84\uc57c", url: "#_22", children: [
              {title: "\ud504\ub85c\uc138\uc2a4 \uc81c\uc5b4", url: "#_23" },
              {title: "\uc790\ub3d9\ucc28 \uc81c\uc5b4", url: "#_24" },
              {title: "\ub85c\ubd07 \uc81c\uc5b4", url: "#_25" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1402/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1402/" class="btn btn-xs btn-link">
        수소 전지 모델링
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_13/1305/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_13/1305/" class="btn btn-xs btn-link">
        실시간 데이터 수집 및 분석
      </a>
    </div>
    
  </div>

    

    <p>모델 기반 제어(Model Predictive Control, MPC)는 다변수 제어 시스템에서 미래의 시스템 동작을 예측하고 제어 입력을 결정하는 최적 제어 기법이다. 기본적으로 MPC는 시스템의 동적 모델을 활용하여 일정한 예측 시간을 설정하고, 그 기간 동안 시스템의 상태를 예측한다. 이를 통해 MPC는 시스템의 상태와 제어 목표를 만족시키기 위한 최적의 제어 입력을 계산한다.</p>
<h2 id="_1">모델 기반 제어의 기본 원리</h2>
<p>모델 기반 제어는 시스템의 수학적 모델을 사용하여 상태 변수들의 미래 동작을 예측한다. 이 과정에서 예측 시간 구간을 설정하고, 예측 모델을 바탕으로 제어 입력을 미리 계산하는 방식으로 동작한다. 시스템의 상태는 상태 공간 표현으로 나타낼 수 있으며, 이는 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(k+1) = \mathbf{A}\mathbf{x}(k) + \mathbf{B}\mathbf{u}(k)
</div>
<script type="math/tex; mode=display">
\mathbf{x}(k+1) = \mathbf{A}\mathbf{x}(k) + \mathbf{B}\mathbf{u}(k)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-번째 시간 스텝에서의 상태 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 시스템의 상태 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 제어 입력 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-번째 시간 스텝에서의 제어 입력 벡터이다.</p>
<p>이 상태 공간 모델을 사용하여 MPC는 예측 시간 동안의 상태 변화를 예측한다.</p>
<h2 id="_2">제어 목적</h2>
<p>모델 기반 제어의 주요 목적은 시스템의 상태가 특정 목표 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{ref}}</span><script type="math/tex">\mathbf{x}_{\text{ref}}</script></span>에 가까워지도록 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>를 결정하는 것이다. 이때, 제어 입력을 결정하는 과정에서 여러 제약 조건도 고려된다. 제약 조건은 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{\text{min}} \leq \mathbf{u}(k) \leq \mathbf{u}_{\text{max}}
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{\text{min}} \leq \mathbf{u}(k) \leq \mathbf{u}_{\text{max}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{\text{min}}</span><script type="math/tex">\mathbf{u}_{\text{min}}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{\text{max}}</span><script type="math/tex">\mathbf{u}_{\text{max}}</script></span>는 제어 입력의 하한과 상한을 나타낸다.</p>
<p>MPC는 예측 기간 동안의 상태 변화를 고려하여 비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>를 최소화하는 최적 제어 문제로 변환된다. 비용 함수는 상태 변수와 제어 입력의 편차를 기반으로 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
J = \sum_{i=k}^{k+N-1} \left[ (\mathbf{x}(i) - \mathbf{x}_{\text{ref}})^T \mathbf{Q} (\mathbf{x}(i) - \mathbf{x}_{\text{ref}}) + \mathbf{u}(i)^T \mathbf{R} \mathbf{u}(i) \right]
</div>
<script type="math/tex; mode=display">
J = \sum_{i=k}^{k+N-1} \left[ (\mathbf{x}(i) - \mathbf{x}_{\text{ref}})^T \mathbf{Q} (\mathbf{x}(i) - \mathbf{x}_{\text{ref}}) + \mathbf{u}(i)^T \mathbf{R} \mathbf{u}(i) \right]
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>는 상태 변수의 편차에 대한 가중치 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>는 제어 입력의 가중치 행렬이다.</p>
<p>MPC는 이 비용 함수를 최소화하는 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>를 찾는다.</p>
<h2 id="_3">예측 및 최적화</h2>
<p>모델 기반 제어에서 예측 기간은 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 스텝의 길이를 갖는다. 이 기간 동안 각 시간 스텝에서 상태 변수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(i)</span><script type="math/tex">\mathbf{x}(i)</script></span>는 예측되며, 그에 따른 최적의 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(i)</span><script type="math/tex">\mathbf{u}(i)</script></span>가 계산된다. 계산된 제어 입력은 제약 조건을 만족하면서 비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>를 최소화해야 한다. 이 최적화 문제는 일반적으로 수학적 프로그래밍 기법을 사용하여 해결된다.</p>
<p>모델 기반 제어는 다음과 같은 반복적인 과정으로 실행된다:
1. 현재 시스템 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>를 측정.
2. 예측 기간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 동안의 상태 변화를 예측.
3. 비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>를 최소화하는 최적 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>를 계산.
4. 첫 번째 시간 스텝에서의 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>를 적용.
5. 시간을 <span class="arithmatex"><span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script></span>로 증가시키고, 과정을 반복.</p>
<p>이러한 방식으로 MPC는 실시간으로 시스템의 상태를 최적화한다.</p>
<h2 id="_4">제약 조건과 시스템의 안정성</h2>
<p>모델 기반 제어에서 중요한 요소 중 하나는 제약 조건이다. 시스템의 물리적 한계나 제어 입력의 한계를 설정하고, 이를 고려하여 최적의 제어 입력을 계산하는 것이 MPC의 특징이다. 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>에 대한 제약 조건 외에도 상태 변수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>에 대한 제약 조건이 있을 수 있다. 이러한 상태 제약 조건은 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{\text{min}} \leq \mathbf{x}(k) \leq \mathbf{x}_{\text{max}}
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{\text{min}} \leq \mathbf{x}(k) \leq \mathbf{x}_{\text{max}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{min}}</span><script type="math/tex">\mathbf{x}_{\text{min}}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{max}}</span><script type="math/tex">\mathbf{x}_{\text{max}}</script></span>는 상태 변수의 하한과 상한이다.</p>
<p>이러한 제약 조건을 만족시키면서도 최적의 제어 입력을 찾는 것은 복잡한 최적화 문제로 이어지며, 이를 해결하기 위해 선형 및 비선형 프로그래밍 기법이 사용된다. 제약 조건을 충족하지 못하면 시스템의 안전성이나 성능이 저하될 수 있으므로, 제약 조건은 매우 중요한 요소이다.</p>
<h3 id="_5">시스템의 안정성</h3>
<p>MPC의 또 다른 중요한 개념은 시스템의 안정성이다. 제어 시스템에서 안정성을 유지하기 위해, MPC는 목표 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{ref}}</span><script type="math/tex">\mathbf{x}_{\text{ref}}</script></span>로의 수렴을 보장하는 방식으로 설계된다. 이를 위해 두 가지 방법이 주로 사용된다:</p>
<ol>
<li>
<p><strong>종료 상태 제약</strong>: 예측 기간이 끝나는 시점에 상태 변수가 목표 상태에 가까워지도록 제약 조건을 설정하는 방법이다. 이는 시스템이 예측 기간 내에 목표 상태로 수렴하게 한다.</p>
</li>
<li>
<p><strong>종료 비용 함수</strong>: 종료 시점의 상태 변수에 대한 비용을 추가로 설정하여, 상태 변수가 목표 상태에 가까워질수록 더 작은 비용을 갖도록 한다. 종료 비용 함수는 다음과 같이 나타낼 수 있다.</p>
</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
J_{\text{end}} = (\mathbf{x}(k+N) - \mathbf{x}_{\text{ref}})^T \mathbf{P} (\mathbf{x}(k+N) - \mathbf{x}_{\text{ref}})
</div>
<script type="math/tex; mode=display">
J_{\text{end}} = (\mathbf{x}(k+N) - \mathbf{x}_{\text{ref}})^T \mathbf{P} (\mathbf{x}(k+N) - \mathbf{x}_{\text{ref}})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>는 종료 비용 함수에 대한 가중치 행렬이다.</p>
<p>이와 같은 방법을 통해 MPC는 시스템의 안정성을 유지하면서 최적의 제어 입력을 계산한다. 종료 상태에 대한 제약 조건이나 종료 비용 함수를 적절히 설계함으로써 시스템의 안정성을 보장할 수 있다.</p>
<h2 id="_6">예측 모델의 선택</h2>
<p>모델 기반 제어에서 사용하는 예측 모델은 시스템의 성능에 큰 영향을 미친다. 예측 모델이 시스템의 동작을 정확하게 반영하지 못할 경우, MPC의 성능은 크게 저하될 수 있다. 예측 모델은 시스템의 동적 특성을 표현해야 하며, 모델의 정확도와 계산 복잡도 간의 절충이 필요하다. 예측 모델은 주로 다음과 같은 형태로 구성된다:</p>
<ul>
<li><strong>선형 모델</strong>: 시스템이 선형 특성을 가진 경우, 상태 공간 모델은 선형 행렬 방정식으로 표현된다. 이는 계산이 비교적 간단하며, 많은 실시간 제어 시스템에서 사용된다.</li>
<li><strong>비선형 모델</strong>: 시스템이 비선형 특성을 보일 경우, 비선형 모델을 사용해야 한다. 이는 더욱 정확한 예측을 가능하게 하지만, 계산 복잡도가 증가한다.</li>
</ul>
<p>실제 시스템의 경우 비선형 특성을 보이는 경우가 많으므로, 비선형 모델이 더 적합할 수 있다. 그러나 비선형 모델은 계산 비용이 크므로, 실시간으로 최적화 문제를 해결하는 데는 어려움이 따를 수 있다. 따라서 모델을 단순화하거나 선형 근사 모델을 사용하는 방법도 있다.</p>
<h2 id="_7">예측 시간 구간과 제어 주기의 설정</h2>
<p>모델 기반 제어(MPC)에서 예측 시간 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>과 제어 주기 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 시스템의 성능과 계산 복잡도에 큰 영향을 미치는 중요한 요소이다. 예측 시간 구간은 시스템의 미래 상태를 예측하는 범위를 설정하며, 이 구간이 길수록 시스템의 미래 상태에 대한 더 많은 정보를 얻을 수 있다. 그러나 예측 시간 구간이 너무 길어지면 계산 복잡도가 증가하고, 실시간 제어에 어려움을 초래할 수 있다.</p>
<h3 id="_8">예측 시간 구간</h3>
<p>예측 시간 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 시스템의 상태를 예측하는 시간 범위로 정의된다. 이는 다음과 같은 방식으로 설정된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
t_{\text{predict}} = N \cdot \Delta t
</div>
<script type="math/tex; mode=display">
t_{\text{predict}} = N \cdot \Delta t
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">t_{\text{predict}}</span><script type="math/tex">t_{\text{predict}}</script></span>는 전체 예측 기간,
- <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 예측 시간 구간의 스텝 수,
- <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 제어 주기를 의미한다.</p>
<p>MPC에서 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>의 선택은 시스템의 동작 특성에 따라 달라진다. 예를 들어, 시스템의 동작이 빠를수록 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>을 작게 설정하여 짧은 예측 기간 동안의 정확한 제어를 수행하는 것이 유리할 수 있다. 반대로 시스템의 동작이 느리거나 장기적인 동작을 예측해야 하는 경우, <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>을 크게 설정하여 장기적인 예측을 고려해야 한다.</p>
<h3 id="_9">제어 주기</h3>
<p>제어 주기 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 각 시간 스텝에서 MPC가 제어 입력을 계산하고 적용하는 시간 간격이다. 제어 주기가 짧을수록 더 빠른 빈도로 제어 입력을 계산하게 되어, 더욱 정교한 제어가 가능해진다. 그러나 제어 주기가 짧아지면 그만큼 최적화 문제를 해결해야 하는 빈도가 증가하기 때문에 계산 부하도 커진다.</p>
<p>제어 주기는 시스템의 동작 속도에 맞춰 적절히 설정되어야 하며, 너무 길거나 너무 짧지 않게 조정해야 한다. 예를 들어, 로봇 제어 시스템에서는 제어 주기가 짧아야 신속한 동작이 가능하지만, 지나치게 짧은 주기는 연산 비용을 감당하기 어렵게 만들 수 있다.</p>
<h2 id="_10">최적화 문제의 해결</h2>
<p>MPC에서 제어 입력을 계산하는 과정은 일반적으로 최적화 문제로 변환된다. 앞서 언급한 비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>를 최소화하면서 제약 조건을 만족시키는 최적의 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>를 찾는 것이 목표이다. 이 최적화 문제는 다음과 같이 요약될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{u}(k)} J = \sum_{i=k}^{k+N-1} \left[ (\mathbf{x}(i) - \mathbf{x}_{\text{ref}})^T \mathbf{Q} (\mathbf{x}(i) - \mathbf{x}_{\text{ref}}) + \mathbf{u}(i)^T \mathbf{R} \mathbf{u}(i) \right]
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{u}(k)} J = \sum_{i=k}^{k+N-1} \left[ (\mathbf{x}(i) - \mathbf{x}_{\text{ref}})^T \mathbf{Q} (\mathbf{x}(i) - \mathbf{x}_{\text{ref}}) + \mathbf{u}(i)^T \mathbf{R} \mathbf{u}(i) \right]
</script>
</div>
<p>제약 조건을 만족하는 상태에서 위의 비용 함수를 최소화하는 것이 MPC의 핵심이다. 이 최적화 문제는 선형 제약 조건을 갖는 경우에는 <strong>선형 계획법</strong>(Linear Programming, LP)을 사용할 수 있으며, 비선형 제약 조건을 포함하는 경우에는 <strong>비선형 계획법</strong>(Nonlinear Programming, NLP)을 사용해야 한다.</p>
<h3 id="_11">선형 계획법</h3>
<p>선형 계획법은 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>와 상태 변수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>가 선형 관계를 가질 때 적용될 수 있다. 이때 비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>와 제약 조건이 선형 형태로 주어지면, 선형 계획법을 사용하여 최적해를 빠르게 계산할 수 있다. 선형 계획법은 계산 비용이 상대적으로 낮으며, 실시간 제어에 적합하다.</p>
<h3 id="_12">비선형 계획법</h3>
<p>실제 시스템은 비선형 특성을 갖는 경우가 많다. 이때는 비선형 계획법을 사용하여 최적화를 수행해야 한다. 비선형 계획법은 복잡한 계산 과정을 필요로 하며, 실시간으로 문제를 해결하는 데는 어려움이 따를 수 있다. 비선형 계획법을 적용할 때는 다양한 수치 최적화 알고리즘을 사용할 수 있으며, 대표적으로 <strong>내부점법</strong>(Interior Point Method)이나 <strong>신경망 기반 최적화</strong> 기법이 있다.</p>
<h2 id="_13">비용 함수의 구성과 가중치 선택</h2>
<p>모델 기반 제어(MPC)에서 중요한 부분 중 하나는 비용 함수의 구체적인 구성이다. 비용 함수는 시스템의 목표 상태와 실제 상태 간의 차이를 최소화하기 위한 지표로 사용된다. 비용 함수는 상태 변수와 제어 입력에 대한 가중치가 반영된 형태로 나타나며, 이를 통해 시스템이 목표 상태로 수렴하도록 유도한다. 비용 함수의 일반적인 형태는 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
J = \sum_{i=k}^{k+N-1} \left[ (\mathbf{x}(i) - \mathbf{x}_{\text{ref}})^T \mathbf{Q} (\mathbf{x}(i) - \mathbf{x}_{\text{ref}}) + \mathbf{u}(i)^T \mathbf{R} \mathbf{u}(i) \right]
</div>
<script type="math/tex; mode=display">
J = \sum_{i=k}^{k+N-1} \left[ (\mathbf{x}(i) - \mathbf{x}_{\text{ref}})^T \mathbf{Q} (\mathbf{x}(i) - \mathbf{x}_{\text{ref}}) + \mathbf{u}(i)^T \mathbf{R} \mathbf{u}(i) \right]
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(i)</span><script type="math/tex">\mathbf{x}(i)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-번째 시간 스텝에서의 상태 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{ref}}</span><script type="math/tex">\mathbf{x}_{\text{ref}}</script></span>는 목표 상태 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(i)</span><script type="math/tex">\mathbf{u}(i)</script></span>는 제어 입력 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>는 상태 오차에 대한 가중치 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>는 제어 입력에 대한 가중치 행렬이다.</p>
<p>이 비용 함수는 크게 두 부분으로 나뉜다: 첫 번째 항은 상태 변수와 목표 상태 간의 차이를 나타내며, 두 번째 항은 제어 입력에 대한 패널티를 나타낸다. </p>
<h3 id="mathbfqmathbfq">상태 오차 가중치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span></h3>
<p>상태 오차 가중치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>는 상태 벡터와 목표 상태 간의 차이를 최소화하는 데 중요한 역할을 한다. <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span> 행렬은 대각 행렬로 설정되며, 각 상태 변수에 대해 다른 가중치를 설정할 수 있다. 예를 들어, 특정 상태 변수가 더 중요한 경우, 해당 변수에 더 큰 가중치를 부여하여 그 상태 변수가 목표 상태에 더 가깝게 수렴하도록 유도할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{Q} = \text{diag}(q_1, q_2, \dots, q_n)
</div>
<script type="math/tex; mode=display">
\mathbf{Q} = \text{diag}(q_1, q_2, \dots, q_n)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">q_i</span><script type="math/tex">q_i</script></span>는 각 상태 변수에 대한 가중치이다. 가중치 값이 클수록 해당 상태 변수의 오차를 줄이는 것이 더 중요하게 여겨진다.</p>
<h3 id="mathbfrmathbfr">제어 입력 가중치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span></h3>
<p>제어 입력 가중치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>는 제어 입력 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(i)</span><script type="math/tex">\mathbf{u}(i)</script></span>에 대한 패널티를 나타낸다. <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span> 또한 대각 행렬로 설정되며, 각 제어 입력에 대해 다른 가중치를 설정할 수 있다. 제어 입력에 대한 가중치가 클수록 제어 입력의 변화가 적어지며, 시스템의 동작이 더 부드러워진다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{R} = \text{diag}(r_1, r_2, \dots, r_m)
</div>
<script type="math/tex; mode=display">
\mathbf{R} = \text{diag}(r_1, r_2, \dots, r_m)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">r_i</span><script type="math/tex">r_i</script></span>는 각 제어 입력에 대한 가중치이다. <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span> 행렬은 제어 입력의 크기나 변화율에 제한을 두어 시스템의 과도한 제어 동작을 억제하는 데 사용된다. 이 가중치를 적절히 설정하면 시스템의 안정성과 성능을 동시에 보장할 수 있다.</p>
<h3 id="_14">가중치 선택의 중요성</h3>
<p>비용 함수에서 사용되는 가중치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>의 선택은 MPC의 성능에 직접적인 영향을 미친다. 예를 들어, 상태 오차에 대한 가중치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>가 너무 크면 시스템이 목표 상태에 빠르게 도달하려고 하지만, 그 과정에서 제어 입력이 크게 변동할 수 있다. 반면에, 제어 입력 가중치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>가 너무 크면 제어 입력의 변화가 제한되어 시스템이 목표 상태에 천천히 수렴할 수 있다.</p>
<p>따라서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>의 값을 적절히 설정하는 것이 매우 중요하다. 이를 위해서는 시스템의 특성과 제어 목표를 정확히 이해해야 하며, 필요에 따라 시뮬레이션을 통해 최적의 가중치를 찾아야 한다.</p>
<h2 id="_15">실시간 적용을 위한 계산 최적화</h2>
<p>MPC는 최적화 문제를 실시간으로 해결해야 하기 때문에, 계산 효율성이 매우 중요하다. 특히 예측 시간 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>이 커지면 계산 복잡도 또한 비례하여 증가한다. 이를 해결하기 위해 여러 가지 계산 최적화 기법이 적용된다.</p>
<h3 id="_16">축소된 예측 모델 사용</h3>
<p>하나의 방법은 예측 시간 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>을 줄이거나 단순화된 모델을 사용하는 것이다. 예측 시간 구간을 줄이면 시스템의 미래 상태를 예측하는 범위가 줄어들지만, 계산 시간은 크게 단축된다. 이를 통해 실시간 제어 시스템에서도 충분한 속도로 MPC를 적용할 수 있다.</p>
<h3 id="_17">병렬 처리 기법</h3>
<p>또한, 현대의 고성능 컴퓨팅 시스템에서는 병렬 처리를 통해 계산을 가속화할 수 있다. 상태 예측과 최적화 문제 해결을 병렬로 처리함으로써 계산 시간을 줄일 수 있다. 특히 복잡한 비선형 시스템에서는 병렬 처리의 이점을 극대화할 수 있다.</p>
<h2 id="_18">하위 최적화 문제 분할</h2>
<p>실시간 모델 기반 제어(MPC)를 더욱 효율적으로 실행하기 위해, 큰 최적화 문제를 여러 개의 하위 최적화 문제로 분할하는 방법이 사용될 수 있다. 이는 예측 시간 구간을 여러 개의 작은 구간으로 나누어 각각 독립적인 최적화 문제로 처리하는 방식이다. 이렇게 하면 전체 계산 부하를 줄이고, 계산의 병렬 처리를 용이하게 할 수 있다. </p>
<p>하위 최적화 문제로 분할하는 대표적인 방법은 다음과 같다:</p>
<h3 id="receding-horizon-optimization">이동 구간 최적화 (Receding Horizon Optimization)</h3>
<p>MPC는 기본적으로 <strong>이동 구간 최적화</strong>(Receding Horizon Optimization) 기법을 사용한다. 이동 구간 최적화는 일정한 길이의 예측 구간을 설정한 뒤, 예측 구간이 끝나면 그 구간을 한 스텝 앞으로 이동하여 다시 최적화를 수행하는 방식이다. 이 방법은 실시간 제어에서 매우 유용하다. 이동 구간 최적화의 과정은 다음과 같이 요약된다.</p>
<ol>
<li>현재 시간 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>에서 예측 시간 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>을 설정한다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>부터 <span class="arithmatex"><span class="MathJax_Preview">k+N-1</span><script type="math/tex">k+N-1</script></span>까지의 미래 상태를 예측한다.</li>
<li>예측된 구간 내에서 최적의 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>를 계산한다.</li>
<li>제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>를 적용하고, <span class="arithmatex"><span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script></span>로 시간 스텝을 이동시킨다.</li>
<li>위 과정을 반복한다.</li>
</ol>
<p>이 방식은 미래의 상태를 반복적으로 예측하고, 제어 입력을 실시간으로 업데이트하면서 실행되므로, 실시간 제어의 요구 사항을 만족시킬 수 있다.</p>
<h3 id="distributed-model-predictive-control-dmpc">분산 모델 기반 제어 (Distributed Model Predictive Control, DMPC)</h3>
<p>큰 규모의 시스템에서는 단일 MPC로는 복잡한 제어 문제를 해결하기 어려울 수 있다. 이때, 분산 모델 기반 제어(DMPC)를 사용하여 문제를 여러 개의 소규모 최적화 문제로 분할할 수 있다. DMPC는 시스템을 여러 개의 하위 시스템으로 나누고, 각 하위 시스템이 독립적으로 최적화를 수행하도록 한다. 그 후, 각각의 하위 시스템 간의 정보를 공유하여 전체 시스템의 최적화를 달성한다.</p>
<p>DMPC는 다음과 같은 특징을 가진다:
- 각 하위 시스템은 독립적으로 최적화 문제를 해결하여 계산 복잡도를 줄인다.
- 하위 시스템 간의 상호작용을 고려하여 전체 시스템의 일관된 동작을 보장한다.</p>
<p>이 방식은 복잡한 시스템을 제어할 때 계산 부하를 줄일 수 있으며, 각 하위 시스템에서 발생하는 제어 문제를 개별적으로 해결할 수 있기 때문에 실시간 제어에 적합하다.</p>
<h2 id="_19">상태 예측과 시스템 모델의 정확성</h2>
<p>모델 기반 제어(MPC)는 시스템의 미래 상태를 예측하여 최적의 제어 입력을 결정하는 방식이기 때문에, 상태 예측의 정확성이 매우 중요하다. 상태 예측의 정확성은 시스템 모델의 정확성에 의해 크게 좌우된다. 따라서 시스템 모델이 실제 시스템을 얼마나 정확하게 표현하는지가 MPC의 성능에 큰 영향을 미친다.</p>
<h3 id="_20">모델 불확실성</h3>
<p>실제 시스템에서 모든 모델이 완벽하게 정확할 수는 없으며, 반드시 일정한 모델 불확실성이 존재한다. 이러한 불확실성은 시스템의 동작 특성을 정확하게 예측하지 못하게 하며, MPC의 성능을 저하시키는 원인이 될 수 있다. 예를 들어, 시스템의 파라미터가 시간에 따라 변화하거나, 외란에 의해 시스템의 동작이 예상과 다르게 나타날 수 있다.</p>
<p>모델 불확실성을 고려하는 방법으로는 다음과 같은 기법이 있다:
- <strong>강건 모델 기반 제어</strong>(Robust MPC): 시스템 모델에 존재하는 불확실성을 고려하여 제어 입력을 계산하는 방식이다. 이는 최악의 경우를 가정하여 시스템이 안정적으로 동작하도록 한다.
- <strong>적응형 모델 기반 제어</strong>(Adaptive MPC): 시스템의 동작 특성이 시간에 따라 변할 때, 시스템 모델을 실시간으로 업데이트하여 변화에 적응하는 방식이다.</p>
<h3 id="_21">외란과 잡음 처리</h3>
<p>모델 기반 제어에서 중요한 또 다른 요소는 외란과 잡음의 처리이다. 시스템에 가해지는 외란이나 측정 과정에서 발생하는 잡음은 MPC의 성능을 저하시키는 원인이 될 수 있다. 이러한 외란을 효과적으로 처리하기 위해서는 시스템 모델에 외란 모델을 포함하거나, 외란을 추정하는 알고리즘을 추가할 수 있다.</p>
<p>외란과 잡음을 처리하는 대표적인 기법으로는 <strong>칼만 필터</strong>(Kalman Filter)가 있다. 칼만 필터는 시스템의 상태를 추정하고, 잡음이 포함된 측정 데이터를 기반으로 상태를 보정하는 알고리즘이다. MPC에서 칼만 필터를 사용하여 상태 추정의 정확성을 높이고, 외란과 잡음의 영향을 줄일 수 있다.</p>
<h2 id="_22">모델 기반 제어의 응용 분야</h2>
<p>MPC는 여러 산업 분야에서 널리 사용되고 있다. 대표적인 응용 분야는 다음과 같다.</p>
<h3 id="_23">프로세스 제어</h3>
<p>MPC는 화학 공정, 석유 정제, 발전소 등에서 프로세스 제어에 많이 사용된다. 프로세스 제어에서는 여러 개의 변수들이 상호작용하며, 시스템의 상태가 복잡하게 변화한다. MPC는 이러한 다변수 시스템에서 목표 상태로 정확하게 제어하기 위한 최적의 제어 입력을 계산하는 데 유리하다.</p>
<h3 id="_24">자동차 제어</h3>
<p>자동차 제어에서는 차량의 안정성, 효율성, 승차감 등을 향상시키기 위해 MPC가 사용된다. 자율주행 차량에서는 경로 추적과 장애물 회피를 위한 제어 시스템에 MPC가 적용될 수 있다. MPC는 차량의 동적 특성을 예측하고, 최적의 경로를 따라가도록 제어 입력을 계산할 수 있다.</p>
<h3 id="_25">로봇 제어</h3>
<p>로봇 시스템에서도 MPC는 매우 중요한 역할을 한다. 로봇의 위치, 속도, 조인트 각도 등을 제어하기 위해서는 높은 정확도가 요구되며, MPC는 이를 실시간으로 처리할 수 있는 방법을 제공한다. 특히, 멀티 조인트 로봇이나 다체 시스템에서 여러 변수를 동시에 제어하는 문제를 해결하는 데 적합하다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1402/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1402/" class="btn btn-xs btn-link">
        수소 전지 모델링
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_13/1305/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_13/1305/" class="btn btn-xs btn-link">
        실시간 데이터 수집 및 분석
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>