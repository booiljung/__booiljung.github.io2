<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/control_engineering/hydrogen_fuel_cell_control/chapter_14/1403/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>모델 기반 예측 제어 알고리즘 - 소프트웨어 융합</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "MPC\uc758 \uae30\ubcf8 \uac1c\ub150", url: "#_top", children: [
          ]},
          {title: "MPC\uc758 \uc218\ud559\uc801 \uc815\uc758", url: "#mpc_1", children: [
          ]},
          {title: "\uc81c\uc57d \uc870\uac74", url: "#_1", children: [
          ]},
          {title: "\ubaa8\ub378 \uae30\ubc18 \uc608\uce21 \uc81c\uc5b4\uc758 \uad6c\ud604", url: "#_2", children: [
              {title: "1. \uc2dc\uc2a4\ud15c \ubaa8\ub378\ub9c1", url: "#1" },
              {title: "2. \ucd5c\uc801\ud654 \ubb38\uc81c \uc124\uc815", url: "#2" },
              {title: "3. \uc2e4\uc2dc\uac04 \uc81c\uc5b4 \uc785\ub825 \uacc4\uc0b0", url: "#3" },
          ]},
          {title: "MPC\uc758 \uc81c\uc57d \uc870\uac74 \ucc98\ub9ac", url: "#mpc_2", children: [
              {title: "1. \uc0c1\ud0dc \uc81c\uc57d \uc870\uac74", url: "#1_1" },
              {title: "2. \uc81c\uc5b4 \uc785\ub825 \uc81c\uc57d \uc870\uac74", url: "#2_1" },
              {title: "3. \ucd5c\uc801\ud654 \ubb38\uc81c\uc5d0\uc11c \uc81c\uc57d \uc870\uac74 \ubc18\uc601", url: "#3_1" },
              {title: "4. \uc18c\ud504\ud2b8 \uc81c\uc57d \uc870\uac74", url: "#4" },
          ]},
          {title: "MPC\uc758 \uc608\uce21 \uad6c\uac04", url: "#mpc_3", children: [
              {title: "1. \uc608\uce21 \uad6c\uac04\uc758 \uc815\uc758", url: "#1_2" },
              {title: "2. \uc608\uce21 \uad6c\uac04\uc758 \uae38\uc774 \uc120\ud0dd", url: "#2_2" },
              {title: "3. \uc774\ub3d9 \uad6c\uac04 \ucd5c\uc801\ud654", url: "#3_2" },
              {title: "4. \uc608\uce21 \uad6c\uac04\uacfc \uc81c\uc5b4 \uad6c\uac04\uc758 \ucc28\uc774", url: "#4_1" },
          ]},
          {title: "MPC\uc5d0\uc11c\uc758 \ube44\uc6a9 \ud568\uc218 \ucd5c\uc801\ud654", url: "#mpc_4", children: [
              {title: "1. \ube44\uc6a9 \ud568\uc218 \uc815\uc758", url: "#1_3" },
              {title: "2. \uc0c1\ud0dc \uc624\ucc28\uc5d0 \ub300\ud55c \uac00\uc911\uce58 QQ", url: "#2-qq" },
              {title: "3. \uc81c\uc5b4 \uc785\ub825\uc5d0 \ub300\ud55c \uac00\uc911\uce58 RR", url: "#3-rr" },
              {title: "4. \ube44\uc6a9 \ud568\uc218\uc758 \ud2b8\ub808\uc774\ub4dc\uc624\ud504", url: "#4_2" },
          ]},
          {title: "MPC\uc5d0\uc11c\uc758 \uc81c\uc57d \uc870\uac74 \ucc98\ub9ac \ubc29\uc2dd", url: "#mpc_5", children: [
              {title: "1. \uc0c1\ud0dc \uc81c\uc57d \uc870\uac74", url: "#1_4" },
              {title: "2. \uc81c\uc5b4 \uc785\ub825 \uc81c\uc57d \uc870\uac74", url: "#2_3" },
              {title: "3. \ucd9c\ub825 \uc81c\uc57d \uc870\uac74", url: "#3_3" },
              {title: "4. \uc81c\uc57d \uc870\uac74\uc744 \uace0\ub824\ud55c \ucd5c\uc801\ud654 \ubb38\uc81c", url: "#4_3" },
              {title: "5. \uc18c\ud504\ud2b8 \uc81c\uc57d \uc870\uac74", url: "#5" },
          ]},
          {title: "MPC\uc5d0\uc11c\uc758 \ucd5c\uc801\ud654 \ubc29\ubc95", url: "#mpc_6", children: [
              {title: "1. \uc120\ud615 \uc774\ucc28 \uacc4\ud68d\ubc95 (Quadratic Programming, QP)", url: "#1-quadratic-programming-qp" },
              {title: "2. \ube44\uc120\ud615 \uacc4\ud68d\ubc95 (Nonlinear Programming, NLP)", url: "#2-nonlinear-programming-nlp" },
              {title: "3. \uc2e4\uc2dc\uac04 \ucd5c\uc801\ud654", url: "#3_4" },
              {title: "4. \uc628-\ub77c\uc778\uacfc \uc624\ud504-\ub77c\uc778 \ucd5c\uc801\ud654", url: "#4-" },
          ]},
          {title: "MPC\uc5d0\uc11c\uc758 \uc774\ub3d9 \uad6c\uac04 \ucd5c\uc801\ud654 (Receding Horizon Optimization)", url: "#mpc-receding-horizon-optimization", children: [
              {title: "1. \uc774\ub3d9 \uad6c\uac04 \ucd5c\uc801\ud654\uc758 \uac1c\ub150", url: "#1_5" },
              {title: "2. \uc774\ub3d9 \uad6c\uac04 \ucd5c\uc801\ud654\uc758 \uc7a5\uc810", url: "#2_4" },
              {title: "3. \uc774\ub3d9 \uad6c\uac04 \ucd5c\uc801\ud654\uc758 \uacc4\uc0b0 \ubcf5\uc7a1\ub3c4", url: "#3_5" },
              {title: "4. \uc774\ub3d9 \uad6c\uac04 \ucd5c\uc801\ud654\uc640 \uc608\uce21 \uad6c\uac04\uc758 \uad00\uacc4", url: "#4_4" },
              {title: "5. \uc81c\uc5b4 \uad6c\uac04\uacfc\uc758 \ucc28\uc774", url: "#5_1" },
          ]},
          {title: "MPC\uc5d0\uc11c\uc758 \uc548\uc815\uc131 \ubcf4\uc7a5", url: "#mpc_7", children: [
              {title: "1. \ud130\ubbf8\ub110 \ube44\uc6a9 \ud568\uc218\uc640 \ud130\ubbf8\ub110 \uc81c\uc57d \uc870\uac74", url: "#1_6" },
              {title: "2. \uc801\uc808\ud55c \uc608\uce21 \uad6c\uac04 \uc124\uc815", url: "#2_5" },
              {title: "3. \uc81c\uc5b4 \uad6c\uac04 \uc81c\ud55c", url: "#3_6" },
              {title: "4. \ucd9c\ub825 \ud53c\ub4dc\ubc31", url: "#4_5" },
              {title: "5. \ub85c\ubc84\uc2a4\ud2b8 MPC", url: "#5-mpc" },
              {title: "6. \uc2e4\uc2dc\uac04 \ucd5c\uc801\ud654\uc758 \uc815\ud655\ub3c4", url: "#6" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1404/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1404/" class="btn btn-xs btn-link">
        제어 시스템의 동적 응답 최적화
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1402/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1402/" class="btn btn-xs btn-link">
        수소 전지 모델링
      </a>
    </div>
    
  </div>

    

    <p>모델 기반 예측 제어(MPC, Model Predictive Control) 알고리즘은 공정 제어에서 매우 중요한 역할을 하며, 현재 상태를 바탕으로 미래의 동작을 예측하고 최적의 제어 입력을 계산하는 방식으로 동작한다. 특히, 제약 조건이 있는 시스템에서 높은 성능을 보인다. MPC는 시간에 따라 변화하는 시스템의 상태를 관리하고, 예측 모델을 통해 미래 상태를 추정하여 최적화 문제를 해결함으로써 원하는 출력에 도달하게 한다.</p>
<h3 id="mpc">MPC의 기본 개념</h3>
<p>MPC는 주어진 시스템의 동적 모델을 사용하여 일정한 시간 구간 동안의 제어 변수를 최적화하는 제어 방법이다. 이 과정에서 시스템의 미래 상태를 예측하고, 여러 제약 조건을 고려하여 제어 입력을 산출한다. MPC는 이 과정을 반복하면서 실시간으로 최적화된 제어 입력을 결정한다. MPC의 기본 구조는 다음과 같다.</p>
<ol>
<li><strong>모델 예측</strong>: 주어진 모델을 사용하여 현재 상태에서 미래의 상태를 예측한다.</li>
<li><strong>목표 최적화</strong>: 최적의 제어 입력을 계산하기 위해 비용 함수를 설정하고, 이 비용을 최소화하는 방식으로 제어 입력을 산출한다.</li>
<li><strong>제약 조건 고려</strong>: 시스템 제약 조건(상태 및 제어 입력 제약 조건 등)을 반영하여 최적화 문제를 해결한다.</li>
<li><strong>이동 구간 최적화</strong>: 일정 시간 구간 동안의 제어 입력을 계산하지만, 그중 첫 번째 입력 값만을 시스템에 적용하고 나머지는 버린다. 다음 시점에서는 새로운 현재 상태를 바탕으로 다시 최적화를 수행한다.</li>
</ol>
<h3 id="mpc_1">MPC의 수학적 정의</h3>
<p>MPC 알고리즘은 일반적으로 다음과 같은 수학적 최적화 문제를 풀게 된다. 예측 구간을 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>이라 하고, 시스템의 상태를 나타내는 벡터를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>, 제어 입력을 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>로 나타내면, 시스템의 동역학은 다음과 같은 상태 방정식으로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(k+1) = f(\mathbf{x}(k), \mathbf{u}(k))
</div>
<script type="math/tex; mode=display">
\mathbf{x}(k+1) = f(\mathbf{x}(k), \mathbf{u}(k))
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">f(\cdot)</span><script type="math/tex">f(\cdot)</script></span>는 시스템의 동적 모델을 나타내며, 이는 선형 또는 비선형일 수 있다. MPC는 다음과 같은 최적화 문제를 풀어 제어 입력을 산출한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)} \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)} \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{ref}}(k+i)</span><script type="math/tex">\mathbf{x}_{\text{ref}}(k+i)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">k+i</span><script type="math/tex">k+i</script></span> 시점에서의 참조 상태(reference state)이며, <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>는 각각 상태 및 제어 입력에 대한 가중치 행렬이다. 이 문제는 예측 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 동안의 상태와 제어 입력의 변화를 최소화하는 것을 목표로 한다.</p>
<h3 id="_1">제약 조건</h3>
<p>MPC는 제약 조건을 다루기 때문에 다양한 실제 시스템에 적용할 수 있다. 상태와 제어 입력에 대한 제약 조건은 다음과 같이 정의할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{\min} \leq \mathbf{x}(k) \leq \mathbf{x}_{\max}
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{\min} \leq \mathbf{x}(k) \leq \mathbf{x}_{\max}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{\min} \leq \mathbf{u}(k) \leq \mathbf{u}_{\max}
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{\min} \leq \mathbf{u}(k) \leq \mathbf{u}_{\max}
</script>
</div>
<p>이 제약 조건은 MPC에서 중요한 역할을 하며, 시스템의 물리적 한계를 반영한다.</p>
<h3 id="_2">모델 기반 예측 제어의 구현</h3>
<p>모델 기반 예측 제어(MPC) 알고리즘의 구현 과정은 크게 세 가지 단계로 나뉜다: 시스템 모델링, 최적화 문제 설정, 그리고 실시간 제어 입력 계산이다. 이 과정에서 사용되는 주요 요소들은 다음과 같다.</p>
<h4 id="1">1. 시스템 모델링</h4>
<p>MPC는 시스템의 동적 모델을 기반으로 예측을 수행하기 때문에, 시스템 모델링이 중요한 첫 번째 단계이다. 시스템 모델은 선형 또는 비선형일 수 있으며, 일반적으로 상태 공간 모델(State-space model)로 나타낸다. 시스템의 상태 공간 모델은 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(k+1) = \mathbf{A} \mathbf{x}(k) + \mathbf{B} \mathbf{u}(k)
</div>
<script type="math/tex; mode=display">
\mathbf{x}(k+1) = \mathbf{A} \mathbf{x}(k) + \mathbf{B} \mathbf{u}(k)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}(k) = \mathbf{C} \mathbf{x}(k)
</div>
<script type="math/tex; mode=display">
\mathbf{y}(k) = \mathbf{C} \mathbf{x}(k)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>에서의 상태 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>는 제어 입력 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}(k)</span><script type="math/tex">\mathbf{y}(k)</script></span>는 출력 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 각각 시스템 행렬을 나타낸다.</p>
<p>비선형 시스템의 경우, 다음과 같은 비선형 상태 방정식이 사용될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(k+1) = f(\mathbf{x}(k), \mathbf{u}(k))
</div>
<script type="math/tex; mode=display">
\mathbf{x}(k+1) = f(\mathbf{x}(k), \mathbf{u}(k))
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}(k) = g(\mathbf{x}(k))
</div>
<script type="math/tex; mode=display">
\mathbf{y}(k) = g(\mathbf{x}(k))
</script>
</div>
<h4 id="2">2. 최적화 문제 설정</h4>
<p>MPC는 주어진 목적을 달성하기 위해 최적화 문제를 설정한다. 이 목적은 대개 시스템의 참조 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{ref}}</span><script type="math/tex">\mathbf{x}_{\text{ref}}</script></span>에 대한 추종 성능을 극대화하는 것이다. 이를 위해, 비용 함수(cost function)를 정의하고 이를 최소화하는 제어 입력을 계산한다. 비용 함수는 시스템 상태와 제어 입력의 변화에 대한 가중치를 반영하며, 아래와 같이 정의할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
J = \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</div>
<script type="math/tex; mode=display">
J = \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>는 상태 오차에 대한 가중치 행렬, <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>는 제어 입력에 대한 가중치 행렬이다. MPC는 이 비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>를 최소화하는 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>를 구한다.</p>
<h4 id="3">3. 실시간 제어 입력 계산</h4>
<p>MPC는 예측 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 동안의 최적 제어 입력을 계산하지만, 실제로는 첫 번째 입력 값만 시스템에 적용하고 나머지는 버린다. 이는 '이동 구간 최적화'(receding horizon optimization)라 불리며, 매 시간 스텝마다 새로운 상태를 바탕으로 최적화를 반복 수행한다. 즉, <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 시점에서 예측한 최적 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>를 시스템에 적용한 후, 다음 <span class="arithmatex"><span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script></span> 시점에서 다시 상태를 업데이트하고 최적화를 수행한다.</p>
<p>이 과정을 요약하면, 다음과 같다:
1. 현재 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>를 바탕으로 예측 모델을 통해 미래 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k+1), \mathbf{x}(k+2), \dots</span><script type="math/tex">\mathbf{x}(k+1), \mathbf{x}(k+2), \dots</script></span>를 계산한다.
2. 비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>를 최소화하는 최적 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>를 구한다.
3. 구한 제어 입력 중 첫 번째 값 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>만을 시스템에 적용한다.
4. 다음 시점 <span class="arithmatex"><span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script></span>에서 다시 최적화를 반복한다.</p>
<h3 id="mpc_2">MPC의 제약 조건 처리</h3>
<p>모델 기반 예측 제어(MPC)의 중요한 특성 중 하나는 제약 조건을 명시적으로 다룬다는 점이다. 시스템의 상태와 제어 입력에 대해 물리적 또는 운영상의 제약이 있을 수 있으며, 이러한 제약 조건을 만족시키면서도 최적의 성능을 달성하는 것이 MPC의 목표이다. MPC에서 다루는 대표적인 제약 조건은 다음과 같다.</p>
<h4 id="1_1">1. 상태 제약 조건</h4>
<p>상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>는 물리적 한계에 의해 제약될 수 있다. 예를 들어, 시스템의 온도, 속도, 압력 등은 특정 범위 내에서 유지되어야 한다. 이러한 제약 조건은 다음과 같이 정의할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{\min} \leq \mathbf{x}(k) \leq \mathbf{x}_{\max}
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{\min} \leq \mathbf{x}(k) \leq \mathbf{x}_{\max}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\min}</span><script type="math/tex">\mathbf{x}_{\min}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\max}</span><script type="math/tex">\mathbf{x}_{\max}</script></span>은 각각 상태 벡터의 하한 및 상한을 나타낸다. 이러한 제약 조건은 예측 기간 동안 모든 시점에서 만족되어야 하며, 최적화 과정에서 제약 조건으로 포함된다.</p>
<h4 id="2_1">2. 제어 입력 제약 조건</h4>
<p>제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span> 역시 물리적 또는 기계적 한계로 인해 특정 범위 내에서 유지되어야 할 수 있다. 예를 들어, 모터의 토크나 전류의 크기에는 한계가 존재한다. 이러한 제약 조건은 다음과 같이 정의할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{\min} \leq \mathbf{u}(k) \leq \mathbf{u}_{\max}
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{\min} \leq \mathbf{u}(k) \leq \mathbf{u}_{\max}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{\min}</span><script type="math/tex">\mathbf{u}_{\min}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{\max}</span><script type="math/tex">\mathbf{u}_{\max}</script></span>은 각각 제어 입력의 하한 및 상한을 나타낸다. MPC는 이 제약 조건을 만족시키면서 최적의 제어 입력을 산출한다.</p>
<h4 id="3_1">3. 최적화 문제에서 제약 조건 반영</h4>
<p>MPC의 최적화 문제는 상태와 제어 입력의 제약 조건을 포함하여 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)} \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)} \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</script>
</div>
<p>주어진 제약 조건:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{\min} \leq \mathbf{x}(k+i) \leq \mathbf{x}_{\max} \quad \forall i = 0, 1, \dots, N-1
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{\min} \leq \mathbf{x}(k+i) \leq \mathbf{x}_{\max} \quad \forall i = 0, 1, \dots, N-1
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{\min} \leq \mathbf{u}(k+i) \leq \mathbf{u}_{\max} \quad \forall i = 0, 1, \dots, N-1
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{\min} \leq \mathbf{u}(k+i) \leq \mathbf{u}_{\max} \quad \forall i = 0, 1, \dots, N-1
</script>
</div>
<p>이와 같이 제약 조건을 포함한 최적화 문제는 일반적으로 <strong>제약 최적화 문제</strong>로 불리며, 이를 풀기 위해 다양한 수치적 방법이 사용된다. 대표적으로, 선형 제약 조건을 가진 시스템에서는 선형 계획법(Linear Programming, LP)이나 이차 계획법(Quadratic Programming, QP)을 이용할 수 있으며, 비선형 제약 조건을 가진 경우에는 비선형 계획법(Nonlinear Programming, NLP)이 적용된다.</p>
<h4 id="4">4. 소프트 제약 조건</h4>
<p>때로는 제약 조건을 엄격하게 만족시키는 것이 불가능하거나 비현실적일 수 있다. 이 경우 <strong>소프트 제약 조건</strong>(Soft Constraints)이 사용되는데, 이는 제약 조건을 어느 정도 위반하더라도 허용하는 방법이다. 소프트 제약 조건을 도입하면 최적화 문제에서 제약 조건 위반에 대한 패널티를 비용 함수에 추가하여 처리할 수 있다.</p>
<p>예를 들어, 상태 제약 조건을 완화하기 위해 다음과 같은 패널티 항을 추가할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
J = \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 + \rho \cdot \|\mathbf{x}(k+i) - \mathbf{x}_{\max}\|^2_+
\right)
</div>
<script type="math/tex; mode=display">
J = \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 + \rho \cdot \|\mathbf{x}(k+i) - \mathbf{x}_{\max}\|^2_+
\right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\rho</span><script type="math/tex">\rho</script></span>는 패널티에 대한 가중치이며, <span class="arithmatex"><span class="MathJax_Preview">\|\cdot\|_+</span><script type="math/tex">\|\cdot\|_+</script></span>는 상태가 제약을 위반할 때만 발생하는 패널티 함수이다.</p>
<h3 id="mpc_3">MPC의 예측 구간</h3>
<p>모델 기반 예측 제어(MPC)에서 <strong>예측 구간</strong>(Prediction Horizon)은 중요한 개념으로, 미래의 시스템 동작을 예측하고 최적화하는 데 필요한 시간 범위를 정의한다. 예측 구간의 길이는 제어 성능과 계산 복잡성 사이의 트레이드오프를 결정하는 핵심 요소이다.</p>
<h4 id="1_2">1. 예측 구간의 정의</h4>
<p>예측 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 시스템의 현재 상태에서 시작하여 미래 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 스텝 동안의 상태와 제어 입력을 예측하는 구간을 나타낸다. 예측 구간이 길어질수록 더 많은 미래 정보를 고려하게 되므로 더 정밀한 제어가 가능할 수 있지만, 계산 비용이 증가하게 된다. 예측 구간은 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>으로 정의되며, 이때 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 시간 스텝의 수를 나타낸다.</p>
<p>예측 구간 동안의 시스템 상태와 제어 입력은 다음과 같이 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(k+1), \mathbf{x}(k+2), \dots, \mathbf{x}(k+N)
</div>
<script type="math/tex; mode=display">
\mathbf{x}(k+1), \mathbf{x}(k+2), \dots, \mathbf{x}(k+N)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)
</div>
<script type="math/tex; mode=display">
\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)
</script>
</div>
<p>MPC는 이 예측 구간에서의 상태와 제어 입력을 최적화하여 비용 함수를 최소화하고, 제어 목표를 달성한다.</p>
<h4 id="2_2">2. 예측 구간의 길이 선택</h4>
<p>예측 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>을 선택하는 것은 MPC 성능을 결정짓는 중요한 요소이다. 예측 구간이 너무 짧으면 미래의 변화를 충분히 고려하지 못해 제어 성능이 저하될 수 있다. 반대로 예측 구간이 너무 길면 계산 비용이 과도하게 증가하고, 실시간 제어에 필요한 계산 시간이 제한될 수 있다.</p>
<p>예측 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 일반적으로 다음 요인에 따라 결정된다:</p>
<ul>
<li><strong>시스템의 동적 특성</strong>: 시스템이 빠르게 변화하는 경우 예측 구간이 짧아도 충분할 수 있지만, 느린 시스템일수록 긴 예측 구간이 필요하다.</li>
<li><strong>계산 능력</strong>: 예측 구간이 길어질수록 최적화 문제의 계산 복잡도가 증가하므로, 실시간으로 계산 가능한 구간을 선택해야 한다.</li>
<li><strong>제약 조건</strong>: 제약 조건이 엄격할수록 미래의 상태를 더 세밀하게 예측해야 하므로, 긴 예측 구간이 필요할 수 있다.</li>
</ul>
<h4 id="3_2">3. 이동 구간 최적화</h4>
<p>MPC의 특징 중 하나는 <strong>이동 구간 최적화</strong>(Receding Horizon Optimization)이다. 예측 구간 동안의 제어 입력을 모두 계산하더라도, 실제로는 첫 번째 제어 입력만을 시스템에 적용하고 나머지는 버린다. 그 후, 시스템의 상태가 업데이트되면 새로운 현재 상태를 바탕으로 다시 최적화를 수행하는 방식이다.</p>
<p>이 과정은 다음과 같이 반복된다:</p>
<ol>
<li>현재 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>에서 예측 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 동안의 상태와 제어 입력을 계산한다.</li>
<li>계산된 제어 입력 중 첫 번째 값 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>만을 시스템에 적용한다.</li>
<li>다음 시간 스텝 <span class="arithmatex"><span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script></span>에서 새로운 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k+1)</span><script type="math/tex">\mathbf{x}(k+1)</script></span>를 바탕으로 다시 최적화를 수행한다.</li>
</ol>
<p>이 과정은 예측 구간을 매번 이동시키면서 제어를 수행하기 때문에, 예측 구간을 "이동 구간"(receding horizon)이라고 부른다. 이를 통해 시스템은 실시간으로 변화하는 동적 환경에서도 안정적으로 제어할 수 있다.</p>
<h4 id="4_1">4. 예측 구간과 제어 구간의 차이</h4>
<p>MPC에서는 <strong>예측 구간</strong>(Prediction Horizon)과 <strong>제어 구간</strong>(Control Horizon)을 구분할 수 있다. 예측 구간은 시스템 상태를 예측하는 시간 범위이며, 제어 구간은 최적화 과정에서 제어 입력을 실제로 조정하는 시간 범위를 나타낸다.</p>
<ul>
<li><strong>예측 구간</strong>: 상태를 예측하는 구간으로, 시스템의 미래 동작을 예측하기 위한 길이.</li>
<li><strong>제어 구간</strong>: 제어 입력을 최적화하는 구간으로, 제어 입력이 일정한 구간 동안 적용되는 범위.</li>
</ul>
<p>제어 구간이 예측 구간보다 짧을 수 있으며, 이는 계산 부담을 줄이기 위해 사용되기도 한다. 예를 들어, 예측 구간은 10 스텝이지만 제어 구간은 3 스텝만 적용될 수 있다. 이때 나머지 스텝은 미래 입력의 변화를 예측하는 데 사용된다.</p>
<h3 id="mpc_4">MPC에서의 비용 함수 최적화</h3>
<p>모델 기반 예측 제어(MPC)에서 제어 입력을 산출하는 핵심은 비용 함수(cost function)를 정의하고, 이를 최소화하는 것이다. 비용 함수는 제어 성능과 안정성의 기준을 제공하며, 시스템 상태와 제어 입력의 변화를 가중치로 조절한다.</p>
<h4 id="1_3">1. 비용 함수 정의</h4>
<p>비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>는 시스템 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>와 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>의 오차를 최소화하는 방식으로 정의된다. 이때 참조 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{ref}}(k)</span><script type="math/tex">\mathbf{x}_{\text{ref}}(k)</script></span>는 시스템이 도달해야 하는 목표 상태를 의미한다. 비용 함수는 예측 구간 동안의 상태 오차와 제어 입력의 크기를 모두 고려하며, 다음과 같은 형태로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
J = \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</div>
<script type="math/tex; mode=display">
J = \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k+i)</span><script type="math/tex">\mathbf{x}(k+i)</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">k+i</span><script type="math/tex">k+i</script></span>에서의 시스템 상태,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{ref}}(k+i)</span><script type="math/tex">\mathbf{x}_{\text{ref}}(k+i)</script></span>는 참조 상태,
- <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>는 상태 오차에 대한 가중치 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>는 제어 입력에 대한 가중치 행렬이다.</p>
<p>이 비용 함수는 상태와 제어 입력 사이의 트레이드오프를 설정하는 역할을 하며, 각각의 가중치에 따라 제어 목표를 설정할 수 있다. 예를 들어, 상태 오차가 더 중요한 경우 <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>의 값을 크게 설정하여 상태를 더 정확하게 추종하도록 제어할 수 있다.</p>
<h4 id="2-qq">2. 상태 오차에 대한 가중치 <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span></h4>
<p>상태 오차에 대한 가중치 행렬 <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>는 시스템의 목표 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{ref}}</span><script type="math/tex">\mathbf{x}_{\text{ref}}</script></span>와 실제 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> 사이의 오차에 대한 중요도를 나타낸다. 이는 예측 구간 동안 시스템이 목표 상태에 얼마나 근접하는지를 평가하며, 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 = (\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i))^\top Q (\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i))
</div>
<script type="math/tex; mode=display">
\|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 = (\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i))^\top Q (\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i))
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>는 대칭 양의 정부호 행렬이며, 각 상태 변수에 대한 가중치를 정의한다. 이 가중치를 통해 특정 상태 변수에 대한 제어 성능을 더 높이거나 낮출 수 있다. 예를 들어, 속도 제어가 중요하다면 속도 상태 변수에 대한 가중치를 더 높게 설정할 수 있다.</p>
<h4 id="3-rr">3. 제어 입력에 대한 가중치 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span></h4>
<p>제어 입력에 대한 가중치 행렬 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>는 예측 구간 동안 제어 입력의 크기를 최소화하는 데 사용된다. 이는 제어 입력의 변화가 너무 급격하거나 과도한 에너지를 소비하지 않도록 하는 역할을 한다. 제어 입력에 대한 비용은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{u}(k+i)\|_R^2 = \mathbf{u}(k+i)^\top R \mathbf{u}(k+i)
</div>
<script type="math/tex; mode=display">
\|\mathbf{u}(k+i)\|_R^2 = \mathbf{u}(k+i)^\top R \mathbf{u}(k+i)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>은 대칭 양의 정부호 행렬로, 제어 입력에 대한 가중치를 조절한다. 만약 제어 입력의 변화가 급격하게 발생하는 것을 피하고 싶다면 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>의 값을 크게 설정할 수 있다. 이는 시스템이 안정적이면서도 부드러운 제어를 수행하게 한다.</p>
<h4 id="4_2">4. 비용 함수의 트레이드오프</h4>
<p>비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>는 상태 오차와 제어 입력 간의 균형을 맞추는 역할을 한다. 이때 <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>의 값을 적절하게 조정하는 것이 매우 중요하다. <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>의 값이 너무 크면 상태 오차를 최소화하는 데만 집중하여 제어 입력이 급격하게 변화할 수 있고, 반대로 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>의 값이 너무 크면 제어 입력의 변화가 적어지지만 목표 상태에 도달하는 시간이 길어질 수 있다.</p>
<p>이러한 트레이드오프는 시스템의 요구 사항에 따라 조정되며, 이를 통해 제어 성능과 안정성 간의 균형을 맞출 수 있다.</p>
<h3 id="mpc_5">MPC에서의 제약 조건 처리 방식</h3>
<p>모델 기반 예측 제어(MPC)의 강점 중 하나는 제어 과정에서 시스템의 제약 조건을 명시적으로 다룰 수 있다는 것이다. 제약 조건은 상태, 제어 입력, 그리고 출력 등에 대해 물리적, 안전적, 또는 성능적 제한을 부여할 수 있으며, 이를 만족하면서도 최적의 제어를 수행하는 것이 목표이다.</p>
<h4 id="1_4">1. 상태 제약 조건</h4>
<p>상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>는 시스템의 물리적 또는 운영적 한계로 인해 특정 범위 내에서 유지되어야 한다. 예를 들어, 온도, 속도, 위치 등의 상태 변수는 시스템의 안정성과 성능을 유지하기 위해 일정 범위를 넘지 않도록 해야 한다. 이러한 상태 제약 조건은 다음과 같은 형태로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{\min} \leq \mathbf{x}(k+i) \leq \mathbf{x}_{\max}, \quad i = 0, 1, \dots, N-1
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{\min} \leq \mathbf{x}(k+i) \leq \mathbf{x}_{\max}, \quad i = 0, 1, \dots, N-1
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\min}</span><script type="math/tex">\mathbf{x}_{\min}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\max}</span><script type="math/tex">\mathbf{x}_{\max}</script></span>은 각각 상태 벡터의 하한과 상한을 나타낸다.
- <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 예측 구간의 길이이다.</p>
<p>이 상태 제약 조건은 예측 구간 동안 모든 시점에서 적용되며, 최적화 문제를 풀 때 필수적으로 반영된다.</p>
<h4 id="2_3">2. 제어 입력 제약 조건</h4>
<p>제어 입력 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span> 또한 시스템의 물리적 한계나 장비의 성능 제한으로 인해 특정 범위 내에서 유지되어야 한다. 예를 들어, 모터의 전류나 토크는 과부하를 방지하기 위해 일정 범위 내에서 동작해야 한다. 제어 입력 제약 조건은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{\min} \leq \mathbf{u}(k+i) \leq \mathbf{u}_{\max}, \quad i = 0, 1, \dots, N-1
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{\min} \leq \mathbf{u}(k+i) \leq \mathbf{u}_{\max}, \quad i = 0, 1, \dots, N-1
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{\min}</span><script type="math/tex">\mathbf{u}_{\min}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{\max}</span><script type="math/tex">\mathbf{u}_{\max}</script></span>은 각각 제어 입력 벡터의 하한과 상한을 나타낸다.
- 이 제약 조건 역시 예측 구간 전체에 걸쳐 적용된다.</p>
<h4 id="3_3">3. 출력 제약 조건</h4>
<p>출력 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}(k)</span><script type="math/tex">\mathbf{y}(k)</script></span>에 대한 제약 조건도 MPC에서 처리할 수 있다. 출력은 시스템의 상태와 제어 입력을 결합한 결과로서, 사용자가 관심을 가지는 물리량을 의미한다. 출력 제약 조건은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}_{\min} \leq \mathbf{y}(k+i) \leq \mathbf{y}_{\max}, \quad i = 0, 1, \dots, N-1
</div>
<script type="math/tex; mode=display">
\mathbf{y}_{\min} \leq \mathbf{y}(k+i) \leq \mathbf{y}_{\max}, \quad i = 0, 1, \dots, N-1
</script>
</div>
<p>출력 제약은 시스템의 동작이 특정 범위를 넘지 않도록 하여, 예를 들어 안전한 동작을 보장하거나 성능을 유지하는 데 사용된다. 출력 제약 조건을 고려할 때는 상태 및 제어 입력의 변화가 출력에 미치는 영향을 반드시 함께 분석해야 한다.</p>
<h4 id="4_3">4. 제약 조건을 고려한 최적화 문제</h4>
<p>MPC는 제약 조건을 포함한 최적화 문제를 풀어야 하며, 이를 <strong>제약 최적화 문제</strong>(Constrained Optimization Problem)라고 한다. 상태와 제어 입력에 대한 제약 조건을 모두 포함한 최적화 문제는 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)} \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)} \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</script>
</div>
<p>주어진 제약 조건은 다음과 같이 명시된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{\min} \leq \mathbf{x}(k+i) \leq \mathbf{x}_{\max}, \quad i = 0, 1, \dots, N-1
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{\min} \leq \mathbf{x}(k+i) \leq \mathbf{x}_{\max}, \quad i = 0, 1, \dots, N-1
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_{\min} \leq \mathbf{u}(k+i) \leq \mathbf{u}_{\max}, \quad i = 0, 1, \dots, N-1
</div>
<script type="math/tex; mode=display">
\mathbf{u}_{\min} \leq \mathbf{u}(k+i) \leq \mathbf{u}_{\max}, \quad i = 0, 1, \dots, N-1
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}_{\min} \leq \mathbf{y}(k+i) \leq \mathbf{y}_{\max}, \quad i = 0, 1, \dots, N-1
</div>
<script type="math/tex; mode=display">
\mathbf{y}_{\min} \leq \mathbf{y}(k+i) \leq \mathbf{y}_{\max}, \quad i = 0, 1, \dots, N-1
</script>
</div>
<p>이러한 제약 조건을 만족하는 최적 제어 입력을 계산하는 것이 MPC의 목표이다. 이때 선형 제약 조건을 가지는 경우 <strong>이차 계획법</strong>(Quadratic Programming, QP)이 주로 사용되며, 비선형 제약 조건을 가지는 경우 <strong>비선형 계획법</strong>(Nonlinear Programming, NLP)이 사용된다.</p>
<h4 id="5">5. 소프트 제약 조건</h4>
<p>때로는 제약 조건을 엄격하게 적용하는 것이 현실적이지 않거나 불가능할 수 있다. 예를 들어, 상태가 한계 값을 초과할 가능성이 있을 때, 이를 완화할 필요가 생긴다. 이때 <strong>소프트 제약 조건</strong>(Soft Constraints)을 사용하여, 제약 조건을 완화하는 대신 위반에 대한 패널티를 부과할 수 있다.</p>
<p>소프트 제약 조건은 비용 함수에 패널티 항을 추가하는 방식으로 구현된다. 예를 들어, 상태가 제약 조건을 위반할 경우 그에 따른 비용을 추가하여 최적화를 수행한다. 이러한 패널티 항은 다음과 같이 추가될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
J = \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 + \rho \cdot \max(0, \mathbf{x}(k+i) - \mathbf{x}_{\max})^2 \right)
</div>
<script type="math/tex; mode=display">
J = \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 + \rho \cdot \max(0, \mathbf{x}(k+i) - \mathbf{x}_{\max})^2 \right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\rho</span><script type="math/tex">\rho</script></span>는 패널티에 대한 가중치로, 상태가 제약을 위반하는 경우에만 패널티가 부과된다. 이러한 방식으로 제약을 완화하면서도 시스템의 성능을 유지할 수 있다.</p>
<h3 id="mpc_6">MPC에서의 최적화 방법</h3>
<p>모델 기반 예측 제어(MPC)에서 제어 입력을 결정하는 과정은 제약 조건을 만족시키면서 비용 함수를 최소화하는 최적화 문제를 푸는 것과 같다. 이 과정에서 사용되는 최적화 방법은 시스템의 성격에 따라 다르며, 선형 또는 비선형 모델, 제약 조건의 유무에 따라 달라질 수 있다. 대표적인 최적화 방법에는 <strong>선형 이차 계획법</strong>(QP, Quadratic Programming)과 <strong>비선형 계획법</strong>(NLP, Nonlinear Programming)이 있다.</p>
<h4 id="1-quadratic-programming-qp">1. 선형 이차 계획법 (Quadratic Programming, QP)</h4>
<p>선형 시스템에서는 제약 조건을 고려한 비용 함수가 이차 형태로 나타날 수 있다. 이때 MPC의 최적화 문제는 다음과 같은 이차 계획 문제로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)} \frac{1}{2} \mathbf{u}^\top H \mathbf{u} + \mathbf{f}^\top \mathbf{u}
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)} \frac{1}{2} \mathbf{u}^\top H \mathbf{u} + \mathbf{f}^\top \mathbf{u}
</script>
</div>
<p>제약 조건:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
G \mathbf{u} \leq \mathbf{h}
</div>
<script type="math/tex; mode=display">
G \mathbf{u} \leq \mathbf{h}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span>는 대칭 양의 정부호 행렬로, 제어 입력에 대한 이차 비용을 나타낸다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span>는 제어 입력에 대한 선형 항이다.
- <span class="arithmatex"><span class="MathJax_Preview">G</span><script type="math/tex">G</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{h}</span><script type="math/tex">\mathbf{h}</script></span>는 각각 제어 입력에 대한 제약 조건을 나타낸다.</p>
<p>이차 계획법(QP)은 이러한 문제를 효율적으로 해결할 수 있는 수치적 방법이다. 선형 시스템에 대한 MPC는 일반적으로 QP를 통해 해결되며, QP는 실시간 제어에서 널리 사용된다.</p>
<h4 id="2-nonlinear-programming-nlp">2. 비선형 계획법 (Nonlinear Programming, NLP)</h4>
<p>만약 시스템이 비선형이거나 제약 조건이 비선형일 경우, MPC의 최적화 문제는 비선형 계획 문제로 나타난다. 이때 비용 함수와 제약 조건은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)} J(\mathbf{x}, \mathbf{u})
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)} J(\mathbf{x}, \mathbf{u})
</script>
</div>
<p>제약 조건:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{g}(\mathbf{x}, \mathbf{u}) \leq 0
</div>
<script type="math/tex; mode=display">
\mathbf{g}(\mathbf{x}, \mathbf{u}) \leq 0
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">J(\mathbf{x}, \mathbf{u})</span><script type="math/tex">J(\mathbf{x}, \mathbf{u})</script></span>는 비선형 비용 함수로, 상태와 제어 입력에 대해 비선형 형태를 띤다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{g}(\mathbf{x}, \mathbf{u})</span><script type="math/tex">\mathbf{g}(\mathbf{x}, \mathbf{u})</script></span>는 상태 및 제어 입력에 대한 비선형 제약 조건이다.</p>
<p>비선형 계획법(NLP)은 이러한 비선형 최적화 문제를 해결하는 방법으로, 주로 실시간 제어에는 <strong>이전 조건 기반 방법</strong>(Sequential Quadratic Programming, SQP)이나 <strong>내부점 방법</strong>(Interior Point Methods)이 사용된다. 이 방법들은 복잡도가 높은 비선형 문제를 실시간으로 해결하는 데 적합하다.</p>
<h4 id="3_4">3. 실시간 최적화</h4>
<p>MPC는 실시간 제어에서 사용되므로, 최적화 문제를 해결하는 데 걸리는 시간이 매우 중요하다. 이를 위해 다음과 같은 실시간 최적화 기법들이 사용된다:</p>
<ol>
<li><strong>이전 조건 기반 최적화</strong>: 최적화 문제를 풀 때 이전 시점의 해를 초기 값으로 사용하여 현재의 최적화 문제를 빠르게 해결하는 방법이다. 이를 통해 계산 시간을 크게 줄일 수 있다.</li>
<li><strong>순차적 이차 계획법 (Sequential Quadratic Programming, SQP)</strong>: 비선형 최적화 문제를 순차적으로 선형 이차 계획 문제(QP)로 변환하여 해결하는 방법이다. 각 반복 단계에서 이차 계획 문제를 풀어 비선형 문제를 근사적으로 해결한다.</li>
<li><strong>모델 감소 기법</strong>: 예측 구간을 줄이거나, 상태 공간 모델의 차원을 축소하여 계산 복잡도를 줄이는 방법이다. 이를 통해 실시간 최적화를 수행하는데 필요한 시간을 줄일 수 있다.</li>
</ol>
<h4 id="4-">4. 온-라인과 오프-라인 최적화</h4>
<p>MPC에서는 실시간으로 최적화 문제를 푸는 <strong>온-라인 최적화</strong>가 일반적이지만, 일부 경우에는 <strong>오프-라인 최적화</strong>가 사용되기도 한다. 오프-라인 최적화는 예측 구간 동안의 최적 제어 입력을 미리 계산하고, 이를 저장한 후 실시간으로 필요할 때 참조하여 사용하는 방식이다.</p>
<p>이러한 방식은 계산 복잡도를 줄일 수 있지만, 시스템의 동적 변화에 실시간으로 대응하지 못한다는 단점이 있다. 따라서 대부분의 MPC 구현에서는 온-라인 최적화를 사용하며, 실시간 최적화를 위해 효율적인 수치적 방법이 필수적이다.</p>
<h3 id="mpc-receding-horizon-optimization">MPC에서의 이동 구간 최적화 (Receding Horizon Optimization)</h3>
<p>모델 기반 예측 제어(MPC)의 주요 특징 중 하나는 <strong>이동 구간 최적화</strong>(Receding Horizon Optimization) 방식이다. 이는 MPC가 실시간으로 동작하는 시스템의 상태를 지속적으로 예측하고 제어 입력을 계산하는 데 매우 중요한 메커니즘이다.</p>
<h4 id="1_5">1. 이동 구간 최적화의 개념</h4>
<p>MPC는 일정한 시간 구간 동안의 제어 입력을 계산하고, 그중 첫 번째 제어 입력만을 시스템에 적용한다. 다음 시간 스텝에서는 새롭게 측정된 현재 상태를 바탕으로 다시 최적화를 수행하여 새로운 제어 입력을 계산하는 방식을 반복한다. 이 과정을 <strong>이동 구간 최적화</strong>라고 부르며, 이를 통해 시스템은 실시간으로 변화하는 환경에 적응할 수 있다.</p>
<p>구체적으로, MPC는 다음과 같은 단계를 거친다:</p>
<ol>
<li>현재 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k)</span><script type="math/tex">\mathbf{x}(k)</script></span>에서 시작하여 예측 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> 동안의 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k+1), \mathbf{x}(k+2), \dots, \mathbf{x}(k+N)</span><script type="math/tex">\mathbf{x}(k+1), \mathbf{x}(k+2), \dots, \mathbf{x}(k+N)</script></span>를 예측한다.</li>
<li>비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>를 최소화하는 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)</span><script type="math/tex">\mathbf{u}(k), \mathbf{u}(k+1), \dots, \mathbf{u}(k+N-1)</script></span>를 계산한다.</li>
<li>계산된 제어 입력 중 첫 번째 값 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(k)</span><script type="math/tex">\mathbf{u}(k)</script></span>만 시스템에 적용한다.</li>
<li>다음 시간 스텝 <span class="arithmatex"><span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script></span>에서 다시 상태를 업데이트하고 새로운 최적화 문제를 풀어 제어 입력을 계산한다.</li>
</ol>
<p>이 방식의 핵심은 매번 예측 구간을 이동시키면서 최적화를 반복 수행하여 시스템이 변화하는 환경에서 실시간 제어를 유지하는 것이다.</p>
<h4 id="2_4">2. 이동 구간 최적화의 장점</h4>
<p>이동 구간 최적화는 여러 가지 장점을 제공한다:</p>
<ol>
<li><strong>실시간 적응</strong>: 시스템이 실시간으로 변화하는 환경에서도 최적의 제어 입력을 계산할 수 있다. 이는 시스템이 비선형적이거나 외란이 있을 때에도 안정적인 제어를 가능하게 한다.</li>
<li><strong>제약 조건 처리</strong>: 이동 구간 최적화는 제약 조건을 포함한 최적화 문제를 반복적으로 풀기 때문에, 시스템이 제약 조건을 지속적으로 만족하도록 제어할 수 있다.</li>
<li><strong>미래 상태 고려</strong>: MPC는 현재 상태뿐만 아니라 미래의 상태를 예측하여 제어 입력을 결정하므로, 시스템의 미래 동작을 미리 고려할 수 있다.</li>
</ol>
<h4 id="3_5">3. 이동 구간 최적화의 계산 복잡도</h4>
<p>이동 구간 최적화의 단점은 계산 복잡도에 있다. 매 시간 스텝마다 최적화 문제를 새로 풀어야 하므로, 실시간으로 동작하는 시스템에서는 계산 시간이 제한적일 수 있다. 따라서 MPC의 계산 복잡도를 줄이기 위한 다양한 방법들이 사용된다.</p>
<ul>
<li><strong>모델 차원 축소</strong>: 상태 공간 모델의 차원을 축소하여 계산 복잡도를 줄인다.</li>
<li><strong>최적화 구간 축소</strong>: 예측 구간이나 제어 구간의 길이를 줄여서 계산 시간을 단축한다.</li>
<li><strong>이전 해를 초기화로 사용</strong>: 이전 시간 스텝에서 계산된 최적화 해를 다음 스텝의 초기 값으로 사용하여 최적화 속도를 높인다.</li>
</ul>
<h4 id="4_4">4. 이동 구간 최적화와 예측 구간의 관계</h4>
<p>MPC에서 <strong>이동 구간</strong>과 <strong>예측 구간</strong>은 밀접하게 연관되어 있다. 예측 구간은 시스템의 미래 상태를 예측하는 시간 범위이며, 이동 구간은 예측 구간을 매번 이동시키면서 최적화를 수행하는 방식을 의미한다. </p>
<p>예측 구간이 너무 짧으면 미래 상태를 충분히 고려하지 못해 제어 성능이 저하될 수 있고, 예측 구간이 너무 길면 계산 복잡도가 증가하여 실시간 제어가 어려워질 수 있다. 따라서 시스템의 특성에 맞게 적절한 예측 구간을 설정하는 것이 중요하다.</p>
<h4 id="5_1">5. 제어 구간과의 차이</h4>
<p>MPC에서는 <strong>제어 구간</strong>(Control Horizon)과 <strong>예측 구간</strong>(Prediction Horizon)을 구분할 수 있다. 제어 구간은 실제로 제어 입력을 조정하는 구간을 의미하며, 예측 구간은 시스템의 미래 상태를 예측하는 구간을 의미한다. 제어 구간이 예측 구간보다 짧을 수 있으며, 이는 계산 복잡도를 줄이기 위한 하나의 방법이다. 예를 들어, 예측 구간은 10 스텝이지만 제어 구간은 3 스텝만 적용될 수 있다. 나머지 스텝은 미래 상태를 예측하는 데 사용된다.</p>
<p>이러한 방식은 실시간 제어에서 매우 유용하며, 계산 시간과 제어 성능 사이의 균형을 맞추는 데 도움을 준다.</p>
<h3 id="mpc_7">MPC에서의 안정성 보장</h3>
<p>모델 기반 예측 제어(MPC)는 실시간 제어를 위한 강력한 방법이지만, 안정성 보장은 매우 중요한 문제이다. MPC가 시스템의 성능을 최적화하는 동안 제어 시스템이 불안정해지지 않도록 적절한 설계가 필요하다. 안정성을 보장하기 위해서는 다양한 기법이 사용되며, 다음은 그중 몇 가지 중요한 방법들이다.</p>
<h4 id="1_6">1. 터미널 비용 함수와 터미널 제약 조건</h4>
<p>MPC에서 안정성을 보장하는 가장 일반적인 방법 중 하나는 <strong>터미널 비용 함수</strong>(Terminal Cost Function)와 <strong>터미널 제약 조건</strong>(Terminal Constraints)을 도입하는 것이다. 이들은 예측 구간의 마지막 시점에서 시스템이 안정적인 상태로 수렴하도록 돕는다.</p>
<ul>
<li><strong>터미널 비용 함수</strong> <span class="arithmatex"><span class="MathJax_Preview">V_f(\mathbf{x}(k+N))</span><script type="math/tex">V_f(\mathbf{x}(k+N))</script></span>는 예측 구간의 마지막 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(k+N)</span><script type="math/tex">\mathbf{x}(k+N)</script></span>에서 추가로 부과되는 비용 함수이다. 이는 시스템이 최종적으로 원하는 상태로 수렴하도록 유도한다. 터미널 비용 함수는 다음과 같은 형태로 정의될 수 있다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
J = \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right) + V_f(\mathbf{x}(k+N))
</div>
<script type="math/tex; mode=display">
J = \sum_{i=0}^{N-1} \left( \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right) + V_f(\mathbf{x}(k+N))
</script>
</div>
<ul>
<li><strong>터미널 제약 조건</strong>은 예측 구간 끝에서 시스템 상태가 특정 안정 영역 내에 있도록 제약하는 조건이다. 이 조건을 만족시키는 상태는 시스템이 장기적으로 안정적인 동작을 할 수 있도록 보장한다. 터미널 제약 조건은 다음과 같이 나타낼 수 있다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(k+N) \in \mathcal{X}_f
</div>
<script type="math/tex; mode=display">
\mathbf{x}(k+N) \in \mathcal{X}_f
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{X}_f</span><script type="math/tex">\mathcal{X}_f</script></span>는 터미널 상태가 포함될 수 있는 안정 영역을 나타낸다.</p>
<h4 id="2_5">2. 적절한 예측 구간 설정</h4>
<p>MPC의 예측 구간 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 안정성에 직접적인 영향을 미친다. 예측 구간이 너무 짧으면 시스템의 장기적인 동작을 충분히 예측할 수 없어 제어 성능이 저하될 수 있다. 반대로 예측 구간이 너무 길면 실시간으로 제어 입력을 계산하는 데 걸리는 시간이 증가하여, 안정성을 보장하기 어려워질 수 있다.</p>
<p>따라서 예측 구간은 시스템의 동적 특성과 계산 능력을 고려하여 적절하게 설정해야 한다. 일반적으로, 시스템이 빠르게 변하는 경우 예측 구간을 짧게 설정하고, 시스템이 느리게 변화하거나 큰 시간을 요구하는 경우 예측 구간을 길게 설정한다.</p>
<h4 id="3_6">3. 제어 구간 제한</h4>
<p>제어 구간(또는 이동 구간)의 길이를 적절하게 조절하는 것도 시스템 안정성에 중요한 역할을 한다. 예측 구간이 길더라도, 제어 입력을 실시간으로 적절히 조정하지 못하면 불안정한 동작이 발생할 수 있다. 제어 구간은 실제 제어 입력을 적용하는 범위이므로, 이 구간이 너무 길면 시스템의 미래 상태 예측이 부정확해질 수 있다.</p>
<p>따라서 제어 구간의 길이는 일반적으로 예측 구간보다 짧게 설정되며, 이를 통해 시스템이 예측 구간 동안 더 나은 미래 상태를 고려하면서도 실시간으로 안정적인 제어를 유지할 수 있도록 한다.</p>
<h4 id="4_5">4. 출력 피드백</h4>
<p>MPC는 미래 상태를 예측하기 때문에, 측정된 현재 상태에서 예측된 상태 사이의 오차가 발생할 수 있다. 이를 보정하기 위해 <strong>출력 피드백</strong>(Output Feedback)을 사용하여, 측정된 현재 상태와 예측 상태를 비교하고 오차를 줄이는 방향으로 제어 입력을 수정한다. 이 피드백을 통해 예측 오차가 발생하더라도 시스템이 안정적으로 동작할 수 있도록 할 수 있다.</p>
<p>출력 피드백은 일반적으로 다음과 같은 형태로 추가된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(k) = \mathbf{u}_{\text{MPC}}(k) + K (\mathbf{x}_{\text{meas}}(k) - \mathbf{x}_{\text{pred}}(k))
</div>
<script type="math/tex; mode=display">
\mathbf{u}(k) = \mathbf{u}_{\text{MPC}}(k) + K (\mathbf{x}_{\text{meas}}(k) - \mathbf{x}_{\text{pred}}(k))
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{\text{MPC}}(k)</span><script type="math/tex">\mathbf{u}_{\text{MPC}}(k)</script></span>는 MPC가 계산한 제어 입력,
- <span class="arithmatex"><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>는 피드백 게인,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{meas}}(k)</span><script type="math/tex">\mathbf{x}_{\text{meas}}(k)</script></span>는 측정된 상태,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{pred}}(k)</span><script type="math/tex">\mathbf{x}_{\text{pred}}(k)</script></span>는 예측된 상태이다.</p>
<p>이 피드백을 통해 예측 오차가 발생하더라도 시스템의 안정성이 보장된다.</p>
<h4 id="5-mpc">5. 로버스트 MPC</h4>
<p>시스템이 모델링 불확실성이나 외란에 민감한 경우, <strong>로버스트 MPC</strong>(Robust MPC)를 통해 안정성을 보장할 수 있다. 로버스트 MPC는 외란이나 모델링 오류가 존재할 때에도 시스템이 안정적으로 동작할 수 있도록 제어 입력을 계산한다.</p>
<p>로버스트 MPC는 불확실성을 고려한 비용 함수와 제약 조건을 설정하고, 최적화 문제를 해결한다. 이를 통해 시스템이 예측되지 않은 변화에도 불구하고 안정적으로 동작할 수 있도록 한다. 로버스트 MPC의 비용 함수는 다음과 같이 정의될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
J = \sum_{i=0}^{N-1} \left( \max_{\mathbf{w}(k)} \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</div>
<script type="math/tex; mode=display">
J = \sum_{i=0}^{N-1} \left( \max_{\mathbf{w}(k)} \|\mathbf{x}(k+i) - \mathbf{x}_{\text{ref}}(k+i)\|_Q^2 + \|\mathbf{u}(k+i)\|_R^2 \right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{w}(k)</span><script type="math/tex">\mathbf{w}(k)</script></span>는 외란 벡터로, 외부 요인에 의해 발생할 수 있는 오차를 고려한 형태이다.</p>
<h4 id="6">6. 실시간 최적화의 정확도</h4>
<p>MPC는 실시간 제어 입력을 계산하기 때문에, 계산 시간 안에 최적의 제어 입력을 찾는 것이 중요하다. 그러나 실시간 최적화는 제한된 시간 내에 이루어져야 하므로, 때로는 최적화 문제의 근사해를 사용하는 것이 필요하다. 이를 위해 실시간 최적화 알고리즘을 개선하거나, 최적화 문제를 간단히 만들어 계산 시간을 줄이는 방법이 사용된다. </p>
<p>이러한 근사 해도 적절히 활용하면 안정성을 보장할 수 있다. 예를 들어, <strong>순차적 이차 계획법</strong>(Sequential Quadratic Programming, SQP)이나 <strong>이전 해를 활용한 초기화 방법</strong>을 통해 빠른 최적화를 수행할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1404/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1404/" class="btn btn-xs btn-link">
        제어 시스템의 동적 응답 최적화
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1402/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1402/" class="btn btn-xs btn-link">
        수소 전지 모델링
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>