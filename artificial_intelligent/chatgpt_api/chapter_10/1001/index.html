<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/artificial_intelligent/chatgpt_api/chapter_10/1001/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>유닛 테스트 및 통합 테스트 - 소프트웨어 융합</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc720\ub2db \ud14c\uc2a4\ud2b8 \uac1c\uc694", url: "#_top", children: [
              {title: "Mocking\uc758 \ud544\uc694\uc131", url: "#mocking" },
          ]},
          {title: "\uc758\uc874\uc131 \ubd84\ub9ac", url: "#_2", children: [
              {title: "\uc608\uc2dc: \uc758\uc874\uc131 \uc8fc\uc785", url: "#_3" },
          ]},
          {title: "API \ud638\ucd9c\uc5d0 \ub300\ud55c \ud14c\uc2a4\ud2b8 \uc2dc\ub098\ub9ac\uc624", url: "#api", children: [
          ]},
          {title: "\ud14c\uc2a4\ud2b8 \ucee4\ubc84\ub9ac\uc9c0", url: "#_4", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8 \uac1c\uc694", url: "#_5", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc758 \uc811\uadfc \ubc29\uc2dd", url: "#_6", children: [
              {title: "\uc2e4\uc81c API \ud638\ucd9c\uc744 \ud1b5\ud55c \ud14c\uc2a4\ud2b8", url: "#api_1" },
              {title: "\ud558\uc774\ube0c\ub9ac\ub4dc \ud1b5\ud569 \ud14c\uc2a4\ud2b8", url: "#_7" },
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc758 \uc5b4\ub824\uc6c0\uacfc \ud574\uacb0\ucc45", url: "#_8", children: [
              {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8 \ucd5c\uc801\ud654", url: "#_9" },
          ]},
          {title: "\uc758\uc874\uc131 \uad00\ub9ac \ubc0f \ubaa8\uc758 \ub370\uc774\ud130", url: "#_10", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8 \uc0ac\ub840", url: "#_11", children: [
              {title: "ChatGPT API\uc640 \ub370\uc774\ud130\ubca0\uc774\uc2a4 \ud1b5\ud569 \ud14c\uc2a4\ud2b8", url: "#chatgpt-api" },
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 \ubb38\uc81c \ud574\uacb0", url: "#_12", children: [
              {title: "\ube44\uacb0\uc815\uc801 \ud14c\uc2a4\ud2b8", url: "#_13" },
              {title: "\ud14c\uc2a4\ud2b8 \ud658\uacbd \uaca9\ub9ac", url: "#_14" },
              {title: "\uc678\ubd80 \uc2dc\uc2a4\ud15c \uc758\uc874\uc131 \ucd5c\uc18c\ud654", url: "#_15" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1002/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1002/" class="btn btn-xs btn-link">
        테스트 자동화 및 CI 파이프라인 구축
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_09/0904/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_09/0904/" class="btn btn-xs btn-link">
        모니터링 및 운영 자동화
      </a>
    </div>
    
  </div>

    

    <p>유닛 테스트(Unit Testing)와 통합 테스트(Integration Testing)는 소프트웨어의 품질을 유지하고, 오류를 사전에 예방하며, 코드 변경 시 예상치 못한 문제를 방지하기 위해 중요한 역할을 한다. ChatGPT API와 같은 외부 API를 사용하는 애플리케이션에서는 다양한 상황을 고려한 테스트를 작성해야 한다.</p>
<h3 id="_1">유닛 테스트 개요</h3>
<p>유닛 테스트는 코드의 개별 모듈이나 기능을 검증하는 테스트로, 일반적으로 함수나 메서드 단위에서 작성된다. ChatGPT API와 같은 외부 서비스 호출이 포함된 함수에서 유닛 테스트를 작성할 때는 API 호출을 실제로 수행하는 것이 아니라, <strong>Mocking</strong> 기법을 통해 호출을 모방하는 것이 일반적이다.</p>
<h4 id="mocking">Mocking의 필요성</h4>
<p>API 호출을 실제로 수행하지 않고 테스트할 수 있도록 도와주는 것이 Mocking이다. Mocking을 사용하면 API가 정상적으로 작동하는지 확인할 수 있을 뿐만 아니라, 네트워크 오류나 시간 초과 등의 예외적인 상황도 쉽게 시뮬레이션할 수 있다.</p>
<p>예를 들어, Python의 <code>unittest</code> 라이브러리에서 제공하는 <code>unittest.mock</code> 모듈을 이용하면, 외부 API 호출을 간단하게 모킹할 수 있다.</p>
<pre><code class="language-python">import unittest
from unittest.mock import patch
from myapp import chatgpt_api_request

class TestChatGPTAPI(unittest.TestCase):
    @patch('myapp.chatgpt_api_request')
    def test_api_response(self, mock_api):
        mock_api.return_value = {&quot;choices&quot;: [{&quot;text&quot;: &quot;Hello, World!&quot;}]}
        response = chatgpt_api_request(&quot;Hello&quot;)
        self.assertEqual(response['choices'][0]['text'], &quot;Hello, World!&quot;)
</code></pre>
<p>위 코드에서는 <code>chatgpt_api_request</code> 함수가 ChatGPT API를 호출하는 대신 모킹된 데이터를 반환하도록 설정한다. 이를 통해 실제 API 호출 없이 유닛 테스트를 수행할 수 있다.</p>
<h3 id="_2">의존성 분리</h3>
<p>유닛 테스트는 시스템의 다른 부분들과 격리되어야 한다. 이를 위해서는 함수나 메서드의 의존성을 외부에서 주입하는 방식을 사용하는 것이 좋다. 이러한 기법은 <strong>의존성 주입(Dependency Injection)</strong>이라고 불리며, 외부 API와의 통신이 필요한 함수를 테스트할 때 특히 유용하다.</p>
<h4 id="_3">예시: 의존성 주입</h4>
<p>다음은 ChatGPT API와 상호작용하는 함수에 의존성 주입을 적용한 예이다.</p>
<pre><code class="language-python">class ChatGPTClient:
    def __init__(self, api_client):
        self.api_client = api_client

    def generate_text(self, prompt):
        return self.api_client.create_completion(prompt=prompt)
</code></pre>
<p>테스트 시 <code>api_client</code> 객체를 모킹하여 실제 API 호출을 대체할 수 있다.</p>
<pre><code class="language-python">class TestChatGPTClient(unittest.TestCase):
    def test_generate_text(self):
        mock_api_client = unittest.mock.Mock()
        mock_api_client.create_completion.return_value = {&quot;choices&quot;: [{&quot;text&quot;: &quot;Test response&quot;}]}

        client = ChatGPTClient(api_client=mock_api_client)
        response = client.generate_text(&quot;Test prompt&quot;)
        self.assertEqual(response['choices'][0]['text'], &quot;Test response&quot;)
</code></pre>
<p>위와 같이 의존성 주입을 통해 코드를 테스트하기 쉽게 설계하면, 테스트 환경에서 실제 외부 API 호출을 차단하면서도 유닛 테스트를 작성할 수 있다.</p>
<h3 id="api">API 호출에 대한 테스트 시나리오</h3>
<p>유닛 테스트에서 중요한 부분은 다양한 시나리오를 테스트하는 것이다. 특히 외부 API 호출을 다루는 경우, 정상적인 응답뿐만 아니라 다양한 오류 상황에 대해서도 테스트를 작성해야 한다. 대표적인 시나리오로는 다음과 같다.</p>
<ul>
<li><strong>정상적인 API 응답</strong>: API 호출이 정상적으로 완료되었을 때의 처리를 검증한다.</li>
<li><strong>네트워크 오류 발생</strong>: 네트워크 문제로 인해 API 호출이 실패했을 때의 처리를 검증한다.</li>
<li><strong>API Rate Limit 초과</strong>: 요청이 너무 많아 Rate Limit에 걸렸을 때의 처리를 검증한다.</li>
</ul>
<p>각 상황에 맞게 Mocking을 사용하여 API의 응답을 시뮬레이션하고, 애플리케이션이 어떻게 동작하는지 확인해야 한다.</p>
<pre><code class="language-python">@patch('myapp.chatgpt_api_request')
def test_network_error(self, mock_api):
    mock_api.side_effect = ConnectionError(&quot;Network Error&quot;)
    with self.assertRaises(ConnectionError):
        chatgpt_api_request(&quot;Test prompt&quot;)
</code></pre>
<p>위 코드에서는 네트워크 오류가 발생했을 때 <code>ConnectionError</code> 예외가 발생하는지를 검증한다.</p>
<h3 id="_4">테스트 커버리지</h3>
<p>유닛 테스트에서 중요한 또 하나의 개념은 <strong>테스트 커버리지(Test Coverage)</strong>이다. 이는 코드베이스 중 얼마나 많은 부분이 테스트되고 있는지를 나타내는 지표이다. 테스트 커버리지를 높이기 위해서는 다양한 입력 값과 오류 상황을 고려하여 테스트를 작성해야 한다.</p>
<p>테스트 커버리지를 확인하기 위해 Python에서는 <code>coverage.py</code>와 같은 도구를 사용할 수 있다. 이 도구는 코드 실행 시 각 코드 라인이 얼마나 실행되었는지를 분석하고, 테스트되지 않은 부분을 확인하는 데 유용하다.</p>
<pre><code class="language-bash">pip install coverage
coverage run -m unittest discover
coverage report -m
</code></pre>
<p>위 명령어는 테스트를 실행하고, 커버리지 리포트를 생성한다.</p>
<h3 id="_5">통합 테스트 개요</h3>
<p>통합 테스트(Integration Testing)는 개별 모듈을 결합한 후, 그 모듈들이 함께 잘 작동하는지 확인하는 테스트이다. 유닛 테스트가 모듈 단위로 동작하는지 확인하는 것이라면, 통합 테스트는 여러 모듈 간의 상호작용이 예상대로 이루어지는지를 확인한다.</p>
<p>통합 테스트에서는 외부 API와의 상호작용도 실제로 수행될 수 있으며, 시스템 전반의 흐름이 제대로 동작하는지를 검증하는 것이 중요하다. ChatGPT API와 같은 외부 API를 사용한 애플리케이션에서는, 테스트 환경에서 실제로 API를 호출하거나, 일부 Mocking을 유지하는 방식으로 통합 테스트를 진행할 수 있다.</p>
<h3 id="_6">통합 테스트의 접근 방식</h3>
<p>통합 테스트에서는 유닛 테스트와 달리 전체 시스템이 연동된 환경에서 테스트가 이루어지기 때문에, 실제 API를 호출할 수 있는 테스트 환경을 설정하거나, 중요하지 않은 외부 시스템은 모킹할 수 있다.</p>
<h4 id="api_1">실제 API 호출을 통한 테스트</h4>
<p>실제 API를 호출하는 통합 테스트를 수행할 때는, 테스트 환경에서 발생할 수 있는 변수들에 대비해야 한다. 이를 위해 테스트용 API 키를 사용하는 것이 일반적이며, 테스트 중 발생하는 비용을 최소화하기 위해 API 호출 수를 제한해야 한다.</p>
<pre><code class="language-python">class TestChatGPTIntegration(unittest.TestCase):
    def test_integration_with_actual_api(self):
        client = ChatGPTClient(api_key=&quot;TEST_API_KEY&quot;)
        response = client.generate_text(&quot;What is the weather today?&quot;)
        self.assertIn(&quot;weather&quot;, response['choices'][0]['text'])
</code></pre>
<p>위 예제에서는 실제 ChatGPT API를 호출하는 통합 테스트를 수행하며, 응답에 "weather"라는 단어가 포함되어 있는지를 확인한다. 이러한 통합 테스트는 개발 환경에서만 실행해야 하며, 프로덕션 환경에서는 비용 관리와 안정성을 위해 주의가 필요하다.</p>
<h4 id="_7">하이브리드 통합 테스트</h4>
<p>통합 테스트에서도 모든 외부 의존성을 실제로 호출하는 대신, 중요한 부분만 실제 API를 호출하고 나머지는 모킹하여 테스트하는 방식도 있다. 이를 <strong>하이브리드 통합 테스트</strong>라고 부를 수 있다.</p>
<p>예를 들어, 데이터베이스와의 상호작용은 실제로 테스트하면서, 외부 API는 모킹하는 방식이다.</p>
<pre><code class="language-python">class TestChatGPTIntegrationWithMock(unittest.TestCase):
    @patch('myapp.chatgpt_api_request')
    def test_partial_integration_with_mock(self, mock_api):
        mock_api.return_value = {&quot;choices&quot;: [{&quot;text&quot;: &quot;Hello!&quot;}]}
        client = ChatGPTClient(api_key=&quot;TEST_API_KEY&quot;)
        response = client.generate_text(&quot;Hello?&quot;)
        self.assertEqual(response['choices'][0]['text'], &quot;Hello!&quot;)
</code></pre>
<p>위 코드에서는 API 호출 부분만 모킹하고, 나머지 시스템은 실제로 동작하도록 설정하여 통합 테스트를 수행한다.</p>
<h3 id="_8">통합 테스트의 어려움과 해결책</h3>
<p>통합 테스트는 시스템의 전체 흐름을 확인하는 중요한 역할을 하지만, 다음과 같은 어려움이 존재한다.</p>
<ul>
<li><strong>복잡한 설정</strong>: 통합 테스트는 모든 모듈이 함께 동작해야 하므로, 설정이 복잡해질 수 있다. 이를 해결하기 위해서는 컨테이너화된 테스트 환경(Docker)을 사용하거나, CI/CD 파이프라인에서 자동으로 설정되는 테스트 환경을 구성할 수 있다.</li>
<li><strong>외부 의존성 문제</strong>: 외부 시스템이나 API가 불안정할 경우, 통합 테스트도 영향을 받을 수 있다. 이를 해결하기 위해 Mocking을 적절히 사용하는 하이브리드 접근법을 도입하는 것이 좋다.</li>
<li><strong>느린 테스트 실행</strong>: 모든 시스템을 통합한 후 테스트를 진행하므로, 테스트 속도가 느려질 수 있다. 이를 해결하기 위해서는 병렬 테스트 실행이나 선택적 테스트 실행 전략을 고려해야 한다.</li>
</ul>
<h4 id="_9">통합 테스트 최적화</h4>
<p>통합 테스트는 단일 테스트로 많은 모듈을 결합하여 검증하기 때문에, 성능 최적화가 중요하다. 효율적인 테스트를 위해 다음과 같은 전략을 사용할 수 있다.</p>
<ol>
<li><strong>병렬 테스트 실행</strong>: 테스트 케이스를 병렬로 실행하여 전체 테스트 시간을 줄일 수 있다.</li>
<li><strong>테스트 샌드박스</strong>: 테스트 환경에서 데이터를 샌드박스 형태로 격리하여, 데이터가 오염되지 않도록 설정한다.</li>
<li><strong>캐싱</strong>: 일부 테스트에서 동일한 데이터나 응답을 사용하는 경우, 이를 캐싱하여 테스트 시간을 줄일 수 있다.</li>
</ol>
<p>테스트의 성능을 높이는 것은 통합 테스트를 실용적으로 만드는 데 매우 중요하며, 특히 대규모 애플리케이션에서 그 효과가 두드러진다.</p>
<h3 id="_10">의존성 관리 및 모의 데이터</h3>
<p>통합 테스트에서는 데이터베이스, 캐시 서버, 외부 API 등 여러 가지 의존성에 맞춰 테스트 환경을 구성해야 한다. 이를 위해 <strong>테스트 더블(Test Double)</strong> 기법을 활용할 수 있다. 테스트 더블에는 <strong>더미(Dummy)</strong>, <strong>스텁(Stub)</strong>, <strong>모크(Mock)</strong>, <strong>페이크(Fake)</strong> 등이 있다. 각 기법은 서로 다른 상황에서 사용되며, 통합 테스트에서 유용하게 활용된다.</p>
<ul>
<li><strong>더미(Dummy)</strong>: 실제로 사용되지 않는 더미 객체를 생성하여 의존성을 충족시킨다.</li>
<li><strong>스텁(Stub)</strong>: 실제 객체를 대체할 수 있는 간단한 객체로, 미리 정의된 응답을 반환하는 방식으로 동작한다.</li>
<li><strong>모크(Mock)</strong>: 테스트 중 호출된 메서드나 프로세스를 추적할 수 있는 객체로, 상호작용을 검증한다.</li>
<li><strong>페이크(Fake)</strong>: 실제로 동작하지만, 간소화된 버전의 구현체를 의미한다.</li>
</ul>
<h3 id="_11">통합 테스트 사례</h3>
<p>실제 ChatGPT API를 사용하는 애플리케이션에서 통합 테스트를 작성할 때는 다양한 시나리오를 고려해야 한다. 예를 들어, 프롬프트를 사용하여 API 요청을 보내고, 그 결과를 처리하는 로직이 올바르게 동작하는지를 검증하는 통합 테스트를 작성할 수 있다.</p>
<h4 id="chatgpt-api">ChatGPT API와 데이터베이스 통합 테스트</h4>
<p>다음은 ChatGPT API와 데이터베이스가 상호작용하는 애플리케이션의 통합 테스트 예시이다. 이 테스트에서는 ChatGPT API를 호출하여 응답을 받은 후, 그 결과를 데이터베이스에 저장하는 로직을 검증한다.</p>
<pre><code class="language-python">import unittest
from unittest.mock import patch
from myapp import chatgpt_api_request, save_to_database

class TestChatGPTDatabaseIntegration(unittest.TestCase):
    @patch('myapp.chatgpt_api_request')
    @patch('myapp.save_to_database')
    def test_api_and_db_integration(self, mock_save, mock_api):
        # API 응답 모킹
        mock_api.return_value = {&quot;choices&quot;: [{&quot;text&quot;: &quot;Sample response&quot;}]}

        # API 호출 및 DB 저장 함수 실행
        response = chatgpt_api_request(&quot;Sample prompt&quot;)
        save_to_database(response['choices'][0]['text'])

        # API 응답이 DB에 저장되었는지 검증
        mock_save.assert_called_once_with(&quot;Sample response&quot;)
</code></pre>
<p>위 테스트는 API와 데이터베이스 간의 상호작용을 검증한다. <code>chatgpt_api_request</code> 함수는 API 호출을 모킹하고, <code>save_to_database</code> 함수는 모킹된 API 응답을 데이터베이스에 저장하는 것을 검증한다. 여기서 중요한 점은 두 모듈이 함께 동작하는지를 확인하는 것이다.</p>
<h3 id="_12">통합 테스트에서 발생하는 문제 해결</h3>
<p>통합 테스트에서는 다양한 문제가 발생할 수 있으며, 이를 해결하기 위한 몇 가지 전략이 있다.</p>
<h4 id="_13">비결정적 테스트</h4>
<p>통합 테스트 중 일부는 매번 다른 결과를 반환할 수 있는 비결정적(non-deterministic) 테스트가 될 수 있다. 예를 들어, API 응답이 항상 동일하지 않을 때가 있다. 이런 경우에는 테스트에서 예측 가능한 결과를 만들기 위해 다음과 같은 방법을 사용할 수 있다.</p>
<ul>
<li><strong>Mocking을 통해 예측 가능한 응답을 설정</strong>: API의 응답을 일정하게 설정하여 비결정적 요소를 제거할 수 있다.</li>
<li><strong>테스트 데이터 고정</strong>: 입력 데이터와 테스트 시나리오를 고정하여 예측 가능한 결과를 얻을 수 있도록 한다.</li>
</ul>
<h4 id="_14">테스트 환경 격리</h4>
<p>테스트 간에 환경이 서로 간섭하지 않도록 하는 것도 매우 중요하다. 특히 데이터베이스나 외부 시스템과의 상호작용을 테스트할 때는 테스트 환경이 격리되어야 한다. 이를 위해 다음과 같은 전략을 사용할 수 있다.</p>
<ul>
<li><strong>독립적인 테스트 데이터베이스 사용</strong>: 테스트 환경에서만 사용되는 별도의 데이터베이스를 설정하여, 실제 데이터를 오염시키지 않도록 해야 한다.</li>
<li><strong>테스트 데이터 초기화</strong>: 각 테스트가 시작되기 전에 데이터베이스나 캐시를 초기화하여, 테스트 간의 데이터 충돌을 방지한다.</li>
</ul>
<h4 id="_15">외부 시스템 의존성 최소화</h4>
<p>통합 테스트에서 외부 시스템(예: API, 데이터베이스)에 대한 의존성을 최소화하는 것이 중요하다. 외부 시스템이 불안정하거나 예측 불가능한 상태에서 테스트를 수행하면, 테스트가 불안정해질 수 있다. 이를 방지하기 위해 외부 시스템에 대한 의존성을 줄이는 방법이 필요하다.</p>
<ul>
<li><strong>모의 서버(Mock Server) 사용</strong>: 외부 API와 상호작용하는 대신, 테스트 환경에서 모의 서버를 실행하여 API 응답을 시뮬레이션할 수 있다.</li>
<li><strong>로컬 데이터베이스 사용</strong>: 외부 데이터베이스 대신 로컬 데이터베이스나 인메모리 데이터베이스를 사용하여 테스트의 성능을 향상시킬 수 있다.</li>
</ul>
<hr />
<p>유닛 테스트와 통합 테스트는 각각 다른 범위와 목적을 가지고 있지만, 모두 고품질의 코드를 유지하는 데 필수적이다. 유닛 테스트를 통해 개별 모듈의 동작을 검증하고, 통합 테스트를 통해 모듈 간의 상호작용이 올바르게 이루어지는지를 확인해야 한다. 외부 API를 사용하는 애플리케이션에서는 Mocking을 통해 효율적인 테스트를 작성하고, 실제 API와 통합된 테스트 환경에서 모든 시스템이 예상대로 동작하는지를 확인하는 것이 중요하다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1002/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1002/" class="btn btn-xs btn-link">
        테스트 자동화 및 CI 파이프라인 구축
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_09/0904/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_09/0904/" class="btn btn-xs btn-link">
        모니터링 및 운영 자동화
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>