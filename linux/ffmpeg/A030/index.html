<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/linux/ffmpeg/A030/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>스트리밍 설정 - 실험 도서관</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <link href="../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "RTMP \ud504\ub85c\ud1a0\ucf5c \uac1c\uc694", url: "#_top", children: [
          ]},
          {title: "FFmpeg\ub85c RTMP \uc2a4\ud2b8\ub9ac\ubc0d \uc124\uc815", url: "#ffmpeg-rtmp", children: [
          ]},
          {title: "HTTP \uc2a4\ud2b8\ub9ac\ubc0d \uc124\uc815", url: "#http", children: [
          ]},
          {title: "\ube44\ud2b8\ub808\uc774\ud2b8 \uc870\uc815", url: "#_1", children: [
          ]},
          {title: "\uc2a4\ud2b8\ub9ac\ubc0d\uc758 \ubc84\ud37c \uc124\uc815", url: "#_2", children: [
          ]},
          {title: "\ub77c\uc774\ube0c \uc2a4\ud2b8\ub9ac\ubc0d \ubcc0\ud658", url: "#_3", children: [
              {title: "\ube44\ub514\uc624 \ubc0f \uc624\ub514\uc624 \ucf54\ub371 \uc120\ud0dd", url: "#_4" },
              {title: "\uc2e4\uc2dc\uac04 \uc778\ucf54\ub529\uacfc \ud2b8\ub79c\uc2a4\ucf54\ub529", url: "#_5" },
          ]},
          {title: "RTMP/HTTP \uc2a4\ud2b8\ub9ac\ubc0d \uc124\uc815", url: "#rtmphttp", children: [
              {title: "HLS \uc2a4\ud2b8\ub9ac\ubc0d \uc124\uc815", url: "#hls" },
          ]},
          {title: "\ub2e4\uc911 \ube44\ud2b8\ub808\uc774\ud2b8 \uc2a4\ud2b8\ub9ac\ubc0d", url: "#_6", children: [
          ]},
          {title: "DASH \uc2a4\ud2b8\ub9ac\ubc0d \uc124\uc815", url: "#dash", children: [
              {title: "DASH \ub2e4\uc911 \ube44\ud2b8\ub808\uc774\ud2b8 \uc2a4\ud2b8\ub9ac\ubc0d \uc124\uc815", url: "#dash_1" },
          ]},
          {title: "\uc2a4\ud2b8\ub9ac\ubc0d \uc2dc \uc9c0\uc5f0 \uc2dc\uac04(Latency) \ucd5c\uc801\ud654", url: "#latency", children: [
              {title: "\ube44\ub514\uc624 \uc778\ucf54\ub529 \uc9c0\uc5f0 \uc2dc\uac04 \ucd5c\uc801\ud654", url: "#_7" },
              {title: "\ubc84\ud37c \ud06c\uae30 \uc904\uc774\uae30", url: "#_8" },
              {title: "\uc624\ub514\uc624 \uc778\ucf54\ub529 \uc9c0\uc5f0 \uc2dc\uac04 \ucd5c\uc801\ud654", url: "#_9" },
          ]},
          {title: "\uc2a4\ud2b8\ub9ac\ubc0d\uc5d0\uc11c \ube44\ub514\uc624 \ud574\uc0c1\ub3c4 \uc870\uc815", url: "#_10", children: [
          ]},
          {title: "FFmpeg\ub97c \uc0ac\uc6a9\ud55c \uc2a4\ud2b8\ub9ac\ubc0d \uc2dc \uc8fc\uc758\uc0ac\ud56d", url: "#ffmpeg", children: [
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../A031/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../A031/" class="btn btn-xs btn-link">
        라이브 스트리밍 변환
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../A029/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../A029/" class="btn btn-xs btn-link">
        메타데이터 관리
      </a>
    </div>
    
  </div>

    

    <h2 id="rtmp">RTMP 프로토콜 개요</h2>
<p>RTMP(Real-Time Messaging Protocol)는 주로 오디오, 비디오, 데이터 스트리밍을 위한 프로토콜이다. FFmpeg에서 RTMP를 사용하여 라이브 스트리밍을 설정할 수 있다. RTMP는 Adobe가 만든 프로토콜로, 주로 Flash Media 서버에 사용되었으며, 현재도 많은 플랫폼에서 실시간 방송을 송출하는 데 쓰이다.</p>
<h2 id="ffmpeg-rtmp">FFmpeg로 RTMP 스트리밍 설정</h2>
<p>FFmpeg로 RTMP 스트리밍을 설정하려면, 입력 소스를 RTMP 서버로 전송하는 명령어를 사용한다. 기본적인 명령어 구조는 다음과 같다:</p>
<pre><code class="language-bash">ffmpeg -re -i input_file -c:v libx264 -b:v 2M -c:a aac -f flv rtmp://server/live/stream_key
</code></pre>
<p>여기서 주요 옵션들을 살펴보겠다:</p>
<ul>
<li><code>-re</code>: 실시간 전송을 위한 옵션으로, 입력 파일을 원본 파일 속도로 읽어온다.</li>
<li><code>-i input_file</code>: 입력 소스(비디오 파일, 웹캠, 데스크탑 등)를 지정한다.</li>
<li><code>-c:v libx264</code>: 비디오 코덱을 <code>libx264</code>로 설정한다.</li>
<li><code>-b:v 2M</code>: 비디오 비트레이트를 2Mbps로 설정한다.</li>
<li><code>-c:a aac</code>: 오디오 코덱을 <code>aac</code>로 설정한다.</li>
<li><code>-f flv</code>: 스트리밍 포맷을 <code>flv</code>로 설정한다.</li>
<li><code>rtmp://server/live/stream_key</code>: RTMP 서버 주소 및 스트림 키를 입력한다.</li>
</ul>
<h2 id="http">HTTP 스트리밍 설정</h2>
<p>FFmpeg를 사용하여 HTTP 라이브 스트리밍(HLS)을 설정할 수 있다. HLS는 주로 Apple에서 개발된 프로토콜로, 네트워크 상태에 따라 품질을 동적으로 조정할 수 있는 장점이 있다.</p>
<p>HLS를 위한 기본 명령어는 다음과 같다:</p>
<pre><code class="language-bash">ffmpeg -i input_file -codec: copy -start_number 0 -hls_time 10 -hls_list_size 0 -f hls output.m3u8
</code></pre>
<ul>
<li><code>-i input_file</code>: 입력 소스를 지정한다.</li>
<li><code>-codec: copy</code>: 입력 소스의 비디오 및 오디오 코덱을 그대로 복사한다.</li>
<li><code>-start_number 0</code>: 세그먼트 번호를 0부터 시작한다.</li>
<li><code>-hls_time 10</code>: HLS 세그먼트의 길이를 10초로 설정한다.</li>
<li><code>-hls_list_size 0</code>: 무제한 세그먼트를 허용한다.</li>
<li><code>-f hls</code>: 출력 파일 형식을 HLS로 설정한다.</li>
</ul>
<h2 id="_1">비트레이트 조정</h2>
<p>라이브 스트리밍에서 비트레이트는 중요한 요소이다. 비트레이트는 네트워크 대역폭에 맞춰 조정해야 하며, 비트레이트가 높으면 품질이 좋아지지만, 네트워크 상황이 좋지 않을 경우 끊김 현상이 발생할 수 있다.</p>
<p>비트레이트는 다음과 같이 FFmpeg에서 설정할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{R} = \frac{\text{Video Bitrate} + \text{Audio Bitrate}}{\text{Frame Rate}}
</div>
<script type="math/tex; mode=display">
\mathbf{R} = \frac{\text{Video Bitrate} + \text{Audio Bitrate}}{\text{Frame Rate}}
</script>
</div>
<p>여기서:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 총 데이터 전송 속도를 나타낸다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\text{Video Bitrate}</span><script type="math/tex">\text{Video Bitrate}</script></span>는 비디오의 비트레이트이다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\text{Audio Bitrate}</span><script type="math/tex">\text{Audio Bitrate}</script></span>는 오디오의 비트레이트이다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\text{Frame Rate}</span><script type="math/tex">\text{Frame Rate}</script></span>는 비디오의 초당 프레임 수이다.</li>
</ul>
<p>비트레이트 설정은 다음과 같은 명령어로 이루어진다:</p>
<pre><code class="language-bash">ffmpeg -i input_file -b:v 2M -b:a 128k -f flv rtmp://server/live/stream_key
</code></pre>
<p>위에서 <code>-b:v 2M</code>은 비디오 비트레이트를 2Mbps로, <code>-b:a 128k</code>는 오디오 비트레이트를 128kbps로 설정하는 것이다.</p>
<h2 id="_2">스트리밍의 버퍼 설정</h2>
<p>네트워크 상황이 좋지 않을 때, 버퍼 설정을 통해 안정적인 스트리밍이 가능하도록 할 수 있다. FFmpeg에서 버퍼는 <code>-bufsize</code> 옵션을 통해 설정된다. 버퍼의 크기는 다음과 같이 계산할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{B} = \frac{\mathbf{R} \times T}{8}
</div>
<script type="math/tex; mode=display">
\mathbf{B} = \frac{\mathbf{R} \times T}{8}
</script>
</div>
<p>여기서:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 버퍼 크기(바이트)이다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 총 비트레이트이다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 버퍼링 시간(초)이다.</li>
</ul>
<p>FFmpeg 명령어에서 버퍼 크기를 설정하는 방법은 다음과 같다:</p>
<pre><code class="language-bash">ffmpeg -i input_file -b:v 2M -bufsize 4M -f flv rtmp://server/live/stream_key
</code></pre>
<p>위 명령어에서 <code>-bufsize 4M</code>은 4MB 버퍼를 설정하는 것이다.</p>
<h2 id="_3">라이브 스트리밍 변환</h2>
<p>FFmpeg는 기존의 비디오 파일을 실시간으로 변환하여 라이브 스트리밍에 사용할 수 있다. 이를 위해서 <code>-re</code> 옵션을 사용하여 입력 소스를 원본 파일 속도로 읽는 것이 중요하다. 또한, 스트리밍 포맷으로 변환하는 과정에서 인코딩과 트랜스코딩이 필요할 수 있다.</p>
<h3 id="_4">비디오 및 오디오 코덱 선택</h3>
<p>스트리밍 시, 네트워크 대역폭에 맞는 코덱을 선택하는 것이 중요하다. 다음과 같은 코덱들이 자주 사용된다:</p>
<ul>
<li><strong>비디오 코덱</strong>: H.264 (libx264), H.265 (libx265), VP8, VP9</li>
<li><strong>오디오 코덱</strong>: AAC, MP3, Opus</li>
</ul>
<p>비디오 및 오디오 코덱을 설정하는 명령어는 다음과 같다:</p>
<pre><code class="language-bash">ffmpeg -re -i input_file -c:v libx264 -c:a aac -b:v 2M -b:a 128k -f flv rtmp://server/live/stream_key
</code></pre>
<h3 id="_5">실시간 인코딩과 트랜스코딩</h3>
<p>실시간 스트리밍에서 인코딩 및 트랜스코딩 과정은 매우 중요한 역할을 한다. 인코딩은 압축된 형식으로 데이터를 변환하고, 트랜스코딩은 이미 인코딩된 파일을 다시 다른 형식으로 변환하는 과정이다. FFmpeg에서 실시간 인코딩 및 트랜스코딩을 수행하려면 다음과 같은 명령어를 사용한다:</p>
<pre><code class="language-bash">ffmpeg -re -i input_file -c:v libx264 -preset veryfast -crf 23 -c:a aac -b:a 128k -f flv rtmp://server/live/stream_key
</code></pre>
<p>위 명령어에서:</p>
<ul>
<li><code>-preset veryfast</code>: 인코딩 속도를 빠르게 설정한다. 이는 실시간 스트리밍에서 중요한 역할을 한다.</li>
<li><code>-crf 23</code>: 비디오 품질을 설정하는 CRF(Constant Rate Factor) 값이다. 낮을수록 품질이 높아진다.</li>
</ul>
<h2 id="rtmphttp">RTMP/HTTP 스트리밍 설정</h2>
<p>RTMP 프로토콜을 사용하는 기본적인 라이브 스트리밍 설정 외에도 HTTP 프로토콜을 사용한 스트리밍 설정이 가능한다. HTTP 스트리밍은 주로 HLS(HTTP Live Streaming)와 DASH(Dynamic Adaptive Streaming over HTTP) 같은 프로토콜을 이용하여 네트워크 상태에 따라 스트리밍 품질을 동적으로 조정할 수 있다.</p>
<h3 id="hls">HLS 스트리밍 설정</h3>
<p>HLS 스트리밍은 Apple이 개발한 기술로, 주로 iOS 및 macOS 환경에서 널리 사용된다. 다음은 FFmpeg로 HLS 스트리밍을 설정하는 방법이다:</p>
<pre><code class="language-bash">ffmpeg -re -i input_file -codec: copy -start_number 0 -hls_time 10 -hls_list_size 0 -f hls output.m3u8
</code></pre>
<ul>
<li><code>-hls_time 10</code>: HLS 세그먼트 파일의 길이를 10초로 설정한다.</li>
<li><code>-hls_list_size 0</code>: HLS 목록에 포함되는 세그먼트의 개수를 무제한으로 설정한다.</li>
<li><code>output.m3u8</code>: HLS 스트리밍의 출력 파일 이름이다. 이 파일은 여러 세그먼트 파일을 참조하는 목록 파일이다.</li>
</ul>
<h2 id="_6">다중 비트레이트 스트리밍</h2>
<p>네트워크 상태에 따라 비트레이트를 동적으로 조정하기 위해 다중 비트레이트 스트리밍을 사용할 수 있다. 이는 여러 해상도와 비트레이트로 비디오를 동시에 인코딩하여 클라이언트가 네트워크 상태에 따라 적절한 품질을 선택할 수 있도록 하는 방법이다.</p>
<p>다중 비트레이트 스트리밍을 설정하는 방법은 다음과 같다:</p>
<pre><code class="language-bash">ffmpeg -re -i input_file -map 0:v -map 0:a -c:v libx264 -c:a aac \
    -b:v:0 2M -s:v:0 1920x1080 \
    -b:v:1 1M -s:v:1 1280x720 \
    -b:v:2 500k -s:v:2 640x360 \
    -f hls -var_stream_map &quot;v:0,a:0 v:1,a:1 v:2,a:2&quot; output.m3u8
</code></pre>
<p>여기서:</p>
<ul>
<li><code>-map 0:v</code>, <code>-map 0:a</code>: 입력 스트림에서 비디오와 오디오를 각각 매핑한다.</li>
<li><code>-b:v:0</code>, <code>-b:v:1</code>, <code>-b:v:2</code>: 각 해상도에 대한 비트레이트를 설정한다.</li>
<li><code>-s:v:0</code>, <code>-s:v:1</code>, <code>-s:v:2</code>: 각 해상도에 대한 크기를 설정한다.</li>
<li><code>-var_stream_map</code>: 각 해상도에 대해 변수를 정의한다.</li>
</ul>
<p>다중 비트레이트 스트리밍은 사용자의 네트워크 상태에 따라 동적으로 스트리밍 품질을 조정하는데 유용하며, 특히 대역폭이 제한된 모바일 환경에서 큰 장점을 갖는다.</p>
<h2 id="dash">DASH 스트리밍 설정</h2>
<p>DASH(Dynamic Adaptive Streaming over HTTP)는 HTTP를 통해 적응형 비디오 스트리밍을 제공하는 표준이다. 비트레이트에 따라 동적으로 비디오 품질을 조정하는 방식으로, 주로 MPEG-DASH 형식이 사용된다.</p>
<p>FFmpeg를 사용하여 DASH 스트리밍을 설정하는 기본 명령어는 다음과 같다:</p>
<pre><code class="language-bash">ffmpeg -i input_file -map 0 -map 0 -b:v:0 2M -b:v:1 1M -b:v:2 500k -c:v libx264 -c:a aac -f dash output.mpd
</code></pre>
<p>여기서:</p>
<ul>
<li><code>-map 0</code>: 입력 파일에서 모든 스트림을 매핑한다.</li>
<li><code>-b:v:0</code>, <code>-b:v:1</code>, <code>-b:v:2</code>: 각각의 비트레이트를 설정한다.</li>
<li><code>-c:v libx264</code>: 비디오 코덱을 H.264로 설정한다.</li>
<li><code>-c:a aac</code>: 오디오 코덱을 AAC로 설정한다.</li>
<li><code>-f dash</code>: DASH 포맷으로 출력한다.</li>
<li><code>output.mpd</code>: DASH 스트리밍의 메인 목록 파일이다.</li>
</ul>
<h3 id="dash_1">DASH 다중 비트레이트 스트리밍 설정</h3>
<p>DASH 스트리밍에서도 다중 비트레이트를 지원할 수 있다. 이를 통해 사용자는 자신의 네트워크 상태에 맞는 최적의 스트리밍 품질을 선택할 수 있다.</p>
<p>다중 비트레이트를 설정하는 명령어는 다음과 같다:</p>
<pre><code class="language-bash">ffmpeg -i input_file -map 0 -map 0 -b:v:0 2M -s:v:0 1920x1080 -b:v:1 1M -s:v:1 1280x720 -b:v:2 500k -s:v:2 640x360 -c:v libx264 -c:a aac -f dash output.mpd
</code></pre>
<p>여기서 각 해상도와 비트레이트가 달리 설정된 것을 확인할 수 있다. 이는 사용자의 대역폭 상태에 따라 적절한 스트리밍 품질을 선택할 수 있게 해준다.</p>
<h2 id="latency">스트리밍 시 지연 시간(Latency) 최적화</h2>
<p>라이브 스트리밍에서 지연 시간은 중요한 요소이다. 특히 RTMP와 같은 실시간 스트리밍에서는 지연 시간을 최소화하는 것이 중요하다. 이를 위해 FFmpeg에서 몇 가지 설정을 조정할 수 있다.</p>
<h3 id="_7">비디오 인코딩 지연 시간 최적화</h3>
<p>비디오 인코딩에서 지연 시간을 줄이기 위해 FFmpeg는 <code>-tune zerolatency</code> 옵션을 사용할 수 있다. 이 옵션은 낮은 지연 시간을 목표로 인코딩 설정을 최적화한다.</p>
<pre><code class="language-bash">ffmpeg -re -i input_file -c:v libx264 -preset ultrafast -tune zerolatency -c:a aac -f flv rtmp://server/live/stream_key
</code></pre>
<ul>
<li><code>-preset ultrafast</code>: 인코딩 속도를 최대로 올려 지연 시간을 줄이다.</li>
<li><code>-tune zerolatency</code>: 지연 시간을 최소화하도록 설정한다.</li>
</ul>
<h3 id="_8">버퍼 크기 줄이기</h3>
<p>FFmpeg에서 버퍼 크기를 줄이면 네트워크 지연 시간을 줄일 수 있다. 이때 <code>-max_delay</code> 옵션을 사용하여 버퍼 크기를 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -re -i input_file -c:v libx264 -b:v 2M -bufsize 1M -max_delay 500000 -f flv rtmp://server/live/stream_key
</code></pre>
<ul>
<li><code>-max_delay 500000</code>: 최대 지연 시간을 500ms로 설정한다.</li>
</ul>
<h3 id="_9">오디오 인코딩 지연 시간 최적화</h3>
<p>오디오 인코딩에서도 지연 시간을 줄이기 위해 FFmpeg는 <code>-async</code> 옵션을 사용할 수 있다. 이 옵션은 비디오와 오디오 간의 동기화를 유지하면서 지연 시간을 줄이는 데 사용된다.</p>
<pre><code class="language-bash">ffmpeg -re -i input_file -c:v libx264 -c:a aac -async 1 -f flv rtmp://server/live/stream_key
</code></pre>
<ul>
<li><code>-async 1</code>: 오디오와 비디오의 동기화를 맞추면서 지연 시간을 줄이다.</li>
</ul>
<h2 id="_10">스트리밍에서 비디오 해상도 조정</h2>
<p>FFmpeg를 사용하여 스트리밍할 때, 네트워크 상태에 맞는 적절한 해상도로 비디오를 스트리밍할 수 있다. 해상도는 다음과 같은 명령어를 통해 조정할 수 있다:</p>
<pre><code class="language-bash">ffmpeg -re -i input_file -s 1280x720 -c:v libx264 -c:a aac -f flv rtmp://server/live/stream_key
</code></pre>
<p>여기서 <code>-s 1280x720</code> 옵션은 출력 비디오의 해상도를 1280x720으로 설정한다. FFmpeg에서는 다양한 해상도로 비디오를 스트리밍할 수 있으며, 다음과 같은 해상도들이 자주 사용된다:</p>
<ul>
<li>4K: <code>3840x2160</code></li>
<li>Full HD: <code>1920x1080</code></li>
<li>HD: <code>1280x720</code></li>
<li>SD: <code>640x480</code></li>
</ul>
<h2 id="ffmpeg">FFmpeg를 사용한 스트리밍 시 주의사항</h2>
<p>스트리밍 시에는 네트워크 상태에 따른 비트레이트와 해상도 조정이 매우 중요하다. 또한, 라이브 스트리밍의 특성상 지연 시간을 최소화하는 것이 중요하다. 이를 위해 FFmpeg에서 제공하는 다양한 옵션을 적절히 사용하여 스트리밍 성능을 최적화할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../A031/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../A031/" class="btn btn-xs btn-link">
        라이브 스트리밍 변환
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../A029/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../A029/" class="btn btn-xs btn-link">
        메타데이터 관리
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>