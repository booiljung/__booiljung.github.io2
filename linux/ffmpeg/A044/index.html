<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/linux/ffmpeg/A044/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>다중 코덱 사용 - 실험 도서관</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <link href="../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ub2e4\uc911 \ucf54\ub371\uc758 \uc815\uc758", url: "#_top", children: [
          ]},
          {title: "\uae30\ubcf8 \uba85\ub839\uc5b4 \uad6c\uc870", url: "#_2", children: [
          ]},
          {title: "\ube44\ub514\uc624 \ucf54\ub371\uacfc \uc624\ub514\uc624 \ucf54\ub371\uc758 \ucc28\uc774\uc810", url: "#_3", children: [
              {title: "\ube44\ub514\uc624 \ucf54\ub371", url: "#_4" },
              {title: "\uc624\ub514\uc624 \ucf54\ub371", url: "#_5" },
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371 \uc124\uc815 \uc608\uc2dc", url: "#_6", children: [
          ]},
          {title: "\uc2a4\ud2b8\ub9bc\ubcc4 \ucf54\ub371 \uc124\uc815", url: "#_7", children: [
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d", url: "#_8", children: [
          ]},
          {title: "\ube44\ub514\uc624 \ubc0f \uc624\ub514\uc624 \ucf54\ub371\uc758 \ubcd1\ub82c \ucc98\ub9ac", url: "#_9", children: [
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371\uacfc \ubcd1\ub82c \ucc98\ub9ac\uc758 \uc131\ub2a5 \ucd5c\uc801\ud654", url: "#_10", children: [
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371\uc758 \uc7a5\ub2e8\uc810", url: "#_11", children: [
          ]},
          {title: "\ud558\ub4dc\uc6e8\uc5b4 \uac00\uc18d\uacfc \ub2e4\uc911 \ucf54\ub371 \uc0ac\uc6a9", url: "#_12", children: [
              {title: "\ud558\ub4dc\uc6e8\uc5b4 \uac00\uc18d \ud65c\uc131\ud654", url: "#_13" },
              {title: "\ucf54\ub371\uacfc \ud558\ub4dc\uc6e8\uc5b4 \uac00\uc18d\uc758 \uc870\ud569", url: "#_14" },
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371\uacfc \ud30c\uc77c \ud3ec\ub9f7\uc758 \uc0c1\ud638\uc791\uc6a9", url: "#_15", children: [
              {title: "\ud30c\uc77c \ud3ec\ub9f7\uacfc \ucf54\ub371 \ub9e4\ud551", url: "#_16" },
          ]},
          {title: "\uc218\ud559\uc801 \ubaa8\ub378\ub9c1: \ucf54\ub371 \ubcc0\ud658 \ud6a8\uc728\uc131", url: "#_17", children: [
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371\uacfc \ub3d9\uae30\ud654 \ubb38\uc81c", url: "#_18", children: [
              {title: "\ub3d9\uae30\ud654 \ubb38\uc81c \ud574\uacb0", url: "#_19" },
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371 \uc0ac\uc6a9 \uc2dc \ud504\ub808\uc784 \ub808\uc774\ud2b8\uc640 \ube44\ud2b8\ub808\uc774\ud2b8", url: "#_20", children: [
              {title: "\ud504\ub808\uc784 \ub808\uc774\ud2b8 \uc870\uc815", url: "#_21" },
              {title: "\ube44\ud2b8\ub808\uc774\ud2b8 \uc870\uc815", url: "#_22" },
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371\uacfc \ud3ec\ub9f7 \uac04 \ud638\ud658\uc131", url: "#_23", children: [
              {title: "\ucf54\ub371\uacfc \ud3ec\ub9f7 \ud638\ud658\uc131 \ud45c", url: "#_24" },
          ]},
          {title: "\uc218\ud559\uc801 \ubaa8\ub378\ub9c1: \ube44\ud2b8\ub808\uc774\ud2b8\uc640 \ud30c\uc77c \ud06c\uae30", url: "#_25", children: [
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371 \uc0ac\uc6a9 \uc2dc \ud574\uc0c1\ub3c4 \uc870\uc815", url: "#_26", children: [
              {title: "\ud574\uc0c1\ub3c4 \ubcc0\uacbd \uba85\ub839\uc5b4", url: "#_27" },
              {title: "\ub3d9\uc801 \ud574\uc0c1\ub3c4 \uc870\uc815", url: "#_28" },
              {title: "\uc218\ud559\uc801 \ud574\uc0c1\ub3c4 \ubcc0\ud658 \ubaa8\ub378", url: "#_29" },
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371\uacfc \ud544\ud130 \uc801\uc6a9", url: "#_30", children: [
              {title: "\ube44\ub514\uc624 \ud544\ud130 \uc801\uc6a9", url: "#_31" },
              {title: "\uc624\ub514\uc624 \ud544\ud130 \uc801\uc6a9", url: "#_32" },
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371\uacfc \ud544\ud130 \uc801\uc6a9\uc758 \uc218\ud559\uc801 \ud574\uc11d", url: "#_33", children: [
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371 \uc0ac\uc6a9 \uc2dc \uc790\ub9c9 \ucc98\ub9ac", url: "#_34", children: [
              {title: "\uc790\ub9c9 \ucd94\uac00", url: "#_35" },
              {title: "\uc790\ub9c9 \uc778\ucf54\ub529", url: "#_36" },
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371 \uc0ac\uc6a9 \uc2dc \uc790\ub9c9 \ucc98\ub9ac\uc758 \uc218\ud559\uc801 \ud574\uc11d", url: "#_37", children: [
          ]},
          {title: "\uc5ec\ub7ec \uc785\ub825 \ud30c\uc77c \ubcd1\ud569", url: "#_38", children: [
              {title: "\ud30c\uc77c \ubcd1\ud569 \uba85\ub839\uc5b4", url: "#_39" },
              {title: "\uc11c\ub85c \ub2e4\ub978 \ucf54\ub371 \ubcd1\ud569", url: "#_40" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \ubcd1\ud569\ub41c \ud30c\uc77c\uc758 \uc2dc\uac04 \ucd95 \ubcc0\ud658", url: "#_41", children: [
          ]},
          {title: "\ud30c\uc77c \ubd84\ud560", url: "#_42", children: [
              {title: "\uc2dc\uac04 \ub2e8\uc704 \ud30c\uc77c \ubd84\ud560", url: "#_43" },
              {title: "\ud504\ub808\uc784 \ub2e8\uc704 \ud30c\uc77c \ubd84\ud560", url: "#_44" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \uc2dc\uac04 \ub2e8\uc704 \ubd84\ud560", url: "#_45", children: [
          ]},
          {title: "\ud30c\uc77c \uc790\ub974\uae30 \ubc0f \uae38\uc774 \uc870\uc815", url: "#_46", children: [
              {title: "\ud30c\uc77c \uae38\uc774 \uc870\uc815", url: "#_47" },
              {title: "\ud2b9\uc815 \uad6c\uac04 \ucd94\ucd9c", url: "#_48" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \ud2b9\uc815 \uad6c\uac04\uc758 \ucd94\ucd9c", url: "#_49", children: [
          ]},
          {title: "\ube44\ub514\uc624\uc5d0\uc11c \uc624\ub514\uc624 \ucd94\ucd9c", url: "#_50", children: [
              {title: "\uc624\ub514\uc624 \ucd94\ucd9c \uba85\ub839\uc5b4", url: "#_51" },
              {title: "\uc624\ub514\uc624 \ud3ec\ub9f7 \ubcc0\ud658\uacfc \ud568\uaed8 \ucd94\ucd9c", url: "#_52" },
          ]},
          {title: "\uc624\ub514\uc624\uc5d0\uc11c \ube44\ub514\uc624 \ucd94\ucd9c", url: "#_53", children: [
              {title: "\ube44\ub514\uc624 \ucd94\ucd9c \uba85\ub839\uc5b4", url: "#_54" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \uc624\ub514\uc624\uc640 \ube44\ub514\uc624\uc758 \ubd84\ub9ac", url: "#_55", children: [
          ]},
          {title: "\ud2b9\uc815 \uc2dc\uac04\ub300 \ube44\ub514\uc624 \ucd94\ucd9c", url: "#_56", children: [
          ]},
          {title: "\ud2b9\uc815 \uc2dc\uac04\ub300 \uc624\ub514\uc624 \ucd94\ucd9c", url: "#_57", children: [
          ]},
          {title: "\ube44\ub514\uc624 \uc790\ub974\uae30 \ubc0f \ubcd1\ud569", url: "#_58", children: [
              {title: "\ube44\ub514\uc624 \uc790\ub974\uae30", url: "#_59" },
              {title: "\uc790\ub978 \ube44\ub514\uc624 \ubcd1\ud569", url: "#_60" },
          ]},
          {title: "\uc624\ub514\uc624 \uc790\ub974\uae30 \ubc0f \ubcd1\ud569", url: "#_61", children: [
              {title: "\uc624\ub514\uc624 \uc790\ub974\uae30", url: "#_62" },
              {title: "\uc790\ub978 \uc624\ub514\uc624 \ubcd1\ud569", url: "#_63" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \uc624\ub514\uc624 \uc790\ub974\uae30 \ubc0f \ubcd1\ud569", url: "#_64", children: [
              {title: "\uc624\ub514\uc624 \uc790\ub974\uae30", url: "#_65" },
              {title: "\uc624\ub514\uc624 \ubcd1\ud569", url: "#_66" },
          ]},
          {title: "\ube44\ub514\uc624/\uc624\ub514\uc624 \ub3d9\uae30\ud654", url: "#_67", children: [
              {title: "\ub3d9\uae30\ud654 \ubb38\uc81c \ud574\uacb0", url: "#_68" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \ube44\ub514\uc624/\uc624\ub514\uc624 \ub3d9\uae30\ud654", url: "#_69", children: [
          ]},
          {title: "\uba54\ud0c0\ub370\uc774\ud130 \uad00\ub9ac", url: "#_70", children: [
              {title: "\uba54\ud0c0\ub370\uc774\ud130 \ucd94\uac00", url: "#_71" },
              {title: "\uba54\ud0c0\ub370\uc774\ud130 \uc81c\uac70", url: "#_72" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \uba54\ud0c0\ub370\uc774\ud130\uc640 \ud30c\uc77c \uc815\ubcf4", url: "#_73", children: [
          ]},
          {title: "\uc2a4\ud2b8\ub9ac\ubc0d \uc124\uc815", url: "#_74", children: [
              {title: "\uae30\ubcf8 \uc2a4\ud2b8\ub9ac\ubc0d \uc124\uc815", url: "#_75" },
          ]},
          {title: "RTMP/HTTP \uc2a4\ud2b8\ub9ac\ubc0d \uc124\uc815", url: "#rtmphttp", children: [
              {title: "RTMP \uc2a4\ud2b8\ub9ac\ubc0d", url: "#rtmp" },
              {title: "HTTP \uc2a4\ud2b8\ub9ac\ubc0d", url: "#http" },
          ]},
          {title: "\uc2a4\ud2b8\ub9ac\ubc0d \uc2dc \ube44\ud2b8\ub808\uc774\ud2b8 \ubc0f \ud504\ub808\uc784 \ub808\uc774\ud2b8 \uc124\uc815", url: "#_76", children: [
              {title: "\ube44\ud2b8\ub808\uc774\ud2b8 \uc124\uc815", url: "#_77" },
              {title: "\ud504\ub808\uc784 \ub808\uc774\ud2b8 \uc124\uc815", url: "#_78" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \uc2a4\ud2b8\ub9ac\ubc0d\uc758 \ub370\uc774\ud130 \uc804\uc1a1 \uc18d\ub3c4", url: "#_79", children: [
          ]},
          {title: "\ub2e4\uc911 \ud2b8\ub799 \uc9c0\uc6d0", url: "#_80", children: [
              {title: "\ub2e4\uc911 \ud2b8\ub799 \ud30c\uc77c \uc0dd\uc131", url: "#_81" },
              {title: "\uc5ec\ub7ec \uc790\ub9c9 \ud2b8\ub799 \ucd94\uac00", url: "#_82" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \ub2e4\uc911 \ud2b8\ub799\uc758 \uc2a4\ud2b8\ub9bc \ucc98\ub9ac", url: "#_83", children: [
          ]},
          {title: "\ube44\ub514\uc624 \uc18d\ub3c4 \uc870\uc815", url: "#_84", children: [
              {title: "\ube44\ub514\uc624 \uc18d\ub3c4 \ubcc0\uacbd \uba85\ub839\uc5b4", url: "#_85" },
              {title: "\uc2ac\ub85c\uc6b0 \ubaa8\uc158", url: "#_86" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \ube44\ub514\uc624 \uc18d\ub3c4\uc640 PTS", url: "#pts", children: [
          ]},
          {title: "\uc624\ub514\uc624 \uc18d\ub3c4 \uc870\uc815", url: "#_87", children: [
              {title: "\uc624\ub514\uc624 \uc18d\ub3c4 \ubcc0\uacbd \uba85\ub839\uc5b4", url: "#_88" },
              {title: "\uc2ac\ub85c\uc6b0 \ubaa8\uc158 \uc624\ub514\uc624", url: "#_89" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \uc624\ub514\uc624 \uc18d\ub3c4\uc640 atempo", url: "#atempo", children: [
          ]},
          {title: "\ube44\ub514\uc624 \ud488\uc9c8 \ucd5c\uc801\ud654", url: "#_90", children: [
              {title: "\ube44\ud2b8\ub808\uc774\ud2b8 \uc124\uc815", url: "#_91" },
              {title: "\uc778\ucf54\ub529 \ubaa8\ub4dc \uc124\uc815", url: "#_92" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \ube44\ud2b8\ub808\uc774\ud2b8\uc640 \ud488\uc9c8", url: "#_93", children: [
          ]},
          {title: "\uc624\ub514\uc624 \ud488\uc9c8 \ucd5c\uc801\ud654", url: "#_94", children: [
              {title: "\uc624\ub514\uc624 \ube44\ud2b8\ub808\uc774\ud2b8 \uc124\uc815", url: "#_95" },
          ]},
          {title: "\ube44\ub514\uc624 \ud68c\uc804 \ubc0f \ub4a4\uc9d1\uae30", url: "#_96", children: [
              {title: "\ube44\ub514\uc624 \ud68c\uc804", url: "#_97" },
              {title: "\ube44\ub514\uc624 \ub4a4\uc9d1\uae30", url: "#_98" },
          ]},
          {title: "\ube44\ub514\uc624 \ud654\uba74 \ube44\uc728 \uc870\uc815", url: "#_99", children: [
              {title: "\ud654\uba74 \ube44\uc728 \uc870\uc815 \uba85\ub839\uc5b4", url: "#_100" },
              {title: "\ud574\uc0c1\ub3c4 \ubcc0\uacbd\uacfc \ud654\uba74 \ube44\uc728 \uc870\uc815", url: "#_101" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \ud654\uba74 \ube44\uc728 \uc870\uc815", url: "#_102", children: [
          ]},
          {title: "\uc624\ub514\uc624 \ucc44\ub110 \ubcc0\ud658", url: "#_103", children: [
              {title: "\ubaa8\ub178\uc5d0\uc11c \uc2a4\ud14c\ub808\uc624\ub85c \ubcc0\ud658", url: "#_104" },
              {title: "\uc2a4\ud14c\ub808\uc624\uc5d0\uc11c \ubaa8\ub178\ub85c \ubcc0\ud658", url: "#_105" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \uc624\ub514\uc624 \ucc44\ub110 \ubcc0\ud658", url: "#_106", children: [
              {title: "\ubaa8\ub178\uc5d0\uc11c \uc2a4\ud14c\ub808\uc624\ub85c \ubcc0\ud658", url: "#_107" },
              {title: "\uc2a4\ud14c\ub808\uc624\uc5d0\uc11c \ubaa8\ub178\ub85c \ubcc0\ud658", url: "#_108" },
          ]},
          {title: "\ubb34\uc190\uc2e4 \ubcc0\ud658", url: "#_109", children: [
              {title: "\ubb34\uc190\uc2e4 \ube44\ub514\uc624 \ubcc0\ud658", url: "#_110" },
              {title: "\ubb34\uc190\uc2e4 \uc624\ub514\uc624 \ubcc0\ud658", url: "#_111" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \ubb34\uc190\uc2e4 \ubcc0\ud658\uacfc \uc555\ucd95\ub960", url: "#_112", children: [
          ]},
          {title: "\ud558\ub4dc\uc6e8\uc5b4 \uac00\uc18d \uc124\uc815", url: "#_113", children: [
              {title: "\ud558\ub4dc\uc6e8\uc5b4 \uac00\uc18d \ud65c\uc131\ud654", url: "#_114" },
              {title: "\ud558\ub4dc\uc6e8\uc5b4 \uac00\uc18d \ucf54\ub371 \uc0ac\uc6a9", url: "#_115" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \ud558\ub4dc\uc6e8\uc5b4 \uac00\uc18d\uacfc \ucc98\ub9ac \uc2dc\uac04", url: "#_116", children: [
          ]},
          {title: "GPU \uc778\ucf54\ub529/\ub514\ucf54\ub529", url: "#gpu", children: [
              {title: "GPU \uc778\ucf54\ub529", url: "#gpu_1" },
              {title: "GPU \ub514\ucf54\ub529", url: "#gpu_2" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: GPU \uc778\ucf54\ub529 \ubc0f \ub514\ucf54\ub529 \uc131\ub2a5", url: "#gpu_3", children: [
          ]},
          {title: "\ub2e4\uc911 \ucf54\ub371 \uc0ac\uc6a9", url: "#_117", children: [
              {title: "\ube44\ub514\uc624 \ubc0f \uc624\ub514\uc624 \ucf54\ub371 \uc124\uc815", url: "#_118" },
              {title: "\uc11c\ub85c \ub2e4\ub978 \ucf54\ub371\uc744 \ubcd1\ud569", url: "#_119" },
          ]},
          {title: "\uc218\ud559\uc801 \ud574\uc11d: \ub2e4\uc911 \ucf54\ub371 \ucc98\ub9ac", url: "#_120", children: [
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../A045/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../A045/" class="btn btn-xs btn-link">
        다중 파일 변환
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../A043/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../A043/" class="btn btn-xs btn-link">
        GPU 인코딩/디코딩
      </a>
    </div>
    
  </div>

    

    <p>FFmpeg에서 다중 코덱을 사용하여 여러 비디오나 오디오 스트림을 처리하는 것은 고급 기능 중 하나로, 비디오 및 오디오 스트림의 변환, 인코딩, 디코딩에서 유연성을 제공한다. FFmpeg는 다양한 코덱을 지원하며, 여러 코덱을 조합해 파일을 처리할 수 있다.</p>
<h3 id="_1">다중 코덱의 정의</h3>
<p>다중 코덱이란 하나의 멀티미디어 파일 내에서 서로 다른 코덱을 사용하는 것을 의미한다. 비디오 스트림과 오디오 스트림 각각에 다른 코덱을 사용할 수 있으며, FFmpeg는 이러한 코덱을 처리하고 변환하는 데 유용하다.</p>
<p>예를 들어, 비디오 코덱은 <code>H.264</code>, 오디오 코덱은 <code>AAC</code>를 사용하면서 서로 다른 파일 포맷을 출력할 수 있다.</p>
<h3 id="_2">기본 명령어 구조</h3>
<p>다중 코덱을 설정하려면 FFmpeg 명령어에서 각각의 스트림에 대해 별도의 코덱을 명시해야 한다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -c:a aac output.mp4
</code></pre>
<p>위 명령어는 <code>input.mp4</code> 파일에서 비디오 스트림에는 <code>h264</code> 코덱을 사용하고, 오디오 스트림에는 <code>aac</code> 코덱을 적용하여 <code>output.mp4</code> 파일로 변환한다.</p>
<h3 id="_3">비디오 코덱과 오디오 코덱의 차이점</h3>
<p>FFmpeg는 비디오와 오디오 코덱을 개별적으로 제어할 수 있다. 예를 들어, 비디오 코덱 설정은 <code>-c:v</code> 플래그를 사용하고, 오디오 코덱은 <code>-c:a</code> 플래그를 사용한다. 각각의 스트림에 대해 원하는 코덱을 설정할 수 있다.</p>
<h4 id="_4">비디오 코덱</h4>
<p>비디오 코덱은 영상을 압축하고 복원하는 역할을 한다. 예를 들어, <code>H.264</code>, <code>VP9</code>, <code>HEVC(H.265)</code> 등이 자주 사용되는 비디오 코덱이다.</p>
<h4 id="_5">오디오 코덱</h4>
<p>오디오 코덱은 음성을 압축하고 복원하는 역할을 한다. 대표적으로 <code>AAC</code>, <code>MP3</code>, <code>Vorbis</code> 등이 있다.</p>
<h3 id="_6">다중 코덱 설정 예시</h3>
<p>다음은 서로 다른 코덱을 설정하는 예시이다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h265 -c:a mp3 output.mkv
</code></pre>
<p>위 명령어는 <code>input.mp4</code> 파일에서 비디오 스트림은 <code>H.265</code> 코덱을 사용하고, 오디오 스트림은 <code>MP3</code> 코덱을 사용하여 <code>output.mkv</code> 파일로 변환하는 과정이다.</p>
<h3 id="_7">스트림별 코덱 설정</h3>
<p>하나의 파일에 여러 비디오 및 오디오 스트림이 있는 경우, 각 스트림마다 서로 다른 코덱을 설정할 수 있다. 예를 들어, 두 개의 비디오 스트림과 하나의 오디오 스트림이 있는 파일에서 각 비디오 스트림에 다른 코덱을 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mkv -map 0:v:0 -c:v:0 h264 -map 0:v:1 -c:v:1 vp9 -map 0:a -c:a aac output.mkv
</code></pre>
<p>이 명령어는 <code>input.mkv</code> 파일에서 첫 번째 비디오 스트림은 <code>H.264</code>, 두 번째 비디오 스트림은 <code>VP9</code>, 오디오 스트림은 <code>AAC</code> 코덱을 사용하여 변환한다.</p>
<h3 id="_8">수학적 해석</h3>
<p>코덱 변환은 데이터 압축 및 해상도 변화 등의 수학적 연산을 포함하며, 이를 벡터 및 행렬로 나타낼 수 있다. </p>
<p>비디오 압축의 경우, 입력 비디오 스트림을 수학적으로 다음과 같이 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{V}_{\text{input}} = \mathbf{A}_{\text{input}} \cdot \mathbf{B}_{\text{input}}
</div>
<script type="math/tex; mode=display">
\mathbf{V}_{\text{input}} = \mathbf{A}_{\text{input}} \cdot \mathbf{B}_{\text{input}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}_{\text{input}}</span><script type="math/tex">\mathbf{V}_{\text{input}}</script></span>은 입력 비디오 프레임 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{\text{input}}</span><script type="math/tex">\mathbf{A}_{\text{input}}</script></span>은 영상 픽셀 정보 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}_{\text{input}}</span><script type="math/tex">\mathbf{B}_{\text{input}}</script></span>은 압축 인코딩 행렬을 의미한다.</p>
<p>코덱 변환 과정에서 출력 비디오 벡터는 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{V}_{\text{output}} = \mathbf{A}_{\text{output}} \cdot \mathbf{B}_{\text{output}}
</div>
<script type="math/tex; mode=display">
\mathbf{V}_{\text{output}} = \mathbf{A}_{\text{output}} \cdot \mathbf{B}_{\text{output}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}_{\text{output}}</span><script type="math/tex">\mathbf{V}_{\text{output}}</script></span>은 출력 비디오 프레임 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{\text{output}}</span><script type="math/tex">\mathbf{A}_{\text{output}}</script></span>은 변환된 영상 픽셀 정보 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}_{\text{output}}</span><script type="math/tex">\mathbf{B}_{\text{output}}</script></span>은 새로운 코덱 압축 행렬이다.</p>
<h3 id="_9">비디오 및 오디오 코덱의 병렬 처리</h3>
<p>FFmpeg는 다중 코덱을 사용할 때 각 스트림에 대해 병렬 처리를 수행할 수 있다. 즉, 각 스트림의 코덱은 독립적으로 작동하여 처리 속도를 높일 수 있다. 병렬 처리를 수식으로 표현하면, 각 스트림 <span class="arithmatex"><span class="MathJax_Preview">S_i</span><script type="math/tex">S_i</script></span>는 코덱 변환을 다음과 같이 수행한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_i = C(S_i)
</div>
<script type="math/tex; mode=display">
T_i = C(S_i)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_i</span><script type="math/tex">T_i</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>번째 스트림의 처리 시간,
- <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>는 코덱 변환 함수,
- <span class="arithmatex"><span class="MathJax_Preview">S_i</span><script type="math/tex">S_i</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>번째 스트림을 의미한다.</p>
<h3 id="_10">다중 코덱과 병렬 처리의 성능 최적화</h3>
<p>다중 코덱 사용 시 병렬 처리 성능을 최적화하는 방법에는 여러 가지가 있다. 그 중에서 CPU 스레드 수를 조정하는 방법이 있다. FFmpeg에서 <code>-threads</code> 옵션을 사용하여 처리할 스레드 수를 설정할 수 있다. </p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v libx264 -c:a aac -threads 4 output.mp4
</code></pre>
<p>이 명령어는 4개의 스레드를 사용하여 비디오와 오디오 스트림을 각각 다른 코덱으로 처리하는 과정을 수행한다.</p>
<h3 id="_11">다중 코덱의 장단점</h3>
<p>다중 코덱을 사용하는 주요 장점 중 하나는 서로 다른 형식의 미디어를 하나의 파일로 결합할 수 있다는 것이다. 그러나 이 과정은 파일 크기를 크게 만들거나 처리 속도가 느려질 수 있으며, 이러한 점에서 하드웨어 가속 기능을 사용하는 것이 중요하다.</p>
<h3 id="_12">하드웨어 가속과 다중 코덱 사용</h3>
<p>FFmpeg는 하드웨어 가속을 지원하며, 특히 비디오 인코딩 및 디코딩 시 큰 성능 향상을 제공할 수 있다. 하드웨어 가속을 사용하면 CPU 대신 GPU에서 비디오 처리가 이루어지며, 이를 통해 다중 코덱을 사용할 때 성능 저하를 방지할 수 있다.</p>
<h4 id="_13">하드웨어 가속 활성화</h4>
<p>하드웨어 가속을 활성화하려면, <code>-hwaccel</code> 옵션을 사용하여 가속 기능을 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -hwaccel cuvid -i input.mp4 -c:v h264_nvenc -c:a aac output.mp4
</code></pre>
<p>위 명령어는 <code>cuvid</code> 하드웨어 가속을 활성화하고, <code>h264_nvenc</code> 코덱을 사용하여 비디오를 인코딩한다. 이 과정은 GPU에서 처리되며, CPU 부담을 줄여준다.</p>
<h4 id="_14">코덱과 하드웨어 가속의 조합</h4>
<p>다중 코덱을 사용할 때, 각 코덱이 하드웨어 가속을 지원하는지 확인해야 한다. 예를 들어, <code>h264_nvenc</code>는 NVIDIA의 하드웨어 인코더로, 비디오 인코딩 시 GPU를 사용할 수 있다. 하지만 모든 코덱이 하드웨어 가속을 지원하는 것은 아니기 때문에, 코덱 선택 시 이를 고려해야 한다.</p>
<p>하드웨어 가속을 사용하는 경우, 수식으로 하드웨어 가속 적용 전후의 처리 시간을 비교할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{CPU}} = f(C_{\text{CPU}}(S))
</div>
<script type="math/tex; mode=display">
T_{\text{CPU}} = f(C_{\text{CPU}}(S))
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{GPU}} = f(C_{\text{GPU}}(S))
</div>
<script type="math/tex; mode=display">
T_{\text{GPU}} = f(C_{\text{GPU}}(S))
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{CPU}}</span><script type="math/tex">T_{\text{CPU}}</script></span>는 CPU에서 처리할 때의 시간,
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{GPU}}</span><script type="math/tex">T_{\text{GPU}}</script></span>는 GPU에서 처리할 때의 시간,
- <span class="arithmatex"><span class="MathJax_Preview">C_{\text{CPU}}(S)</span><script type="math/tex">C_{\text{CPU}}(S)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">C_{\text{GPU}}(S)</span><script type="math/tex">C_{\text{GPU}}(S)</script></span>는 각각 CPU와 GPU에서 다중 코덱을 처리하는 함수이다.</p>
<p>보통 <span class="arithmatex"><span class="MathJax_Preview">T_{\text{GPU}} &lt; T_{\text{CPU}}</span><script type="math/tex">T_{\text{GPU}} < T_{\text{CPU}}</script></span>가 성립하며, 하드웨어 가속을 통해 처리 시간이 단축된다.</p>
<h3 id="_15">다중 코덱과 파일 포맷의 상호작용</h3>
<p>다중 코덱을 사용할 때, 파일 포맷에 따른 제한 사항을 고려해야 한다. 예를 들어, <code>MP4</code> 파일 포맷은 특정 코덱만을 지원하며, <code>MKV</code> 파일 포맷은 더 다양한 코덱을 지원한다. FFmpeg에서 다중 코덱을 사용할 때, 출력 파일 포맷에 적합한 코덱을 선택해야 한다.</p>
<h4 id="_16">파일 포맷과 코덱 매핑</h4>
<p>다음은 파일 포맷과 그에 적합한 코덱을 매핑하는 표이다.</p>
<table>
<thead>
<tr>
<th>파일 포맷</th>
<th>비디오 코덱</th>
<th>오디오 코덱</th>
<th>지원 코덱</th>
</tr>
</thead>
<tbody>
<tr>
<td>MP4</td>
<td>H.264</td>
<td>AAC</td>
<td>제한적</td>
</tr>
<tr>
<td>MKV</td>
<td>VP9</td>
<td>Opus</td>
<td>광범위</td>
</tr>
<tr>
<td>AVI</td>
<td>MPEG-4</td>
<td>MP3</td>
<td>제한적</td>
</tr>
<tr>
<td>MOV</td>
<td>ProRes</td>
<td>PCM</td>
<td>제한적</td>
</tr>
</tbody>
</table>
<p>이러한 매핑을 참고하여 파일을 변환할 때 적합한 코덱을 선택하는 것이 중요하다.</p>
<pre><code class="language-bash">ffmpeg -i input.mkv -c:v vp9 -c:a opus output.mkv
</code></pre>
<p>위 명령어는 <code>MKV</code> 파일에서 <code>VP9</code> 비디오 코덱과 <code>Opus</code> 오디오 코덱을 사용하여 파일을 변환하는 예시이다.</p>
<h3 id="_17">수학적 모델링: 코덱 변환 효율성</h3>
<p>다중 코덱을 사용할 때, 각 코덱의 변환 효율성을 수학적으로 모델링할 수 있다. 코덱 변환에서 중요한 요소는 압축률과 품질이다. 일반적으로 압축률과 품질 간의 관계는 반비례한다. 이 관계를 수식으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
Q = \frac{C}{R}
</div>
<script type="math/tex; mode=display">
Q = \frac{C}{R}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>는 품질,
- <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>는 코덱의 압축률,
- <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>은 파일 크기를 의미한다.</p>
<p>압축률이 높을수록 파일 크기가 작아지지만, 품질은 떨어질 수 있다. 반면, 낮은 압축률을 사용할 경우 품질은 높아지지만 파일 크기가 커진다.</p>
<h3 id="_18">다중 코덱과 동기화 문제</h3>
<p>다중 코덱을 사용할 때 발생할 수 있는 문제 중 하나는 비디오와 오디오 스트림 간의 동기화 문제이다. 서로 다른 코덱을 사용하면 각각의 스트림 처리 속도가 달라질 수 있으며, 이로 인해 오디오와 비디오가 맞지 않는 현상이 발생할 수 있다. FFmpeg에서는 이러한 동기화 문제를 해결하기 위해 몇 가지 옵션을 제공한다.</p>
<h4 id="_19">동기화 문제 해결</h4>
<p>FFmpeg에서 <code>-async</code>와 <code>-vsync</code> 옵션을 사용하여 동기화 문제를 해결할 수 있다. </p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -c:a aac -async 1 output.mp4
</code></pre>
<p>위 명령어에서 <code>-async 1</code> 옵션은 오디오 스트림의 타이밍을 맞추는 데 사용되며, 동기화 문제를 해결하는 데 도움을 준다.</p>
<p>또한, <code>-vsync</code> 옵션은 비디오 스트림의 동기화를 제어할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -c:a aac -vsync 2 output.mp4
</code></pre>
<p><code>-vsync 2</code>는 비디오 프레임을 복제하거나 드롭하여 비디오 스트림의 타이밍을 조정하는 역할을 한다.</p>
<h3 id="_20">다중 코덱 사용 시 프레임 레이트와 비트레이트</h3>
<p>다중 코덱을 사용할 때는 각 스트림의 프레임 레이트와 비트레이트도 고려해야 한다. 각 코덱마다 최적의 프레임 레이트와 비트레이트가 다르므로 이를 적절히 설정해야 최적의 성능을 낼 수 있다.</p>
<h4 id="_21">프레임 레이트 조정</h4>
<p>FFmpeg에서 특정 프레임 레이트로 비디오를 설정하려면 <code>-r</code> 옵션을 사용한다. 예를 들어, 30fps로 비디오를 설정하려면 다음과 같이 할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -r 30 -c:a aac output.mp4
</code></pre>
<h4 id="_22">비트레이트 조정</h4>
<p>비트레이트는 <code>-b:v</code>와 <code>-b:a</code> 옵션으로 각각 비디오와 오디오 스트림에 대해 설정할 수 있다. 비디오의 경우 <code>-b:v</code> 옵션으로 비트레이트를 설정할 수 있으며, 오디오의 경우는 <code>-b:a</code> 옵션을 사용한다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -b:v 1M -c:a aac -b:a 128k output.mp4
</code></pre>
<p>위 명령어는 비디오의 비트레이트를 1Mbps, 오디오의 비트레이트를 128kbps로 설정하여 변환하는 예시이다.</p>
<h3 id="_23">다중 코덱과 포맷 간 호환성</h3>
<p>서로 다른 코덱을 사용하여 파일을 변환할 때, 출력 포맷과 코덱 간의 호환성도 중요하다. 예를 들어, 특정 파일 포맷은 일부 코덱을 지원하지 않으므로 변환 과정에서 오류가 발생할 수 있다. 이러한 문제를 피하려면 각 코덱이 지원하는 포맷을 확인해야 한다.</p>
<h4 id="_24">코덱과 포맷 호환성 표</h4>
<p>다음은 자주 사용하는 코덱과 파일 포맷의 호환성에 대한 표이다.</p>
<table>
<thead>
<tr>
<th>코덱</th>
<th>지원 파일 포맷</th>
</tr>
</thead>
<tbody>
<tr>
<td>H.264</td>
<td>MP4, MKV, AVI</td>
</tr>
<tr>
<td>H.265</td>
<td>MP4, MKV</td>
</tr>
<tr>
<td>VP9</td>
<td>MKV, WebM</td>
</tr>
<tr>
<td>AAC</td>
<td>MP4, MKV, AVI</td>
</tr>
<tr>
<td>MP3</td>
<td>MP4, MKV, AVI, MP3</td>
</tr>
</tbody>
</table>
<p>이 표는 FFmpeg에서 다중 코덱을 사용할 때 코덱과 파일 포맷 간의 호환성을 확인하는 데 유용하다.</p>
<h3 id="_25">수학적 모델링: 비트레이트와 파일 크기</h3>
<p>비트레이트와 파일 크기 간의 관계는 파일 변환의 중요한 요소이다. 비트레이트가 파일 크기에 미치는 영향을 수식으로 나타내면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S = \frac{B \times t}{8}
</div>
<script type="math/tex; mode=display">
S = \frac{B \times t}{8}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>는 파일 크기(바이트),
- <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>는 비트레이트(비트/초),
- <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>는 파일의 재생 시간(초),
- 8은 바이트 단위로 변환하기 위한 상수이다.</p>
<p>예를 들어, 1Mbps(1,000,000bps) 비트레이트를 사용하는 10초 길이의 비디오 파일 크기는 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S = \frac{1,000,000 \times 10}{8} = 1,250,000 \text{ 바이트} = 1.25 \text{ MB}
</div>
<script type="math/tex; mode=display">
S = \frac{1,000,000 \times 10}{8} = 1,250,000 \text{ 바이트} = 1.25 \text{ MB}
</script>
</div>
<p>이러한 수식을 통해 비트레이트와 파일 크기 간의 관계를 이해하고, 변환 시 필요한 비트레이트를 설정할 수 있다.</p>
<h3 id="_26">다중 코덱 사용 시 해상도 조정</h3>
<p>비디오의 해상도는 화면의 크기와 품질에 직접적인 영향을 미친다. 다중 코덱을 사용하는 경우에도 각 스트림의 해상도를 조정할 수 있다. FFmpeg에서 비디오 해상도를 변경하려면 <code>-vf</code> 옵션을 사용하여 비디오 필터를 적용할 수 있다.</p>
<h4 id="_27">해상도 변경 명령어</h4>
<p>해상도를 조정할 때, <code>scale</code> 필터를 사용하여 비디오의 가로 및 세로 해상도를 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -vf &quot;scale=1280:720&quot; -c:v h264 -c:a aac output.mp4
</code></pre>
<p>위 명령어는 입력 비디오를 <code>1280x720</code> 해상도로 변경하고, <code>H.264</code> 비디오 코덱과 <code>AAC</code> 오디오 코덱을 사용하여 변환한다.</p>
<h4 id="_28">동적 해상도 조정</h4>
<p>비디오의 해상도는 정적일 필요 없이, 다양한 요구에 맞게 동적으로 조정할 수 있다. 예를 들어, FFmpeg에서 동적 비율로 해상도를 조정할 수 있으며, 이는 수식을 이용하여 표현될 수 있다. 가로 비율을 고정하고 세로 비율을 원본 비율에 맞추고자 할 때는 다음과 같은 방법을 사용할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -vf &quot;scale=1280:-1&quot; -c:v h264 -c:a aac output.mp4
</code></pre>
<p>이 명령어에서 <code>-1</code>은 세로 해상도를 원본 비율에 맞게 자동으로 조정하는 옵션이다.</p>
<h4 id="_29">수학적 해상도 변환 모델</h4>
<p>해상도 변환은 영상의 픽셀을 조정하는 과정으로, 이를 수학적으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{R}_{\text{output}} = \mathbf{R}_{\text{input}} \cdot \mathbf{S}
</div>
<script type="math/tex; mode=display">
\mathbf{R}_{\text{output}} = \mathbf{R}_{\text{input}} \cdot \mathbf{S}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_{\text{input}}</span><script type="math/tex">\mathbf{R}_{\text{input}}</script></span>은 입력 해상도 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_{\text{output}}</span><script type="math/tex">\mathbf{R}_{\text{output}}</script></span>은 출력 해상도 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{S}</span><script type="math/tex">\mathbf{S}</script></span>는 해상도 변환 행렬을 의미한다.</p>
<p>만약 가로 해상도를 <span class="arithmatex"><span class="MathJax_Preview">W_{\text{output}}</span><script type="math/tex">W_{\text{output}}</script></span>로, 세로 해상도를 <span class="arithmatex"><span class="MathJax_Preview">H_{\text{output}}</span><script type="math/tex">H_{\text{output}}</script></span>로 변경하고자 한다면, 이는 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{R}_{\text{output}} = \left( \begin{matrix} W_{\text{output}} \\ H_{\text{output}} \end{matrix} \right)
</div>
<script type="math/tex; mode=display">
\mathbf{R}_{\text{output}} = \left( \begin{matrix} W_{\text{output}} \\ H_{\text{output}} \end{matrix} \right)
</script>
</div>
<p>FFmpeg에서 <code>scale</code> 필터를 이용한 해상도 변환은 위의 행렬 연산을 수행하여 새로운 해상도의 비디오를 출력한다.</p>
<h3 id="_30">다중 코덱과 필터 적용</h3>
<p>비디오 및 오디오 코덱을 사용할 때, 필터를 적용하여 영상이나 음성의 품질을 높일 수 있다. FFmpeg는 다양한 비디오 및 오디오 필터를 제공하며, 다중 코덱을 사용할 때도 각 스트림에 맞는 필터를 적용할 수 있다.</p>
<h4 id="_31">비디오 필터 적용</h4>
<p>비디오 필터는 영상의 밝기, 대조, 색상 등 다양한 요소를 조정하는 데 사용된다. 예를 들어, 비디오의 밝기를 조정하려면 <code>eq</code> 필터를 사용할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -vf &quot;eq=brightness=0.05&quot; -c:v h264 -c:a aac output.mp4
</code></pre>
<p>이 명령어는 비디오의 밝기를 0.05만큼 증가시키고, <code>H.264</code> 비디오 코덱과 <code>AAC</code> 오디오 코덱을 사용하여 변환한다.</p>
<h4 id="_32">오디오 필터 적용</h4>
<p>오디오 필터는 음향의 주파수, 볼륨 등을 조정하는 데 사용된다. 예를 들어, 볼륨을 조정하려면 <code>volume</code> 필터를 사용할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -af &quot;volume=1.5&quot; -c:v h264 -c:a aac output.mp4
</code></pre>
<p>위 명령어는 오디오의 볼륨을 1.5배로 증가시키고, <code>H.264</code> 비디오 코덱과 <code>AAC</code> 오디오 코덱을 사용하여 변환한다.</p>
<h3 id="_33">다중 코덱과 필터 적용의 수학적 해석</h3>
<p>비디오 필터를 적용하는 과정은 픽셀 값의 변화를 포함하며, 이는 수식으로 표현될 수 있다. 예를 들어, 밝기 필터를 적용하는 과정은 다음과 같이 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
P_{\text{output}} = P_{\text{input}} \times (1 + B)
</div>
<script type="math/tex; mode=display">
P_{\text{output}} = P_{\text{input}} \times (1 + B)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">P_{\text{input}}</span><script type="math/tex">P_{\text{input}}</script></span>은 입력 픽셀 값,
- <span class="arithmatex"><span class="MathJax_Preview">P_{\text{output}}</span><script type="math/tex">P_{\text{output}}</script></span>은 출력 픽셀 값,
- <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>는 밝기 증가 값이다.</p>
<p>오디오 필터의 경우, 볼륨 조정은 음향 신호의 크기를 조정하는 과정으로, 이를 수식으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
A_{\text{output}} = A_{\text{input}} \times V
</div>
<script type="math/tex; mode=display">
A_{\text{output}} = A_{\text{input}} \times V
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">A_{\text{input}}</span><script type="math/tex">A_{\text{input}}</script></span>은 입력 오디오 신호,
- <span class="arithmatex"><span class="MathJax_Preview">A_{\text{output}}</span><script type="math/tex">A_{\text{output}}</script></span>은 출력 오디오 신호,
- <span class="arithmatex"><span class="MathJax_Preview">V</span><script type="math/tex">V</script></span>는 볼륨 조정 계수이다.</p>
<h3 id="_34">다중 코덱 사용 시 자막 처리</h3>
<p>FFmpeg에서는 비디오에 자막을 추가하거나, 자막을 비디오에 인코딩하는 기능을 지원한다. 자막을 추가할 때는 외부 자막 파일을 비디오에 합치거나, 자막을 비디오에 직접 인코딩할 수 있다.</p>
<h4 id="_35">자막 추가</h4>
<p>외부 자막 파일을 비디오에 추가하려면 다음과 같은 명령어를 사용할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -i subtitles.srt -c:v h264 -c:a aac -c:s mov_text output.mp4
</code></pre>
<p>이 명령어는 <code>input.mp4</code> 파일에 <code>subtitles.srt</code> 자막 파일을 추가하여 <code>output.mp4</code> 파일을 생성한다. <code>-c:s mov_text</code>는 자막을 <code>MP4</code> 파일에서 지원하는 자막 코덱으로 변환하는 옵션이다.</p>
<h4 id="_36">자막 인코딩</h4>
<p>자막을 비디오에 직접 인코딩하려면, 자막을 영상의 일부분으로 합칠 수 있다. 이 경우 자막이 비디오에 고정되어, 재생 중에 자막을 끌 수 없다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -vf &quot;subtitles=subtitles.srt&quot; -c:v h264 -c:a aac output.mp4
</code></pre>
<p>위 명령어는 자막 파일을 비디오에 직접 인코딩하여 자막이 영상에 포함된 형태로 변환한다.</p>
<h3 id="_37">다중 코덱 사용 시 자막 처리의 수학적 해석</h3>
<p>자막 인코딩은 자막을 영상의 일부분으로 변환하는 과정으로, 자막의 좌표와 픽셀 값을 조정하는 연산이 필요하다. 자막 텍스트의 위치를 수식으로 나타내면 다음과 같이 표현할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{\text{subtitle}} = \mathbf{P}_{\text{video}} + \mathbf{T}_{\text{offset}}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{\text{subtitle}} = \mathbf{P}_{\text{video}} + \mathbf{T}_{\text{offset}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{subtitle}}</span><script type="math/tex">\mathbf{P}_{\text{subtitle}}</script></span>은 자막 텍스트의 위치 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{video}}</span><script type="math/tex">\mathbf{P}_{\text{video}}</script></span>는 비디오 화면에서의 기준 위치 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_{\text{offset}}</span><script type="math/tex">\mathbf{T}_{\text{offset}}</script></span>은 자막 위치에 대한 오프셋(좌표 이동) 벡터이다.</p>
<p>자막이 인코딩될 때 텍스트는 비디오 프레임에 결합되므로 픽셀 레벨에서 자막의 위치와 색상, 크기 등이 조정된다. 이러한 과정은 자막이 비디오의 특정 부분에 배치되는 방식으로 수식적으로도 나타낼 수 있다.</p>
<h3 id="_38">여러 입력 파일 병합</h3>
<p>다중 코덱 사용의 또 다른 중요한 기능 중 하나는 여러 입력 파일을 하나의 출력 파일로 병합하는 기능이다. FFmpeg에서는 <code>concat</code> 명령어를 통해 여러 파일을 병합할 수 있다.</p>
<h4 id="_39">파일 병합 명령어</h4>
<p>여러 비디오 파일을 병합하려면, 먼저 병합할 파일 목록을 텍스트 파일로 작성한 후, 해당 파일을 <code>concat</code> 명령어와 함께 사용해야 한다. 예를 들어, 다음과 같이 텍스트 파일을 준비한다.</p>
<pre><code>file 'video1.mp4'
file 'video2.mp4'
file 'video3.mp4'
</code></pre>
<p>이 텍스트 파일을 사용하여 비디오를 병합하는 명령어는 다음과 같다.</p>
<pre><code class="language-bash">ffmpeg -f concat -safe 0 -i filelist.txt -c copy output.mp4
</code></pre>
<p>위 명령어는 <code>filelist.txt</code>에 나열된 비디오 파일을 병합하여 <code>output.mp4</code> 파일로 변환한다. 이때 <code>-c copy</code>는 코덱을 재인코딩하지 않고 그대로 복사하는 옵션이다.</p>
<h4 id="_40">서로 다른 코덱 병합</h4>
<p>서로 다른 코덱을 사용하는 파일을 병합할 때는 각각의 스트림에 맞는 코덱을 지정하여야 한다. 예를 들어, 하나의 파일에서 비디오 코덱은 <code>H.264</code>, 다른 파일에서 비디오 코덱은 <code>HEVC(H.265)</code>일 때, 이를 병합하여 출력할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i video1.mp4 -i video2.mkv -filter_complex &quot;[0:v][1:v]concat=n=2:v=1:a=0[outv]&quot; -map &quot;[outv]&quot; -c:v h264 output.mp4
</code></pre>
<p>이 명령어는 <code>video1.mp4</code>와 <code>video2.mkv</code>의 비디오 스트림을 병합한 후, <code>H.264</code> 코덱으로 변환하여 <code>output.mp4</code>로 출력한다.</p>
<h3 id="_41">수학적 해석: 병합된 파일의 시간 축 변환</h3>
<p>여러 파일을 병합할 때, 시간 축 변환이 필수적이다. 각 파일의 재생 시간과 출력 파일의 재생 시간 간의 관계는 수식으로 표현될 수 있다.</p>
<p>병합된 파일의 총 재생 시간은 각 파일의 재생 시간을 더한 값이다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{total}} = \sum_{i=1}^{n} T_i
</div>
<script type="math/tex; mode=display">
T_{\text{total}} = \sum_{i=1}^{n} T_i
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{total}}</span><script type="math/tex">T_{\text{total}}</script></span>은 병합된 출력 파일의 총 재생 시간,
- <span class="arithmatex"><span class="MathJax_Preview">T_i</span><script type="math/tex">T_i</script></span>는 개별 파일 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>의 재생 시간이다.</p>
<p>FFmpeg에서 파일을 병합할 때, 이러한 시간 축 변환이 자동으로 이루어진다.</p>
<h3 id="_42">파일 분할</h3>
<p>다중 코덱을 사용할 때, 하나의 파일을 여러 부분으로 분할할 수 있다. FFmpeg에서는 특정 시간대에 따라 파일을 분할하거나, 프레임 단위로 분할할 수 있는 기능을 제공한다.</p>
<h4 id="_43">시간 단위 파일 분할</h4>
<p>특정 시간대에 따라 파일을 분할하려면 <code>-t</code> 옵션을 사용하여 분할할 파일의 길이를 지정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -t 00:01:00 -c copy output1.mp4
ffmpeg -i input.mp4 -ss 00:01:00 -t 00:01:00 -c copy output2.mp4
</code></pre>
<p>첫 번째 명령어는 <code>input.mp4</code> 파일의 처음 1분간의 영상을 <code>output1.mp4</code>로 출력하고, 두 번째 명령어는 1분 이후의 1분간 영상을 <code>output2.mp4</code>로 출력한다.</p>
<h4 id="_44">프레임 단위 파일 분할</h4>
<p>프레임 단위로 파일을 분할하려면 <code>-vf</code> 옵션을 사용하여 특정 프레임 범위를 지정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -vf &quot;select='between(n,10,50)'&quot; -c:v h264 -c:a aac output.mp4
</code></pre>
<p>위 명령어는 10번째 프레임부터 50번째 프레임까지의 비디오를 선택하여 <code>output.mp4</code>로 출력한다.</p>
<h3 id="_45">수학적 해석: 시간 단위 분할</h3>
<p>시간 단위로 파일을 분할할 때, 각 분할된 파일의 재생 시간은 전체 파일의 시간에서 일정 구간을 분리한 것으로 나타낼 수 있다.</p>
<p>각 분할된 파일의 재생 시간은 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{split}} = T_{\text{end}} - T_{\text{start}}
</div>
<script type="math/tex; mode=display">
T_{\text{split}} = T_{\text{end}} - T_{\text{start}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{split}}</span><script type="math/tex">T_{\text{split}}</script></span>은 분할된 파일의 재생 시간,
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{start}}</span><script type="math/tex">T_{\text{start}}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">T_{\text{end}}</span><script type="math/tex">T_{\text{end}}</script></span>는 각각 시작과 끝 시간을 의미한다.</p>
<p>FFmpeg에서는 이러한 시간 값을 자동으로 계산하여 파일을 분할한다.</p>
<h3 id="_46">파일 자르기 및 길이 조정</h3>
<p>다중 코덱을 사용할 때, 파일의 길이를 조정하거나 특정 구간을 잘라낼 수 있다. FFmpeg는 특정 시간대를 지정하여 비디오나 오디오 파일을 원하는 길이로 자르거나 특정 구간만을 추출하는 기능을 제공한다.</p>
<h4 id="_47">파일 길이 조정</h4>
<p>파일의 길이를 조정하기 위해 <code>-t</code> 옵션을 사용하여 출력 파일의 재생 시간을 설정할 수 있다. 이때 원본 파일에서 처음부터 원하는 길이까지의 구간만을 추출한다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -t 00:05:00 -c:v h264 -c:a aac output.mp4
</code></pre>
<p>위 명령어는 <code>input.mp4</code> 파일의 처음 5분간의 구간을 추출하여 <code>output.mp4</code> 파일로 저장한다.</p>
<h4 id="_48">특정 구간 추출</h4>
<p>파일의 특정 구간을 추출하려면, <code>-ss</code> 옵션을 사용하여 시작 시간을 지정하고 <code>-t</code> 옵션으로 추출할 구간의 길이를 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -ss 00:01:00 -t 00:02:00 -c:v h264 -c:a aac output.mp4
</code></pre>
<p>이 명령어는 <code>input.mp4</code> 파일의 1분 지점부터 2분간의 구간을 추출하여 <code>output.mp4</code> 파일로 저장한다.</p>
<h3 id="_49">수학적 해석: 특정 구간의 추출</h3>
<p>파일에서 특정 구간을 추출할 때, 시작 시간과 추출할 구간의 길이는 시간 차로 계산할 수 있다. </p>
<p>구간 추출에 대한 수식은 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{output}} = T_{\text{start}} + \Delta T
</div>
<script type="math/tex; mode=display">
T_{\text{output}} = T_{\text{start}} + \Delta T
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{output}}</span><script type="math/tex">T_{\text{output}}</script></span>은 출력 파일의 재생 시간,
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{start}}</span><script type="math/tex">T_{\text{start}}</script></span>는 추출할 구간의 시작 시간,
- <span class="arithmatex"><span class="MathJax_Preview">\Delta T</span><script type="math/tex">\Delta T</script></span>는 추출할 구간의 길이를 의미한다.</p>
<p>이 수식을 통해 FFmpeg는 지정된 구간을 추출하여 출력한다.</p>
<h3 id="_50">비디오에서 오디오 추출</h3>
<p>비디오 파일에서 오디오만 추출하는 것은 자주 사용되는 기능 중 하나이다. FFmpeg에서 오디오를 추출하려면 비디오 코덱을 제거하고 오디오만 유지할 수 있다.</p>
<h4 id="_51">오디오 추출 명령어</h4>
<p>비디오에서 오디오를 추출하려면 <code>-vn</code> 옵션을 사용하여 비디오 스트림을 무시하고, 오디오 코덱만 지정하면 된다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -vn -c:a copy output.mp3
</code></pre>
<p>위 명령어는 <code>input.mp4</code> 파일에서 비디오 스트림을 제거하고, 오디오만 추출하여 <code>output.mp3</code>로 저장한다.</p>
<h4 id="_52">오디오 포맷 변환과 함께 추출</h4>
<p>오디오를 추출하면서 동시에 포맷을 변환할 수도 있다. 예를 들어, <code>MP4</code> 파일에서 <code>AAC</code> 오디오를 <code>MP3</code>로 변환하려면 다음과 같이 할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -vn -c:a mp3 output.mp3
</code></pre>
<p>이 명령어는 비디오 파일에서 오디오를 추출하여 <code>MP3</code> 형식으로 변환한다.</p>
<h3 id="_53">오디오에서 비디오 추출</h3>
<p>오디오 파일에서 특정 이미지나 영상이 포함된 경우, FFmpeg를 사용해 비디오만 추출할 수 있다. 이는 비디오 코덱을 유지하고 오디오 스트림을 제거하는 방법으로 가능하다.</p>
<h4 id="_54">비디오 추출 명령어</h4>
<p>오디오에서 비디오만 추출하려면, <code>-an</code> 옵션을 사용하여 오디오 스트림을 무시하고 비디오 코덱을 유지하면 된다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -an -c:v copy output.mp4
</code></pre>
<p>이 명령어는 <code>input.mp4</code> 파일에서 오디오 스트림을 제거하고, 비디오만 추출하여 <code>output.mp4</code>로 저장한다.</p>
<h3 id="_55">수학적 해석: 오디오와 비디오의 분리</h3>
<p>비디오 파일은 보통 시간 축에 따라 비디오 스트림과 오디오 스트림이 동시에 존재한다. 이 두 스트림을 수학적으로 분리하면 다음과 같이 표현할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{S}_{\text{total}} = \mathbf{S}_{\text{video}} + \mathbf{S}_{\text{audio}}
</div>
<script type="math/tex; mode=display">
\mathbf{S}_{\text{total}} = \mathbf{S}_{\text{video}} + \mathbf{S}_{\text{audio}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{S}_{\text{total}}</span><script type="math/tex">\mathbf{S}_{\text{total}}</script></span>은 전체 스트림,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{S}_{\text{video}}</span><script type="math/tex">\mathbf{S}_{\text{video}}</script></span>는 비디오 스트림,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{S}_{\text{audio}}</span><script type="math/tex">\mathbf{S}_{\text{audio}}</script></span>는 오디오 스트림이다.</p>
<p>이 식에서 비디오나 오디오 스트림을 제거할 때, FFmpeg는 해당 스트림을 무시하고 나머지 스트림만 처리한다.</p>
<h3 id="_56">특정 시간대 비디오 추출</h3>
<p>특정 시간대의 비디오만 추출하려면 <code>-ss</code>와 <code>-t</code> 옵션을 사용하여 시작 시간과 추출할 길이를 설정할 수 있다. 비디오 추출 시 오디오 스트림도 함께 처리되며, 필요에 따라 비디오만 추출할 수도 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -ss 00:02:00 -t 00:01:00 -an -c:v copy output.mp4
</code></pre>
<p>이 명령어는 <code>input.mp4</code> 파일의 2분 지점부터 1분간의 비디오를 추출하며, 오디오 스트림은 포함하지 않는다.</p>
<h3 id="_57">특정 시간대 오디오 추출</h3>
<p>특정 시간대의 오디오만 추출하려면 비디오와 동일한 방식으로 <code>-ss</code>와 <code>-t</code> 옵션을 사용하여 구간을 지정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -ss 00:02:00 -t 00:01:00 -vn -c:a copy output.mp3
</code></pre>
<p>위 명령어는 <code>input.mp4</code> 파일의 2분 지점부터 1분간의 오디오만 추출하여 <code>output.mp3</code> 파일로 저장한다.</p>
<h3 id="_58">비디오 자르기 및 병합</h3>
<p>비디오를 자른 후 여러 비디오 파일을 병합하는 작업도 FFmpeg에서 자주 사용되는 기능이다. 앞서 설명한 <code>concat</code> 명령어와 <code>-t</code>, <code>-ss</code> 옵션을 조합하여 비디오를 자르고 병합할 수 있다.</p>
<h4 id="_59">비디오 자르기</h4>
<p>비디오를 자르려면 <code>-t</code>와 <code>-ss</code> 옵션을 함께 사용하여 원하는 구간을 선택한다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -ss 00:01:00 -t 00:01:00 -c:v copy -c:a copy output.mp4
</code></pre>
<p>이 명령어는 1분 지점부터 1분간의 비디오와 오디오를 추출하여 <code>output.mp4</code>로 저장한다.</p>
<h4 id="_60">자른 비디오 병합</h4>
<p>자른 비디오를 병합하려면 먼저 파일을 자른 후, 각각의 파일을 병합해야 한다.</p>
<pre><code class="language-bash">ffmpeg -i part1.mp4 -i part2.mp4 -filter_complex &quot;[0:v][1:v]concat=n=2:v=1:a=0[outv]&quot; -map &quot;[outv]&quot; -c:v h264 output.mp4
</code></pre>
<p>이 명령어는 <code>part1.mp4</code>와 <code>part2.mp4</code>를 병합하여 <code>output.mp4</code>로 출력한다.</p>
<h3 id="_61">오디오 자르기 및 병합</h3>
<p>오디오 파일도 비디오와 마찬가지로 특정 구간을 잘라내거나 여러 오디오 파일을 병합할 수 있다. FFmpeg에서 오디오 파일을 자르거나 병합하려면 비슷한 옵션을 사용한다.</p>
<h4 id="_62">오디오 자르기</h4>
<p>오디오 파일에서 특정 구간을 잘라내려면 <code>-ss</code>와 <code>-t</code> 옵션을 사용하여 구간을 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp3 -ss 00:01:00 -t 00:02:00 -c:a copy output.mp3
</code></pre>
<p>이 명령어는 <code>input.mp3</code> 파일의 1분 지점부터 2분간의 오디오 구간을 잘라 <code>output.mp3</code> 파일로 저장한다.</p>
<h4 id="_63">자른 오디오 병합</h4>
<p>여러 오디오 파일을 병합할 때는 <code>concat</code> 명령어를 사용할 수 있다. 오디오 병합은 비디오와 동일한 방식으로 처리되며, 먼저 파일 목록을 작성한 후 병합할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -f concat -safe 0 -i filelist.txt -c copy output.mp3
</code></pre>
<p>여기서 <code>filelist.txt</code>에는 병합할 오디오 파일 목록이 포함되어 있다.</p>
<pre><code>file 'part1.mp3'
file 'part2.mp3'
</code></pre>
<p>위 명령어는 <code>part1.mp3</code>와 <code>part2.mp3</code>를 병합하여 <code>output.mp3</code> 파일로 출력한다.</p>
<h3 id="_64">수학적 해석: 오디오 자르기 및 병합</h3>
<p>오디오 스트림도 시간 축에 따라 특정 구간을 잘라내거나 병합할 수 있으며, 이는 수학적으로 다음과 같이 표현된다.</p>
<h4 id="_65">오디오 자르기</h4>
<p>오디오 구간을 자를 때, 시간 축에서 시작 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{\text{start}}</span><script type="math/tex">T_{\text{start}}</script></span>와 구간 길이 <span class="arithmatex"><span class="MathJax_Preview">\Delta T</span><script type="math/tex">\Delta T</script></span>를 설정하여 해당 구간을 추출한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{output}} = T_{\text{start}} + \Delta T
</div>
<script type="math/tex; mode=display">
T_{\text{output}} = T_{\text{start}} + \Delta T
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{output}}</span><script type="math/tex">T_{\text{output}}</script></span>은 출력 오디오 구간의 재생 시간,
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{start}}</span><script type="math/tex">T_{\text{start}}</script></span>는 시작 시간,
- <span class="arithmatex"><span class="MathJax_Preview">\Delta T</span><script type="math/tex">\Delta T</script></span>는 구간의 길이이다.</p>
<h4 id="_66">오디오 병합</h4>
<p>오디오 병합의 경우, 두 개 이상의 오디오 스트림을 시간 축에서 이어 붙이는 방식으로 처리한다. 이는 수식으로 다음과 같이 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{total}} = \sum_{i=1}^{n} T_i
</div>
<script type="math/tex; mode=display">
T_{\text{total}} = \sum_{i=1}^{n} T_i
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{total}}</span><script type="math/tex">T_{\text{total}}</script></span>은 병합된 오디오 파일의 총 재생 시간,
- <span class="arithmatex"><span class="MathJax_Preview">T_i</span><script type="math/tex">T_i</script></span>는 각 오디오 파일의 재생 시간이다.</p>
<h3 id="_67">비디오/오디오 동기화</h3>
<p>비디오와 오디오 스트림이 정확히 동기화되지 않으면 재생 중에 화면과 소리가 맞지 않는 문제가 발생할 수 있다. FFmpeg에서는 이러한 동기화 문제를 해결하기 위한 다양한 옵션을 제공하며, <code>-async</code>와 <code>-vsync</code> 옵션을 사용하여 비디오와 오디오의 타이밍을 조정할 수 있다.</p>
<h4 id="_68">동기화 문제 해결</h4>
<p>비디오와 오디오의 동기화를 맞추려면 <code>-async</code> 옵션을 사용하여 오디오 스트림의 타이밍을 조정할 수 있다. </p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -c:a aac -async 1 output.mp4
</code></pre>
<p>이 명령어는 오디오 스트림을 비디오에 맞추어 동기화하여 출력한다.</p>
<p>또한, <code>-vsync</code> 옵션을 사용하여 비디오 프레임의 타이밍을 조정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -c:a aac -vsync 2 output.mp4
</code></pre>
<p>위 명령어는 비디오 프레임을 드롭하거나 복제하여 비디오와 오디오의 동기화를 맞춘다.</p>
<h3 id="_69">수학적 해석: 비디오/오디오 동기화</h3>
<p>비디오와 오디오의 동기화 문제는 시간 차이로 인해 발생하며, 이를 수학적으로 표현하면 다음과 같다.</p>
<p>비디오와 오디오 스트림 간의 시간 차이는 다음과 같이 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\Delta T = T_{\text{video}} - T_{\text{audio}}
</div>
<script type="math/tex; mode=display">
\Delta T = T_{\text{video}} - T_{\text{audio}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\Delta T</span><script type="math/tex">\Delta T</script></span>는 비디오와 오디오 간의 시간 차이,
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{video}}</span><script type="math/tex">T_{\text{video}}</script></span>는 비디오 스트림의 타이밍,
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{audio}}</span><script type="math/tex">T_{\text{audio}}</script></span>는 오디오 스트림의 타이밍이다.</p>
<p>FFmpeg에서는 이 시간 차이를 조정하여 동기화를 맞춘다.</p>
<h3 id="_70">메타데이터 관리</h3>
<p>FFmpeg는 비디오와 오디오 파일의 메타데이터를 수정하거나 제거하는 기능을 제공한다. 메타데이터는 파일에 대한 정보(예: 제목, 저자, 트랙 번호 등)를 포함하며, 이를 수정하여 파일의 속성을 변경할 수 있다.</p>
<h4 id="_71">메타데이터 추가</h4>
<p>파일에 메타데이터를 추가하려면 <code>-metadata</code> 옵션을 사용할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -metadata title=&quot;New Title&quot; -c:v copy -c:a copy output.mp4
</code></pre>
<p>위 명령어는 <code>input.mp4</code> 파일의 제목 메타데이터를 "New Title"로 변경하여 <code>output.mp4</code> 파일로 저장한다.</p>
<h4 id="_72">메타데이터 제거</h4>
<p>파일에서 메타데이터를 제거하려면 <code>-map_metadata</code> 옵션을 사용할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -map_metadata -1 -c:v copy -c:a copy output.mp4
</code></pre>
<p>이 명령어는 파일의 모든 메타데이터를 제거한 후, 비디오와 오디오 스트림을 그대로 복사하여 출력한다.</p>
<h3 id="_73">수학적 해석: 메타데이터와 파일 정보</h3>
<p>메타데이터는 파일의 스트림 정보와 별도로 저장된 데이터로, 이를 수학적으로는 파일 속성 정보로 나타낼 수 있다. 예를 들어, 파일의 메타데이터는 다음과 같이 벡터로 표현될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{M} = \left( \text{Title}, \text{Author}, \text{Year}, \text{Track Number}, \dots \right)
</div>
<script type="math/tex; mode=display">
\mathbf{M} = \left( \text{Title}, \text{Author}, \text{Year}, \text{Track Number}, \dots \right)
</script>
</div>
<p>이 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span>는 파일의 다양한 속성을 포함하며, FFmpeg에서 이를 수정하거나 제거할 수 있다.</p>
<h3 id="_74">스트리밍 설정</h3>
<p>FFmpeg는 비디오와 오디오 파일을 스트리밍하기 위한 다양한 설정을 제공하며, 이를 통해 라이브 스트리밍이나 HTTP 스트리밍을 구현할 수 있다. 스트리밍 설정은 파일 변환과는 다른 실시간 처리가 요구되기 때문에, 네트워크 설정과 코덱 선택이 매우 중요하다.</p>
<h4 id="_75">기본 스트리밍 설정</h4>
<p>라이브 스트리밍을 위해 FFmpeg에서 사용하는 기본 명령어는 <code>-f</code> 플래그를 사용하여 특정 프로토콜을 지정하고, 네트워크 스트림의 입력 또는 출력을 설정하는 방식이다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -f flv rtmp://example.com/live/stream_key
</code></pre>
<p>위 명령어는 <code>input.mp4</code> 파일을 <code>H.264</code> 코덱으로 인코딩한 후, <code>RTMP</code> 프로토콜을 사용하여 <code>example.com</code> 서버로 스트리밍한다.</p>
<h3 id="rtmphttp">RTMP/HTTP 스트리밍 설정</h3>
<p>RTMP(Real-Time Messaging Protocol)와 HTTP는 실시간 스트리밍에 자주 사용되는 프로토콜이다. 각각의 프로토콜에 맞는 스트리밍 설정을 해야 한다.</p>
<h4 id="rtmp">RTMP 스트리밍</h4>
<p>RTMP는 비디오를 실시간으로 스트리밍하기 위한 프로토콜로, 주로 방송 플랫폼에서 사용된다. FFmpeg에서 RTMP 스트리밍을 설정할 때는 출력 파일 대신 RTMP 서버의 URL을 지정한다.</p>
<pre><code class="language-bash">ffmpeg -re -i input.mp4 -c:v h264 -f flv rtmp://example.com/live/stream_key
</code></pre>
<p>이 명령어에서 <code>-re</code> 옵션은 입력 파일을 실시간으로 스트리밍하기 위해 사용되며, 입력 파일을 원래 속도로 읽어와 스트리밍한다.</p>
<h4 id="http">HTTP 스트리밍</h4>
<p>HTTP를 사용한 스트리밍은 일반적으로 HLS(HTTP Live Streaming) 방식으로 구현된다. FFmpeg에서는 <code>-f hls</code> 옵션을 사용하여 HLS 스트리밍을 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -c:a aac -f hls output.m3u8
</code></pre>
<p>이 명령어는 HLS 포맷을 사용하여 <code>output.m3u8</code> 파일을 생성하고, HTTP 서버에서 실시간 스트리밍할 수 있게 한다.</p>
<h3 id="_76">스트리밍 시 비트레이트 및 프레임 레이트 설정</h3>
<p>스트리밍 설정 시 비트레이트와 프레임 레이트는 매우 중요한 요소이다. 네트워크 대역폭에 맞게 비트레이트를 조정해야 하고, 프레임 레이트는 사용자 경험에 영향을 미칠 수 있다.</p>
<h4 id="_77">비트레이트 설정</h4>
<p>FFmpeg에서 비트레이트는 <code>-b:v</code> 옵션으로 설정할 수 있다. 스트리밍 시 네트워크 대역폭을 고려하여 적절한 비트레이트를 설정해야 한다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -b:v 1M -c:a aac -b:a 128k -f flv rtmp://example.com/live/stream_key
</code></pre>
<p>위 명령어는 비디오 스트림의 비트레이트를 1Mbps, 오디오 스트림의 비트레이트를 128kbps로 설정하여 RTMP 서버로 스트리밍한다.</p>
<h4 id="_78">프레임 레이트 설정</h4>
<p>프레임 레이트는 <code>-r</code> 옵션으로 설정할 수 있으며, 네트워크 대역폭에 맞추어 프레임 레이트를 낮추거나 높일 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -r 30 -c:a aac -f flv rtmp://example.com/live/stream_key
</code></pre>
<p>이 명령어는 비디오의 프레임 레이트를 30fps로 설정하여 스트리밍한다.</p>
<h3 id="_79">수학적 해석: 스트리밍의 데이터 전송 속도</h3>
<p>스트리밍 시 데이터 전송 속도는 네트워크 대역폭에 맞추어 조정되어야 한다. 데이터 전송 속도는 비트레이트와 프레임 레이트에 따라 결정된다. 비트레이트 <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>와 프레임 레이트 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>를 고려한 데이터 전송 속도는 다음과 같이 계산할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
D = B \times R
</div>
<script type="math/tex; mode=display">
D = B \times R
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">D</span><script type="math/tex">D</script></span>는 데이터 전송 속도(비트/초),
- <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>는 비디오 또는 오디오의 비트레이트(비트/프레임),
- <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>는 프레임 레이트(프레임/초)이다.</p>
<p>이 수식을 통해 네트워크 대역폭에 맞는 적절한 비트레이트와 프레임 레이트를 선택할 수 있다.</p>
<h3 id="_80">다중 트랙 지원</h3>
<p>FFmpeg에서는 비디오와 오디오뿐만 아니라 여러 트랙을 포함하는 파일을 처리할 수 있다. 다중 트랙을 지원하면 여러 오디오 트랙이나 자막 트랙을 포함한 비디오 파일을 생성하거나, 이러한 트랙을 병합할 수 있다.</p>
<h4 id="_81">다중 트랙 파일 생성</h4>
<p>다중 오디오 트랙을 가진 파일을 생성하려면, 각 오디오 트랙을 개별적으로 설정하여 입력해야 한다.</p>
<pre><code class="language-bash">ffmpeg -i input1.mp4 -i input2.mp3 -c:v copy -map 0:v -map 1:a -c:a aac -f mp4 output.mp4
</code></pre>
<p>이 명령어는 <code>input1.mp4</code>의 비디오 트랙과 <code>input2.mp3</code>의 오디오 트랙을 결합하여 <code>output.mp4</code> 파일을 생성한다. <code>-map</code> 옵션을 사용하여 각 스트림을 명시적으로 지정할 수 있다.</p>
<h4 id="_82">여러 자막 트랙 추가</h4>
<p>자막 트랙을 추가할 때도 비슷한 방법으로 여러 자막 트랙을 추가할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -i subtitles1.srt -i subtitles2.srt -c:v copy -c:a copy -c:s mov_text -map 0:v -map 0:a -map 1 -map 2 output.mp4
</code></pre>
<p>이 명령어는 <code>input.mp4</code> 파일에 두 개의 자막 트랙을 추가하여 <code>output.mp4</code> 파일을 생성한다. 자막 트랙은 각각 <code>subtitles1.srt</code>와 <code>subtitles2.srt</code>에서 가져온다.</p>
<h3 id="_83">수학적 해석: 다중 트랙의 스트림 처리</h3>
<p>여러 트랙을 가진 파일은 각 트랙이 시간 축에서 독립적으로 존재하며, 이를 결합할 때 시간 동기화가 필요하다. 이를 수식으로 표현하면, 각 트랙의 시작 시간과 길이는 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{track}} = T_{\text{start}} + \Delta T
</div>
<script type="math/tex; mode=display">
T_{\text{track}} = T_{\text{start}} + \Delta T
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{track}}</span><script type="math/tex">T_{\text{track}}</script></span>은 트랙의 재생 시간,
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{start}}</span><script type="math/tex">T_{\text{start}}</script></span>는 트랙의 시작 시간,
- <span class="arithmatex"><span class="MathJax_Preview">\Delta T</span><script type="math/tex">\Delta T</script></span>는 트랙의 길이이다.</p>
<p>이 수식을 통해 여러 트랙을 동기화하여 하나의 파일로 병합할 수 있다.</p>
<h3 id="_84">비디오 속도 조정</h3>
<p>비디오의 재생 속도를 조정하면 슬로우 모션, 빠른 재생 등 다양한 효과를 적용할 수 있다. FFmpeg는 비디오 속도를 변경하는 여러 옵션을 제공하며, 비디오의 재생 속도를 높이거나 낮추는 작업을 지원한다.</p>
<h4 id="_85">비디오 속도 변경 명령어</h4>
<p>비디오의 속도를 조정하려면 <code>-filter:v</code> 옵션을 사용하여 <code>setpts</code> 필터를 적용할 수 있다. 비디오 재생 속도를 2배로 빠르게 하고 싶다면 다음과 같이 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -filter:v &quot;setpts=0.5*PTS&quot; -c:a copy output.mp4
</code></pre>
<p>위 명령어에서 <code>setpts=0.5*PTS</code>는 비디오의 재생 시간을 절반으로 줄여서 재생 속도를 두 배로 빠르게 한다. 오디오의 경우, <code>-c:a copy</code> 옵션을 사용하여 그대로 복사한다.</p>
<h4 id="_86">슬로우 모션</h4>
<p>슬로우 모션 효과를 주기 위해서는 <code>setpts</code> 값을 1보다 크게 설정한다. 예를 들어, 비디오 속도를 2배 느리게 만들려면 다음과 같이 할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -filter:v &quot;setpts=2.0*PTS&quot; -c:a copy output.mp4
</code></pre>
<p>이 명령어는 비디오의 재생 시간을 2배로 늘려, 슬로우 모션 효과를 준다.</p>
<h3 id="pts">수학적 해석: 비디오 속도와 PTS</h3>
<p>비디오 속도 조정은 시간 기반의 PTS(Presentation Time Stamp)를 변형하는 방식으로 이루어진다. 이를 수학적으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{output}} = \alpha \cdot T_{\text{input}}
</div>
<script type="math/tex; mode=display">
T_{\text{output}} = \alpha \cdot T_{\text{input}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{output}}</span><script type="math/tex">T_{\text{output}}</script></span>은 출력 비디오의 재생 시간,
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{input}}</span><script type="math/tex">T_{\text{input}}</script></span>은 입력 비디오의 재생 시간,
- <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 속도 조정 계수이다.</p>
<p>속도를 두 배로 빠르게 할 경우 <span class="arithmatex"><span class="MathJax_Preview">\alpha = 0.5</span><script type="math/tex">\alpha = 0.5</script></span>, 슬로우 모션으로 만들 경우 <span class="arithmatex"><span class="MathJax_Preview">\alpha = 2.0</span><script type="math/tex">\alpha = 2.0</script></span> 등의 값을 설정할 수 있다.</p>
<h3 id="_87">오디오 속도 조정</h3>
<p>비디오 속도와 함께 오디오 속도도 조정할 수 있다. 오디오 속도는 <code>-filter:a</code> 옵션을 사용하여 조정할 수 있으며, <code>atempo</code> 필터를 적용하여 재생 속도를 변경한다.</p>
<h4 id="_88">오디오 속도 변경 명령어</h4>
<p>오디오 속도를 2배로 빠르게 하려면 다음과 같이 <code>atempo</code> 필터를 사용할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -filter:a &quot;atempo=2.0&quot; -c:v copy output.mp4
</code></pre>
<p>이 명령어는 오디오의 재생 속도를 2배로 빠르게 하고, 비디오는 그대로 복사한다.</p>
<h4 id="_89">슬로우 모션 오디오</h4>
<p>오디오의 재생 속도를 2배 느리게 만들려면 <code>atempo</code> 값을 0.5로 설정한다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -filter:a &quot;atempo=0.5&quot; -c:v copy output.mp4
</code></pre>
<p>이 명령어는 오디오의 재생 시간을 2배로 늘려, 슬로우 모션 오디오 효과를 만든다.</p>
<h3 id="atempo">수학적 해석: 오디오 속도와 atempo</h3>
<p>오디오 속도 조정은 샘플링 레이트와 밀접한 관련이 있으며, 이를 수학적으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
A_{\text{output}} = \beta \cdot A_{\text{input}}
</div>
<script type="math/tex; mode=display">
A_{\text{output}} = \beta \cdot A_{\text{input}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">A_{\text{output}}</span><script type="math/tex">A_{\text{output}}</script></span>은 출력 오디오의 샘플링 레이트,
- <span class="arithmatex"><span class="MathJax_Preview">A_{\text{input}}</span><script type="math/tex">A_{\text{input}}</script></span>은 입력 오디오의 샘플링 레이트,
- <span class="arithmatex"><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span>는 속도 조정 계수이다.</p>
<p>속도를 두 배로 빠르게 할 경우 <span class="arithmatex"><span class="MathJax_Preview">\beta = 2.0</span><script type="math/tex">\beta = 2.0</script></span>, 슬로우 모션으로 만들 경우 <span class="arithmatex"><span class="MathJax_Preview">\beta = 0.5</span><script type="math/tex">\beta = 0.5</script></span> 등의 값을 설정할 수 있다.</p>
<h3 id="_90">비디오 품질 최적화</h3>
<p>FFmpeg는 비디오 품질을 최적화하기 위한 다양한 옵션을 제공한다. 품질 최적화는 비트레이트, 인코딩 모드, 압축률 등을 조정하여 수행된다.</p>
<h4 id="_91">비트레이트 설정</h4>
<p>비트레이트는 비디오 품질에 큰 영향을 미친다. 비트레이트가 높을수록 품질은 좋아지지만 파일 크기가 커진다. 반대로 비트레이트를 낮추면 품질이 저하되지만 파일 크기가 줄어든다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -b:v 2M -c:a aac -b:a 128k output.mp4
</code></pre>
<p>이 명령어는 비디오 비트레이트를 2Mbps로, 오디오 비트레이트를 128kbps로 설정하여 최적화한다.</p>
<h4 id="_92">인코딩 모드 설정</h4>
<p>FFmpeg에서 비디오 인코딩 품질을 조정하려면 <code>-crf</code>(Constant Rate Factor) 옵션을 사용할 수 있다. CRF 값은 0에서 51 사이로 설정할 수 있으며, 값이 낮을수록 품질이 높아진다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -crf 18 -c:a aac output.mp4
</code></pre>
<p>이 명령어는 CRF 값을 18로 설정하여 비디오 품질을 최적화한다. 일반적으로 18~23 사이의 값이 좋은 품질을 제공한다.</p>
<h3 id="_93">수학적 해석: 비트레이트와 품질</h3>
<p>비트레이트와 품질은 반비례 관계에 있으며, 이를 수식으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
Q \propto \frac{B}{R}
</div>
<script type="math/tex; mode=display">
Q \propto \frac{B}{R}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>는 비디오 품질,
- <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>는 비트레이트,
- <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>는 해상도 또는 프레임 레이트이다.</p>
<p>비트레이트가 증가하면 품질도 향상되지만, 파일 크기가 커지므로 적절한 비트레이트를 선택해야 한다.</p>
<h3 id="_94">오디오 품질 최적화</h3>
<p>오디오 품질 최적화를 위해 FFmpeg에서는 비트레이트를 조정하거나 고급 코덱 설정을 적용할 수 있다.</p>
<h4 id="_95">오디오 비트레이트 설정</h4>
<p>오디오 품질을 높이려면 비트레이트를 높게 설정하면 된다. 다음 명령어는 오디오 비트레이트를 320kbps로 설정하여 고품질 오디오를 생성한다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:a aac -b:a 320k output.mp4
</code></pre>
<p>이 명령어는 오디오 스트림의 비트레이트를 320kbps로 설정하여 출력한다.</p>
<h3 id="_96">비디오 회전 및 뒤집기</h3>
<p>FFmpeg는 비디오 파일을 회전하거나 뒤집는 기능도 제공한다. 이 기능은 주로 비디오를 잘못된 방향으로 촬영했을 때 유용하다.</p>
<h4 id="_97">비디오 회전</h4>
<p>비디오를 90도 회전하려면 <code>transpose</code> 필터를 사용한다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -vf &quot;transpose=1&quot; -c:a copy output.mp4
</code></pre>
<p>이 명령어는 비디오를 시계 방향으로 90도 회전시킨다.</p>
<h4 id="_98">비디오 뒤집기</h4>
<p>비디오를 수직으로 뒤집으려면 <code>vflip</code> 필터를 사용할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -vf &quot;vflip&quot; -c:a copy output.mp4
</code></pre>
<p>이 명령어는 비디오를 수직으로 뒤집어서 출력한다.</p>
<h3 id="_99">비디오 화면 비율 조정</h3>
<p>비디오의 화면 비율(Aspect Ratio)은 가로와 세로의 비율로, 잘못된 화면 비율을 수정하거나 특정 비율로 맞출 때 유용하다. FFmpeg는 화면 비율을 조정하는 옵션을 제공하며, 비디오를 재인코딩하면서 해당 비율을 적용할 수 있다.</p>
<h4 id="_100">화면 비율 조정 명령어</h4>
<p>FFmpeg에서 화면 비율을 변경하려면 <code>-aspect</code> 옵션을 사용할 수 있다. 예를 들어, 비디오의 화면 비율을 16:9로 변경하려면 다음과 같이 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -aspect 16:9 -c:v h264 -c:a copy output.mp4
</code></pre>
<p>이 명령어는 비디오의 화면 비율을 16:9로 조정하며, 비디오는 <code>H.264</code> 코덱을 사용해 인코딩하고 오디오는 그대로 복사한다.</p>
<h4 id="_101">해상도 변경과 화면 비율 조정</h4>
<p>해상도를 변경하면서 동시에 화면 비율을 조정할 수 있다. 예를 들어, 해상도를 1280x720으로 변경하고 화면 비율을 16:9로 설정하려면 다음과 같은 명령어를 사용할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -vf &quot;scale=1280:720,setdar=16/9&quot; -c:v h264 -c:a copy output.mp4
</code></pre>
<p>이 명령어는 비디오 해상도를 1280x720으로 변경하고, 화면 비율을 16:9로 설정한다.</p>
<h3 id="_102">수학적 해석: 화면 비율 조정</h3>
<p>화면 비율(Aspect Ratio)은 비디오의 가로 길이 <span class="arithmatex"><span class="MathJax_Preview">W</span><script type="math/tex">W</script></span>와 세로 길이 <span class="arithmatex"><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span> 간의 비율로, 이를 수학적으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
AR = \frac{W}{H}
</div>
<script type="math/tex; mode=display">
AR = \frac{W}{H}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">AR</span><script type="math/tex">AR</script></span>는 화면 비율,
- <span class="arithmatex"><span class="MathJax_Preview">W</span><script type="math/tex">W</script></span>는 비디오의 가로 해상도,
- <span class="arithmatex"><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span>는 비디오의 세로 해상도이다.</p>
<p>화면 비율을 변경하면 가로와 세로 길이의 비율을 재조정하여 출력 비디오가 원하는 비율에 맞춰진다.</p>
<h3 id="_103">오디오 채널 변환</h3>
<p>오디오 파일의 채널을 변환하여 모노에서 스테레오로, 혹은 그 반대로 변경할 수 있다. FFmpeg는 다양한 오디오 채널 변환 옵션을 제공하며, 이러한 변환은 오디오 장비나 재생 환경에 맞게 파일을 최적화하는 데 유용하다.</p>
<h4 id="_104">모노에서 스테레오로 변환</h4>
<p>모노 오디오 파일을 스테레오로 변환하려면 <code>-ac</code> 옵션을 사용하여 오디오 채널 수를 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp3 -ac 2 output.mp3
</code></pre>
<p>이 명령어는 <code>input.mp3</code> 파일을 스테레오(2 채널)로 변환하여 <code>output.mp3</code> 파일로 저장한다.</p>
<h4 id="_105">스테레오에서 모노로 변환</h4>
<p>스테레오 파일을 모노로 변환하려면 오디오 채널을 1로 설정하면 된다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp3 -ac 1 output.mp3
</code></pre>
<p>이 명령어는 스테레오(2 채널) 파일을 모노(1 채널)로 변환하여 출력한다.</p>
<h3 id="_106">수학적 해석: 오디오 채널 변환</h3>
<p>오디오 채널 변환은 각 채널에서의 음향 신호를 결합하거나 분리하는 과정으로, 이를 수학적으로 표현할 수 있다.</p>
<h4 id="_107">모노에서 스테레오로 변환</h4>
<p>모노 신호 <span class="arithmatex"><span class="MathJax_Preview">M(t)</span><script type="math/tex">M(t)</script></span>를 스테레오로 변환할 때, 두 개의 동일한 신호를 각 채널에 복사한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S_{\text{left}}(t) = S_{\text{right}}(t) = M(t)
</div>
<script type="math/tex; mode=display">
S_{\text{left}}(t) = S_{\text{right}}(t) = M(t)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">S_{\text{left}}(t)</span><script type="math/tex">S_{\text{left}}(t)</script></span>는 왼쪽 채널의 스테레오 신호,
- <span class="arithmatex"><span class="MathJax_Preview">S_{\text{right}}(t)</span><script type="math/tex">S_{\text{right}}(t)</script></span>는 오른쪽 채널의 스테레오 신호,
- <span class="arithmatex"><span class="MathJax_Preview">M(t)</span><script type="math/tex">M(t)</script></span>는 모노 신호이다.</p>
<h4 id="_108">스테레오에서 모노로 변환</h4>
<p>스테레오 신호 <span class="arithmatex"><span class="MathJax_Preview">S_{\text{left}}(t)</span><script type="math/tex">S_{\text{left}}(t)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">S_{\text{right}}(t)</span><script type="math/tex">S_{\text{right}}(t)</script></span>를 모노로 변환할 때, 두 신호의 평균을 취하여 하나의 모노 신호를 만든다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
M(t) = \frac{S_{\text{left}}(t) + S_{\text{right}}(t)}{2}
</div>
<script type="math/tex; mode=display">
M(t) = \frac{S_{\text{left}}(t) + S_{\text{right}}(t)}{2}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">M(t)</span><script type="math/tex">M(t)</script></span>는 모노 신호,
- <span class="arithmatex"><span class="MathJax_Preview">S_{\text{left}}(t)</span><script type="math/tex">S_{\text{left}}(t)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">S_{\text{right}}(t)</span><script type="math/tex">S_{\text{right}}(t)</script></span>는 각각 왼쪽과 오른쪽 스테레오 신호이다.</p>
<h3 id="_109">무손실 변환</h3>
<p>FFmpeg에서는 무손실 변환(Lossless Conversion)을 통해 파일을 인코딩할 때 품질 저하 없이 변환할 수 있다. 무손실 변환은 주로 비디오의 원본 품질을 유지해야 할 때 사용되며, <code>FFV1</code> 코덱과 같은 무손실 코덱을 사용한다.</p>
<h4 id="_110">무손실 비디오 변환</h4>
<p>무손실 비디오 변환을 수행하려면 <code>-c:v ffv1</code> 옵션을 사용하여 <code>FFV1</code> 코덱을 선택할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v ffv1 output.mkv
</code></pre>
<p>이 명령어는 <code>input.mp4</code> 파일을 <code>FFV1</code> 무손실 코덱을 사용하여 변환하고, <code>MKV</code> 파일로 출력한다.</p>
<h4 id="_111">무손실 오디오 변환</h4>
<p>오디오 파일에서 무손실 변환을 수행하려면 <code>FLAC</code> 코덱을 사용할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.wav -c:a flac output.flac
</code></pre>
<p>이 명령어는 <code>input.wav</code> 파일을 무손실 오디오 코덱인 <code>FLAC</code>으로 변환하여 출력한다.</p>
<h3 id="_112">수학적 해석: 무손실 변환과 압축률</h3>
<p>무손실 변환에서 중요한 요소는 압축률과 품질 간의 관계이다. 무손실 변환에서는 압축률이 높더라도 품질이 유지된다. 이를 수학적으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
Q_{\text{output}} = Q_{\text{input}}
</div>
<script type="math/tex; mode=display">
Q_{\text{output}} = Q_{\text{input}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">Q_{\text{output}}</span><script type="math/tex">Q_{\text{output}}</script></span>은 출력 파일의 품질,
- <span class="arithmatex"><span class="MathJax_Preview">Q_{\text{input}}</span><script type="math/tex">Q_{\text{input}}</script></span>은 입력 파일의 품질이다.</p>
<p>무손실 변환에서는 압축률이 증가해도 입력과 출력 품질이 동일하게 유지된다.</p>
<h3 id="_113">하드웨어 가속 설정</h3>
<p>FFmpeg는 하드웨어 가속을 통해 인코딩 및 디코딩 속도를 크게 향상시킬 수 있다. 하드웨어 가속은 CPU 대신 GPU에서 비디오 처리를 수행하며, 이를 통해 고해상도 비디오의 처리 성능을 개선할 수 있다.</p>
<h4 id="_114">하드웨어 가속 활성화</h4>
<p>하드웨어 가속을 활성화하려면 <code>-hwaccel</code> 옵션을 사용하여 GPU 가속 기능을 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -hwaccel cuda -i input.mp4 -c:v h264_nvenc -c:a copy output.mp4
</code></pre>
<p>이 명령어는 <code>CUDA</code> 하드웨어 가속을 활성화하고, <code>H.264</code> 코덱을 사용하여 GPU에서 인코딩한다.</p>
<h4 id="_115">하드웨어 가속 코덱 사용</h4>
<p>GPU 가속을 사용할 때는 <code>NVENC</code>, <code>VAAPI</code>, <code>AMF</code> 등 다양한 하드웨어 가속 코덱을 사용할 수 있다. 예를 들어, NVIDIA의 하드웨어 가속 인코더인 <code>NVENC</code>를 사용하려면 다음과 같이 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264_nvenc -c:a aac output.mp4
</code></pre>
<p>이 명령어는 NVIDIA의 <code>NVENC</code> 하드웨어 인코더를 사용하여 <code>H.264</code> 코덱으로 비디오를 인코딩한다.</p>
<h3 id="_116">수학적 해석: 하드웨어 가속과 처리 시간</h3>
<p>하드웨어 가속을 사용할 때, CPU와 GPU 간의 처리 시간 비교는 중요한 요소이다. 하드웨어 가속을 적용한 후, GPU에서 처리되는 시간은 CPU에서의 처리 시간보다 짧다. 이를 수학적으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{GPU}} &lt; T_{\text{CPU}}
</div>
<script type="math/tex; mode=display">
T_{\text{GPU}} < T_{\text{CPU}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{GPU}}</span><script type="math/tex">T_{\text{GPU}}</script></span>는 GPU에서 처리하는 시간,
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{CPU}}</span><script type="math/tex">T_{\text{CPU}}</script></span>는 CPU에서 처리하는 시간이다.</p>
<p>FFmpeg에서 하드웨어 가속을 적용하면 비디오 처리 시간이 크게 단축된다.</p>
<h3 id="gpu">GPU 인코딩/디코딩</h3>
<p>FFmpeg는 GPU를 사용하여 인코딩 및 디코딩 성능을 최적화할 수 있는 다양한 옵션을 제공한다. GPU 인코딩 및 디코딩은 주로 고해상도 비디오나 실시간 스트리밍 환경에서 사용되며, 성능 향상과 처리 속도를 크게 개선할 수 있다.</p>
<h4 id="gpu_1">GPU 인코딩</h4>
<p>GPU 인코딩은 CPU 대신 GPU를 사용하여 비디오 스트림을 인코딩하는 작업이다. FFmpeg는 NVIDIA의 NVENC, AMD의 VCE/AMF, 그리고 Intel의 QSV(Quick Sync Video) 등 다양한 GPU 인코딩 옵션을 지원한다.</p>
<h5 id="nvidia-nvenc">NVIDIA NVENC 인코딩</h5>
<p>NVIDIA의 NVENC 인코더는 고성능 GPU 인코딩을 제공하며, 특히 실시간 스트리밍과 같은 환경에서 많이 사용된다. 다음 명령어는 <code>NVENC</code>를 사용하여 비디오를 인코딩하는 예시이다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264_nvenc -b:v 5M -c:a copy output.mp4
</code></pre>
<p>이 명령어는 <code>NVENC</code> 하드웨어 인코더를 사용하여 비디오를 <code>H.264</code> 코덱으로 인코딩하며, 비트레이트는 5Mbps로 설정한다.</p>
<h5 id="intel-quick-sync">Intel Quick Sync 인코딩</h5>
<p>Intel의 Quick Sync Video(QSV)도 하드웨어 가속 인코딩을 제공하며, 주로 Intel CPU에서 사용된다. 다음 명령어는 QSV를 사용하여 비디오를 인코딩하는 예시이다.</p>
<pre><code class="language-bash">ffmpeg -hwaccel qsv -i input.mp4 -c:v h264_qsv -c:a copy output.mp4
</code></pre>
<p>이 명령어는 Intel의 Quick Sync 하드웨어 가속을 사용하여 비디오를 <code>H.264</code> 코덱으로 인코딩한다.</p>
<h4 id="gpu_2">GPU 디코딩</h4>
<p>GPU 디코딩은 비디오 파일을 재생하거나 처리할 때 GPU를 사용하여 디코딩 속도를 높이는 작업이다. GPU 디코딩은 특히 고해상도 비디오에서 CPU의 부담을 줄이고, 실시간 디코딩 성능을 크게 향상시킬 수 있다.</p>
<h5 id="nvidia-nvdec">NVIDIA NVDEC 디코딩</h5>
<p>NVIDIA NVDEC는 GPU 기반의 비디오 디코더로, NVIDIA GPU에서 비디오 디코딩 성능을 크게 개선한다. 다음 명령어는 <code>NVDEC</code>을 사용하여 비디오 파일을 디코딩하는 예시이다.</p>
<pre><code class="language-bash">ffmpeg -hwaccel nvdec -i input.mp4 -c:v h264 -c:a copy output.mp4
</code></pre>
<p>이 명령어는 <code>NVDEC</code> 하드웨어 디코더를 사용하여 비디오 파일을 디코딩하고, <code>H.264</code> 코덱으로 변환한다.</p>
<h3 id="gpu_3">수학적 해석: GPU 인코딩 및 디코딩 성능</h3>
<p>GPU 인코딩 및 디코딩에서 중요한 요소는 처리 속도와 프레임 레이트이다. GPU의 성능이 높을수록 인코딩 및 디코딩 속도가 빨라지고, 처리할 수 있는 프레임 수가 증가한다.</p>
<p>처리 속도 <span class="arithmatex"><span class="MathJax_Preview">S_{\text{GPU}}</span><script type="math/tex">S_{\text{GPU}}</script></span>는 GPU의 성능에 따라 달라지며, CPU에서의 처리 속도 <span class="arithmatex"><span class="MathJax_Preview">S_{\text{CPU}}</span><script type="math/tex">S_{\text{CPU}}</script></span>보다 빠르다. 이를 수식으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S_{\text{GPU}} &gt; S_{\text{CPU}}
</div>
<script type="math/tex; mode=display">
S_{\text{GPU}} > S_{\text{CPU}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">S_{\text{GPU}}</span><script type="math/tex">S_{\text{GPU}}</script></span>는 GPU에서의 처리 속도,
- <span class="arithmatex"><span class="MathJax_Preview">S_{\text{CPU}}</span><script type="math/tex">S_{\text{CPU}}</script></span>는 CPU에서의 처리 속도이다.</p>
<p>GPU를 사용할 경우 더 많은 프레임을 빠르게 처리할 수 있어, 고해상도 비디오 인코딩 및 디코딩에서 큰 성능 향상을 기대할 수 있다.</p>
<h3 id="_117">다중 코덱 사용</h3>
<p>FFmpeg는 한 파일 내에서 여러 코덱을 조합하여 사용할 수 있다. 각 스트림에 대해 별도의 코덱을 지정할 수 있으며, 이를 통해 하나의 파일에 서로 다른 비디오 및 오디오 코덱을 결합할 수 있다.</p>
<h4 id="_118">비디오 및 오디오 코덱 설정</h4>
<p>서로 다른 비디오 및 오디오 코덱을 설정하려면 각각의 스트림에 대해 코덱을 지정할 수 있다. 예를 들어, 비디오에는 <code>H.264</code> 코덱을, 오디오에는 <code>AAC</code> 코덱을 사용하려면 다음과 같이 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i input.mp4 -c:v h264 -c:a aac output.mp4
</code></pre>
<p>이 명령어는 비디오 스트림을 <code>H.264</code> 코덱으로, 오디오 스트림을 <code>AAC</code> 코덱으로 인코딩한다.</p>
<h4 id="_119">서로 다른 코덱을 병합</h4>
<p>FFmpeg는 비디오 스트림과 오디오 스트림에 각각 다른 코덱을 적용한 후 하나의 파일로 병합할 수 있다. 예를 들어, <code>H.264</code> 비디오와 <code>MP3</code> 오디오를 하나의 <code>MKV</code> 파일로 병합하려면 다음과 같이 설정할 수 있다.</p>
<pre><code class="language-bash">ffmpeg -i video.mp4 -i audio.mp3 -c:v h264 -c:a mp3 output.mkv
</code></pre>
<p>이 명령어는 비디오 파일과 오디오 파일을 각각 인코딩한 후 <code>MKV</code> 파일로 병합한다.</p>
<h3 id="_120">수학적 해석: 다중 코덱 처리</h3>
<p>다중 코덱을 사용할 때는 각각의 스트림에 대해 독립적인 코덱 처리가 이루어진다. 이를 수학적으로 나타내면 각 스트림의 코덱 변환을 다음과 같이 표현할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{total}} = \sum_{i=1}^{n} C_i(S_i)
</div>
<script type="math/tex; mode=display">
T_{\text{total}} = \sum_{i=1}^{n} C_i(S_i)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">T_{\text{total}}</span><script type="math/tex">T_{\text{total}}</script></span>은 전체 처리 시간,
- <span class="arithmatex"><span class="MathJax_Preview">C_i(S_i)</span><script type="math/tex">C_i(S_i)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>번째 스트림의 코덱 변환 함수이다.</p>
<p>각 스트림이 독립적으로 처리된 후 최종 파일로 병합된다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../A045/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../A045/" class="btn btn-xs btn-link">
        다중 파일 변환
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../A043/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../A043/" class="btn btn-xs btn-link">
        GPU 인코딩/디코딩
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>