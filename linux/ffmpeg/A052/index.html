<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/linux/ffmpeg/A052/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>FFMPEG 스크립트 작성 - 실험 도서관</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <link href="../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc2a4\ud06c\ub9bd\ud2b8 \uc791\uc131\uc758 \ud544\uc694\uc131", url: "#_top", children: [
          ]},
          {title: "\uc2a4\ud06c\ub9bd\ud2b8 \uc791\uc131\uc758 \uae30\ubcf8 \uac1c\ub150", url: "#_2", children: [
              {title: "\uc178 \uc2a4\ud06c\ub9bd\ud2b8\uc5d0\uc11c FFMPEG \uc0ac\uc6a9", url: "#ffmpeg" },
          ]},
          {title: "\uc2a4\ud06c\ub9bd\ud2b8 \ub0b4 \ubcc0\uc218 \uc0ac\uc6a9", url: "#_3", children: [
              {title: "\ubcc0\uc218 \uc124\uc815 \uc608\uc2dc", url: "#_4" },
          ]},
          {title: "\uc870\uac74\ubb38 \uc0ac\uc6a9", url: "#_5", children: [
              {title: "\uc870\uac74\ubb38 \uc608\uc2dc", url: "#_6" },
          ]},
          {title: "\ud30c\uc77c \uacbd\ub85c \ucc98\ub9ac", url: "#_7", children: [
              {title: "\ud30c\uc77c \uacbd\ub85c \ucc98\ub9ac \uc608\uc2dc", url: "#_8" },
          ]},
          {title: "\ubc30\uce58 \ud30c\uc77c\uc5d0\uc11c FFMPEG \uc0ac\uc6a9", url: "#ffmpeg_1", children: [
              {title: "\ubc30\uce58 \ud30c\uc77c \uc608\uc2dc", url: "#_9" },
          ]},
          {title: "\ud30c\uc774\uc36c \uc2a4\ud06c\ub9bd\ud2b8\uc5d0\uc11c FFMPEG \uc0ac\uc6a9", url: "#ffmpeg_2", children: [
              {title: "\ud30c\uc774\uc36c\uc5d0\uc11c FFMPEG \ud638\ucd9c", url: "#ffmpeg_3" },
          ]},
          {title: "\uc2a4\ud06c\ub9bd\ud2b8\uc758 \uc2e4\ud589 \ubc0f \ub514\ubc84\uae45", url: "#_10", children: [
              {title: "\ub514\ubc84\uae45 \uae30\ubc95", url: "#_11" },
          ]},
          {title: "\ub8e8\ud504\uc640 \ubc18\ubcf5 \ucc98\ub9ac", url: "#_12", children: [
              {title: "\ub8e8\ud504 \uad6c\uc870\uc758 \ud65c\uc6a9", url: "#_13" },
          ]},
          {title: "\uc624\ub958 \ucc98\ub9ac \ubc0f \uc608\uc678 \ucc98\ub9ac", url: "#_14", children: [
              {title: "\uc178 \uc2a4\ud06c\ub9bd\ud2b8\uc5d0\uc11c\uc758 \uc624\ub958 \ucc98\ub9ac", url: "#_15" },
          ]},
          {title: "\ud30c\uc774\uc36c\uc5d0\uc11c\uc758 \uc608\uc678 \ucc98\ub9ac", url: "#_17", children: [
              {title: "\ud30c\uc774\uc36c \uc608\uc678 \ucc98\ub9ac \uc608\uc2dc", url: "#_18" },
          ]},
          {title: "\ub85c\uadf8 \ud30c\uc77c \uad00\ub9ac", url: "#_19", children: [
              {title: "\ub85c\uadf8 \ud30c\uc77c \uc800\uc7a5 \uc608\uc2dc", url: "#_20" },
          ]},
          {title: "\ubcd1\ub82c \ucc98\ub9ac", url: "#_21", children: [
              {title: "\uc178 \uc2a4\ud06c\ub9bd\ud2b8\uc5d0\uc11c\uc758 \ubcd1\ub82c \ucc98\ub9ac", url: "#_22" },
              {title: "\ud30c\uc774\uc36c\uc5d0\uc11c\uc758 \ubcd1\ub82c \ucc98\ub9ac", url: "#_23" },
          ]},
          {title: "\uc2a4\ud06c\ub9bd\ud2b8\uc5d0\uc11c \uc0ac\uc6a9\uc790 \uc785\ub825 \ubc1b\uae30", url: "#_25", children: [
              {title: "\uc178 \uc2a4\ud06c\ub9bd\ud2b8\uc5d0\uc11c \uc0ac\uc6a9\uc790 \uc785\ub825 \ubc1b\uae30", url: "#_26" },
              {title: "\ud30c\uc774\uc36c\uc5d0\uc11c \uc0ac\uc6a9\uc790 \uc785\ub825 \ubc1b\uae30", url: "#_28" },
          ]},
          {title: "\ud658\uacbd \ubcc0\uc218 \uc0ac\uc6a9", url: "#_30", children: [
              {title: "\ud658\uacbd \ubcc0\uc218 \uc124\uc815 \uc608\uc2dc (\uc178 \uc2a4\ud06c\ub9bd\ud2b8)", url: "#_31" },
              {title: "\ud658\uacbd \ubcc0\uc218 \uc124\uc815 \uc608\uc2dc (\ud30c\uc774\uc36c)", url: "#_32" },
          ]},
          {title: "\ubc30\uce58 \ud30c\uc77c\uc5d0\uc11c\uc758 \uc0ac\uc6a9\uc790 \uc785\ub825", url: "#_33", children: [
              {title: "\ubc30\uce58 \ud30c\uc77c \uc0ac\uc6a9\uc790 \uc785\ub825 \uc608\uc2dc", url: "#_34" },
          ]},
          {title: "\uc791\uc5c5 \uc790\ub3d9\ud654\uc640 \ud06c\ub860\ud0ed \uc0ac\uc6a9", url: "#_35", children: [
              {title: "\ud06c\ub860\ud0ed \uc124\uc815 \uc608\uc2dc", url: "#_36" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../A053/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../A053/" class="btn btn-xs btn-link">
        FFMPEG API 사용법
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../A051/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../A051/" class="btn btn-xs btn-link">
        자주 발생하는 문제 해결
      </a>
    </div>
    
  </div>

    

    <h2 id="_1">스크립트 작성의 필요성</h2>
<p>FFMPEG을 명령줄에서 반복적으로 사용해야 할 경우, 매번 동일한 명령어를 입력하는 것은 비효율적일 수 있다. 특히 여러 파일을 변환하거나 복잡한 파라미터를 사용하는 경우, 스크립트로 작업을 자동화하면 시간과 노력을 절약할 수 있다. 스크립트 작성은 FFMPEG의 강력한 기능을 효율적으로 사용할 수 있게 해주는 중요한 도구이다.</p>
<h2 id="_2">스크립트 작성의 기본 개념</h2>
<p>스크립트는 단순히 여러 명령을 한 번에 실행할 수 있도록 미리 작성한 명령어 모음이다. 스크립트는 다양한 운영체제에서 사용할 수 있으며, 주로 셸 스크립트(bash), 배치 파일(batch file), 파이썬 스크립트 등이 사용된다.</p>
<h3 id="ffmpeg">셸 스크립트에서 FFMPEG 사용</h3>
<p>리눅스 및 macOS에서 주로 사용되는 셸 스크립트를 활용해 FFMPEG 명령어를 자동화할 수 있다. 예를 들어, 다음과 같은 간단한 스크립트를 작성하여 여러 비디오 파일을 일괄 변환할 수 있다.</p>
<pre><code class="language-bash">#!/bin/bash
for file in *.mp4; do
    ffmpeg -i &quot;$file&quot; -c:v libx264 &quot;${file%.mp4}.mkv&quot;
done
</code></pre>
<p>이 스크립트는 디렉토리 내에 있는 모든 <code>.mp4</code> 파일을 <code>.mkv</code> 파일로 변환한다. 여기서 <code>for</code> 루프는 디렉토리 내의 모든 파일을 순차적으로 처리하며, <code>ffmpeg</code> 명령을 통해 비디오 변환 작업을 수행한다.</p>
<h2 id="_3">스크립트 내 변수 사용</h2>
<p>스크립트 내에서 변수를 사용하면 코드의 재사용성을 높일 수 있다. 특히 FFMPEG 명령어는 다양한 파라미터를 사용하는 경우가 많기 때문에, 변수를 활용하면 코드를 더 효율적으로 관리할 수 있다.</p>
<h3 id="_4">변수 설정 예시</h3>
<pre><code class="language-bash">#!/bin/bash
input_format=&quot;mp4&quot;
output_format=&quot;mkv&quot;
codec=&quot;libx264&quot;

for file in *.$input_format; do
    ffmpeg -i &quot;$file&quot; -c:v$codec &quot;${file%.$input_format}.$output_format&quot;
done
</code></pre>
<p>여기서 <code>input_format</code>, <code>output_format</code>, 그리고 <code>codec</code> 변수를 사용하여 입력 파일 형식, 출력 파일 형식, 코덱을 설정하였다. 이러한 방식을 사용하면 간단한 변수 변경만으로도 여러 파일을 쉽게 변환할 수 있다.</p>
<h2 id="_5">조건문 사용</h2>
<p>스크립트에서 조건문을 사용하여 특정 조건에 따라 FFMPEG 명령을 다르게 실행할 수 있다. 이를 통해 더 복잡한 변환 작업을 자동화할 수 있다.</p>
<h3 id="_6">조건문 예시</h3>
<pre><code class="language-bash">#!/bin/bash
input_format=&quot;mp4&quot;
output_format=&quot;mkv&quot;
codec=&quot;libx264&quot;

for file in *.$input_format; do
    if [ &quot;${file: -4}&quot; == &quot;.mp4&quot; ]; then
        ffmpeg -i &quot;$file&quot; -c:v$codec &quot;${file%.$input_format}.$output_format&quot;
    else
        echo &quot;Skipping non-mp4 file: $file&quot;
    fi
done
</code></pre>
<p>위 예시에서는 <code>.mp4</code> 파일만 변환하며, 다른 형식의 파일은 변환하지 않고 건너뛰게 된다. <code>if</code> 조건문을 사용하여 파일 확장자를 검사하며, 조건을 만족하는 경우에만 FFMPEG 명령어를 실행한다.</p>
<h2 id="_7">파일 경로 처리</h2>
<p>스크립트를 작성할 때 파일 경로를 처리하는 방법도 중요하다. 특히 여러 디렉토리에 분산된 파일을 처리해야 하는 경우 파일 경로를 적절히 관리해야 한다.</p>
<h3 id="_8">파일 경로 처리 예시</h3>
<pre><code class="language-bash">#!/bin/bash
input_dir=&quot;/path/to/input/&quot;
output_dir=&quot;/path/to/output/&quot;
codec=&quot;libx264&quot;

for file in &quot;$input_dir&quot;*.mp4; do
    filename=$(basename &quot;$file&quot;)
    ffmpeg -i &quot;$file&quot; -c:v$codec &quot;$output_dir${filename%.mp4}.mkv&quot;
done
</code></pre>
<p>이 스크립트에서는 <code>basename</code> 명령어를 사용하여 파일 이름만 추출한 후, 출력 디렉토리 경로와 함께 출력 파일을 생성한다. <code>input_dir</code>과 <code>output_dir</code> 변수를 사용하여 입력 및 출력 파일의 디렉토리를 각각 설정한다.</p>
<h2 id="ffmpeg_1">배치 파일에서 FFMPEG 사용</h2>
<p>윈도우 환경에서는 배치 파일을 사용하여 FFMPEG 명령어를 자동화할 수 있다. 배치 파일 역시 반복적인 작업을 자동화하는 데 유용하며, 셸 스크립트와 유사한 방식으로 작동한다.</p>
<h3 id="_9">배치 파일 예시</h3>
<pre><code class="language-batch">@echo off
set input_format=mp4
set output_format=mkv
set codec=libx264

for %%f in (*.%input_format%) do (
    ffmpeg -i &quot;%%f&quot; -c:v %codec% &quot;%%~nf.%output_format%&quot;
)
</code></pre>
<p>위 배치 파일은 현재 디렉토리 내의 모든 <code>.mp4</code> 파일을 <code>.mkv</code> 파일로 변환한다. <code>set</code> 명령어를 통해 변수를 설정하며, <code>for</code> 루프를 사용하여 파일을 순차적으로 처리한다.</p>
<h2 id="ffmpeg_2">파이썬 스크립트에서 FFMPEG 사용</h2>
<p>FFMPEG은 파이썬과 같은 프로그래밍 언어에서도 쉽게 호출할 수 있다. 파이썬 스크립트를 통해 FFMPEG 명령어를 실행하는 것은 더 복잡한 작업을 자동화하거나, GUI를 통해 작업을 제어하고자 할 때 매우 유용하다.</p>
<h3 id="ffmpeg_3">파이썬에서 FFMPEG 호출</h3>
<p>파이썬의 <code>subprocess</code> 모듈을 사용하여 FFMPEG 명령어를 실행할 수 있다. 예를 들어, 다음과 같은 파이썬 스크립트는 여러 파일을 변환하는 작업을 수행할 수 있다.</p>
<pre><code class="language-python">import subprocess
import os

input_dir = &quot;/path/to/input/&quot;
output_dir = &quot;/path/to/output/&quot;
codec = &quot;libx264&quot;

for filename in os.listdir(input_dir):
    if filename.endswith(&quot;.mp4&quot;):
        input_path = os.path.join(input_dir, filename)
        output_filename = filename.replace(&quot;.mp4&quot;, &quot;.mkv&quot;)
        output_path = os.path.join(output_dir, output_filename)
        subprocess.run([&quot;ffmpeg&quot;, &quot;-i&quot;, input_path, &quot;-c:v&quot;, codec, output_path])
</code></pre>
<p>이 파이썬 스크립트는 주어진 디렉토리 내에서 <code>.mp4</code> 파일을 찾아 <code>.mkv</code> 형식으로 변환한다. <code>subprocess.run</code>을 사용하여 FFMPEG 명령어를 실행하며, <code>os.path.join</code>을 통해 파일 경로를 처리한다.</p>
<h2 id="_10">스크립트의 실행 및 디버깅</h2>
<p>스크립트를 작성한 후에는 실행 결과를 확인하고, 필요한 경우 디버깅 작업을 수행해야 한다. 특히 복잡한 FFMPEG 명령어를 사용할 때는 예상치 못한 오류가 발생할 수 있으므로, 스크립트의 각 부분을 꼼꼼히 확인해야 한다.</p>
<h3 id="_11">디버깅 기법</h3>
<ul>
<li><strong>에러 출력 확인:</strong> FFMPEG은 명령어 실행 중 발생한 오류를 상세히 출력하므로, 이를 활용하여 문제를 해결할 수 있다.</li>
<li><strong>로그 파일 저장:</strong> 스크립트 실행 시 로그 파일에 출력을 저장하여, 이후에 오류를 추적하고 분석할 수 있다.</li>
</ul>
<pre><code class="language-bash">ffmpeg -i input.mp4 output.mkv 2&gt; error.log
</code></pre>
<p>위 명령어는 오류 메시지를 <code>error.log</code> 파일에 저장한다. 스크립트에서 이 방법을 사용하면, 변환 중 발생한 모든 오류를 한눈에 확인할 수 있다.</p>
<h2 id="_12">루프와 반복 처리</h2>
<p>FFMPEG 작업을 자동화할 때, 반복 처리 루프를 활용하면 효율성을 극대화할 수 있다. 여러 파일을 처리하거나, 동일한 작업을 반복해야 할 때 유용하다.</p>
<h3 id="_13">루프 구조의 활용</h3>
<p>반복적으로 동일한 작업을 수행해야 할 경우, 루프를 사용하여 각 파일에 대해 FFMPEG 명령을 실행할 수 있다. 예를 들어, 아래의 예시는 셸 스크립트에서 다양한 파일 형식을 순차적으로 변환하는 방법을 보여준다.</p>
<pre><code class="language-bash">#!/bin/bash
for ext in mp4 mov avi; do
    for file in *.$ext; do
        ffmpeg -i &quot;$file&quot; -c:v libx264 &quot;${file%.$ext}.mkv&quot;
    done
done
</code></pre>
<p>이 스크립트는 <code>.mp4</code>, <code>.mov</code>, 그리고 <code>.avi</code> 형식의 파일을 순차적으로 변환한다. <code>for</code> 루프를 사용하여 각 파일 형식을 처리하며, 하나의 스크립트로 여러 형식의 파일을 자동으로 변환할 수 있다.</p>
<h2 id="_14">오류 처리 및 예외 처리</h2>
<p>스크립트를 작성할 때 오류 처리 및 예외 처리는 필수적인 부분이다. 특히 FFMPEG은 다양한 미디어 파일을 처리하는 과정에서 파일 형식, 코덱, 해상도 등 여러 가지 이유로 오류가 발생할 수 있다. 스크립트 내에서 이러한 오류를 감지하고 처리할 수 있도록 해야 한다.</p>
<h3 id="_15">셸 스크립트에서의 오류 처리</h3>
<p>셸 스크립트에서는 명령어가 실패했을 경우, 그에 대한 적절한 처리를 추가할 수 있다. <code>if</code> 문과 <code>$?</code> 변수를 활용하여 오류 발생 여부를 확인할 수 있다. <code>$?</code> 변수는 마지막 명령어의 종료 상태를 나타내며, 0이면 성공, 1 이상이면 실패를 의미한다.</p>
<h4 id="_16">오류 처리 예시</h4>
<pre><code class="language-bash">#!/bin/bash
input_file=&quot;input.mp4&quot;
output_file=&quot;output.mkv&quot;

ffmpeg -i &quot;$input_file&quot; -c:v libx264 &quot;$output_file&quot;
if [ $? -ne 0 ]; then
    echo &quot;FFMPEG 변환에 실패하였다. 파일: $input_file&quot;
    exit 1
else
    echo &quot;FFMPEG 변환이 성공적으로 완료되었다. 파일: $output_file&quot;
fi
</code></pre>
<p>위 스크립트는 FFMPEG 변환이 성공했는지 여부를 확인하고, 실패한 경우 에러 메시지를 출력한다. 성공적으로 변환이 완료되면 그 결과를 사용자에게 알려준다.</p>
<h2 id="_17">파이썬에서의 예외 처리</h2>
<p>파이썬에서는 <code>try-except</code> 블록을 사용하여 예외 처리를 할 수 있다. 특히 FFMPEG 명령어가 실패할 경우, 이를 예외로 처리하여 오류 메시지를 출력하고 스크립트가 비정상적으로 종료되지 않도록 할 수 있다.</p>
<h3 id="_18">파이썬 예외 처리 예시</h3>
<pre><code class="language-python">import subprocess
import os

input_file = &quot;input.mp4&quot;
output_file = &quot;output.mkv&quot;
codec = &quot;libx264&quot;

try:
    subprocess.run([&quot;ffmpeg&quot;, &quot;-i&quot;, input_file, &quot;-c:v&quot;, codec, output_file], check=True)
    print(f&quot;변환 성공: {output_file}&quot;)
except subprocess.CalledProcessError as e:
    print(f&quot;FFMPEG 변환 실패: {e}&quot;)
</code></pre>
<p>이 예시에서 <code>subprocess.run</code> 함수는 <code>check=True</code> 옵션을 사용하여 명령어가 실패하면 <code>CalledProcessError</code> 예외를 발생시킨다. <code>try-except</code> 블록을 사용하여 이러한 예외를 처리하고, 오류가 발생했을 때 사용자에게 적절한 메시지를 출력한다.</p>
<h2 id="_19">로그 파일 관리</h2>
<p>스크립트 작성 시 변환 작업의 진행 상황과 오류 로그를 파일로 저장하면, 이후 문제를 분석할 때 유용하다. FFMPEG은 기본적으로 명령어 실행 중 발생하는 모든 출력과 오류 메시지를 출력하는데, 이를 파일로 저장할 수 있다.</p>
<h3 id="_20">로그 파일 저장 예시</h3>
<p>셸 스크립트에서는 표준 출력과 표준 오류 출력을 각각 다른 파일에 저장할 수 있다.</p>
<pre><code class="language-bash">#!/bin/bash
input_file=&quot;input.mp4&quot;
output_file=&quot;output.mkv&quot;
log_file=&quot;output.log&quot;
error_log_file=&quot;error.log&quot;

ffmpeg -i &quot;$input_file&quot; -c:v libx264 &quot;$output_file&quot; &gt; &quot;$log_file&quot; 2&gt; &quot;$error_log_file&quot;
</code></pre>
<p>이 스크립트는 FFMPEG 명령어 실행 결과를 <code>output.log</code> 파일에 저장하고, 오류는 <code>error.log</code> 파일에 저장한다. 이렇게 하면, 스크립트를 실행한 후 로그 파일을 통해 변환 과정에서 발생한 문제를 쉽게 확인할 수 있다.</p>
<h2 id="_21">병렬 처리</h2>
<p>FFMPEG 작업이 대량의 파일을 처리하거나 고화질 영상을 인코딩할 경우, 작업 시간이 길어질 수 있다. 이때 병렬 처리를 통해 작업 시간을 단축할 수 있다. 셸 스크립트와 파이썬 모두에서 병렬 처리를 적용할 수 있다.</p>
<h3 id="_22">셸 스크립트에서의 병렬 처리</h3>
<p>리눅스 셸에서는 <code>&amp;</code> 기호를 사용하여 백그라운드에서 명령어를 실행할 수 있다. 이를 활용하면 여러 FFMPEG 변환 작업을 병렬로 실행할 수 있다.</p>
<pre><code class="language-bash">#!/bin/bash
for file in *.mp4; do
    ffmpeg -i &quot;$file&quot; -c:v libx264 &quot;${file%.mp4}.mkv&quot; &amp;
done
wait
</code></pre>
<p>위 스크립트는 <code>.mp4</code> 파일을 병렬로 변환한 후, 모든 작업이 완료될 때까지 <code>wait</code> 명령어를 사용하여 대기한다. 이렇게 하면 여러 파일을 동시에 처리할 수 있어 작업 시간이 크게 단축된다.</p>
<h3 id="_23">파이썬에서의 병렬 처리</h3>
<p>파이썬에서는 <code>concurrent.futures</code> 모듈을 사용하여 병렬 처리를 구현할 수 있다. <code>ThreadPoolExecutor</code>나 <code>ProcessPoolExecutor</code>를 사용하여 여러 작업을 동시에 실행할 수 있다.</p>
<h4 id="_24">파이썬 병렬 처리 예시</h4>
<pre><code class="language-python">import subprocess
import os
from concurrent.futures import ThreadPoolExecutor

input_dir = &quot;/path/to/input/&quot;
output_dir = &quot;/path/to/output/&quot;
codec = &quot;libx264&quot;

def convert_video(filename):
    input_path = os.path.join(input_dir, filename)
    output_filename = filename.replace(&quot;.mp4&quot;, &quot;.mkv&quot;)
    output_path = os.path.join(output_dir, output_filename)
    subprocess.run([&quot;ffmpeg&quot;, &quot;-i&quot;, input_path, &quot;-c:v&quot;, codec, output_path])

with ThreadPoolExecutor() as executor:
    files = [f for f in os.listdir(input_dir) if f.endswith(&quot;.mp4&quot;)]
    executor.map(convert_video, files)
</code></pre>
<p>이 파이썬 스크립트는 <code>ThreadPoolExecutor</code>를 사용하여 <code>.mp4</code> 파일을 병렬로 변환한다. <code>executor.map</code>을 사용하여 파일 리스트를 순회하며 변환 작업을 동시에 처리한다.</p>
<h2 id="_25">스크립트에서 사용자 입력 받기</h2>
<p>스크립트를 작성할 때, 사용자가 입력할 수 있는 옵션을 제공하면 더욱 유연한 스크립트를 만들 수 있다. 사용자는 파일 경로, 출력 형식, 코덱 등의 파라미터를 직접 입력할 수 있으며, 이를 통해 스크립트의 재사용성을 높일 수 있다.</p>
<h3 id="_26">셸 스크립트에서 사용자 입력 받기</h3>
<p>셸 스크립트에서는 <code>read</code> 명령어를 사용하여 사용자로부터 입력을 받을 수 있다. 이를 통해 FFMPEG의 인코딩 설정이나 출력 파일 형식을 동적으로 설정할 수 있다.</p>
<h4 id="_27">사용자 입력 처리 예시</h4>
<pre><code class="language-bash">#!/bin/bash
echo &quot;변환할 파일의 경로를 입력하라:&quot;
read input_file
echo &quot;출력 파일의 경로를 입력하라:&quot;
read output_file
echo &quot;사용할 코덱을 입력하라 (예: libx264, libx265):&quot;
read codec

ffmpeg -i &quot;$input_file&quot; -c:v$codec &quot;$output_file&quot;
</code></pre>
<p>이 스크립트는 사용자로부터 입력 파일, 출력 파일, 그리고 사용할 코덱을 입력받아 FFMPEG 명령을 실행한다. 이를 통해 스크립트가 다양한 파일 변환 작업에 사용할 수 있도록 유연성을 제공한다.</p>
<h3 id="_28">파이썬에서 사용자 입력 받기</h3>
<p>파이썬에서는 <code>input()</code> 함수를 사용하여 사용자 입력을 처리할 수 있다. 이를 통해 스크립트 실행 중에 변환할 파일이나 출력 형식 등을 사용자가 입력하도록 할 수 있다.</p>
<h4 id="_29">파이썬 사용자 입력 예시</h4>
<pre><code class="language-python">import subprocess

input_file = input(&quot;변환할 파일의 경로를 입력하라: &quot;)
output_file = input(&quot;출력 파일의 경로를 입력하라: &quot;)
codec = input(&quot;사용할 코덱을 입력하라 (예: libx264, libx265): &quot;)

subprocess.run([&quot;ffmpeg&quot;, &quot;-i&quot;, input_file, &quot;-c:v&quot;, codec, output_file])
</code></pre>
<p>이 파이썬 스크립트는 사용자로부터 입력을 받아 FFMPEG 명령을 동적으로 실행한다. 이를 통해 다양한 파일을 변환하는 작업을 효율적으로 처리할 수 있다.</p>
<h2 id="_30">환경 변수 사용</h2>
<p>스크립트에서 환경 변수를 활용하면 시스템의 다양한 설정을 스크립트 내에서 손쉽게 사용할 수 있다. 환경 변수는 스크립트 외부에서 설정된 값들을 참조하거나, 스크립트 실행 시 동적으로 설정할 수 있다.</p>
<h3 id="_31">환경 변수 설정 예시 (셸 스크립트)</h3>
<p>셸 스크립트에서 환경 변수를 사용하려면 <code>export</code> 명령어를 사용하여 변수를 설정할 수 있다.</p>
<pre><code class="language-bash">#!/bin/bash
export INPUT_DIR=&quot;/path/to/input&quot;
export OUTPUT_DIR=&quot;/path/to/output&quot;

for file in &quot;$INPUT_DIR&quot;/*.mp4; do
    ffmpeg -i &quot;$file&quot; -c:v libx264 &quot;$OUTPUT_DIR/${file%.mp4}.mkv&quot;
done
</code></pre>
<p>위 스크립트는 <code>INPUT_DIR</code>과 <code>OUTPUT_DIR</code> 환경 변수를 사용하여 입력 및 출력 파일의 디렉토리를 설정한다. <code>export</code> 명령어를 사용하여 설정된 환경 변수는 스크립트 내에서 사용할 수 있으며, 외부에서도 참조할 수 있다.</p>
<h3 id="_32">환경 변수 설정 예시 (파이썬)</h3>
<p>파이썬에서 환경 변수를 사용하는 방법은 <code>os</code> 모듈의 <code>environ</code>을 사용하여 접근할 수 있다.</p>
<pre><code class="language-python">import os
import subprocess

input_dir = os.environ.get(&quot;INPUT_DIR&quot;, &quot;/path/to/input/&quot;)
output_dir = os.environ.get(&quot;OUTPUT_DIR&quot;, &quot;/path/to/output/&quot;)
codec = &quot;libx264&quot;

for filename in os.listdir(input_dir):
    if filename.endswith(&quot;.mp4&quot;):
        input_path = os.path.join(input_dir, filename)
        output_filename = filename.replace(&quot;.mp4&quot;, &quot;.mkv&quot;)
        output_path = os.path.join(output_dir, output_filename)
        subprocess.run([&quot;ffmpeg&quot;, &quot;-i&quot;, input_path, &quot;-c:v&quot;, codec, output_path])
</code></pre>
<p>이 파이썬 스크립트는 환경 변수를 사용하여 입력 및 출력 디렉토리를 설정한다. <code>os.environ.get</code>을 사용하여 환경 변수 값을 가져오며, 환경 변수가 설정되지 않은 경우 기본 값을 사용할 수 있도록 처리한다.</p>
<h2 id="_33">배치 파일에서의 사용자 입력</h2>
<p>윈도우 배치 파일에서도 사용자의 입력을 받아 FFMPEG 명령어를 동적으로 실행할 수 있다. <code>set /p</code> 명령어를 사용하여 사용자의 입력을 변수에 저장한 후 이를 FFMPEG 명령어에 사용할 수 있다.</p>
<h4 id="_34">배치 파일 사용자 입력 예시</h4>
<pre><code class="language-batch">@echo off
set /p input_file=&quot;변환할 파일의 경로를 입력하라: &quot;
set /p output_file=&quot;출력 파일의 경로를 입력하라: &quot;
set /p codec=&quot;사용할 코덱을 입력하라 (예: libx264, libx265): &quot;

ffmpeg -i &quot;%input_file%&quot; -c:v %codec% &quot;%output_file%&quot;
</code></pre>
<p>이 배치 파일은 사용자로부터 입력을 받아 FFMPEG 명령어를 실행한다. 이를 통해 윈도우 환경에서도 스크립트를 유연하게 작성할 수 있다.</p>
<h2 id="_35">작업 자동화와 크론탭 사용</h2>
<p>리눅스 환경에서는 <code>cron</code>을 사용하여 스크립트를 일정한 시간 간격으로 자동 실행할 수 있다. 이를 통해 FFMPEG 작업을 특정 시간마다 실행하도록 자동화할 수 있다.</p>
<h3 id="_36">크론탭 설정 예시</h3>
<p>크론탭(crontab)은 리눅스의 예약 작업 관리 도구이다. FFMPEG 스크립트를 매일 일정한 시간에 실행하도록 설정할 수 있다.</p>
<ol>
<li>
<p>터미널에서 크론탭 편집기를 엽니다.
   <code>bash
   crontab -e</code></p>
</li>
<li>
<p>다음과 같은 크론탭 항목을 추가하여 매일 오전 3시에 FFMPEG 스크립트를 실행하도록 설정한다.
   <code>bash
   0 3 * * * /path/to/ffmpeg_script.sh</code></p>
</li>
</ol>
<p>이 설정은 매일 오전 3시에 <code>ffmpeg_script.sh</code> 스크립트를 실행한다. 이를 통해 주기적인 비디오 파일 변환 작업을 자동화할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../A053/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../A053/" class="btn btn-xs btn-link">
        FFMPEG API 사용법
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../A051/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../A051/" class="btn btn-xs btn-link">
        자주 발생하는 문제 해결
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>