<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/linux/xenomai/chapter%2009/0906/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>사례 연구 Xenomai를 활용한 산업 제어 시스템 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc11c\ub860", url: "#_top", children: [
          ]},
          {title: "\uc2dc\uc2a4\ud15c \uac1c\uc694", url: "#_2", children: [
              {title: "\uc2dc\uc2a4\ud15c \uc124\uacc4 \uc694\uad6c\uc0ac\ud56d", url: "#_3" },
          ]},
          {title: "\uc544\ud0a4\ud14d\ucc98 \uac1c\uc694", url: "#_4", children: [
              {title: "\ud558\ub4dc\uc6e8\uc5b4 \uad6c\uc131", url: "#_5" },
              {title: "\uc18c\ud504\ud2b8\uc6e8\uc5b4 \uad6c\uc131", url: "#_6" },
          ]},
          {title: "Xenomai \uae30\ubc18 \uc2e4\uc2dc\uac04 \ud0dc\uc2a4\ud06c \uc124\uacc4", url: "#xenomai", children: [
              {title: "\uc2e4\uc2dc\uac04 \ud0dc\uc2a4\ud06c\uc758 \ubd84\ub958", url: "#_7" },
              {title: "\uc2e4\ud589 \uc8fc\uae30 \ubc0f \uc2a4\ucf00\uc904\ub9c1", url: "#_8" },
              {title: "\ucf54\ub4dc \uc608\uc81c", url: "#_9" },
          ]},
          {title: "\uc13c\uc11c \ub370\uc774\ud130 \uc218\uc9d1 \ubc0f \ucc98\ub9ac", url: "#_10", children: [
              {title: "\ub370\uc774\ud130 \uc218\uc9d1 \uba54\ucee4\ub2c8\uc998", url: "#_11" },
              {title: "\ub370\uc774\ud130 \uc804\ucc98\ub9ac", url: "#_12" },
              {title: "\ucf54\ub4dc \uc608\uc81c", url: "#_13" },
          ]},
          {title: "\uc561\ucd94\uc5d0\uc774\ud130 \uc81c\uc5b4", url: "#_14", children: [
              {title: "\uc81c\uc5b4 \uba85\ub839 \uc0dd\uc131 \ubc0f \uc804\uc1a1", url: "#_15" },
              {title: "\uba85\ub839 \uc804\uc1a1 \uba54\ucee4\ub2c8\uc998", url: "#_16" },
              {title: "\ucf54\ub4dc \uc608\uc81c", url: "#_17" },
          ]},
          {title: "\ub370\uc774\ud130 \ud1b5\uc2e0 \ubc0f \ub3d9\uae30\ud654", url: "#_18", children: [
              {title: "IPC (Inter-process Communication) \uae30\ubc95", url: "#ipc-inter-process-communication" },
              {title: "\ub3d9\uae30\ud654 \uba54\ucee4\ub2c8\uc998", url: "#_19" },
              {title: "\ucf54\ub4dc \uc608\uc81c", url: "#_20" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter%2010/1001/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter%2010/1001/" class="btn btn-xs btn-link">
        Xenomai 성능 튜닝 및 최적화
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0905/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0905/" class="btn btn-xs btn-link">
        실시간 신호 처리
      </a>
    </div>
    
  </div>

    

    <h2 id="_1">서론</h2>
<p>Xenomai는 실시간 성능을 필요로 하는 다양한 산업 애플리케이션에 널리 사용되는 실시간 프레임워크이다. 이 장에서는 Xenomai를 활용하여 실시간 데이터 수집 및 제어 시스템을 구현하는 사례 연구를 통해 산업 제어 시스템의 구조와 동작 방법을 상세히 설명한다.</p>
<h2 id="_2">시스템 개요</h2>
<h3 id="_3">시스템 설계 요구사항</h3>
<p>산업 제어 시스템은 여러 센서와 액추에이터를 제어하면서 안정적인 실시간 응답을 제공해야 한다. 주요 설계 요구사항은 다음과 같다:
- 실시간 응답성
- 높은 신뢰성 및 내구성
- 확장성
- 유지보수 용이성</p>
<h2 id="_4">아키텍처 개요</h2>
<h3 id="_5">하드웨어 구성</h3>
<p>산업 제어 시스템의 하드웨어 구성 요소는 다음과 같다:
- <strong>중앙 처리 장치(CPU)</strong>: 시스템의 두뇌로, 실시간 연산을 수행한다.
- <strong>센서</strong>: 다양한 데이터를 수집한다. 예를 들어 온도, 압력, 습도 등을 측정한다.
- <strong>액추에이터</strong>: 특정 작업을 수행한다. 예를 들어 모터를 회전시키는 역할을 한다.
- <strong>네트워크 인터페이스</strong>: 다른 시스템과의 통신을 위한 네트워크 연결</p>
<h3 id="_6">소프트웨어 구성</h3>
<p>시스템 소프트웨어는 주로 Xenomai를 기반으로 구성되어 있다:
- <strong>핵심 Xenomai 라이브러리</strong>: 실시간 작업 스케줄링을 담당한다.
- <strong>실시간 태스크</strong>: 특정 주기마다 실행되는 작업, 센서 데이터 수집 및 제어 명령 전송 등을 수행한다.
- <strong>IPC(Inter-process Communication)</strong>: 데이터 공유 및 동기화를 위한 통신 메커니즘</p>
<h2 id="xenomai">Xenomai 기반 실시간 태스크 설계</h2>
<h3 id="_7">실시간 태스크의 분류</h3>
<p>실시간 태스크는 각기 다른 우선순위를 가지고 다음과 같이 분류된다:
- <strong>고우선 태스크</strong>: 짧은 주기로 자주 발생하는 긴급 작업. 예를 들어, 시스템 안정성 모니터링
- <strong>저우선 태스크</strong>: 긴 주기로 발생하거나, 긴급하지 않은 작업. 예를 들어 데이터 로깅 및 보고서 생성</p>
<h3 id="_8">실행 주기 및 스케줄링</h3>
<p>실시간 태스크는 실행 주기와 우선순위를 기반으로 스케줄링된다. 다음은 주요 설정 변수이다:
- <strong>실행 주기 (T)</strong>: 태스크가 주기적으로 실행되는 주기, 예를 들어 10ms
- <strong>우선순위 (P)</strong>: 태스크가 시스템 내 다른 작업에 비해 얼마나 중요한지를 나타낸다.</p>
<p>수식을 통해 스케줄링을 설명하면 다음과 같다:</p>
<p>$$</p>
<p>T_i = \frac{1}{f_i}</p>
<p>$$</p>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">T_i</span><script type="math/tex">T_i</script></span>는 i번째 태스크의 실행 주기이고, <span class="arithmatex"><span class="MathJax_Preview">f_i</span><script type="math/tex">f_i</script></span>는 태스크의 실행 빈도이다.</p>
<h3 id="_9">코드 예제</h3>
<p>아래는 주기적으로 실행되는 실시간 태스크의 코드 예제이다:</p>
<pre><code class="language-c">#include &lt;xenomai/init.h&gt;
#include &lt;xenomai/native/task.h&gt;

RT_TASK my_task;

void my_task_proc(void *arg) {
    while (1) {
        rt_printf(&quot;실시간 태스크 실행 중...\n&quot;);
        rt_task_sleep(rt_timer_ns2ticks(10000000)); // 10ms 주기
    }
}

int main(int argc, char *argv[]) {
    rt_task_create(&amp;my_task, &quot;MyTask&quot;, 0, 99, 0);
    rt_task_start(&amp;my_task, &amp;my_task_proc, NULL);

    pause();
    return 0;
}
</code></pre>
<h2 id="_10">센서 데이터 수집 및 처리</h2>
<h3 id="_11">데이터 수집 메커니즘</h3>
<p>센서 데이터는 주기적으로 수집되며, 각 센서는 고유의 인터페이스를 통해 데이터를 보내게 된다:
- <strong>폴링 방식</strong>: 주기적으로 센서 상태를 확인하여 데이터를 읽는 방식
- <strong>인터럽트 방식</strong>: 센서에서 신호를 보내 데이터를 즉시 읽어들이는 방식</p>
<h3 id="_12">데이터 전처리</h3>
<p>수집된 데이터는 원시 상태로 사용하기 전에 전처리가 필요하다:
- <strong>필터링</strong>: 노이즈 제거
- <strong>변환</strong>: 센서 출력값을 의미 있는 단위로 변환
- <strong>평균화</strong>: 일관된 값을 얻기 위해 여러 샘플의 평균값 계산</p>
<h3 id="_13">코드 예제</h3>
<p>아래는 주기적으로 센서 데이터를 수집하고 전처리하는 예제 코드이다:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;xenomai/native/task.h&gt;

#define NUM_SENSORS 3
#define DATA_LENGTH 100

RT_TASK data_collect_task;

int sensor_data[NUM_SENSORS][DATA_LENGTH];

void data_collect_proc(void *arg) {
    int sensor_idx;
    while (1) {
        for (sensor_idx = 0; sensor_idx &lt; NUM_SENSORS; sensor_idx++) {
            sensor_data[sensor_idx][0] = read_sensor(sensor_idx);
            filter_data(sensor_data[sensor_idx]);
            convert_data(sensor_data[sensor_idx]);
            store_data(sensor_data[sensor_idx]);
        }
        rt_task_sleep(rt_timer_ns2ticks(5000000)); // 5ms 주기
    }
}

int main(int argc, char *argv[]) {
    rt_task_create(&amp;data_collect_task, &quot;DataCollectTask&quot;, 0, 99, 0);
    rt_task_start(&amp;data_collect_task, &amp;data_collect_proc, NULL);

    pause();
    return 0;
}
</code></pre>
<h2 id="_14">액추에이터 제어</h2>
<h3 id="_15">제어 명령 생성 및 전송</h3>
<p>액추에이터 제어는 실시간으로 생성된 제어 명령을 액추에이터에 전달함으로써 수행된다:
- <strong>PID 제어</strong>: Proportional-Integral-Derivative 컨트롤러를 사용하여 시스템을 안정화하고 원하는 상태로 유지
- <strong>상태 피드백 제어</strong>: 현재 상태를 피드백 받아 제어 시스템을 최적화</p>
<h3 id="_16">명령 전송 메커니즘</h3>
<p>명령 전송은 다음과 같은 방식으로 이루어진다:
- <strong>Direct Memory Access (DMA)</strong>: 대량 데이터 전송시 효율적으로 사용
- <strong>직렬 통신 (UART, I2C, SPI)</strong>: 특정 장치에 명령을 전송할 때 사용
- <strong>이더넷 통신</strong>: 원거리 장치 제어 시 사용</p>
<h3 id="_17">코드 예제</h3>
<p>아래는 주기적으로 액추에이터를 제어하는 예제 코드이다:</p>
<pre><code class="language-c">#include &lt;xenomai/native/task.h&gt;

RT_TASK control_task;

void control_proc(void *arg) {
    int control_cmd;
    while (1) {
        control_cmd = generate_control_cmd();
        send_control_cmd(control_cmd);
        rt_task_sleep(rt_timer_ns2ticks(10000000)); // 10ms 주기
    }
}

int main(int argc, char *argv[]) {
    rt_task_create(&amp;control_task, &quot;ControlTask&quot;, 0, 99, 0);
    rt_task_start(&amp;control_task, &amp;control_proc, NULL);

    pause();
    return 0;
}
</code></pre>
<h2 id="_18">데이터 통신 및 동기화</h2>
<h3 id="ipc-inter-process-communication">IPC (Inter-process Communication) 기법</h3>
<p>다수의 실시간 태스크가 동시에 실행되면서 데이터를 공유하고 통신하기 위해 IPC 기법이 사용된다. 주요 IPC 기법은 다음과 같다:
- <strong>파이프(pipe)</strong>
- <strong>큐(queue)</strong>
- <strong>공유 메모리(shared memory)</strong></p>
<h3 id="_19">동기화 메커니즘</h3>
<p>동기화는 경쟁 조건을 방지하고 데이터 일관성을 유지하기 위해 매우 중요하다. 주요 동기화 메커니즘은 다음과 같다:
- <strong>뮤텍스(Mutex)</strong>
- <strong>세마포어(Semaphore)</strong>
- <strong>이벤트(Event)FLAGS</strong></p>
<h3 id="_20">코드 예제</h3>
<p>아래는 큐를 사용해 데이터 통신을 구현하는 예제 코드이다:</p>
<pre><code class="language-c">#include &lt;xenomai/native/task.h&gt;
#include &lt;xenomai/native/queue.h&gt;

RT_QUEUE my_queue;

RT_TASK producer_task;
RT_TASK consumer_task;

void producer_proc(void *arg) {
    while (1) {
        int data = generate_data();
        rt_queue_write(&amp;my_queue, &amp;data, sizeof(data), Q_NORMAL);
        rt_task_sleep(rt_timer_ns2ticks(1000000)); // 1ms 주기
    }
}

void consumer_proc(void *arg) {
    int data;
    while (1) {
        if (rt_queue_read(&amp;my_queue, &amp;data, sizeof(data), TM_INFINITE) &gt; 0) {
            process_data(data);
        }
    }
}

int main(int argc, char *argv[]) {
    rt_queue_create(&amp;my_queue, &quot;MyQueue&quot;, 10 * sizeof(int), Q_FIFO);

    rt_task_create(&amp;producer_task, &quot;ProducerTask&quot;, 0, 99, 0);
    rt_task_start(&amp;producer_task, &amp;producer_proc, NULL);

    rt_task_create(&amp;consumer_task, &quot;ConsumerTask&quot;, 0, 99, 0);
    rt_task_start(&amp;consumer_task, &amp;consumer_proc, NULL);

    pause();
    return 0;
}
</code></pre>
<p>Xenomai를 활용한 산업 제어 시스템은 높은 신뢰성과 실시간 응답성을 제공하여 다양한 산업 애플리케이션에 적합한다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter%2010/1001/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter%2010/1001/" class="btn btn-xs btn-link">
        Xenomai 성능 튜닝 및 최적화
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0905/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0905/" class="btn btn-xs btn-link">
        실시간 신호 처리
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>