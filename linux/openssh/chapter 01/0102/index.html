<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/linux/openssh/chapter%2001/0102/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>주요 기능과 이점 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc554\ud638\ud654\ub41c \ud1b5\uc2e0", url: "#_top", children: [
          ]},
          {title: "\uc778\uc99d \uae30\ub2a5", url: "#_2", children: [
          ]},
          {title: "\ud3ec\ud2b8 \ud3ec\uc6cc\ub529 \uae30\ub2a5", url: "#_3", children: [
          ]},
          {title: "\ud130\ub110\ub9c1 \uae30\ub2a5", url: "#_4", children: [
          ]},
          {title: "X11 \ud3ec\uc6cc\ub529", url: "#x11", children: [
          ]},
          {title: "SOCKS \ud504\ub85d\uc2dc \uae30\ub2a5", url: "#socks", children: [
          ]},
          {title: "\ud30c\uc77c \uc804\uc1a1 \uae30\ub2a5", url: "#_5", children: [
              {title: "SCP (Secure Copy)", url: "#scp-secure-copy" },
              {title: "SFTP (Secure File Transfer Protocol)", url: "#sftp-secure-file-transfer-protocol" },
          ]},
          {title: "\uacf5\uac1c\ud0a4 \uae30\ubc18 \uc778\uc99d", url: "#_6", children: [
          ]},
          {title: "\uba40\ud2f0\ud329\ud130 \uc778\uc99d", url: "#_7", children: [
          ]},
          {title: "\ud3ec\ud2b8 \ud3ec\uc6cc\ub529", url: "#_8", children: [
          ]},
          {title: "SSH \uc5d0\uc774\uc804\ud2b8\uc640 \uc5d0\uc774\uc804\ud2b8 \ud3ec\uc6cc\ub529", url: "#ssh", children: [
              {title: "SSH \uc5d0\uc774\uc804\ud2b8\uc758 \uc5ed\ud560", url: "#ssh_1" },
              {title: "\uc5d0\uc774\uc804\ud2b8 \ud3ec\uc6cc\ub529", url: "#_9" },
          ]},
          {title: "\uc554\ud638\ud654 \uc54c\uace0\ub9ac\uc998 \ubc0f \ubcf4\uc548 \ub808\uc774\uc5b4", url: "#_10", children: [
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0103/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0103/" class="btn btn-xs btn-link">
        OpenSSH의 구성 요소
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0101/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0101/" class="btn btn-xs btn-link">
        OpenSSH의 역사와 발전
      </a>
    </div>
    
  </div>

    

    <h3 id="_1">암호화된 통신</h3>
<p>OpenSSH의 가장 핵심적인 기능 중 하나는 암호화된 통신을 제공하는 것이다. 이를 통해 네트워크 상에서 전송되는 모든 데이터를 안전하게 보호할 수 있으며, 이로 인해 중간에 데이터가 가로채지더라도 해독할 수 없다. SSH는 다양한 암호화 알고리즘을 사용하여 세션 데이터를 보호하며, 그 중 가장 대표적인 알고리즘으로는 AES (Advanced Encryption Standard), Blowfish, 3DES 등이 있다.</p>
<ul>
<li>
<p>AES (Advanced Encryption Standard)는 블록 암호 방식으로, 데이터를 128비트, 192비트, 또는 256비트로 암호화하여 안전한 통신을 보장한다.</p>
</li>
<li>
<p>Blowfish는 빠르고 효율적인 암호화 알고리즘으로, 종종 CPU 자원이 적은 환경에서 사용된다.</p>
</li>
<li>
<p>3DES는 데이터를 3번 암호화하는 방식으로, 일반적인 DES보다 더 강력한 보안을 제공하지만 속도가 느리다는 단점이 있다.</p>
</li>
</ul>
<p>암호화는 대칭키 암호화 방식을 사용하는데, 이는 클라이언트와 서버가 동일한 키를 공유하여 데이터를 암호화하고 복호화하는 방식이다. 이러한 방식의 장점은 빠르다는 점이지만, 키 교환 방식에서 문제가 발생할 수 있다. 이를 보완하기 위해 SSH에서는 Diffie-Hellman 키 교환 방식을 사용하여 안전한 키 교환을 보장한다.</p>
<h3 id="_2">인증 기능</h3>
<p>OpenSSH는 다양한 인증 방법을 지원하며, 이는 SSH 프로토콜의 또 다른 중요한 기능이다. 기본적으로 OpenSSH는 비밀번호 기반 인증과 공개키 기반 인증을 제공하지만, 그 외에도 Kerberos, GSSAPI, 인증서 기반 인증 등 고급 인증 방법을 지원한다.</p>
<ul>
<li>
<p><strong>비밀번호 기반 인증</strong>은 가장 간단한 방식으로, 사용자는 SSH 서버에 접속할 때 사용자명과 비밀번호를 입력하여 인증을 수행한다.</p>
</li>
<li>
<p><strong>공개키 기반 인증</strong>은 공개키와 개인키 쌍을 사용하는 인증 방식이다. 사용자는 개인키를 로컬 컴퓨터에 보관하고, 서버에는 해당 공개키를 등록하여 비밀번호 없이 인증을 수행할 수 있다.</p>
</li>
</ul>
<p>공개키 기반 인증은 비밀번호 기반 인증보다 훨씬 안전한 방법이다. 이를 수식으로 표현하면, 사용자가 소유한 개인키 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K_{private}}</span><script type="math/tex">\mathbf{K_{private}}</script></span>와 서버에 등록된 공개키 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K_{public}}</span><script type="math/tex">\mathbf{K_{public}}</script></span>가 서로 쌍을 이루며, 다음과 같은 관계가 성립한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{E_{public}}(M) = C \quad \text{and} \quad \mathbf{D_{private}}(C) = M
</div>
<script type="math/tex; mode=display">
\mathbf{E_{public}}(M) = C \quad \text{and} \quad \mathbf{D_{private}}(C) = M
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{E_{public}}</span><script type="math/tex">\mathbf{E_{public}}</script></span>는 공개키를 이용한 암호화, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D_{private}}</span><script type="math/tex">\mathbf{D_{private}}</script></span>는 개인키를 이용한 복호화 과정을 의미하며, <span class="arithmatex"><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>은 원문 메시지, <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>는 암호화된 메시지이다.</p>
<h3 id="_3">포트 포워딩 기능</h3>
<p>포트 포워딩은 SSH의 또 다른 중요한 기능으로, 네트워크의 다른 서버나 클라이언트와의 연결을 중계하는 역할을 한다. 이는 로컬 포트 포워딩, 원격 포트 포워딩, 그리고 동적 포트 포워딩으로 구분된다.</p>
<ul>
<li>
<p><strong>로컬 포트 포워딩</strong>은 클라이언트의 특정 로컬 포트를 SSH 서버를 통해 다른 서버로 전달하는 방식이다. 이를 통해 외부 네트워크의 자원을 안전하게 사용할 수 있다.</p>
</li>
<li>
<p><strong>원격 포트 포워딩</strong>은 반대로, SSH 서버가 클라이언트의 로컬 포트로 트래픽을 전달하는 방식이다. 주로 원격 네트워크에서 클라이언트 네트워크 자원을 접근할 때 유용하다.</p>
</li>
<li>
<p><strong>동적 포트 포워딩</strong>은 SOCKS 프록시를 통해 다양한 대상 서버와의 통신을 중계할 수 있는 방식으로, 클라이언트가 다양한 포트와 연결할 때 사용된다.</p>
</li>
</ul>
<p>이러한 포트 포워딩 기능을 활용하면, 일반적으로 접근이 제한된 서버나 네트워크에 안전하게 접근할 수 있게 되며, 특히 방화벽 뒤에 있는 서버와의 통신에 유용하다.</p>
<h3 id="_4">터널링 기능</h3>
<p>OpenSSH의 <strong>터널링(Tunneling)</strong> 기능은 클라이언트와 서버 간에 안전한 통신 채널을 생성하여 데이터를 보호하는 또 하나의 강력한 기능이다. 이 기능은 보안 터널을 통해 네트워크 트래픽을 전송하여 외부 네트워크의 공격자로부터 데이터를 보호할 수 있다.</p>
<p>SSH 터널링은 특히 보안이 취약한 공용 네트워크에서 민감한 데이터를 보호하기 위해 사용된다. 로컬 네트워크 내에 있는 다른 서버나 서비스에 접속할 때, SSH 터널을 이용하면 데이터가 암호화된 상태로 전송되므로 중간에서 데이터가 유출될 위험이 줄어든다.</p>
<p>터널링에는 로컬, 원격, 동적 포트 포워딩이 포함되며, 이는 앞서 설명한 포트 포워딩 방식과 결합되어 네트워크 보안을 강화하는 데 중요한 역할을 한다.</p>
<h3 id="x11">X11 포워딩</h3>
<p>OpenSSH는 원격 서버의 GUI 애플리케이션을 로컬 클라이언트에서 실행할 수 있게 해주는 <strong>X11 포워딩</strong> 기능을 제공한다. 이는 주로 유닉스 기반 시스템에서 사용되며, 사용자가 원격 서버의 X 윈도우 애플리케이션을 로컬에서 사용할 수 있도록 돕는다.</p>
<p>이를 활성화하기 위해서는 SSH 클라이언트와 서버에서 X11 포워딩을 설정해야 한다. SSH 설정 파일에서 다음과 같이 구성할 수 있다.</p>
<pre><code>X11Forwarding yes
X11DisplayOffset 10
</code></pre>
<p>X11 포워딩은 원격 서버에서 그래픽 환경을 필요로 하는 작업을 수행할 때 유용하지만, 보안상 주의가 필요하다. 이를 통해 공격자가 악의적인 목적으로 서버에 접근할 가능성이 있기 때문에 사용 시 반드시 안전한 환경에서 적용해야 한다.</p>
<h3 id="socks">SOCKS 프록시 기능</h3>
<p>OpenSSH는 <strong>SOCKS5 프록시</strong> 기능을 통해 다양한 클라이언트와 서버 간의 통신을 지원한다. SOCKS 프록시는 SSH를 통해 외부 네트워크로의 모든 트래픽을 중계하며, 이 과정에서 데이터를 암호화하여 보안을 강화한다.</p>
<p>SOCKS 프록시를 설정하는 방법은 간단하다. SSH 클라이언트에서 <code>-D</code> 옵션을 사용하여 SOCKS 프록시 포트를 지정할 수 있다. 예를 들어, 다음과 같이 프록시를 설정할 수 있다.</p>
<pre><code>ssh -D 1080 user@server
</code></pre>
<p>위 명령은 클라이언트 측에서 포트 1080을 열고, 그 포트를 통해 원격 서버와의 연결을 암호화하여 중계한다. 이를 통해 다양한 네트워크 애플리케이션에서 OpenSSH를 프록시로 사용할 수 있다.</p>
<h3 id="_5">파일 전송 기능</h3>
<p>OpenSSH는 안전한 파일 전송을 위한 두 가지 주요 기능을 제공한다: <strong>SCP(Secure Copy)</strong>와 <strong>SFTP(Secure File Transfer Protocol)</strong>. 이 기능들은 네트워크 상에서 안전하게 파일을 전송하기 위한 방법으로, 전송되는 파일 데이터를 암호화하여 제3자가 데이터를 중간에서 가로챌 수 없게 한다.</p>
<h4 id="scp-secure-copy">SCP (Secure Copy)</h4>
<p><strong>SCP</strong>는 SSH 프로토콜을 사용하여 원격 서버와 로컬 컴퓨터 간에 파일을 안전하게 복사할 수 있는 기능이다. SCP는 간단한 명령어 인터페이스를 제공하며, 이를 사용하면 다음과 같이 파일을 전송할 수 있다.</p>
<pre><code>scp localfile user@server:/path/to/remote/
</code></pre>
<p>이 명령어는 로컬 파일을 원격 서버의 지정된 경로로 복사한다. 반대로 원격 서버에서 로컬로 파일을 복사하려면 다음과 같이 사용할 수 있다.</p>
<pre><code>scp user@server:/path/to/remotefile localpath/
</code></pre>
<p>SCP는 직관적이고 빠른 파일 전송 방법을 제공하지만, 파일 전송 도중 중단되면 재개할 수 없다는 단점이 있다. 이런 상황에서 더 유연한 대안으로 SFTP를 사용할 수 있다.</p>
<h4 id="sftp-secure-file-transfer-protocol">SFTP (Secure File Transfer Protocol)</h4>
<p><strong>SFTP</strong>는 SSH 프로토콜 위에서 작동하는 파일 전송 프로토콜로, FTP와 유사한 인터페이스를 제공하지만 전송되는 데이터가 암호화된다는 점에서 차별화된다. SFTP는 파일의 전송, 삭제, 이름 변경, 디렉터리 탐색 등의 작업을 지원하며, 네트워크 중단 시 파일 전송을 재개할 수 있는 기능을 제공한다.</p>
<p>SFTP를 사용하려면 SSH를 통해 서버에 접속한 후 SFTP 세션을 시작할 수 있다.</p>
<pre><code>sftp user@server
</code></pre>
<p>이후 SFTP 세션 내에서 다음과 같은 명령을 사용할 수 있다.</p>
<ul>
<li><code>put localfile</code> : 로컬 파일을 원격 서버에 업로드</li>
<li><code>get remotefile</code> : 원격 서버의 파일을 로컬로 다운로드</li>
<li><code>ls</code> : 원격 서버의 디렉터리 목록을 확인</li>
<li><code>cd</code> : 원격 서버의 디렉터리를 변경</li>
</ul>
<p>SFTP는 SCP보다 더 다양한 기능을 제공하며, 주로 안정적이고 대용량 파일을 전송할 때 유용하다.</p>
<h3 id="_6">공개키 기반 인증</h3>
<p>OpenSSH는 <strong>공개키 기반 인증</strong>을 통해 비밀번호 없이 안전하게 서버에 접속할 수 있다. 이 방법은 개인키와 공개키의 쌍을 사용하는 방식으로, 사용자는 개인키를 로컬 컴퓨터에 저장하고, 서버에는 공개키를 등록하여 비밀번호 없이 서버에 접속할 수 있다.</p>
<ol>
<li>먼저 SSH 키 쌍을 생성한다.</li>
</ol>
<pre><code>ssh-keygen -t rsa
</code></pre>
<p>이 명령어를 사용하면 RSA 알고리즘을 기반으로 개인키와 공개키가 생성된다. 기본적으로 키는 <code>~/.ssh</code> 디렉토리에 저장되며, 개인키는 <code>id_rsa</code>, 공개키는 <code>id_rsa.pub</code>라는 파일 이름으로 저장된다.</p>
<ol>
<li>공개키를 서버에 등록한다.</li>
</ol>
<pre><code>ssh-copy-id user@server
</code></pre>
<p>위 명령어를 사용하면 로컬 컴퓨터의 공개키를 원격 서버에 복사하여 등록할 수 있다. 등록이 완료되면, 이후 서버 접속 시 비밀번호 입력 없이 개인키를 통해 인증이 이루어진다.</p>
<p>공개키 기반 인증의 장점은 비밀번호를 입력할 필요가 없다는 점 외에도, 비밀번호 기반 인증보다 훨씬 안전하다는 것이다. 비밀번호는 중간에서 탈취당할 가능성이 있는 반면, 개인키와 공개키를 사용하는 인증 방식은 중간 공격을 방지할 수 있다.</p>
<h3 id="_7">멀티팩터 인증</h3>
<p>OpenSSH는 <strong>멀티팩터 인증(MFA, Multi-Factor Authentication)</strong>을 통해 보안성을 강화할 수 있다. 멀티팩터 인증은 사용자가 서버에 접속할 때 두 가지 이상의 인증 방법을 요구하는 방식으로, 일반적으로 비밀번호 또는 공개키 인증과 함께 추가적인 인증 방법을 결합하여 보안을 강화한다. 예를 들어, 비밀번호 인증 후에 OTP(One-Time Password)를 사용하는 방식이 일반적이다.</p>
<ol>
<li><strong>TOTP(Time-based One-Time Password)</strong> 기반 인증 설정:</li>
</ol>
<p>OpenSSH는 Google Authenticator와 같은 TOTP 기반 앱을 통해 멀티팩터 인증을 구현할 수 있다. 이를 설정하기 위해서는 서버에 PAM(Pluggable Authentication Modules)을 설정하고 <code>pam_google_authenticator.so</code> 모듈을 활성화해야 한다.</p>
<p>PAM 설정 파일(<code>/etc/pam.d/sshd</code>)에 다음 내용을 추가하여 Google Authenticator 모듈을 활성화할 수 있다.</p>
<p><code>auth required pam_google_authenticator.so</code></p>
<p>이후 사용자는 Google Authenticator 앱에서 생성된 OTP를 SSH 접속 시 입력하여 인증할 수 있다.</p>
<ol>
<li><strong>U2F(FIDO Universal 2nd Factor)</strong> 기반 인증 설정:</li>
</ol>
<p>U2F는 보안키(예: YubiKey)를 이용한 물리적 인증 방법으로, 이를 통해 사용자는 비밀번호나 공개키 인증에 추가하여 보안키를 사용해 더 높은 보안을 제공받을 수 있다. U2F 보안키는 SSH에서 인증서 기반 인증과 함께 사용할 수 있으며, 서버 설정에 따라 SSH 접속 시 U2F 키를 요구하도록 설정할 수 있다.</p>
<p>멀티팩터 인증을 사용하면 사용자가 비밀번호나 공개키만으로 접속하는 것보다 훨씬 안전하게 서버를 보호할 수 있다. 특히, 공격자가 비밀번호를 탈취하더라도 추가적인 인증 방법이 필요하기 때문에 보안성을 크게 향상시킬 수 있다.</p>
<h3 id="_8">포트 포워딩</h3>
<p>포트 포워딩은 OpenSSH에서 자주 사용되는 기능 중 하나로, 클라이언트와 서버 간에 안전한 터널을 형성하여 특정 네트워크 트래픽을 전달할 수 있다. 이를 통해 사용자는 로컬, 원격, 동적 포트 포워딩을 설정하여 네트워크 보안을 강화할 수 있다.</p>
<ol>
<li><strong>로컬 포트 포워딩</strong>:</li>
</ol>
<p>로컬 포트 포워딩은 클라이언트의 로컬 포트를 통해 원격 서버와의 연결을 중계하는 방식이다. 예를 들어, 로컬 머신에서 8080 포트를 사용하여 원격 서버의 80번 포트로 연결을 중계하려면 다음 명령을 사용할 수 있다.</p>
<p><code>ssh -L 8080:localhost:80 user@server</code></p>
<p>이 명령은 로컬의 8080번 포트를 통해 원격 서버의 웹서버(포트 80)로 요청을 전송한다. 로컬 포트 포워딩은 내부 네트워크 리소스에 안전하게 접근할 수 있게 해주며, 방화벽을 통과하여 외부 네트워크 리소스에 접근할 때도 유용하다.</p>
<ol>
<li><strong>원격 포트 포워딩</strong>:</li>
</ol>
<p>원격 포트 포워딩은 반대로, 원격 서버에서 특정 포트를 로컬 클라이언트로 전달하는 방식이다. 이를 통해 원격 서버에서 로컬 머신의 자원에 접근할 수 있다.</p>
<p><code>ssh -R 8080:localhost:80 user@server</code></p>
<p>이 명령은 원격 서버의 8080번 포트를 로컬 클라이언트의 80번 포트로 연결한다. 주로 원격 서버에서 로컬 네트워크에 있는 자원에 접근할 때 사용된다.</p>
<ol>
<li><strong>동적 포트 포워딩</strong>:</li>
</ol>
<p>동적 포트 포워딩은 SOCKS 프록시와 유사하게 다양한 목적지의 포트로 트래픽을 전송할 수 있다. 클라이언트는 SSH를 통해 외부 네트워크로의 모든 트래픽을 프록시처럼 보낼 수 있으며, 이를 통해 네트워크 보안과 익명성을 강화할 수 있다.</p>
<p><code>ssh -D 1080 user@server</code></p>
<p>이 명령은 로컬 머신의 1080번 포트에서 SSH 터널을 통해 원격 서버로 트래픽을 보낸다. 다양한 애플리케이션에서 이 포트를 SOCKS 프록시로 설정하여 사용할 수 있다.</p>
<h3 id="ssh">SSH 에이전트와 에이전트 포워딩</h3>
<p>OpenSSH는 <strong>SSH 에이전트(ssh-agent)</strong>를 통해 사용자가 여러 SSH 서버에 접속할 때 비밀번호나 개인키 암호를 반복적으로 입력하지 않아도 되는 편리한 인증 방법을 제공한다. SSH 에이전트는 로컬 머신에서 SSH 개인키를 메모리에 저장하고, SSH 클라이언트가 서버에 접속할 때 해당 키를 사용해 인증을 수행할 수 있도록 지원한다.</p>
<h4 id="ssh_1">SSH 에이전트의 역할</h4>
<p>SSH 에이전트는 SSH 키 기반 인증을 자동화하는 역할을 한다. 이를 통해 사용자는 개인키에 암호를 설정해도 매번 암호를 입력할 필요 없이, SSH 에이전트에 한 번만 암호를 입력하면 나중에 SSH 서버에 접속할 때 자동으로 인증을 수행할 수 있다.</p>
<ol>
<li><strong>SSH 에이전트 시작</strong>:</li>
</ol>
<p>대부분의 리눅스 배포판에서는 기본적으로 SSH 에이전트가 시작되지만, 수동으로 시작할 수도 있다.</p>
<p><code>eval "$(ssh-agent -s)"</code></p>
<p>위 명령은 SSH 에이전트를 백그라운드에서 실행시키고, 필요한 환경 변수를 설정한다.</p>
<ol>
<li><strong>SSH 키 에이전트에 추가</strong>:</li>
</ol>
<p>에이전트를 실행한 후, 사용자는 개인키를 에이전트에 추가하여 사용할 수 있다.</p>
<p><code>ssh-add ~/.ssh/id_rsa</code></p>
<p>위 명령은 <code>id_rsa</code> 개인키를 에이전트에 추가하여, SSH 서버 접속 시 이 키를 자동으로 사용할 수 있도록 한다.</p>
<h4 id="_9">에이전트 포워딩</h4>
<p><strong>SSH 에이전트 포워딩</strong>은 사용자가 한 SSH 서버에서 다른 SSH 서버로 접속할 때도 에이전트의 인증 정보를 사용할 수 있도록 하는 기능이다. 이 기능을 사용하면, 사용자가 중간 서버를 거쳐 최종 서버로 접속할 때 개인키를 복사하거나 재인증할 필요 없이 한 번의 인증으로 여러 서버에 연결할 수 있다.</p>
<ol>
<li><strong>SSH 에이전트 포워딩 설정</strong>:</li>
</ol>
<p>에이전트 포워딩을 사용하려면 SSH 클라이언트에서 <code>-A</code> 옵션을 사용하여 에이전트 포워딩을 활성화할 수 있다.</p>
<p><code>ssh -A user@intermediate_server</code></p>
<p>이 명령을 사용하면 중간 서버에 접속한 후, 그 서버에서 다시 최종 서버로 SSH 접속할 때도 에이전트에 저장된 인증 정보가 사용된다.</p>
<ol>
<li><strong>SSH 구성 파일에서 에이전트 포워딩 활성화</strong>:</li>
</ol>
<p>에이전트 포워딩을 SSH 클라이언트 설정 파일인 <code>~/.ssh/config</code>에서 자동으로 활성화할 수도 있다.</p>
<p><code>Host *
       ForwardAgent yes</code></p>
<p>위와 같이 설정하면, 모든 SSH 접속에서 자동으로 에이전트 포워딩이 활성화된다. 특정 호스트에만 적용하고 싶다면 <code>Host *</code> 대신 호스트명을 명시하면 된다.</p>
<p>에이전트 포워딩은 원격 서버에 접속할 때 개인키 파일을 복사하거나 여러 번 인증을 요구하지 않아 편리하지만, 보안상 위험 요소가 될 수 있다. 특히, 중간 서버가 신뢰할 수 없거나 공격에 노출된 경우, 에이전트 포워딩을 통한 인증 정보가 유출될 위험이 있으므로, 반드시 신뢰할 수 있는 서버에서만 사용해야 한다.</p>
<h3 id="_10">암호화 알고리즘 및 보안 레이어</h3>
<p>OpenSSH는 통신 과정에서 데이터를 보호하기 위해 다양한 암호화 알고리즘을 지원한다. SSH는 세션 데이터와 인증 정보를 암호화하기 위해 주로 대칭키 알고리즘을 사용하며, 이러한 알고리즘들은 보안성과 성능 면에서 중요한 역할을 한다.</p>
<ol>
<li><strong>대칭키 암호화 알고리즘</strong>:</li>
</ol>
<p>OpenSSH에서 주로 사용되는 대칭키 암호화 알고리즘으로는 AES, 3DES, Blowfish 등이 있다. 이러한 알고리즘들은 빠르게 데이터를 암호화하고 복호화할 수 있으며, 네트워크 성능을 크게 저하시키지 않으면서도 높은 수준의 보안을 제공한다.</p>
<ul>
<li>
<p><strong>AES (Advanced Encryption Standard)</strong>: AES는 블록 크기가 128비트이고, 128, 192, 256 비트의 키를 사용할 수 있는 대칭키 암호화 방식이다. AES는 현대적인 암호화 알고리즘 중 하나로, 안전성과 성능 면에서 뛰어난 평가를 받고 있다.</p>
</li>
<li>
<p><strong>3DES (Triple DES)</strong>: 3DES는 DES 알고리즘을 3번 반복하여 암호화하는 방식이다. DES의 취약점을 보완하기 위해 사용되지만, AES보다 속도가 느리다는 단점이 있다.</p>
</li>
<li>
<p><strong>Blowfish</strong>: Blowfish는 AES보다 가벼운 대칭키 암호화 알고리즘으로, 자원이 제한된 환경에서 종종 사용된다. 빠르고 간단하며, 비트 크기와 상관없이 다양한 키 길이를 사용할 수 있다는 장점이 있다.</p>
</li>
<li>
<p><strong>비대칭키 암호화 알고리즘</strong>:</p>
</li>
</ul>
<p>SSH는 세션 키 교환 및 인증 과정에서 비대칭키 암호화 알고리즘을 사용한다. 대표적인 비대칭키 암호화 알고리즘으로는 RSA, DSA, ECDSA 등이 있으며, 주로 공개키와 개인키 쌍을 사용하여 데이터를 보호한다.</p>
<ul>
<li>
<p><strong>RSA</strong>: RSA는 공개키와 개인키를 사용하여 데이터를 암호화하고 복호화하는 비대칭키 암호화 방식이다. 키 길이에 따라 안전성이 결정되며, 보통 2048비트 이상의 키 길이를 사용하여 높은 수준의 보안을 제공한다.</p>
</li>
<li>
<p><strong>ECDSA (Elliptic Curve Digital Signature Algorithm)</strong>: ECDSA는 RSA보다 짧은 키 길이로도 높은 보안을 제공하는 비대칭키 알고리즘이다. 타원 곡선 암호화 방식을 사용하여 성능을 최적화한 알고리즘으로, 모바일 기기나 자원이 제한된 환경에서 많이 사용된다.</p>
</li>
<li>
<p><strong>메시지 인증 코드 (MAC)</strong>:</p>
</li>
</ul>
<p>OpenSSH는 메시지의 무결성을 보장하기 위해 <strong>메시지 인증 코드(MAC, Message Authentication Code)</strong>를 사용한다. MAC는 데이터를 암호화하는 과정에서 데이터가 변조되지 않았음을 확인하는 방법으로, 주로 HMAC-SHA2, HMAC-MD5와 같은 해시 함수를 사용한다.</p>
<ul>
<li>
<p><strong>HMAC-SHA2</strong>: SHA2 해시 함수 기반의 MAC 알고리즘으로, 해시 함수의 결과값을 사용하여 데이터의 무결성을 확인한다.</p>
</li>
<li>
<p><strong>HMAC-MD5</strong>: MD5 해시 함수 기반의 MAC 알고리즘으로, 데이터 변조 여부를 확인한다. 하지만, MD5는 보안 취약점이 발견되어 현재는 사용이 권장되지 않는다.</p>
</li>
</ul>
<p>SSH는 이러한 다양한 암호화 알고리즘을 결합하여 통신 과정에서 데이터를 안전하게 보호하며, 사용자와 서버 간의 신뢰성을 보장한다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0103/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0103/" class="btn btn-xs btn-link">
        OpenSSH의 구성 요소
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0101/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0101/" class="btn btn-xs btn-link">
        OpenSSH의 역사와 발전
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>