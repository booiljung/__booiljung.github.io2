<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/sensor_data_processing/_pointcloud/chapter_02/0208/" rel="canonical"/>
<link href="../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>PCL의 확장성과 모듈화 - 실험 도서관</title>
<link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ubaa8\ub4c8\ud654 \uad6c\uc870", url: "#_top", children: [
          ]},
          {title: "\ud655\uc7a5\uc131", url: "#_2", children: [
              {title: "\ucf54\ub4dc \uc608\uc81c: \ud544\ud130 \ubaa8\ub4c8 \ud655\uc7a5", url: "#_3" },
          ]},
          {title: "PCL \ubaa8\ub4c8 \uac04 \uc0c1\ud638\uc791\uc6a9", url: "#pcl", children: [
          ]},
          {title: "\ubaa8\ub4c8 \ud655\uc7a5 \ubc29\ubc95", url: "#_4", children: [
              {title: "\uae30\uc874 \ubaa8\ub4c8 \ud655\uc7a5", url: "#_5" },
              {title: "\uc0c8\ub85c\uc6b4 \ubaa8\ub4c8 \ucd94\uac00", url: "#_6" },
          ]},
          {title: "PCL \ubaa8\ub4c8 \ud655\uc7a5\uc758 \uc2e4\uc81c \uc0ac\ub840", url: "#pcl_1", children: [
              {title: "\uc790\uc728\uc8fc\ud589\ucc28\uc5d0\uc11c\uc758 PCL \ud655\uc7a5 \uc608\uc81c", url: "#pcl_2" },
          ]},
          {title: "\ubcd1\ub82c \ucc98\ub9ac\uc640 \uc131\ub2a5 \ucd5c\uc801\ud654", url: "#_7", children: [
              {title: "OpenMP\ub97c \uc0ac\uc6a9\ud55c \ubcd1\ub82c \ucc98\ub9ac", url: "#openmp" },
              {title: "TBB\ub97c \uc0ac\uc6a9\ud55c \ubcd1\ub82c \ucc98\ub9ac", url: "#tbb" },
          ]},
          {title: "PCL\uc758 \ubaa8\ub4c8\ud654 \ud655\uc7a5 \uc0ac\ub840", url: "#pcl_3", children: [
          ]},
        ];

    </script>
<script src="../../../../js/base.js"></script>
<script src="../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<p>PCL(Point Cloud Library)은 포인트 클라우드 데이터를 다루는 다양한 기능을 제공하는 라이브러리로, 높은 확장성과 모듈화를 자랑한다. 이는 PCL이 다양한 사용자의 요구에 맞게 기능을 추가하거나 성능을 조정할 수 있는 구조를 가지고 있음을 의미한다. PCL의 확장성과 모듈화는 라이브러리의 각 구성 요소가 독립적으로 동작할 수 있도록 설계된 것이 특징이다. 이러한 특징 덕분에 PCL은 다양한 애플리케이션에서 유연하게 사용될 수 있다.</p>
<h3 id="_1">모듈화 구조</h3>
<p>PCL은 여러 모듈로 나뉘어져 있으며, 각각의 모듈은 특정 기능을 수행하도록 설계되었다. 이 모듈들은 상호 독립적으로 동작할 수 있으며, 필요한 모듈만을 선택적으로 사용할 수 있다. 이러한 구조 덕분에 사용자는 불필요한 코드나 기능을 포함하지 않고도 가볍고 빠른 애플리케이션을 개발할 수 있다.</p>
<p>PCL의 주요 모듈은 다음과 같다:</p>
<ul>
<li><strong>Filters</strong>: 포인트 클라우드 데이터를 필터링하여 노이즈 제거나 다운샘플링을 수행하는 모듈.</li>
<li><strong>Features</strong>: 포인트 클라우드에서 특징을 추출하고, 그 특징을 기반으로 매칭을 수행하는 모듈.</li>
<li><strong>Registration</strong>: 두 포인트 클라우드를 정렬하거나 매칭하는 기능을 제공하는 모듈.</li>
<li><strong>Segmentation</strong>: 포인트 클라우드 데이터를 여러 부분으로 나누는 모듈.</li>
<li><strong>Surface</strong>: 포인트 클라우드를 기반으로 3D 표면을 재구성하는 모듈.</li>
</ul>
<p>각 모듈은 해당 기능에 맞는 클래스를 제공하며, 다른 모듈과 결합하여 보다 복잡한 작업을 수행할 수 있다. 예를 들어, <strong>Filters</strong> 모듈을 사용하여 데이터에서 노이즈를 제거한 후, <strong>Segmentation</strong> 모듈을 이용해 객체를 분할하는 방식으로 작업을 진행할 수 있다.</p>
<h3 id="_2">확장성</h3>
<p>PCL의 확장성은 사용자가 라이브러리에 추가적인 기능을 쉽게 추가할 수 있도록 도와준다. 특히, PCL은 오픈소스 라이브러리로, 누구나 기존 모듈에 기능을 추가하거나 새로운 모듈을 개발하여 PCL에 기여할 수 있다. 확장을 위해서는 PCL의 클래스 구조와 기본적인 인터페이스를 이해하고, 해당 규칙에 맞추어 새로운 기능을 추가하면 된다.</p>
<p>예를 들어, PCL의 <strong>Filters</strong> 모듈에 새로운 필터링 방법을 추가하고 싶다면, 기존 필터 클래스를 상속받아 새로운 필터 클래스를 구현할 수 있다. 이는 PCL이 객체 지향적으로 설계되었기 때문에 가능한 일이다.</p>
<h4 id="_3">코드 예제: 필터 모듈 확장</h4>
<p>다음은 간단한 PCL의 필터 모듈을 확장하여 새로운 필터 클래스를 추가하는 예제이다. 이 예제에서는 기본 필터 클래스를 상속받아 새로운 필터링 방법을 구현한다.</p>
<pre><code class="language-cpp">#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/filters/filter.h&gt;
#include &lt;pcl/filters/passthrough.h&gt;

class MyCustomFilter : public pcl::Filter&lt;pcl::PointXYZ&gt;
{
protected:
    void applyFilter(pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; output) override
    {
        // 사용자 정의 필터링 로직을 여기에 구현
        for (size_t i = 0; i &lt; input_-&gt;points.size(); ++i)
        {
            // 포인트를 필터링할 조건을 정의
            if (input_-&gt;points[i].z &lt; 1.0) // z 축 값이 1.0 미만인 포인트만 포함
            {
                output.points.push_back(input_-&gt;points[i]);
            }
        }
        output.width = static_cast&lt;uint32_t&gt;(output.points.size());
        output.height = 1;
        output.is_dense = true;
    }
};

int main()
{
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

    // 포인트 클라우드를 생성하거나 로드
    cloud-&gt;points.push_back(pcl::PointXYZ(0.0, 0.0, 0.5));
    cloud-&gt;points.push_back(pcl::PointXYZ(1.0, 1.0, 2.0));

    // 사용자 정의 필터 객체 생성
    MyCustomFilter custom_filter;
    custom_filter.setInputCloud(cloud);
    custom_filter.filter(*filtered_cloud);

    // 필터링된 결과 출력
    for (const auto&amp; point : filtered_cloud-&gt;points)
    {
        std::cout &lt;&lt; "Filtered point: " &lt;&lt; point.x &lt;&lt; ", " &lt;&lt; point.y &lt;&lt; ", " &lt;&lt; point.z &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<p>이 코드에서는 <code>Filter</code> 클래스를 상속받아 사용자 정의 필터를 구현하였다. 이 필터는 <code>z</code> 값이 1.0 미만인 포인트만을 통과시키는 간단한 로직을 가지고 있다. 실제로는 이와 같이 PCL의 다양한 모듈을 확장하거나 새로운 기능을 추가하여 사용자 요구에 맞는 포인트 클라우드 처리를 구현할 수 있다.</p>
<h3 id="pcl">PCL 모듈 간 상호작용</h3>
<p>PCL의 모듈들은 각기 다른 기능을 수행하지만, 상호 간의 의존성을 적절하게 처리하여 복합적인 작업을 수행할 수 있다. 예를 들어, <strong>Filters</strong> 모듈에서 데이터를 정제한 후 <strong>Segmentation</strong> 모듈에서 객체를 분할하고, <strong>Registration</strong> 모듈을 통해 두 포인트 클라우드를 매칭하는 작업을 연속적으로 처리할 수 있다. 이를 통해 사용자는 자신만의 파이프라인을 구성하여 복잡한 포인트 클라우드 작업을 손쉽게 처리할 수 있다.</p>
<p>PCL이 제공하는 모듈들은 상호 독립적이지만, 특정 작업을 처리하는 데 있어 서로 결합하여 사용될 수 있다. 예를 들어, <strong>Features</strong> 모듈을 사용하여 특징점을 추출한 후, <strong>Registration</strong> 모듈을 사용하여 다른 포인트 클라우드와 매칭할 수 있다.</p>
<h3 id="_4">모듈 확장 방법</h3>
<p>PCL 모듈을 확장하는 방법은 크게 두 가지로 나눌 수 있다. 첫 번째는 기존 모듈의 클래스를 상속받아 새롭게 기능을 추가하는 방식이고, 두 번째는 완전히 새로운 모듈을 만들어 기존 모듈과 연동하는 방식이다.</p>
<h4 id="_5">기존 모듈 확장</h4>
<p>기존 모듈을 확장하는 방법은 앞서 설명한 코드 예제와 같이, PCL에서 제공하는 클래스들을 상속받아 새로운 기능을 구현하는 방식이다. 예를 들어, 필터 모듈을 확장하여 고유의 필터링 방법을 적용하거나, 특징 추출 모듈을 확장하여 새로운 특징 추출 알고리즘을 구현할 수 있다. </p>
<p>이러한 방식은 PCL의 기본 설계 구조인 객체 지향적 클래스 구조 덕분에 비교적 쉽다. 기존의 <code>applyFilter</code>, <code>computeFeature</code> 등과 같은 가상 함수를 오버라이드하여 확장할 수 있다.</p>
<pre><code class="language-cpp">class MyCustomFeatureExtractor : public pcl::Feature&lt;pcl::PointXYZ, pcl::FPFHSignature33&gt;
{
protected:
    void computeFeature(pcl::PointCloud&lt;pcl::FPFHSignature33&gt;&amp; output) override
    {
        // 새로운 특징 추출 로직을 구현
    }
};
</code></pre>
<p>위 코드에서 <code>Feature</code> 클래스를 상속받아 사용자 정의 특징 추출기를 구현하는 예시를 볼 수 있다. 이렇게 모듈 확장을 통해 기존 PCL이 제공하는 기능 외에도 사용자 맞춤형 기능을 추가할 수 있다.</p>
<h4 id="_6">새로운 모듈 추가</h4>
<p>기존 모듈이 제공하지 않는 완전히 새로운 기능이 필요할 때는, 새로운 모듈을 추가하여 PCL의 기존 모듈과 상호작용할 수 있다. 새로운 모듈을 추가하려면 PCL의 코어 라이브러리에서 제공하는 기본 클래스들을 적절히 활용하고, 다른 모듈과의 의존성을 관리하는 것이 중요하다.</p>
<p>이를 위해서는 새로운 모듈이 제공할 기능에 대한 명확한 설계가 필요하다. 보통 포인트 클라우드 데이터를 입력받아 새로운 알고리즘을 적용하거나 새로운 방식으로 데이터를 처리하는 모듈을 개발하게 된다.</p>
<p>다음은 새로운 모듈을 추가하는 기본적인 구조를 mermaid로 시각화한 것이다.</p>
<div class="mermaid">graph TB
    subgraph PCL Core
        A1[Point Cloud] --&gt; A2[Filters]
        A2 --&gt; A3[Segmentation]
    end
    B1[New Module] --&gt; A3
    A3 --&gt; A4[Registration]
    A4 --&gt; A5[Surface Reconstruction]
</div>
<p>여기서 새로운 모듈(B1)은 기존의 <strong>Segmentation</strong> 모듈과 연동되어 새로운 방식으로 데이터를 처리하고, <strong>Registration</strong> 및 <strong>Surface Reconstruction</strong> 모듈과 상호작용할 수 있다. PCL의 모듈화 구조 덕분에 이러한 확장은 비교적 쉽게 이루어질 수 있다.</p>
<h3 id="pcl_1">PCL 모듈 확장의 실제 사례</h3>
<p>PCL의 확장성은 다양한 산업과 연구 분야에서 활용되고 있다. 특히 자율주행차, 로봇공학, 3D 스캔 및 재구성 등 다양한 응용 사례에서 PCL이 확장되어 사용되고 있다. 예를 들어, 자율주행차에서는 라이다(LiDAR) 데이터를 실시간으로 처리하여 도로와 주변 환경을 인식하고, 이를 기반으로 주행 경로를 계획하는 데 PCL이 사용된다.</p>
<p>또한, 로봇공학에서는 로봇의 3D 환경 인식과 경로 계획, 물체 인식 및 매니퓰레이션을 위해 PCL이 확장되어 사용된다. 특히, 포인트 클라우드 데이터를 처리하여 환경의 장애물을 인식하고, 이를 기반으로 경로를 동적으로 조정하는 방식에서 PCL은 중요한 역할을 한다.</p>
<h4 id="pcl_2">자율주행차에서의 PCL 확장 예제</h4>
<p>자율주행차에서는 라이다 센서를 통해 실시간으로 포인트 클라우드를 획득하고, 이를 기반으로 도로와 주변 환경을 실시간으로 인식해야 한다. 이 과정에서 PCL을 확장하여 실시간 성능 최적화 및 병렬 처리를 구현할 수 있다.</p>
<pre><code class="language-cpp">#include &lt;pcl/point_cloud.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;
#include &lt;pcl/segmentation/sac_segmentation.h&gt;

int main()
{
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

    // 라이다 데이터를 로드
    pcl::io::loadPCDFile("lidar_data.pcd", *cloud);

    // VoxelGrid 필터를 이용한 다운샘플링
    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; voxel_filter;
    voxel_filter.setInputCloud(cloud);
    voxel_filter.setLeafSize(0.1f, 0.1f, 0.1f); // 10cm 단위로 다운샘플링
    voxel_filter.filter(*filtered_cloud);

    // 평면 탐지를 위한 세그먼테이션
    pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;
    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setDistanceThreshold(0.01);
    seg.setInputCloud(filtered_cloud);

    pcl::ModelCoefficients coefficients;
    pcl::PointIndices inliers;
    seg.segment(inliers, coefficients);

    // 결과 출력
    std::cout &lt;&lt; "Plane coefficients: " &lt;&lt; coefficients.values[0] &lt;&lt; " "
              &lt;&lt; coefficients.values[1] &lt;&lt; " " &lt;&lt; coefficients.values[2] &lt;&lt; " "
              &lt;&lt; coefficients.values[3] &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>이 예제에서는 자율주행차에서 라이다 데이터를 로드한 후, 다운샘플링과 평면 세그먼테이션을 수행하는 과정을 보여준다. PCL의 <strong>VoxelGrid</strong> 필터를 사용하여 포인트 클라우드를 간소화한 후, <strong>SACSegmentation</strong> 모듈을 사용하여 도로 평면을 탐지하는 방식이다.</p>
<h3 id="_7">병렬 처리와 성능 최적화</h3>
<p>PCL은 대용량의 포인트 클라우드 데이터를 다루기 때문에, 성능 최적화가 매우 중요한 요소이다. 특히 실시간 시스템에서는 데이터를 빠르게 처리해야 하므로 병렬 처리를 통해 성능을 크게 향상시킬 수 있다. PCL은 기본적으로 OpenMP 및 TBB(Threading Building Blocks)와 같은 멀티스레드 라이브러리를 지원하여 병렬 처리를 가능하게 한다.</p>
<h4 id="openmp">OpenMP를 사용한 병렬 처리</h4>
<p>OpenMP는 PCL 내에서 반복문을 병렬화하여 성능을 최적화하는 데 사용된다. 다음은 OpenMP를 사용하여 포인트 클라우드의 필터링 과정을 병렬화한 예제이다.</p>
<pre><code class="language-cpp">#include &lt;pcl/point_cloud.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;
#include &lt;omp.h&gt;

int main()
{
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

    // 포인트 클라우드를 로드하거나 생성
    cloud-&gt;points.push_back(pcl::PointXYZ(0.0, 0.0, 0.5));
    cloud-&gt;points.push_back(pcl::PointXYZ(1.0, 1.0, 2.0));

    // VoxelGrid 필터링을 병렬로 처리
    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; voxel_filter;
    voxel_filter.setInputCloud(cloud);
    voxel_filter.setLeafSize(0.1f, 0.1f, 0.1f);

    #pragma omp parallel for
    for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i)
    {
        // 병렬로 포인트를 필터링
        if (cloud-&gt;points[i].z &lt; 1.0) 
        {
            filtered_cloud-&gt;points.push_back(cloud-&gt;points[i]);
        }
    }

    // 필터링된 결과 출력
    for (const auto&amp; point : filtered_cloud-&gt;points)
    {
        std::cout &lt;&lt; "Filtered point: " &lt;&lt; point.x &lt;&lt; ", " &lt;&lt; point.y &lt;&lt; ", " &lt;&lt; point.z &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<p>위 예제에서 <code>#pragma omp parallel for</code> 구문을 사용하여 반복문이 병렬화되었고, 각 스레드는 포인트 클라우드에서 필터링 작업을 동시에 수행한다. 이처럼 OpenMP를 통해 반복문을 병렬화하면 다중 코어 시스템에서 성능을 크게 향상시킬 수 있다.</p>
<h4 id="tbb">TBB를 사용한 병렬 처리</h4>
<p>Intel의 Threading Building Blocks(TBB)는 PCL의 또 다른 성능 최적화 도구로, 더 정교한 병렬 처리를 가능하게 한다. OpenMP와 달리 TBB는 작업의 동적 병렬 처리를 지원하며, 특히 비정형 데이터 처리에 유리한다. PCL의 내부에서 TBB를 사용할 수 있으며, 이를 통해 대규모 포인트 클라우드 데이터를 병렬로 처리할 수 있다.</p>
<p>다음은 TBB를 이용해 포인트 클라우드 필터링을 최적화한 예제이다.</p>
<pre><code class="language-cpp">#include &lt;pcl/point_cloud.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;
#include &lt;tbb/parallel_for.h&gt;
#include &lt;tbb/blocked_range.h&gt;

int main()
{
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

    // 포인트 클라우드를 로드하거나 생성
    cloud-&gt;points.push_back(pcl::PointXYZ(0.0, 0.0, 0.5));
    cloud-&gt;points.push_back(pcl::PointXYZ(1.0, 1.0, 2.0));

    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; voxel_filter;
    voxel_filter.setInputCloud(cloud);
    voxel_filter.setLeafSize(0.1f, 0.1f, 0.1f);

    tbb::parallel_for(tbb::blocked_range&lt;size_t&gt;(0, cloud-&gt;points.size()),
                      [&amp;](const tbb::blocked_range&lt;size_t&gt;&amp; r)
                      {
                          for (size_t i = r.begin(); i != r.end(); ++i)
                          {
                              if (cloud-&gt;points[i].z &lt; 1.0)
                              {
                                  filtered_cloud-&gt;points.push_back(cloud-&gt;points[i]);
                              }
                          }
                      });

    // 필터링된 결과 출력
    for (const auto&amp; point : filtered_cloud-&gt;points)
    {
        std::cout &lt;&lt; "Filtered point: " &lt;&lt; point.x &lt;&lt; ", " &lt;&lt; point.y &lt;&lt; ", " &lt;&lt; point.z &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<p>이 예제에서는 TBB를 사용하여 필터링 작업을 병렬화하였다. <code>tbb::parallel_for</code> 함수는 데이터의 범위를 나누어 여러 스레드에서 동시에 처리할 수 있도록 한다. TBB는 작업 스케줄링을 동적으로 처리하기 때문에, 포인트 클라우드의 크기가 매우 클 때 유리한다.</p>
<h3 id="pcl_3">PCL의 모듈화 확장 사례</h3>
<p>PCL의 모듈화와 확장성 덕분에 다양한 응용 사례에서 PCL이 활용된다. 예를 들어, <strong>포인트 클라우드 등록(Registration)</strong> 모듈은 로봇공학이나 자율주행차에서 지도 생성 및 객체 추적에 널리 사용된다. 또한 <strong>세그먼테이션(Segmentation)</strong> 모듈은 물체 인식 및 로봇 매니퓰레이션에서 중요한 역할을 한다. 각각의 모듈은 독립적으로 동작할 수 있지만, 여러 모듈을 결합하여 복합적인 작업을 처리할 수 있다는 점에서 PCL의 확장성과 모듈화는 매우 유용하다.</p>
<p>특히, 자율주행차의 라이다 데이터를 처리하는 데 있어 PCL은 중요한 역할을 한다. PCL의 필터링 및 세그먼테이션 기능을 확장하여 실시간으로 도로와 주변 환경을 분석하고, 이를 기반으로 주행 경로를 계획할 수 있다.</p>
<p>다음은 라이다 데이터를 기반으로 3D 환경을 인식하고 객체를 분리하는 예제를 보여준다.</p>
<pre><code class="language-cpp">#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_cloud.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;
#include &lt;pcl/segmentation/extract_clusters.h&gt;

int main()
{
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

    // 포인트 클라우드 데이터를 로드
    pcl::io::loadPCDFile("lidar_data.pcd", *cloud);

    // VoxelGrid 필터를 이용한 다운샘플링
    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; voxel_filter;
    voxel_filter.setInputCloud(cloud);
    voxel_filter.setLeafSize(0.1f, 0.1f, 0.1f); // 10cm 단위로 다운샘플링
    voxel_filter.filter(*filtered_cloud);

    // 유클리드 클러스터링을 이용한 객체 분리
    pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
    tree-&gt;setInputCloud(filtered_cloud);

    std::vector&lt;pcl::PointIndices&gt; cluster_indices;
    pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;
    ec.setClusterTolerance(0.02); // 2cm 클러스터링 허용 범위
    ec.setMinClusterSize(100);
    ec.setMaxClusterSize(25000);
    ec.setSearchMethod(tree);
    ec.setInputCloud(filtered_cloud);
    ec.extract(cluster_indices);

    // 각 클러스터를 분리하여 출력
    int j = 0;
    for (const auto&amp; indices : cluster_indices)
    {
        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_cluster(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
        for (const auto&amp; index : indices.indices)
            cloud_cluster-&gt;points.push_back(filtered_cloud-&gt;points[index]);

        std::cout &lt;&lt; "Cluster " &lt;&lt; j &lt;&lt; ": " &lt;&lt; cloud_cluster-&gt;points.size() &lt;&lt; " points." &lt;&lt; std::endl;
        j++;
    }

    return 0;
}
</code></pre>
<p>이 예제에서는 라이다 데이터를 필터링한 후 유클리드 클러스터링을 사용하여 객체를 분리하는 방법을 보여준다. <strong>EuclideanClusterExtraction</strong> 클래스는 포인트 클라우드에서 밀집된 포인트들을 클러스터로 분리하는 데 사용된다. 이를 통해 객체를 인식하고 분리할 수 있다.</p>
<br/>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>