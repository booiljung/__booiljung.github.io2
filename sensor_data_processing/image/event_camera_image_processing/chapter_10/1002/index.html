<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/image/event_camera_image_processing/chapter_10/1002/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>효율적인 데이터 저장 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc774\ubca4\ud2b8 \ub370\uc774\ud130\uc758 \ud2b9\uc131", url: "#_top", children: [
          ]},
          {title: "\uc774\ubca4\ud2b8 \ub370\uc774\ud130 \uc555\ucd95 \uae30\ubc95", url: "#_2", children: [
              {title: "\uc2dc\uac04 \uae30\ubc18 \uc555\ucd95", url: "#_3" },
              {title: "\uacf5\uac04 \uae30\ubc18 \uc555\ucd95", url: "#_4" },
          ]},
          {title: "\uc774\ubca4\ud2b8\uc758 \uc911\ubcf5 \uc81c\uac70 \ubc0f \ubcd1\ud569", url: "#_5", children: [
          ]},
          {title: "\uc774\ubca4\ud2b8 \uc2a4\ud2b8\ub9bc\uc758 \uc2dc\uac04 \uc708\ub3c4\uc6b0 \uae30\ubc18 \uc800\uc7a5", url: "#_6", children: [
              {title: "\uc2dc\uac04 \uc708\ub3c4\uc6b0 \uc124\uc815", url: "#_7" },
              {title: "\uc774\ubca4\ud2b8 \uc9d1\ud569\uc758 \uc800\uc7a5", url: "#_8" },
          ]},
          {title: "\uc774\ubca4\ud2b8 \ub370\uc774\ud130\uc758 \uc804\uc1a1 \ucd5c\uc801\ud654", url: "#_9", children: [
              {title: "\uc911\uc694 \uc774\ubca4\ud2b8 \uc6b0\uc120 \uc804\uc1a1", url: "#_10" },
              {title: "\ub370\uc774\ud130 \ud328\ud0b7\uc758 \ud06c\uae30 \ucd5c\uc801\ud654", url: "#_11" },
              {title: "\ube44\ud2b8 \ub2e8\uc704 \uc555\ucd95", url: "#_12" },
          ]},
          {title: "\uc774\ubca4\ud2b8 \ub370\uc774\ud130\uc758 \uc800\uc7a5 \ud3ec\ub9f7", url: "#_13", children: [
              {title: "\uae30\uc874 \ud3ec\ub9f7\uc758 \ud55c\uacc4", url: "#_14" },
              {title: "\uc0c8\ub85c\uc6b4 \ud3ec\ub9f7\uc758 \ud544\uc694\uc131", url: "#_15" },
              {title: "\uc804\uc6a9 \uc774\ubca4\ud2b8 \ub370\uc774\ud130 \ud3ec\ub9f7 \uc608\uc2dc: AEDAT", url: "#aedat" },
          ]},
          {title: "\uc774\ubca4\ud2b8 \ub370\uc774\ud130\uc758 \ud6a8\uc728\uc801\uc778 \uc778\ub371\uc2f1", url: "#_16", children: [
              {title: "\uc2dc\uac04 \uae30\ubc18 \uc778\ub371\uc2f1", url: "#_17" },
              {title: "\uacf5\uac04 \uae30\ubc18 \uc778\ub371\uc2f1", url: "#_18" },
              {title: "\ud63c\ud569 \uc778\ub371\uc2f1", url: "#_19" },
          ]},
          {title: "\uc774\ubca4\ud2b8 \ub370\uc774\ud130\uc758 \uc800\uc7a5 \ucd5c\uc801\ud654 \uc804\ub7b5", url: "#_20", children: [
              {title: "\uc774\ubca4\ud2b8 \ud544\ud130\ub9c1", url: "#_21" },
              {title: "\ub370\uc774\ud130 \uc911\ubcf5 \uc81c\uac70", url: "#_24" },
              {title: "\uc774\ubca4\ud2b8 \ub370\uc774\ud130 \uc800\uc7a5\uc18c\uc758 \ucd5c\uc801\ud654", url: "#_27" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1003/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1003/" class="btn btn-xs btn-link">
        전송 및 통신 고려사항
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1001/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1001/" class="btn btn-xs btn-link">
        이벤트 데이터 압축 기법
      </a>
    </div>
    
  </div>

    

    <p>이벤트 카메라에서 발생하는 데이터는 매우 고해상도의 시간적 정보를 포함하고 있기 때문에 대규모 데이터를 실시간으로 처리하고 저장하는 것이 중요한 과제이다. 이벤트 기반 데이터는 프레임 기반 카메라와 달리, 픽셀 단위의 변화만을 기록하기 때문에 데이터 양을 줄일 수 있지만, 여전히 저장과 전송의 효율성을 높이기 위한 다양한 기법들이 필요하다.</p>
<h3 id="_1">이벤트 데이터의 특성</h3>
<p>이벤트 카메라의 데이터는 각각의 픽셀에서 변화가 발생할 때마다 기록된다. 즉, 이벤트 카메라의 출력은 프레임이 아니라, 각 픽셀에서 특정 시점에 발생한 밝기의 변화에 대한 이벤트 스트림이다. 각 이벤트는 다음과 같은 정보로 구성된다:</p>
<ul>
<li><strong>시간 정보</strong>: <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}_i</span><script type="math/tex">\mathbf{t}_i</script></span>, 이벤트가 발생한 시간 (고해상도 시간 정보)</li>
<li><strong>좌표 정보</strong>: <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_i</span><script type="math/tex">\mathbf{x}_i</script></span>, 이벤트가 발생한 좌표 (픽셀 단위)</li>
<li><strong>극성 정보</strong>: <span class="arithmatex"><span class="MathJax_Preview">p_i \in \{+1, -1\}</span><script type="math/tex">p_i \in \{+1, -1\}</script></span>, 밝기의 증가 혹은 감소를 나타냄</li>
</ul>
<p>이 이벤트 스트림은 픽셀 단위의 변화만을 기록하므로 전통적인 프레임 기반 영상보다 훨씬 더 효율적인 저장이 가능하지만, 빠른 시간 변화로 인해 데이터의 양이 매우 많을 수 있다. 따라서 이러한 데이터를 효율적으로 저장하는 방법은 매우 중요하다.</p>
<h3 id="_2">이벤트 데이터 압축 기법</h3>
<p>효율적인 저장을 위해 다양한 데이터 압축 기법이 제안되어 왔다. 이벤트 카메라 데이터의 압축은 일반적으로 시간적 및 공간적 상관관계를 활용한 방식으로 접근할 수 있다.</p>
<h4 id="_3">시간 기반 압축</h4>
<p>이벤트 데이터는 각 픽셀의 시간 변화를 기록하는 것이기 때문에, 이벤트 간의 시간적 상관관계를 활용하여 데이터를 압축할 수 있다. 예를 들어, 이벤트의 시간 정보를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}_i</span><script type="math/tex">\mathbf{t}_i</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">\Delta t_i</span><script type="math/tex">\Delta t_i</script></span>로 변환하여 인접 이벤트들 간의 시간차를 기록하는 방법이 있다.</p>
<p>이 시간차를 기록하는 방식은 매우 짧은 시간 동안 많은 이벤트가 발생할 때 데이터 양을 줄일 수 있다. 이를 수학적으로 표현하면,</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\Delta t_i = t_i - t_{i-1}
</div>
<script type="math/tex; mode=display">
\Delta t_i = t_i - t_{i-1}
</script>
</div>
<p>위 식에서 <span class="arithmatex"><span class="MathJax_Preview">\Delta t_i</span><script type="math/tex">\Delta t_i</script></span>는 인접한 두 이벤트 간의 시간차를 의미하며, 이를 통해 시간 정보의 절대값이 아닌 상대적인 변화를 저장함으로써 압축 효과를 얻을 수 있다.</p>
<h4 id="_4">공간 기반 압축</h4>
<p>이벤트 데이터는 공간적으로 인접한 픽셀에서 발생하는 이벤트들이 높은 상관관계를 갖는다. 이러한 공간적 상관관계를 활용하여 데이터를 효율적으로 저장하는 방법이 제안된다. 특히, 동일한 시간 구간 내에서 인접한 좌표에서 발생한 이벤트들을 묶어서 저장하는 방식이 있다.</p>
<p>이 방법은 다음과 같이 표현할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_i = \{ (x_j, y_j) \mid t_j \in [t_i, t_i + \Delta t]\}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_i = \{ (x_j, y_j) \mid t_j \in [t_i, t_i + \Delta t]\}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_i</span><script type="math/tex">\mathbf{P}_i</script></span>는 시간 구간 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span> 동안 발생한 이벤트들의 좌표 집합을 나타낸다. 이와 같은 공간적 묶음을 통해 각 이벤트마다 좌표 정보를 저장하는 대신, 시간 구간별로 좌표의 변화를 묶어 저장할 수 있다. </p>
<h3 id="_5">이벤트의 중복 제거 및 병합</h3>
<p>이벤트 데이터는 시간과 공간에 따라 중복된 정보가 발생할 수 있다. 특히, 동일한 위치에서 극성이 반복적으로 변하는 경우가 발생할 수 있는데, 이를 적절히 병합하여 중복된 데이터를 제거하는 기법이 필요하다. 이때 중복된 이벤트는 하나로 병합하고, 불필요한 이벤트는 삭제함으로써 저장 효율을 극대화할 수 있다.</p>
<h3 id="_6">이벤트 스트림의 시간 윈도우 기반 저장</h3>
<p>이벤트 데이터는 매우 고해상도의 시간 정보를 포함하므로, 효율적인 저장을 위해 시간 윈도우를 설정하여 해당 구간 동안 발생한 이벤트들을 한 번에 저장하는 방법이 있다. 시간 윈도우 기반 저장 기법은 다음과 같은 절차를 따른다:</p>
<h4 id="_7">시간 윈도우 설정</h4>
<p>시간 윈도우는 이벤트 발생 빈도에 따라 동적으로 조정될 수 있다. 만약 특정 시간 구간 내에서 많은 이벤트가 발생한다면, 그 구간의 시간 윈도우를 짧게 설정하여 저장하고, 반대로 이벤트가 적게 발생하는 시간 구간에서는 윈도우를 길게 설정하여 저장할 수 있다. 시간 윈도우의 설정은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\Delta T = f(\text{event density})
</div>
<script type="math/tex; mode=display">
\Delta T = f(\text{event density})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\Delta T</span><script type="math/tex">\Delta T</script></span>는 시간 윈도우의 크기이고, 이벤트 밀도(event density)에 따라 윈도우 크기를 동적으로 조정한다.</p>
<h4 id="_8">이벤트 집합의 저장</h4>
<p>설정된 시간 윈도우 내에서 발생한 모든 이벤트를 하나의 데이터 블록으로 묶어서 저장한다. 이때 시간 구간을 벗어난 이벤트는 다음 윈도우로 넘어가게 되며, 이는 시간 기반 압축 기법과 결합하여 효율적으로 관리될 수 있다. 각 시간 윈도우 내에서 발생한 이벤트들은 다음과 같이 저장된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
E_{\Delta T} = \{(t_i, x_i, y_i, p_i) \mid t_i \in [t_0, t_0 + \Delta T]\}
</div>
<script type="math/tex; mode=display">
E_{\Delta T} = \{(t_i, x_i, y_i, p_i) \mid t_i \in [t_0, t_0 + \Delta T]\}
</script>
</div>
<p>이와 같은 방식으로 시간 구간 내에서 발생한 이벤트들을 하나의 집합으로 저장함으로써, 개별적으로 이벤트를 저장하는 것보다 데이터의 처리 및 검색 속도를 향상시킬 수 있다.</p>
<h3 id="_9">이벤트 데이터의 전송 최적화</h3>
<p>이벤트 기반 데이터는 실시간으로 처리되는 경우가 많기 때문에, 저장뿐만 아니라 데이터 전송 과정에서도 효율성을 고려해야 한다. 특히, 네트워크 대역폭이 제한된 환경에서는 불필요한 이벤트 데이터의 전송을 줄이기 위한 여러 최적화 방법이 필요하다.</p>
<h4 id="_10">중요 이벤트 우선 전송</h4>
<p>모든 이벤트가 중요한 것은 아니므로, 중요도가 높은 이벤트를 먼저 전송하는 방식이 사용될 수 있다. 예를 들어, 객체 인식이나 추적에 관련된 주요 에지 또는 코너 이벤트들을 우선적으로 전송하고, 나머지 이벤트들은 나중에 전송하거나 압축된 상태로 전송할 수 있다.</p>
<h4 id="_11">데이터 패킷의 크기 최적화</h4>
<p>네트워크를 통해 이벤트 데이터를 전송할 때, 패킷의 크기를 적절히 최적화하는 것이 중요하다. 패킷 크기는 이벤트 밀도 및 네트워크 조건에 따라 동적으로 조정될 수 있으며, 패킷 크기가 너무 작을 경우 전송 효율이 떨어지고, 너무 클 경우 실시간성을 저해할 수 있다.</p>
<h4 id="_12">비트 단위 압축</h4>
<p>이벤트 데이터는 각 이벤트의 시간, 위치, 극성 정보를 포함하기 때문에 이를 비트 단위로 압축하여 전송할 수 있다. 시간 정보는 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>로, 좌표는 상대 좌표로 변환하여 압축한 후, 극성 정보는 1비트로 저장하여 전송할 수 있다. 예를 들어, 다음과 같이 각 이벤트를 비트 단위로 표현할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
(t_i, x_i, y_i, p_i) \rightarrow \Delta t_i, \Delta x_i, \Delta y_i, p_i
</div>
<script type="math/tex; mode=display">
(t_i, x_i, y_i, p_i) \rightarrow \Delta t_i, \Delta x_i, \Delta y_i, p_i
</script>
</div>
<p>이 방법은 각 이벤트의 데이터를 최소화하여 전송 대역폭을 줄일 수 있다.</p>
<h3 id="_13">이벤트 데이터의 저장 포맷</h3>
<p>효율적인 데이터 저장을 위해서는 적절한 파일 포맷을 선택하는 것도 중요한 고려 사항이다. 이벤트 기반 데이터는 기존의 프레임 기반 영상 데이터와는 다른 특성을 가지기 때문에, 이를 저장하기 위한 포맷도 맞춤형으로 설계될 필요가 있다.</p>
<h4 id="_14">기존 포맷의 한계</h4>
<p>일반적인 영상 데이터는 JPEG, PNG 등의 정지 이미지 포맷이나 MP4와 같은 동영상 포맷으로 저장된다. 그러나 이러한 포맷들은 프레임 단위의 데이터만을 처리할 수 있기 때문에 이벤트 스트림을 효과적으로 저장하지 못한다. 특히, 시간적으로 불규칙하게 발생하는 이벤트 데이터를 이러한 정해진 프레임 단위로 저장하려면 불필요한 프레임을 추가해야 하고, 그 결과 저장 효율이 매우 낮아질 수 있다.</p>
<h4 id="_15">새로운 포맷의 필요성</h4>
<p>이벤트 데이터는 고해상도 시간 정보를 포함하고 있어, 이벤트마다 발생 시점과 위치, 극성 정보를 기록해야 한다. 이를 위해 각 이벤트의 정보를 효율적으로 저장할 수 있는 새로운 포맷이 필요하다. 이러한 포맷은 다음과 같은 요구 사항을 충족해야 한다:</p>
<ul>
<li><strong>시간 정보 저장</strong>: 각 이벤트의 발생 시점을 정확하게 기록할 수 있어야 한다.</li>
<li><strong>공간 정보 저장</strong>: 이벤트가 발생한 좌표를 효율적으로 기록해야 한다.</li>
<li><strong>극성 정보 저장</strong>: 각 이벤트가 밝기 증가 또는 감소 중 어떤 변화를 나타내는지 기록할 수 있어야 한다.</li>
<li><strong>압축 효율성</strong>: 불필요한 데이터 중복을 최소화하고, 높은 압축률을 달성할 수 있어야 한다.</li>
</ul>
<h4 id="aedat">전용 이벤트 데이터 포맷 예시: AEDAT</h4>
<p>현재 이벤트 카메라 데이터 저장을 위해 널리 사용되는 포맷 중 하나는 <strong>AEDAT</strong> 포맷이다. AEDAT 포맷은 이벤트 기반 데이터의 시간, 공간, 극성 정보를 효율적으로 저장할 수 있도록 설계되었다. 각 이벤트는 <strong>이벤트 타입</strong>과 <strong>데이터 페이로드</strong>로 나뉘며, 이벤트 타입에 따라 페이로드의 구조가 달라진다. 예를 들어, 가장 기본적인 이벤트 데이터는 다음과 같은 정보를 포함할 수 있다:</p>
<ul>
<li><strong>Timestamp</strong>: 이벤트 발생 시점</li>
<li><strong>X, Y</strong>: 이벤트 발생 좌표</li>
<li><strong>Polarity</strong>: 밝기의 증가 또는 감소</li>
</ul>
<p>AEDAT 포맷은 각 이벤트를 효율적으로 저장하기 위해 비트 단위로 압축되어 있으며, 파일 내부에서는 이벤트를 시간 순서대로 나열하여 빠른 액세스가 가능하게 설계되었다. 이와 같은 포맷을 통해 이벤트 데이터를 효율적으로 저장하고, 나중에 분석하거나 학습 모델에 사용할 수 있다.</p>
<h3 id="_16">이벤트 데이터의 효율적인 인덱싱</h3>
<p>이벤트 카메라 데이터는 발생 빈도가 매우 높고, 특정 시간 구간이나 공간 구역에서 발생한 이벤트들을 빠르게 검색하는 것이 중요하다. 이를 위해서는 효율적인 인덱싱 구조를 사용하는 것이 필수적이다.</p>
<h4 id="_17">시간 기반 인덱싱</h4>
<p>시간 기반 인덱싱은 주어진 시간 범위 내에서 이벤트 데이터를 빠르게 검색하는 방법이다. 이벤트 카메라 데이터는 매우 높은 시간 해상도를 가지므로, 이러한 데이터를 효과적으로 관리하기 위해 시간 인덱스를 사용하는 방법이 제안된다.</p>
<p>이 방법은 시간 구간을 여러 개의 작은 블록으로 나누고, 각 블록에 해당하는 이벤트 데이터를 별도의 저장소에 저장하거나 인덱스 테이블을 생성하는 방식이다. 이를 통해 주어진 시간 범위 내에서 이벤트들을 빠르게 찾을 수 있다. 시간 기반 인덱싱은 다음과 같은 구조로 설계될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T = \{ t_i \mid t_0 \leq t_i \leq t_0 + \Delta T \}
</div>
<script type="math/tex; mode=display">
T = \{ t_i \mid t_0 \leq t_i \leq t_0 + \Delta T \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 특정 시간 구간 <span class="arithmatex"><span class="MathJax_Preview">\Delta T</span><script type="math/tex">\Delta T</script></span> 동안 발생한 이벤트들의 시간 정보 집합을 나타낸다. 이 시간 집합을 기준으로 각 이벤트에 빠르게 접근할 수 있는 인덱스 테이블을 생성한다.</p>
<h4 id="_18">공간 기반 인덱싱</h4>
<p>이벤트 데이터는 2D 공간 상에서 발생하므로, 공간적 인덱싱 구조를 사용하여 특정 좌표나 영역에서 발생한 이벤트를 빠르게 검색할 수 있다. 공간 기반 인덱싱을 위한 대표적인 방법은 <strong>R-Tree</strong>와 같은 공간 분할 알고리즘을 사용하는 것이다.</p>
<p>R-Tree는 2D 또는 3D 공간 내에서 데이터 객체를 효율적으로 저장하고 검색할 수 있는 트리 구조로, 이벤트 데이터의 좌표 <span class="arithmatex"><span class="MathJax_Preview">(x, y)</span><script type="math/tex">(x, y)</script></span>를 기반으로 해당 위치에서 발생한 이벤트들을 빠르게 찾을 수 있도록 돕는다. 공간 기반 인덱싱을 활용하면 특정 좌표 근처에서 발생한 이벤트들을 효과적으로 탐색할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
X, Y = \{(x_i, y_i) \mid x_{\min} \leq x_i \leq x_{\max}, y_{\min} \leq y_i \leq y_{\max} \}
</div>
<script type="math/tex; mode=display">
X, Y = \{(x_i, y_i) \mid x_{\min} \leq x_i \leq x_{\max}, y_{\min} \leq y_i \leq y_{\max} \}
</script>
</div>
<p>위 수식에서 <span class="arithmatex"><span class="MathJax_Preview">X, Y</span><script type="math/tex">X, Y</script></span>는 특정 좌표 범위 <span class="arithmatex"><span class="MathJax_Preview">(x_{\min}, x_{\max})</span><script type="math/tex">(x_{\min}, x_{\max})</script></span>, <span class="arithmatex"><span class="MathJax_Preview">(y_{\min}, y_{\max})</span><script type="math/tex">(y_{\min}, y_{\max})</script></span> 내에서 발생한 이벤트들의 좌표 정보를 나타낸다. 이러한 범위 기반 검색을 통해 특정 영역 내의 이벤트 데이터에 빠르게 접근할 수 있다.</p>
<h4 id="_19">혼합 인덱싱</h4>
<p>시간과 공간 모두를 고려한 인덱싱 기법도 많이 사용된다. 이는 시간-공간 인덱스를 결합하여 특정 시간 구간과 공간 내에서 발생한 이벤트들을 동시에 빠르게 검색할 수 있도록 돕는다. 시간 기반 인덱싱과 공간 기반 인덱싱을 결합하면 다음과 같은 쿼리가 가능해진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{X,Y} = \{ (t_i, x_i, y_i) \mid t_0 \leq t_i \leq t_0 + \Delta T, x_{\min} \leq x_i \leq x_{\max}, y_{\min} \leq y_i \leq y_{\max} \}
</div>
<script type="math/tex; mode=display">
T_{X,Y} = \{ (t_i, x_i, y_i) \mid t_0 \leq t_i \leq t_0 + \Delta T, x_{\min} \leq x_i \leq x_{\max}, y_{\min} \leq y_i \leq y_{\max} \}
</script>
</div>
<p>위 식은 주어진 시간 구간과 공간 내에서 발생한 이벤트 집합 <span class="arithmatex"><span class="MathJax_Preview">T_{X,Y}</span><script type="math/tex">T_{X,Y}</script></span>를 나타내며, 이를 통해 이벤트 데이터를 효율적으로 검색할 수 있다. 이와 같은 혼합 인덱싱을 사용하면 대규모 이벤트 데이터의 검색 속도를 크게 향상시킬 수 있다.</p>
<h3 id="_20">이벤트 데이터의 저장 최적화 전략</h3>
<p>대규모 이벤트 데이터를 효율적으로 저장하기 위해서는 데이터의 특성에 맞춘 최적화 전략이 필요하다. 이벤트 데이터는 매우 큰 양이 실시간으로 생성되기 때문에, 이를 저장하고 관리하기 위한 최적화 방법들이 제안된다.</p>
<h4 id="_21">이벤트 필터링</h4>
<p>이벤트 데이터의 양을 줄이기 위한 첫 번째 단계는 불필요하거나 중복된 이벤트들을 제거하는 것이다. 이를 통해 데이터의 양을 줄이고 저장 공간을 절약할 수 있다.</p>
<h5 id="_22">극성 필터링</h5>
<p>특정 애플리케이션에서는 밝기 변화의 극성 정보가 중요한 경우가 많다. 그러나 일부 경우에는 극성 정보가 중요한 역할을 하지 않거나, 특정 극성에 해당하는 이벤트들만 필요할 수 있다. 이러한 경우, 극성 필터링을 통해 필요 없는 이벤트들을 제거할 수 있다.</p>
<p>예를 들어, 다음과 같은 필터링 조건을 사용할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
E_p = \{(t_i, x_i, y_i, p_i) \mid p_i = +1\}
</div>
<script type="math/tex; mode=display">
E_p = \{(t_i, x_i, y_i, p_i) \mid p_i = +1\}
</script>
</div>
<p>위 식은 극성이 <span class="arithmatex"><span class="MathJax_Preview">+1</span><script type="math/tex">+1</script></span>인 이벤트들만 필터링하여 저장하는 방법을 나타낸다. 이와 같은 방법으로 극성 정보에 따라 데이터를 선택적으로 저장할 수 있다.</p>
<h5 id="_23">노이즈 필터링</h5>
<p>이벤트 데이터에는 센서 노이즈로 인해 불필요한 이벤트들이 발생할 수 있다. 이러한 노이즈 이벤트는 실제로 의미 있는 데이터와는 관계가 없으므로, 이를 사전에 제거하여 저장 공간을 절약할 수 있다. 노이즈 필터링은 주로 이벤트의 시간적 또는 공간적 특성을 분석하여 이루어진다.</p>
<p>노이즈 필터링의 예시로는 공간적 밀도를 기반으로 이벤트를 필터링하는 방법이 있다. 특정 시간 구간 내에 발생한 이벤트들 중에서 일정 수 이상의 이벤트가 발생한 영역만을 저장하는 방식이다. 이는 다음과 같이 표현할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
E_{\text{valid}} = \{(t_i, x_i, y_i) \mid \sum_{j=1}^{n} \mathbf{1}_{(x_j, y_j)} \geq N_{\text{th}}\}
</div>
<script type="math/tex; mode=display">
E_{\text{valid}} = \{(t_i, x_i, y_i) \mid \sum_{j=1}^{n} \mathbf{1}_{(x_j, y_j)} \geq N_{\text{th}}\}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{1}_{(x_j, y_j)}</span><script type="math/tex">\mathbf{1}_{(x_j, y_j)}</script></span>는 해당 좌표에서 이벤트가 발생했음을 나타내는 지시 함수이며, <span class="arithmatex"><span class="MathJax_Preview">N_{\text{th}}</span><script type="math/tex">N_{\text{th}}</script></span>는 특정 임계값을 나타낸다. 이를 통해 노이즈가 적고 신뢰할 수 있는 이벤트 데이터만을 저장하게 된다.</p>
<h4 id="_24">데이터 중복 제거</h4>
<p>이벤트 데이터는 시간과 공간에서 중복되는 정보가 발생할 수 있다. 예를 들어, 매우 짧은 시간 동안 동일한 좌표에서 반복적으로 이벤트가 발생하는 경우, 이 이벤트들은 사실상 동일한 정보를 담고 있으므로 이를 하나로 병합하여 저장할 수 있다.</p>
<h5 id="_25">시간적 중복 제거</h5>
<p>시간적으로 매우 근접한 이벤트들을 하나로 병합하는 방법이다. 특정 시간 구간 내에서 발생한 이벤트들이 모두 동일한 좌표에서 발생했다면, 이를 하나의 이벤트로 병합할 수 있다. 이를 수식으로 나타내면 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
E_{\text{merged}} = \{ (t_i, x_i, y_i, p_i) \mid t_{i+1} - t_i \geq \Delta t_{\text{th}} \}
</div>
<script type="math/tex; mode=display">
E_{\text{merged}} = \{ (t_i, x_i, y_i, p_i) \mid t_{i+1} - t_i \geq \Delta t_{\text{th}} \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\Delta t_{\text{th}}</span><script type="math/tex">\Delta t_{\text{th}}</script></span>는 시간 간격의 임계값을 의미하며, 이 임계값 내에서 발생한 이벤트들은 병합된다. 이를 통해 이벤트 데이터를 보다 효율적으로 저장할 수 있다.</p>
<h5 id="_26">공간적 중복 제거</h5>
<p>공간적으로 가까운 좌표에서 발생한 이벤트들은 데이터의 밀도가 높을 때 중복된 정보일 수 있다. 이러한 경우, 공간적으로 인접한 이벤트들을 하나로 묶어서 저장할 수 있다. 공간적 중복 제거는 특히 높은 해상도의 이벤트 데이터를 다룰 때 매우 효과적이다.</p>
<p>이를 수식으로 나타내면 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
E_{\text{spatial}} = \{ (t_i, x_i, y_i, p_i) \mid \sqrt{(x_{i+1} - x_i)^2 + (y_{i+1} - y_i)^2} \geq d_{\text{th}} \}
</div>
<script type="math/tex; mode=display">
E_{\text{spatial}} = \{ (t_i, x_i, y_i, p_i) \mid \sqrt{(x_{i+1} - x_i)^2 + (y_{i+1} - y_i)^2} \geq d_{\text{th}} \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{th}}</span><script type="math/tex">d_{\text{th}}</script></span>는 공간적 거리의 임계값을 의미하며, 이 임계값 내에 발생한 이벤트들은 하나로 병합된다.</p>
<h4 id="_27">이벤트 데이터 저장소의 최적화</h4>
<p>이벤트 데이터의 저장소는 데이터를 효율적으로 저장하고 검색할 수 있도록 최적화되어야 한다. 특히 대규모의 실시간 데이터를 다룰 때는 빠른 액세스와 저장 성능을 유지하면서도 저장 공간을 최소화하는 것이 중요하다.</p>
<h5 id="_28">데이터베이스 구조</h5>
<p>이벤트 데이터를 저장하기 위한 데이터베이스는 주로 시간과 공간 인덱스를 결합한 구조를 사용할 수 있다. 이는 각 이벤트가 발생한 시점과 위치를 기준으로 데이터를 저장하고 검색할 수 있도록 설계된 구조이다. 이러한 데이터베이스 구조는 이벤트 데이터를 저장할 때 인덱스의 크기를 줄이고, 빠르게 검색할 수 있는 최적화된 구조를 갖추어야 한다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1003/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1003/" class="btn btn-xs btn-link">
        전송 및 통신 고려사항
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1001/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1001/" class="btn btn-xs btn-link">
        이벤트 데이터 압축 기법
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>