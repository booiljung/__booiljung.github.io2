<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introductions_to_pointcloud_processing_with_pcl_library/chapter_12/1202/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>컬러 정보를 포함한 포인트 클라우드 처리 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc0c9\uc0c1 \uc815\ubcf4\uc640 \ub370\uc774\ud130 \uad6c\uc870", url: "#_top", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uc815\ubcf4 \ubcd1\ud569 \ubc0f \ubcc0\ud658", url: "#_2", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uae30\ubc18 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ud544\ud130\ub9c1", url: "#_3", children: [
          ]},
          {title: "\uc0c9\uc0c1 \ubcc0\ud658 \ubc0f \ub9e4\ud551", url: "#_4", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uc815\ubcf4\uc640 \uc815\uaddc\ud654", url: "#_5", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uc815\ubcf4\uc758 \ub9ac\uc0d8\ud50c\ub9c1 \ubc0f \ubcf4\uac04", url: "#_6", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uceec\ub7ec \uc138\uadf8\uba3c\ud14c\uc774\uc158", url: "#_7", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uc815\ubcf4\ub97c \uc774\uc6a9\ud55c \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub9e4\uce6d", url: "#_8", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uae30\ubc18 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc815\ub82c", url: "#_9", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uc815\ubcf4\ub97c \uc774\uc6a9\ud55c \ud074\ub7ec\uc2a4\ud130\ub9c1 \ubc0f \uac1d\uccb4 \uc778\uc2dd", url: "#_10", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uae30\ubc18\uc758 \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#_11", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uc815\ubcf4 \ubcf4\uc815 \ubc0f \uad50\uc815", url: "#_12", children: [
              {title: "\uac10\ub9c8 \ubcf4\uc815", url: "#_13" },
              {title: "\ud654\uc774\ud2b8 \ubc38\ub7f0\uc2a4", url: "#_14" },
              {title: "\ud788\uc2a4\ud1a0\uadf8\ub7a8 \uade0\ub4f1\ud654", url: "#_15" },
          ]},
          {title: "\uc0c9\uc0c1 \uae30\ubc18 \uac1d\uccb4 \ucd94\uc801", url: "#_16", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uc815\ubcf4\ub97c \uc774\uc6a9\ud55c \ubb3c\uccb4 \uc2dd\ubcc4", url: "#_17", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uc815\ubcf4\ub97c \ud65c\uc6a9\ud55c \uc2dc\uba58\ud2f1 \ubd84\ud560", url: "#_18", children: [
          ]},
          {title: "\uc0c9\uc0c1 \uc815\ubcf4\ub97c \ud65c\uc6a9\ud55c \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc555\ucd95", url: "#_19", children: [
              {title: "\ud000\ud0c0\uc774\uc81c\uc774\uc158(Quantization)", url: "#quantization" },
              {title: "\uc0c9\uc0c1 \uacc4\uce35 \uad6c\uc870 \uc555\ucd95", url: "#_20" },
              {title: "\uc9c0\uac01\uc801 \uc0c9\uc0c1 \ubaa8\ub378 \uae30\ubc18 \uc555\ucd95", url: "#_21" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1203/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1203/" class="btn btn-xs btn-link">
        색상 기반 클러스터링 기법
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1201/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1201/" class="btn btn-xs btn-link">
        RGB-D 카메라 데이터와 PCL
      </a>
    </div>
    
  </div>

    

    <p>포인트 클라우드는 3차원 공간에서 각 포인트가 위치 정보를 가지고 있는 데이터 구조로, 주로 공간 정보 처리에 많이 사용된다. 이러한 포인트 클라우드는 단순히 위치 정보만을 포함할 수도 있지만, 현실 세계의 데이터는 종종 시각적 정보를 함께 담고 있는 경우가 많다. 이를 위해 포인트 클라우드 데이터에 색상 정보를 추가로 포함하여 처리할 수 있으며, 이는 다양한 응용 분야에서 중요한 역할을 한다.</p>
<p>포인트 클라우드에 포함된 컬러 정보는 각 포인트가 가지고 있는 색상 값을 나타내며, 일반적으로 RGB(Red, Green, Blue)로 표현된다. 각 포인트는 3차원 좌표 정보 <span class="arithmatex"><span class="MathJax_Preview">(x, y, z)</span><script type="math/tex">(x, y, z)</script></span>와 더불어 RGB 색상 값 <span class="arithmatex"><span class="MathJax_Preview">(r, g, b)</span><script type="math/tex">(r, g, b)</script></span>을 갖게 되며, 이 정보를 바탕으로 컬러가 포함된 3차원 공간을 구성할 수 있다. 이를 수식으로 표현하면, 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 다음과 같이 정의될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p} = (x, y, z, r, g, b)
</div>
<script type="math/tex; mode=display">
\mathbf{p} = (x, y, z, r, g, b)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">x, y, z</span><script type="math/tex">x, y, z</script></span>는 3차원 공간상의 좌표,
- <span class="arithmatex"><span class="MathJax_Preview">r, g, b</span><script type="math/tex">r, g, b</script></span>는 각각 Red, Green, Blue 채널의 색상 값이다.</p>
<h3 id="_1">색상 정보와 데이터 구조</h3>
<p>포인트 클라우드를 처리할 때, 색상 정보는 기본적으로 정수형으로 표현된다. 일반적으로 RGB 값은 <span class="arithmatex"><span class="MathJax_Preview">[0, 255]</span><script type="math/tex">[0, 255]</script></span>의 범위를 가지며, 8비트로 표현된다. 즉, 하나의 포인트는 <span class="arithmatex"><span class="MathJax_Preview">x, y, z</span><script type="math/tex">x, y, z</script></span> 좌표와 함께 3개의 8비트 값을 가지므로, 각 포인트의 크기는 상당히 커질 수 있다.</p>
<p>포인트 클라우드 라이브러리(PCL)에서는 포인트의 좌표 정보와 함께 색상 정보를 함께 저장하기 위해 구조체를 확장하거나 별도의 필드를 추가하여 처리한다. 예를 들어, PCL에서 제공하는 <code>PointXYZRGB</code> 구조체는 3차원 좌표와 RGB 색상 값을 함께 포함할 수 있는 데이터 타입이다. 이는 다음과 같이 정의된다.</p>
<pre><code class="language-cpp">struct PointXYZRGB {
  float x;
  float y;
  float z;
  uint32_t rgb;
};
</code></pre>
<p>이때 RGB 값은 32비트 정수형으로 저장되며, 각 8비트가 R, G, B 채널을 나타낸다.</p>
<h3 id="_2">색상 정보 병합 및 변환</h3>
<p>포인트 클라우드를 처리하는 과정에서, 다양한 연산이 필요하다. 예를 들어, 서로 다른 두 포인트 클라우드를 병합할 때, 색상 정보도 함께 고려하여 병합해야 한다. 두 포인트의 색상 정보를 병합하는 한 가지 방법은 두 포인트의 색상 값의 평균을 취하는 것이다. 두 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_1} = (r_1, g_1, b_1)</span><script type="math/tex">\mathbf{p_1} = (r_1, g_1, b_1)</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_2} = (r_2, g_2, b_2)</span><script type="math/tex">\mathbf{p_2} = (r_2, g_2, b_2)</script></span>의 색상 정보를 평균하는 경우, 병합된 포인트의 색상 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_{avg}}</span><script type="math/tex">\mathbf{p_{avg}}</script></span>는 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p_{avg}} = \left( \frac{r_1 + r_2}{2}, \frac{g_1 + g_2}{2}, \frac{b_1 + b_2}{2} \right)
</div>
<script type="math/tex; mode=display">
\mathbf{p_{avg}} = \left( \frac{r_1 + r_2}{2}, \frac{g_1 + g_2}{2}, \frac{b_1 + b_2}{2} \right)
</script>
</div>
<p>이와 같은 방식으로, 다양한 연산 중에도 색상 정보를 유지하거나 변환할 수 있다. 하지만 색상 정보를 단순히 평균 내는 것 외에도 더 복잡한 처리가 필요할 수 있다. 예를 들어, 색상 정보에 가중치를 부여하거나, 특정 색상 정보만을 강조하는 방법이 있을 수 있다. 이러한 경우는 애플리케이션의 요구사항에 따라 다르게 구현할 수 있다.</p>
<h3 id="_3">색상 기반 포인트 클라우드 필터링</h3>
<p>포인트 클라우드 데이터를 필터링할 때, 색상 정보는 중요한 기준이 될 수 있다. 예를 들어, 특정 색상 값을 가지는 포인트만을 추출하거나, 색상 값에 따라 데이터를 분할하는 방법이 있다. 이를 수학적으로 표현하면, 특정 색상 범위를 기준으로 필터링하는 과정을 다음과 같이 나타낼 수 있다.</p>
<p>색상 값의 범위를 <span class="arithmatex"><span class="MathJax_Preview">r_{\text{min}}, r_{\text{max}}, g_{\text{min}}, g_{\text{max}}, b_{\text{min}}, b_{\text{max}}</span><script type="math/tex">r_{\text{min}}, r_{\text{max}}, g_{\text{min}}, g_{\text{max}}, b_{\text{min}}, b_{\text{max}}</script></span>로 정의하면, 필터링 조건은 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
r_{\text{min}} \leq r \leq r_{\text{max}}, \quad g_{\text{min}} \leq g \leq g_{\text{max}}, \quad b_{\text{min}} \leq b \leq b_{\text{max}}
</div>
<script type="math/tex; mode=display">
r_{\text{min}} \leq r \leq r_{\text{max}}, \quad g_{\text{min}} \leq g \leq g_{\text{max}}, \quad b_{\text{min}} \leq b \leq b_{\text{max}}
</script>
</div>
<p>이 조건을 만족하는 포인트만을 선택하여 새로운 포인트 클라우드를 구성할 수 있다. 이를 코드로 구현하면, 각 포인트에 대해 RGB 값을 비교하여 해당 범위에 속하는지 확인하고, 조건을 만족하는 포인트만을 새로운 데이터로 저장하는 방식이 된다.</p>
<p>필터링의 또 다른 방법은 색상 클러스터링을 통한 포인트 클라우드 분할이다. K-평균 알고리즘을 사용하여 색상 값을 기준으로 포인트들을 클러스터링한 후, 각 클러스터에 해당하는 색상 범위에 따라 포인트들을 그룹화할 수 있다.</p>
<h3 id="_4">색상 변환 및 매핑</h3>
<p>포인트 클라우드 데이터에서 색상 정보를 다룰 때는 색상 공간을 변환하거나, 다른 형태의 색상 표현으로 매핑하는 작업이 필요할 수 있다. 예를 들어, RGB 색상 공간에서 HSV(Hue, Saturation, Value) 색상 공간으로 변환하는 경우는 다음과 같다.</p>
<p>RGB에서 HSV로 변환하는 공식은 아래와 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
V = \max(R, G, B)
</div>
<script type="math/tex; mode=display">
V = \max(R, G, B)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
S = \frac{V - \min(R, G, B)}{V}, \quad \text{if } V \neq 0
</div>
<script type="math/tex; mode=display">
S = \frac{V - \min(R, G, B)}{V}, \quad \text{if } V \neq 0
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
H = 
\begin{cases} 
60^\circ \times \frac{G - B}{V - \min(R, G, B)}, &amp; \text{if } V = R \\
60^\circ \times \left( 2 + \frac{B - R}{V - \min(G, B)} \right), &amp; \text{if } V = G \\
60^\circ \times \left( 4 + \frac{R - G}{V - \min(B, R)} \right), &amp; \text{if } V = B \\
\end{cases}
</div>
<script type="math/tex; mode=display">
H = 
\begin{cases} 
60^\circ \times \frac{G - B}{V - \min(R, G, B)}, & \text{if } V = R \\
60^\circ \times \left( 2 + \frac{B - R}{V - \min(G, B)} \right), & \text{if } V = G \\
60^\circ \times \left( 4 + \frac{R - G}{V - \min(B, R)} \right), & \text{if } V = B \\
\end{cases}
</script>
</div>
<p>이와 같이 색상 공간을 변환하면, 색상 정보가 다르게 표현되며, 이를 통해 포인트 클라우드 데이터를 다양한 방식으로 시각화하거나 분석할 수 있다.</p>
<h3 id="_5">색상 정보와 정규화</h3>
<p>포인트 클라우드에서 색상 정보를 다룰 때, 각 채널의 값이 [0, 255] 범위로 표현되지만, 일부 알고리즘이나 연산 과정에서는 이 값을 [0, 1] 사이로 정규화해야 하는 경우가 있다. 정규화는 RGB 값을 실수 범위로 변환하여 연산의 효율성을 높이고, 다른 유형의 데이터를 함께 처리할 수 있게 한다.</p>
<p>RGB 값을 [0, 1]로 정규화하는 방법은 단순하며, 각 채널의 값을 255로 나누면 된다. 즉, 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p} = (r, g, b)</span><script type="math/tex">\mathbf{p} = (r, g, b)</script></span>에 대한 정규화된 값 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_{\text{norm}}}</span><script type="math/tex">\mathbf{p_{\text{norm}}}</script></span>는 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
r_{\text{norm}} = \frac{r}{255}, \quad g_{\text{norm}} = \frac{g}{255}, \quad b_{\text{norm}} = \frac{b}{255}
</div>
<script type="math/tex; mode=display">
r_{\text{norm}} = \frac{r}{255}, \quad g_{\text{norm}} = \frac{g}{255}, \quad b_{\text{norm}} = \frac{b}{255}
</script>
</div>
<p>정규화된 포인트는 <span class="arithmatex"><span class="MathJax_Preview">(r_{\text{norm}}, g_{\text{norm}}, b_{\text{norm}})</span><script type="math/tex">(r_{\text{norm}}, g_{\text{norm}}, b_{\text{norm}})</script></span>의 형태를 가지며, 이는 색상 정보를 보다 효율적으로 처리하는 데에 유용하다. 특히 머신러닝 또는 딥러닝 알고리즘에서 정규화된 데이터를 사용하는 경우가 많기 때문에, 포인트 클라우드를 분석할 때 필수적인 단계일 수 있다.</p>
<h3 id="_6">색상 정보의 리샘플링 및 보간</h3>
<p>포인트 클라우드에서 색상 정보를 처리할 때는, 종종 해상도를 변경하거나 포인트 개수를 줄이는 작업이 필요하다. 이때, 색상 정보를 잃지 않고 포인트를 리샘플링하거나 보간하는 것이 중요하다.</p>
<p>리샘플링은 포인트 클라우드의 해상도를 변경하는 과정에서 기존에 있던 포인트들의 위치와 색상 정보를 적절히 보존하면서 새로운 포인트를 생성하거나, 불필요한 포인트를 제거하는 방법을 의미한다. 예를 들어, 리샘플링 과정에서 특정 포인트의 색상은 주변 포인트의 색상을 고려하여 보간할 수 있다.</p>
<p>포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_1} = (x_1, y_1, z_1, r_1, g_1, b_1)</span><script type="math/tex">\mathbf{p_1} = (x_1, y_1, z_1, r_1, g_1, b_1)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_2} = (x_2, y_2, z_2, r_2, g_2, b_2)</span><script type="math/tex">\mathbf{p_2} = (x_2, y_2, z_2, r_2, g_2, b_2)</script></span> 사이의 보간된 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_{\text{interp}}}</span><script type="math/tex">\mathbf{p_{\text{interp}}}</script></span>는 다음과 같이 선형 보간을 통해 계산할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p_{\text{interp}}} = \left( \frac{x_1 + x_2}{2}, \frac{y_1 + y_2}{2}, \frac{z_1 + z_2}{2}, \frac{r_1 + r_2}{2}, \frac{g_1 + g_2}{2}, \frac{b_1 + b_2}{2} \right)
</div>
<script type="math/tex; mode=display">
\mathbf{p_{\text{interp}}} = \left( \frac{x_1 + x_2}{2}, \frac{y_1 + y_2}{2}, \frac{z_1 + z_2}{2}, \frac{r_1 + r_2}{2}, \frac{g_1 + g_2}{2}, \frac{b_1 + b_2}{2} \right)
</script>
</div>
<p>이 방식으로, 포인트 간의 색상과 위치를 모두 고려하여 새로운 포인트를 생성할 수 있다.</p>
<p>또한, 특정 영역에서 포인트 간의 색상 차이가 클 경우, 단순한 선형 보간보다는 더 복잡한 기법을 사용해 색상 값을 보간하는 것이 필요할 수 있다. 예를 들어, 다차원 공간에서의 크리깅(Kriging) 기법이나 거리에 기반한 가중 보간 방법을 사용할 수 있다.</p>
<h3 id="_7">포인트 클라우드 컬러 세그먼테이션</h3>
<p>포인트 클라우드에서 컬러 세그먼테이션은 색상 정보를 이용해 클라우드를 여러 개의 부분으로 나누는 작업이다. 이는 주로 물체 인식, 물체 추적, 혹은 표면 분할과 같은 작업에서 사용된다. 세그먼테이션을 통해 특정 색상 범위에 해당하는 포인트만을 추출할 수 있으며, 이를 통해 객체나 영역을 분리할 수 있다.</p>
<p>세그먼테이션 작업에서 가장 간단한 방식은 특정 색상 값을 기준으로 필터링하는 것이다. 예를 들어, 빨간색 계열의 포인트만을 추출하려면, 다음과 같은 조건을 적용할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
r &gt; g + t, \quad r &gt; b + t
</div>
<script type="math/tex; mode=display">
r > g + t, \quad r > b + t
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>는 색상 차이를 구분하는 임계값이다. 이러한 방식으로 특정 색상에 해당하는 포인트들을 간단하게 추출할 수 있다. 그러나 실제 포인트 클라우드에서는 색상 변화가 자연스럽지 않거나 잡음이 많을 수 있기 때문에, 보다 정교한 세그먼테이션 기법을 사용하는 것이 일반적이다.</p>
<p>컬러 세그먼테이션의 보다 정교한 방법으로는 K-평균 클러스터링, Gaussian Mixture Models(GMM), Mean Shift 등의 기법이 있다. K-평균 클러스터링을 예로 들면, 포인트 클라우드 내의 색상 값을 기반으로 포인트들을 여러 클러스터로 나누고, 각 클러스터에 해당하는 포인트들을 세그먼트로 분할할 수 있다. 클러스터링을 통해 분할된 각 영역은 서로 다른 색상 범위를 가지게 된다.</p>
<p>K-평균 클러스터링 알고리즘은 다음과 같은 과정으로 이루어진다.</p>
<ol>
<li>초기 클러스터 중심 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c_k}</span><script type="math/tex">\mathbf{c_k}</script></span>를 랜덤으로 설정한다.</li>
<li>각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_i}</span><script type="math/tex">\mathbf{p_i}</script></span>에 대해, 가장 가까운 클러스터 중심에 해당 포인트를 할당한다.</li>
<li>각 클러스터에 할당된 포인트들의 색상 값을 평균 내어 클러스터 중심을 업데이트한다.</li>
<li>클러스터 중심이 더 이상 변화하지 않을 때까지 2-3 단계를 반복한다.</li>
</ol>
<p>이를 통해 색상 기반으로 여러 개의 그룹으로 포인트를 나눌 수 있으며, 세그먼테이션을 통해 분석하고자 하는 특정 객체나 영역을 추출할 수 있다.</p>
<h3 id="_8">색상 정보를 이용한 포인트 클라우드 매칭</h3>
<p>포인트 클라우드 매칭은 서로 다른 두 포인트 클라우드를 정렬하거나, 공통된 특징을 찾아내는 과정에서 중요한 역할을 한다. 매칭은 주로 기하학적 정보를 기반으로 하지만, 색상 정보를 추가로 활용하면 보다 정확한 매칭이 가능하다. 특히, 두 포인트 클라우드가 서로 다른 각도나 거리에서 캡처된 경우, 색상 정보가 중요한 단서로 사용될 수 있다.</p>
<p>포인트 클라우드 매칭 과정에서, 기하학적 정보뿐만 아니라 색상 정보를 함께 고려하는 방법 중 하나는, 각 포인트의 특징 벡터에 색상 정보를 포함시키는 것이다. 즉, 각 포인트를 매칭할 때, 위치 정보와 함께 색상 정보도 매칭 기준에 포함되는 방식이다.</p>
<p>특징 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f_p}</span><script type="math/tex">\mathbf{f_p}</script></span>를 기하학적 좌표와 색상 정보를 함께 포함한 형태로 정의하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{f_p} = [x, y, z, r, g, b]
</div>
<script type="math/tex; mode=display">
\mathbf{f_p} = [x, y, z, r, g, b]
</script>
</div>
<p>이 특징 벡터를 이용하여 두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P_1}, \mathbf{P_2}</span><script type="math/tex">\mathbf{P_1}, \mathbf{P_2}</script></span>의 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_1} \in \mathbf{P_1}</span><script type="math/tex">\mathbf{p_1} \in \mathbf{P_1}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_2} \in \mathbf{P_2}</span><script type="math/tex">\mathbf{p_2} \in \mathbf{P_2}</script></span> 간의 거리 <span class="arithmatex"><span class="MathJax_Preview">d(\mathbf{p_1}, \mathbf{p_2})</span><script type="math/tex">d(\mathbf{p_1}, \mathbf{p_2})</script></span>는 기하학적 거리와 색상 거리의 조합으로 정의될 수 있다.</p>
<p>두 포인트 간의 기하학적 거리는 유클리드 거리로 표현되며, 색상 거리 역시 유클리드 거리 또는 다른 색상 공간 기반의 거리를 사용할 수 있다. 두 포인트 간의 종합적인 거리는 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{p_1}, \mathbf{p_2}) = \alpha \cdot d_{\text{geo}}(\mathbf{p_1}, \mathbf{p_2}) + \beta \cdot d_{\text{color}}(\mathbf{p_1}, \mathbf{p_2})
</div>
<script type="math/tex; mode=display">
d(\mathbf{p_1}, \mathbf{p_2}) = \alpha \cdot d_{\text{geo}}(\mathbf{p_1}, \mathbf{p_2}) + \beta \cdot d_{\text{color}}(\mathbf{p_1}, \mathbf{p_2})
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">d_{\text{geo}}(\mathbf{p_1}, \mathbf{p_2})</span><script type="math/tex">d_{\text{geo}}(\mathbf{p_1}, \mathbf{p_2})</script></span>는 기하학적 거리,
- <span class="arithmatex"><span class="MathJax_Preview">d_{\text{color}}(\mathbf{p_1}, \mathbf{p_2})</span><script type="math/tex">d_{\text{color}}(\mathbf{p_1}, \mathbf{p_2})</script></span>는 색상 거리,
- <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span>는 각각 기하학적 정보와 색상 정보의 가중치를 의미한다.</p>
<p>색상 거리 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{color}}</span><script type="math/tex">d_{\text{color}}</script></span>는 RGB 값 간의 유클리드 거리로 정의될 수 있으며, 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d_{\text{color}}(\mathbf{p_1}, \mathbf{p_2}) = \sqrt{(r_1 - r_2)^2 + (g_1 - g_2)^2 + (b_1 - b_2)^2}
</div>
<script type="math/tex; mode=display">
d_{\text{color}}(\mathbf{p_1}, \mathbf{p_2}) = \sqrt{(r_1 - r_2)^2 + (g_1 - g_2)^2 + (b_1 - b_2)^2}
</script>
</div>
<p>이러한 방식으로, 색상 정보가 포함된 포인트 클라우드 매칭은 보다 정밀하게 두 클라우드를 정렬하거나 특정 영역을 매칭할 수 있게 해준다.</p>
<h3 id="_9">색상 기반 포인트 클라우드 정렬</h3>
<p>포인트 클라우드 정렬은 두 포인트 클라우드를 동일한 좌표계로 맞추는 과정이다. 일반적으로 Iterative Closest Point(ICP) 알고리즘과 같은 기법이 기하학적 정보를 사용하여 정렬을 수행하지만, 색상 정보를 포함하면 정렬의 정확도를 향상시킬 수 있다.</p>
<p>ICP 알고리즘을 색상 정보까지 고려하여 확장한 방법을 사용하면, 두 포인트 간의 매칭에서 단순히 좌표상의 거리가 아닌 색상 차이까지 함께 고려할 수 있다. 이 경우, ICP의 최적화 과정에서 색상 차이 또한 오차로 반영된다.</p>
<p>ICP 알고리즘의 기본 단계는 다음과 같다:
1. 초기 포즈 추정: 두 포인트 클라우드의 상대적인 위치와 방향을 초기화한다.
2. 최근접 포인트 쌍 찾기: 각 포인트에 대해, 상대 포인트 클라우드에서 가장 가까운 포인트를 찾는다.
3. 변환 계산: 포인트 쌍들 간의 기하학적 변환(회전 및 평행 이동)을 계산한다.
4. 변환 적용: 계산된 변환을 포인트 클라우드에 적용하고, 오차를 줄이는 방향으로 반복한다.</p>
<p>이 과정에서 기하학적 정보만을 사용하는 것이 아니라, 색상 정보를 포함하여 두 포인트 간의 유사성을 계산하는 방법을 추가할 수 있다. 이렇게 하면 매칭이 단순한 거리 기반에서 벗어나, 색상 차이를 줄이는 방향으로 정렬이 이루어진다.</p>
<h3 id="_10">색상 정보를 이용한 클러스터링 및 객체 인식</h3>
<p>포인트 클라우드에서 색상 정보를 활용한 클러스터링은 객체 인식의 중요한 부분이다. 기하학적 정보만을 사용할 때보다, 색상 정보를 추가로 고려하면 보다 효과적인 클러스터링과 객체 인식이 가능하다. 예를 들어, 자동차의 포인트 클라우드에서 빨간색과 회색 부분이 있으면, 색상 정보를 이용해 각 부분을 쉽게 분리할 수 있다.</p>
<p>대표적인 클러스터링 알고리즘으로는 DBSCAN(Density-Based Spatial Clustering of Applications with Noise)이나 K-평균 알고리즘이 있다. 색상 정보를 활용한 클러스터링은 기하학적 거리와 색상 거리를 동시에 고려하여 클러스터를 형성한다.</p>
<p>DBSCAN 알고리즘을 예로 들면, 포인트 간의 거리를 계산할 때 색상 정보를 포함한 거리로 확장할 수 있다. DBSCAN은 밀도 기반의 클러스터링 방법으로, 밀도가 높은 영역을 클러스터로 정의하고, 밀도가 낮은 영역을 잡음으로 처리한다. 색상 정보를 포함하면, 기하학적으로는 떨어져 있지만 색상이 비슷한 포인트들을 동일한 클러스터로 포함시킬 수 있다.</p>
<p>DBSCAN의 핵심 파라미터는 다음과 같다:
- <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>: 클러스터의 반경을 결정하는 값으로, 포인트 간의 최대 거리.
- MinPts: 클러스터를 형성하기 위한 최소한의 이웃 포인트 수.</p>
<p>이때, 색상 정보를 포함하여 포인트 간의 거리를 계산하면, 다음과 같은 총 거리를 정의할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d_{\text{total}} = \alpha \cdot d_{\text{geo}} + \beta \cdot d_{\text{color}}
</div>
<script type="math/tex; mode=display">
d_{\text{total}} = \alpha \cdot d_{\text{geo}} + \beta \cdot d_{\text{color}}
</script>
</div>
<p>이를 통해 색상과 기하학적 정보가 모두 반영된 클러스터링을 수행할 수 있으며, 색상에 따라 물체를 보다 명확하게 인식할 수 있다.</p>
<h3 id="_11">색상 기반의 데이터 시각화</h3>
<p>포인트 클라우드 데이터를 시각화할 때, 색상 정보는 매우 중요한 역할을 한다. 색상 정보는 단순한 위치 데이터만으로는 확인할 수 없는 다양한 시각적 단서를 제공하며, 이를 통해 포인트 클라우드의 구조와 특성을 보다 명확하게 파악할 수 있다.</p>
<p>포인트 클라우드에서 색상 정보는 크게 두 가지 방식으로 시각화될 수 있다:
1. 원본 색상 데이터 시각화: 실제 캡처된 색상 값을 그대로 시각화하는 방법으로, 각 포인트에 할당된 색상 값을 화면에 표시한다. 이는 주로 스캔된 실세계 데이터를 표현할 때 유용하다.
2. 속성 기반 색상 매핑: 포인트 클라우드의 특정 속성(예: 높이, 밀도, 반사 강도 등)에 따라 색상을 매핑하는 방법이다. 이 방식에서는 색상 정보가 직접적으로 포함되지 않은 데이터에서도, 특정 속성에 기반하여 임의의 색상 값을 할당할 수 있다.</p>
<p>속성 기반 색상 매핑의 한 예로, 포인트의 높이에 따라 색상을 다르게 표시하는 경우가 있다. 이를 수학적으로 표현하면, 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span> 값을 <span class="arithmatex"><span class="MathJax_Preview">z_{\text{min}}</span><script type="math/tex">z_{\text{min}}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">z_{\text{max}}</span><script type="math/tex">z_{\text{max}}</script></span> 사이에서 정규화한 후, 정규화된 값에 따라 색상을 매핑하는 방식이다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
z_{\text{norm}} = \frac{z - z_{\text{min}}}{z_{\text{max}} - z_{\text{min}}}
</div>
<script type="math/tex; mode=display">
z_{\text{norm}} = \frac{z - z_{\text{min}}}{z_{\text{max}} - z_{\text{min}}}
</script>
</div>
<p>이 <span class="arithmatex"><span class="MathJax_Preview">z_{\text{norm}}</span><script type="math/tex">z_{\text{norm}}</script></span> 값에 따라 색상을 결정하는 컬러맵을 적용하면, 포인트 클라우드에서 높이 정보를 직관적으로 표현할 수 있다.</p>
<h3 id="_12">색상 정보 보정 및 교정</h3>
<p>포인트 클라우드에서 색상 정보를 처리할 때, 실제 스캔된 데이터의 색상이 왜곡되거나 오류가 발생하는 경우가 종종 있다. 이러한 오류는 다양한 이유로 발생할 수 있으며, 주로 다음과 같은 원인들로 발생한다:
- 스캐너나 카메라의 색상 감지 오류
- 조명 조건의 변화
- 반사나 그림자 등 외부 요인</p>
<p>따라서, 포인트 클라우드에서 정확한 색상 데이터를 얻기 위해서는 색상 보정 및 교정 작업이 필수적이다. 이 과정에서는 다음과 같은 방법들을 활용할 수 있다.</p>
<h4 id="_13">감마 보정</h4>
<p>감마 보정은 카메라 센서의 비선형 응답을 보정하는 기법으로, 색상 데이터를 보다 정확하게 표현하기 위해 사용된다. 포인트 클라우드에서 색상 정보를 다룰 때, RGB 값은 보통 비선형적인 방식으로 감지되기 때문에 이를 선형화하는 과정이 필요하다. 감마 보정은 다음과 같은 공식으로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
I_{\text{corrected}} = I_{\text{original}}^{\gamma}
</div>
<script type="math/tex; mode=display">
I_{\text{corrected}} = I_{\text{original}}^{\gamma}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">I_{\text{corrected}}</span><script type="math/tex">I_{\text{corrected}}</script></span>는 보정된 색상 값, <span class="arithmatex"><span class="MathJax_Preview">I_{\text{original}}</span><script type="math/tex">I_{\text{original}}</script></span>은 원본 색상 값, <span class="arithmatex"><span class="MathJax_Preview">\gamma</span><script type="math/tex">\gamma</script></span>는 감마 값이다. 일반적으로 <span class="arithmatex"><span class="MathJax_Preview">\gamma</span><script type="math/tex">\gamma</script></span> 값은 2.2로 설정되며, 이를 통해 색상 데이터를 선형화할 수 있다.</p>
<p>감마 보정을 통해 포인트 클라우드의 색상 정보를 더 명확하게 하고, 비정상적인 색상 표현을 줄일 수 있다.</p>
<h4 id="_14">화이트 밸런스</h4>
<p>화이트 밸런스는 색온도의 차이에 의해 발생하는 색상 왜곡을 교정하는 과정이다. 특히 실외나 조명이 일정하지 않은 환경에서 스캔된 포인트 클라우드는 색상이 왜곡될 수 있으며, 이를 보정하기 위해 화이트 밸런스 조정이 필요하다.</p>
<p>화이트 밸런스는 보통 다음과 같은 방식으로 이루어진다:
- 이미지의 평균 색상을 계산하여, 이를 중립적인 색상(일반적으로 회색)으로 맞춘다.
- 각 채널(R, G, B)의 값에 적절한 가중치를 곱하여, 색온도에 따른 왜곡을 줄인다.</p>
<p>화이트 밸런스를 통해 포인트 클라우드의 색상 정보가 원래의 색상에 가깝도록 교정할 수 있다. PCL 라이브러리에서는 이러한 교정을 위한 다양한 함수와 알고리즘을 제공한다.</p>
<h4 id="_15">히스토그램 균등화</h4>
<p>히스토그램 균등화는 색상 데이터의 분포를 개선하여 더 풍부한 시각적 정보를 제공하는 방법이다. 포인트 클라우드에서 색상 값이 특정 범위에 집중되어 있을 때, 이 정보를 균등하게 분포시키기 위해 히스토그램 균등화를 사용할 수 있다.</p>
<p>히스토그램 균등화는 RGB 각 채널에 대해 다음과 같은 절차로 수행된다:
1. 각 채널에 대한 누적 분포 함수(CDF)를 계산한다.
2. CDF를 이용해 각 색상 값을 재매핑하여 균등한 분포를 만든다.</p>
<p>이를 통해 색상 값이 한정된 범위에 몰려 있는 문제를 해결하고, 보다 풍부한 색상 표현을 가능하게 한다.</p>
<h3 id="_16">색상 기반 객체 추적</h3>
<p>포인트 클라우드에서 객체를 추적하는 작업은 주로 기하학적 정보에 의존하지만, 색상 정보를 포함하면 추적 성능을 크게 향상시킬 수 있다. 색상 기반 객체 추적은 특히 색상이 명확히 구분되는 물체에 대해 효과적이며, 카메라로 촬영한 포인트 클라우드에서는 색상 정보가 중요한 단서로 사용된다.</p>
<p>색상 기반 객체 추적은 일반적으로 다음과 같은 과정으로 수행된다:
1. 초기 객체 위치와 색상 정보 추출: 첫 번째 프레임에서 추적할 객체의 위치와 색상 값을 추출한다.
2. 다음 프레임에서 해당 색상 값을 기반으로 객체를 탐색: 연속된 프레임에서 이전에 추적된 색상 값과 유사한 색상 값을 가진 포인트를 찾아 객체의 위치를 추적한다.
3. 색상 정보와 기하학적 정보를 함께 사용하여 객체의 이동을 추적: 색상 정보뿐만 아니라, 위치 정보와 속도 등도 함께 고려하여 객체의 움직임을 예측한다.</p>
<p>색상 기반 객체 추적에서는 색상 값만으로는 잡음이나 오차가 발생할 수 있기 때문에, 기하학적 정보와 결합하여 보다 안정적인 추적을 수행하는 것이 일반적이다.</p>
<h3 id="_17">색상 정보를 이용한 물체 식별</h3>
<p>포인트 클라우드에서 특정 물체를 식별하는 작업에 색상 정보는 매우 유용하게 사용될 수 있다. 색상 정보는 물체의 기하학적 모양이 비슷한 다른 물체와 구별할 수 있는 중요한 단서가 될 수 있으며, 이를 통해 더욱 정밀한 물체 인식을 가능하게 한다.</p>
<p>특정 색상을 가진 물체를 식별하기 위해, 다음과 같은 절차를 따를 수 있다:
1. 색상 특징 추출: RGB 값 또는 다른 색상 공간으로 변환한 후, 물체의 색상 특징을 추출한다.
2. 색상 기반의 특징 매칭: 데이터베이스에 있는 물체의 색상 특징과 현재 포인트 클라우드에서 추출한 색상 특징을 비교하여, 가장 유사한 물체를 식별한다.
3. 물체 인식: 색상 정보와 기하학적 정보를 결합하여, 물체의 위치와 범위를 파악하고, 이를 바탕으로 최종적으로 물체를 식별한다.</p>
<p>예를 들어, 특정 색상을 가진 차량이나 신호등, 도로 표지판 등의 물체를 포인트 클라우드에서 추출할 수 있으며, 이 정보를 바탕으로 자율주행차나 로봇 시스템에서 중요한 역할을 할 수 있다.</p>
<h3 id="_18">색상 정보를 활용한 시멘틱 분할</h3>
<p>시멘틱 분할(Semantic Segmentation)은 포인트 클라우드를 영역별로 나누고, 각 영역에 의미 있는 레이블을 할당하는 작업이다. 색상 정보는 이러한 시멘틱 분할 작업에서 중요한 역할을 할 수 있다. 특히 실세계에서 캡처한 포인트 클라우드 데이터는 물체마다 고유한 색상 패턴을 가지는 경우가 많기 때문에, 색상 정보는 분할의 정확도를 크게 향상시킬 수 있다.</p>
<p>시멘틱 분할에서 색상 정보를 활용하는 방법은 다음과 같다:
1. 색상 기반 특징 추출: 각 포인트의 RGB 값을 기반으로 색상 특징을 추출하고, 이를 기하학적 정보와 함께 사용한다.
2. 머신러닝 또는 딥러닝 모델 적용: 추출된 색상 특징을 이용해 학습된 모델을 적용하여, 각 포인트가 어느 클래스에 속하는지 분류한다. 대표적인 모델로는 랜덤 포레스트, 서포트 벡터 머신(SVM), 혹은 최근에는 딥러닝 기반의 PointNet, PointCNN 등이 있다.
3. 분할 결과의 후처리: 색상 정보와 기하학적 정보를 결합하여, 보다 세밀한 분할 결과를 도출하고, 잡음이나 오류를 최소화한다.</p>
<h3 id="_19">색상 정보를 활용한 포인트 클라우드 압축</h3>
<p>포인트 클라우드 데이터를 저장하고 전송할 때, 색상 정보는 데이터를 크게 증가시키는 요소 중 하나이다. 따라서 포인트 클라우드의 색상 정보를 효율적으로 압축하는 것은 매우 중요하다. 색상 정보를 압축하는 방법은 주로 이미지 압축 기술에서 차용되며, 대표적인 방식으로는 다음과 같은 방법이 있다.</p>
<h4 id="quantization">퀀타이제이션(Quantization)</h4>
<p>퀀타이제이션은 색상 값을 제한된 범위로 줄이는 방법이다. 일반적으로 RGB 색상 값은 각 채널당 8비트(256단계)로 표현되지만, 이를 4비트 또는 2비트로 줄이면 데이터 크기를 크게 줄일 수 있다. 퀀타이제이션은 포인트 클라우드의 해상도와 색상 정보의 정확도 사이의 균형을 맞추는 것이 핵심이다.</p>
<h4 id="_20">색상 계층 구조 압축</h4>
<p>색상 계층 구조 압축은 포인트 클라우드의 공간 분할 방식(예: 옥트리 구조)을 활용하여, 공간적으로 인접한 포인트들의 색상 정보를 공유하거나 유사한 색상 값을 가지는 영역을 함께 압축하는 방법이다. 이 방식은 포인트 간의 기하학적 인접성을 고려하여 색상 정보를 효율적으로 표현할 수 있다.</p>
<h4 id="_21">지각적 색상 모델 기반 압축</h4>
<p>지각적 색상 모델을 기반으로 색상 정보를 압축하는 방법은 인간이 인식하는 색상 차이를 고려하여, 시각적으로 큰 차이가 없는 색상 값을 함께 묶어 압축하는 방식이다. 예를 들어, 라비엘의 색상 공간(L<em>a</em>b*)과 같은 지각적 색상 모델을 사용하면, RGB보다 더 효율적인 색상 압축이 가능하다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1203/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1203/" class="btn btn-xs btn-link">
        색상 기반 클러스터링 기법
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1201/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1201/" class="btn btn-xs btn-link">
        RGB-D 카메라 데이터와 PCL
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>