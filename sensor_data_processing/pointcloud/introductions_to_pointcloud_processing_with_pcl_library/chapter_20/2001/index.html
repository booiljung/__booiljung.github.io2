<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introductions_to_pointcloud_processing_with_pcl_library/chapter_20/2001/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>로봇과 PCL의 연동 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "1. \ub85c\ubd07\uc758 3D \uc13c\uc11c \uc2dc\uc2a4\ud15c", url: "#_top", children: [
          ]},
          {title: "2. PCL\uc744 \uc774\uc6a9\ud55c \ud658\uacbd \uc778\uc2dd", url: "#2-pcl", children: [
          ]},
          {title: "3. \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\ub97c \uc774\uc6a9\ud55c \ub85c\ubd07\uc758 \uc9c0\ub3c4 \uc791\uc131 (SLAM)", url: "#3-slam", children: [
          ]},
          {title: "4. \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\ub97c \uc774\uc6a9\ud55c \uac1d\uccb4 \uc778\uc2dd", url: "#4", children: [
          ]},
          {title: "5. \ub85c\ubd07\uc758 \uacbd\ub85c \uacc4\ud68d \ubc0f \uc7a5\uc560\ubb3c \ud68c\ud53c", url: "#5", children: [
          ]},
          {title: "6. \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ucc98\ub9ac \ubc0f \uc81c\uc5b4 \ud53c\ub4dc\ubc31", url: "#6", children: [
          ]},
          {title: "7. \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uae30\ubc18\uc758 \uac1d\uccb4 \ucd94\uc801", url: "#7", children: [
          ]},
          {title: "8. \ub85c\ubd07\uacfc PCL\uc758 \ud1b5\uc2e0 \ud504\ub85c\ud1a0\ucf5c", url: "#8-pcl", children: [
          ]},
          {title: "9. \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\ub97c \uc774\uc6a9\ud55c \ub85c\ubd07\uc758 \uacf5\uac04 \uc778\uc2dd \ubc0f \uc791\uc5c5 \uacc4\ud68d", url: "#9", children: [
              {title: "\uacf5\uac04 \ubd84\ud560 \ubc0f \ubd84\uc11d", url: "#_1" },
              {title: "\uac1d\uccb4\uc758 \uc704\uce58\uc640 \uc790\uc138 \ucd94\uc815", url: "#_2" },
              {title: "\uc791\uc5c5 \uacc4\ud68d \ubc0f \uacbd\ub85c \uc0dd\uc131", url: "#_3" },
              {title: "\ucda9\ub3cc \uac10\uc9c0 \ubc0f \ud68c\ud53c", url: "#_4" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2002/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2002/" class="btn btn-xs btn-link">
        이동 로봇의 포인트 클라우드 활용
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_19/1905/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_19/1905/" class="btn btn-xs btn-link">
        실시간 데이터 전송을 위한 압축 기법
      </a>
    </div>
    
  </div>

    

    <p>PCL(Point Cloud Library)은 로봇공학에서 매우 유용한 도구로, 주로 3차원 센서 데이터를 처리하는 데 사용된다. 이를 통해 로봇은 환경을 보다 효과적으로 인식하고 상호작용할 수 있다. 로봇과 PCL의 연동에서 가장 중요한 요소는 로봇이 3차원 데이터를 실시간으로 수집하고 이를 기반으로 동작을 계획하거나 적응하는 과정이다. 이러한 연동을 위해서는 로봇의 센서 시스템, PCL의 데이터 처리 파이프라인, 그리고 로봇의 운동 계획 및 제어 시스템 간의 밀접한 통합이 필요하다.</p>
<h3 id="1-3d">1. 로봇의 3D 센서 시스템</h3>
<p>로봇에 부착된 3차원 센서들은 주로 LiDAR, RGB-D 카메라, 또는 스테레오 카메라로 구성된다. 이러한 센서들은 주변 환경을 포인트 클라우드 형태로 기록하며, 이 데이터는 로봇의 지각 시스템의 핵심 입력이 된다.</p>
<p>포인트 클라우드는 일반적으로 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P} = \{ \mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n \}</span><script type="math/tex">\mathbf{P} = \{ \mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n \}</script></span> 형태로 표현되며, 여기서 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i = [x_i, y_i, z_i]^T</span><script type="math/tex">\mathbf{p}_i = [x_i, y_i, z_i]^T</script></span>는 공간 좌표를 나타낸다. 이러한 데이터를 실시간으로 수집하고 처리하기 위해서는 고속의 데이터 전송과 병렬 처리 시스템이 필요하다.</p>
<h3 id="2-pcl">2. PCL을 이용한 환경 인식</h3>
<p>PCL은 이러한 센서 데이터를 처리하여 로봇이 환경을 인식할 수 있도록 돕는다. 예를 들어, 지면이나 벽과 같은 평면을 추출하는데 RANSAC(Random Sample Consensus) 알고리즘이 사용될 수 있다. 이는 포인트 클라우드에서 평면을 찾는 과정에서 유용하며, 다음과 같은 과정을 거친다:</p>
<ol>
<li>임의의 점들을 샘플링하여 모델을 생성한다.</li>
<li>모델에 맞는 포인트를 찾는다.</li>
<li>모델에 맞지 않는 포인트를 제거한다.</li>
</ol>
<p>이 과정을 통해 로봇은 주변의 평면을 감지하고, 이를 기반으로 경로를 계획하거나 장애물을 회피할 수 있다.</p>
<p>수학적으로, 평면 방정식은 다음과 같이 표현될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
ax + by + cz + d = 0
</div>
<script type="math/tex; mode=display">
ax + by + cz + d = 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>, <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>, <span class="arithmatex"><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span>, <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>는 평면을 정의하는 계수이고, <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, <span class="arithmatex"><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>, <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>는 포인트 클라우드 상의 한 점이다.</p>
<h3 id="3-slam">3. 포인트 클라우드를 이용한 로봇의 지도 작성 (SLAM)</h3>
<p>로봇이 PCL을 이용하여 지도 작성(Simultaneous Localization and Mapping, SLAM)을 수행하는 경우, 포인트 클라우드를 실시간으로 처리하여 로봇의 위치와 환경 지도를 동시에 갱신한다. 로봇은 연속적인 포인트 클라우드를 통해 주어진 환경의 공간적 구조를 학습하고, 이를 기반으로 주행 경로를 결정한다. </p>
<p>SLAM의 수학적 기초는 다음과 같이 표현할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_t = f(\mathbf{x}_{t-1}, \mathbf{u}_t) + \mathbf{w}_t
</div>
<script type="math/tex; mode=display">
\mathbf{x}_t = f(\mathbf{x}_{t-1}, \mathbf{u}_t) + \mathbf{w}_t
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{z}_t = h(\mathbf{x}_t) + \mathbf{v}_t
</div>
<script type="math/tex; mode=display">
\mathbf{z}_t = h(\mathbf{x}_t) + \mathbf{v}_t
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_t</span><script type="math/tex">\mathbf{x}_t</script></span>는 로봇의 상태 벡터 (위치, 방향 등),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_t</span><script type="math/tex">\mathbf{u}_t</script></span>는 입력 명령 (로봇의 이동 또는 회전),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_t</span><script type="math/tex">\mathbf{z}_t</script></span>는 센서 측정치 (포인트 클라우드),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{w}_t</span><script type="math/tex">\mathbf{w}_t</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}_t</span><script type="math/tex">\mathbf{v}_t</script></span>는 잡음 항이다.</p>
<p>이 방정식은 로봇의 상태가 이전 상태와 입력 명령을 기반으로 어떻게 변하는지를 설명하며, 동시에 센서 데이터는 현재 상태에 대한 정보를 제공한다. </p>
<h3 id="4">4. 포인트 클라우드를 이용한 객체 인식</h3>
<p>로봇은 PCL을 통해 주변 환경을 인식할 뿐만 아니라, 특정 객체를 탐지하고 인식할 수 있다. 이를 위해서는 주로 다음과 같은 순서로 작업이 진행된다:</p>
<ol>
<li><strong>전처리</strong>: 먼저 포인트 클라우드에서 불필요한 노이즈를 제거하고, 다운샘플링 등을 통해 데이터를 간소화한다. 이 단계에서는 Voxel Grid 필터와 같은 기법을 사용할 수 있다. 이 필터는 3D 공간을 일정 크기의 그리드로 나누고, 각 그리드에서 대표적인 포인트를 선택하여 데이터의 해상도를 낮춘다.</li>
</ol>
<p>수학적으로, 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P} = \{ \mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n \}</span><script type="math/tex">\mathbf{P} = \{ \mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n \}</script></span>가 주어졌을 때, Voxel Grid 필터는 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i = [x_i, y_i, z_i]^T</span><script type="math/tex">\mathbf{p}_i = [x_i, y_i, z_i]^T</script></span>를 작은 3D 그리드 상에서 하나의 셀에 매핑하여 대표 포인트를 선택한다. </p>
<ol>
<li>
<p><strong>세그멘테이션(Segmentation)</strong>: 포인트 클라우드 데이터를 의미 있는 그룹으로 분할한다. 예를 들어, 테이블 위의 물체들을 인식하려면 먼저 테이블을 감지한 후 테이블 위의 객체들을 추출해야 한다. 이때 RANSAC 알고리즘과 같은 기법을 사용하여 평면을 분리할 수 있다.</p>
</li>
<li>
<p><strong>특징 추출 및 매칭</strong>: 각 객체를 고유하게 구분할 수 있는 특징을 추출하여 학습된 데이터베이스와 비교한다. PCL은 다양한 특징 기술자를 제공하며, 대표적인 예로 PFH (Point Feature Histograms)와 FPFH (Fast Point Feature Histograms)가 있다.</p>
</li>
</ol>
<p>PFH는 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해 주변 포인트와의 기하학적 관계를 기반으로 특징 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}_i</span><script type="math/tex">\mathbf{f}_i</script></span>를 생성한다. 이를 통해 객체의 모양을 보다 정밀하게 인식할 수 있다.</p>
<p>FPFH는 PFH를 계산하는 과정을 더 빠르게 하기 위해 고안된 기법으로, 지역적인 정보만을 사용하여 특징을 계산한다. PFH와 FPFH 모두 포인트 클라우드에서 객체의 형상을 구체화하는 데 유용하다.</p>
<ol>
<li><strong>객체 인식</strong>: 위의 특징 추출 과정에서 얻어진 특징 벡터를 사전에 학습된 모델과 비교하여 객체를 인식한다. 이 과정은 주로 최근에는 딥러닝 기반의 모델을 활용하여 더 높은 정확도로 수행되며, 이를 통해 로봇은 주어진 환경에서 특정 객체를 탐지하고, 이를 기반으로 동작할 수 있다.</li>
</ol>
<h3 id="5">5. 로봇의 경로 계획 및 장애물 회피</h3>
<p>로봇이 PCL을 통해 수집한 환경 데이터를 바탕으로, 실시간으로 경로를 계획하고 장애물을 회피하는 기능도 매우 중요하다. 이를 위해 로봇은 포인트 클라우드 데이터에서 장애물을 탐지하고, 안전한 경로를 탐색하게 된다.</p>
<p>로봇의 경로 계획 문제는 일반적으로 다음과 같이 최적화 문제로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min \int_0^T L(\mathbf{x}(t), \mathbf{u}(t)) dt
</div>
<script type="math/tex; mode=display">
\min \int_0^T L(\mathbf{x}(t), \mathbf{u}(t)) dt
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{subject to } \mathbf{x}(0) = \mathbf{x}_0, \mathbf{x}(T) = \mathbf{x}_f, \mathbf{x}(t) \in \Omega
</div>
<script type="math/tex; mode=display">
\text{subject to } \mathbf{x}(0) = \mathbf{x}_0, \mathbf{x}(T) = \mathbf{x}_f, \mathbf{x}(t) \in \Omega
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서의 로봇의 상태 벡터 (위치 및 방향),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서의 입력 벡터 (속도, 회전 속도 등),
- <span class="arithmatex"><span class="MathJax_Preview">L(\mathbf{x}, \mathbf{u})</span><script type="math/tex">L(\mathbf{x}, \mathbf{u})</script></span>는 비용 함수 (예: 거리, 에너지 소비),
- <span class="arithmatex"><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span>는 로봇의 상태 공간 제약 (예: 장애물 피하기).</p>
<p>이 문제를 풀기 위해서는 포인트 클라우드 데이터에서 장애물을 인식하고, 그 정보를 활용하여 로봇이 안전한 경로를 탐색하게 된다. 일반적인 알고리즘으로는 D<em> Lite, A</em>, 그리고 RRT (Rapidly-exploring Random Trees) 등이 사용될 수 있다.</p>
<p>특히, RRT 알고리즘은 랜덤한 샘플링을 통해 빠르게 경로를 탐색하는 방식으로, 큰 환경에서도 효율적으로 사용할 수 있다. 로봇은 포인트 클라우드에서 장애물의 위치를 실시간으로 인식하고, 이를 기반으로 경로를 동적으로 수정한다.</p>
<h3 id="6">6. 실시간 데이터 처리 및 제어 피드백</h3>
<p>로봇과 PCL의 연동에서 중요한 또 다른 요소는 실시간 데이터 처리와 제어 피드백이다. 로봇은 계속해서 새로운 포인트 클라우드를 수집하고, 이를 바탕으로 실시간으로 환경을 분석한 후, 적절한 행동을 취해야 한다. 이 과정은 여러 가지 실시간 처리 기법이 필요하며, 병렬 처리 및 스트리밍 기술을 사용하여 성능을 최적화할 수 있다.</p>
<p>로봇의 실시간 피드백 루프는 다음과 같은 순서로 구성될 수 있다:</p>
<ol>
<li><strong>센서 데이터 수집</strong>: 로봇은 LiDAR, RGB-D 카메라, 또는 스테레오 카메라 등을 통해 실시간으로 포인트 클라우드를 수집한다.</li>
<li><strong>데이터 처리</strong>: 수집된 데이터를 실시간으로 전처리 및 필터링한다. 예를 들어, 노이즈 제거, 다운샘플링, 평면 추출 등을 수행한다.</li>
<li><strong>환경 분석 및 상태 평가</strong>: 전처리된 데이터를 사용하여 로봇이 현재 위치 및 주변 환경을 인식한다. 이 단계에서 장애물 감지 및 거리 계산 등을 수행한다.</li>
<li><strong>경로 계획 및 제어 명령 생성</strong>: 환경 분석 결과를 바탕으로 경로 계획 알고리즘을 사용하여 최적의 경로를 탐색하고, 필요한 제어 명령을 생성한다.</li>
<li><strong>실시간 제어 명령 실행</strong>: 로봇은 생성된 제어 명령을 즉시 실행하며, 계속해서 센서 데이터를 수집하고 새로운 상황에 맞게 경로를 수정한다.</li>
</ol>
<p>이 피드백 루프는 \textit{sense-think-act} 사이클로 알려져 있으며, 이를 통해 로봇은 동적인 환경에서 안정적으로 동작할 수 있다.</p>
<h3 id="7">7. 포인트 클라우드 기반의 객체 추적</h3>
<p>로봇이 동적인 환경에서 특정 객체를 추적해야 하는 경우, PCL을 활용하여 객체 추적을 실시간으로 수행할 수 있다. 객체 추적은 로봇이 특정 객체를 감지하고, 그 객체의 움직임을 지속적으로 모니터링하는 것을 의미한다. </p>
<p>포인트 클라우드에서 객체를 추적하기 위해서는 다음과 같은 과정이 필요하다:</p>
<ol>
<li>
<p><strong>초기 객체 감지</strong>: 먼저, 로봇은 특정 객체를 감지해야 한다. 이를 위해서는 객체 인식 알고리즘을 사용하여 포인트 클라우드 데이터에서 목표 객체를 식별한다.</p>
</li>
<li>
<p><strong>객체의 모션 모델링</strong>: 감지된 객체가 움직이는 경우, 객체의 모션을 추정해야 한다. 이를 위해 칼만 필터(Kalman Filter)나 입자 필터(Particle Filter)를 사용할 수 있다. 예를 들어, 칼만 필터는 객체의 속도와 가속도를 기반으로 다음 상태를 추정하며, 다음과 같은 수식을 따른다:</p>
</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{x}_{t+1} = \mathbf{A} \mathbf{x}_t + \mathbf{B} \mathbf{u}_t + \mathbf{w}_t
</div>
<script type="math/tex; mode=display">
   \mathbf{x}_{t+1} = \mathbf{A} \mathbf{x}_t + \mathbf{B} \mathbf{u}_t + \mathbf{w}_t
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{z}_t = \mathbf{C} \mathbf{x}_t + \mathbf{v}_t
</div>
<script type="math/tex; mode=display">
   \mathbf{z}_t = \mathbf{C} \mathbf{x}_t + \mathbf{v}_t
</script>
</div>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_t</span><script type="math/tex">\mathbf{x}_t</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서의 객체의 상태 벡터,
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_t</span><script type="math/tex">\mathbf{u}_t</script></span>는 입력 (로봇의 이동),
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_t</span><script type="math/tex">\mathbf{z}_t</script></span>는 센서로부터 측정된 값,
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{w}_t</span><script type="math/tex">\mathbf{w}_t</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}_t</span><script type="math/tex">\mathbf{v}_t</script></span>는 잡음 항이다.</p>
<p>이 모션 모델을 사용하여 객체가 다음 위치에서 어디에 있을지 예측하고, 로봇이 그 객체를 추적할 수 있도록 한다.</p>
<ol>
<li><strong>추적 데이터 갱신</strong>: 추정된 객체의 위치를 계속해서 실시간으로 갱신하며, 로봇은 객체의 위치 변화를 모니터링하고, 해당 객체를 계속 추적한다.</li>
</ol>
<h3 id="8-pcl">8. 로봇과 PCL의 통신 프로토콜</h3>
<p>로봇과 PCL 간의 통신은 주로 다양한 프로토콜을 통해 이루어진다. ROS(Robot Operating System)는 가장 널리 사용되는 미들웨어로, ROS와 PCL을 함께 사용하여 로봇이 센서 데이터를 효율적으로 처리하고, 이를 기반으로 실시간 제어를 할 수 있다.</p>
<p>ROS에서 PCL 데이터를 처리하기 위한 노드(Node)는 포인트 클라우드를 수신하고, 이를 실시간으로 처리한 후 다른 노드에 결과를 전송하는 역할을 한다. 이 과정은 ROS의 퍼블리셔(Publisher)와 서브스크라이버(Subscriber) 모델을 통해 수행된다.</p>
<p>PCL과 ROS의 연동 과정은 다음과 같다:</p>
<ol>
<li><strong>센서 데이터 수집</strong>: ROS의 센서 드라이버를 통해 포인트 클라우드를 수집한다.</li>
<li><strong>PCL 데이터 처리</strong>: 수집된 데이터를 ROS 노드에서 PCL로 처리한다. 여기에는 노이즈 제거, 평면 추출, 객체 인식 등이 포함될 수 있다.</li>
<li><strong>제어 명령 전송</strong>: 처리된 데이터를 기반으로 로봇이 필요한 제어 명령을 생성하고, 이를 ROS를 통해 로봇의 제어 시스템으로 전송한다.</li>
</ol>
<p>PCL과 ROS의 연동을 통해 로봇은 복잡한 환경에서 실시간으로 데이터를 처리하고, 신속하게 적응할 수 있다.</p>
<h3 id="9">9. 포인트 클라우드를 이용한 로봇의 공간 인식 및 작업 계획</h3>
<p>로봇이 PCL을 통해 공간을 인식하고, 그 정보를 바탕으로 특정 작업을 계획하는 과정은 로봇 공학에서 중요한 역할을 한다. 로봇이 물체를 잡거나, 조립을 수행하거나, 특정 지점으로 이동하는 등의 작업을 위해서는 3D 포인트 클라우드를 정확히 이해하고 그에 맞는 행동을 결정해야 한다.</p>
<h4 id="_1">공간 분할 및 분석</h4>
<p>PCL을 활용하여 로봇이 작업할 수 있는 공간을 분석하는 과정은 주로 공간 분할과 관련이 있다. 공간을 효율적으로 분석하기 위해 주로 Octree와 같은 자료 구조가 사용된다. Octree는 3차원 공간을 재귀적으로 8개의 서브 공간으로 나누는 구조로, 포인트 클라우드를 빠르게 처리하는 데 유용하다.</p>
<p>Octree는 특히 로봇이 특정 지역에서 작업을 계획할 때 유용하다. 로봇이 객체를 탐색하거나, 작업 가능한 구역을 파악하는 과정에서 Octree를 사용하면, 로봇이 데이터를 더 효율적으로 탐색할 수 있다. Octree의 구조적 특성상 데이터 탐색이 빠르고, 대용량 포인트 클라우드를 처리할 때 메모리 사용을 줄일 수 있다.</p>
<p>Octree의 수학적 표현은 다음과 같다. 주어진 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>를 Octree 구조에 저장하면, 이 데이터는 계층적인 서브셀들로 나뉘며, 각 서브셀에서 포인트들이 할당된다. 탐색 알고리즘은 이 서브셀을 통해 적합한 데이터 영역을 찾는 방식으로 작동한다.</p>
<h4 id="_2">객체의 위치와 자세 추정</h4>
<p>로봇이 객체를 처리하려면, 해당 객체의 위치와 자세(pose)를 정확히 추정해야 한다. 자세는 위치와 방향을 포함하는데, 포인트 클라우드에서 객체의 자세를 추정하는 과정은 주로 피쳐 매칭 및 최적화 기법을 통해 이루어진다.</p>
<p>객체의 위치는 포인트 클라우드에서 특징점(feature point)을 추출한 후, 사전에 학습된 모델과 비교하여 계산한다. 자세는 주로 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 이동 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>를 사용하여 표현되며, 다음과 같은 변환식으로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p'} = \mathbf{R} \mathbf{p} + \mathbf{t}
</div>
<script type="math/tex; mode=display">
\mathbf{p'} = \mathbf{R} \mathbf{p} + \mathbf{t}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p'}</span><script type="math/tex">\mathbf{p'}</script></span>는 변환 후의 포인트 좌표,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 변환 전의 포인트 좌표,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 객체의 회전 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>는 객체의 이동 벡터이다.</p>
<p>이를 통해 로봇은 포인트 클라우드 상의 객체가 현재 어떤 위치에 있고, 어떤 자세를 취하고 있는지를 계산할 수 있다. 이 과정은 ICP(Iterative Closest Point) 알고리즘과 같은 정합(registration) 알고리즘을 통해 보다 정밀하게 이루어지며, 포인트 클라우드 간의 상관관계를 계산하여 객체의 정확한 자세를 추정한다.</p>
<h4 id="_3">작업 계획 및 경로 생성</h4>
<p>로봇이 객체의 위치와 자세를 파악한 후, 로봇의 작업 계획(Manipulation Planning)이 필요하다. 로봇은 주어진 작업 목표에 맞게 작업 경로를 계획해야 하며, 이 과정에서 포인트 클라우드 기반의 환경 정보를 활용한다.</p>
<p>예를 들어, 로봇이 특정 물체를 집어올려야 하는 작업에서, 로봇은 물체의 위치와 자세를 기반으로 물체를 잡기 위한 경로를 생성한다. 이 경로는 로봇의 팔 또는 그리퍼가 특정 궤적을 따라 이동하면서 작업을 수행하는 것을 의미하며, 경로 계획은 주로 다음과 같은 최적화 문제로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min \int_0^T C(\mathbf{x}(t), \mathbf{u}(t)) \, dt
</div>
<script type="math/tex; mode=display">
\min \int_0^T C(\mathbf{x}(t), \mathbf{u}(t)) \, dt
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서의 로봇의 상태 (위치 및 자세),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서의 로봇의 제어 입력 (속도, 힘 등),
- <span class="arithmatex"><span class="MathJax_Preview">C(\mathbf{x}(t), \mathbf{u}(t))</span><script type="math/tex">C(\mathbf{x}(t), \mathbf{u}(t))</script></span>는 비용 함수 (경로의 길이, 에너지 소비 등).</p>
<p>이 최적화 문제를 해결함으로써, 로봇은 물체를 잡기 위한 최적의 경로를 생성하고, 환경에 맞게 움직인다.</p>
<h4 id="_4">충돌 감지 및 회피</h4>
<p>작업 계획의 마지막 단계에서 로봇은 경로 계획 중 충돌 감지를 수행해야 한다. 로봇이 주어진 경로를 따라 이동할 때, 환경에 있는 다른 물체와의 충돌을 방지하기 위해 포인트 클라우드 데이터를 실시간으로 분석하여 장애물과의 충돌 가능성을 확인한다.</p>
<p>PCL을 활용한 충돌 감지는 주로 KD-Tree 또는 Voxel Grid 기반으로 이루어지며, 이를 통해 로봇의 작업 경로 상에 있는 장애물을 인식하고, 안전한 경로를 탐색할 수 있다.</p>
<p>충돌 감지의 수학적 표현은 다음과 같이 할 수 있다. 로봇의 경로 상의 각 지점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_t</span><script type="math/tex">\mathbf{p}_t</script></span>와 포인트 클라우드 내의 모든 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span> 간의 거리 <span class="arithmatex"><span class="MathJax_Preview">d(\mathbf{p}_t, \mathbf{q}_i)</span><script type="math/tex">d(\mathbf{p}_t, \mathbf{q}_i)</script></span>가 로봇의 충돌 임계값 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{th}}</span><script type="math/tex">d_{\text{th}}</script></span>보다 작으면 충돌로 간주된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{p}_t, \mathbf{q}_i) &lt; d_{\text{th}} \implies \text{충돌 발생}
</div>
<script type="math/tex; mode=display">
d(\mathbf{p}_t, \mathbf{q}_i) < d_{\text{th}} \implies \text{충돌 발생}
</script>
</div>
<p>이를 기반으로 로봇은 경로를 수정하거나 새로운 경로를 탐색하여 안전하게 작업을 수행할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2002/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2002/" class="btn btn-xs btn-link">
        이동 로봇의 포인트 클라우드 활용
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_19/1905/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_19/1905/" class="btn btn-xs btn-link">
        실시간 데이터 전송을 위한 압축 기법
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>