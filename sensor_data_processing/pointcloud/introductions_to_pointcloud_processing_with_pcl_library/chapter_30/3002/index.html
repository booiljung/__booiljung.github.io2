<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introductions_to_pointcloud_processing_with_pcl_library/chapter_30/3002/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>C++를 이용한 PCL 확장 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "PCL \ubaa8\ub4c8 \uad6c\uc870\uc640 \ud655\uc7a5\uc758 \ud544\uc694\uc131", url: "#_top", children: [
          ]},
          {title: "\uc0ac\uc6a9\uc790 \uc815\uc758 \ud074\ub798\uc2a4\uc640 \uba54\uc18c\ub4dc \ucd94\uac00", url: "#_1", children: [
          ]},
          {title: "\uc218\ud559\uc801 \ud655\uc7a5: \uc0ac\uc6a9\uc790 \uc815\uc758 \ud568\uc218 \uc801\uc6a9", url: "#_2", children: [
          ]},
          {title: "\ubcd1\ub82c \ucc98\ub9ac\uc640 \uc131\ub2a5 \ucd5c\uc801\ud654", url: "#_3", children: [
          ]},
          {title: "\uc0ac\uc6a9\uc790 \uc815\uc758 \ud3ec\uc778\ud2b8 \ud0c0\uc785 \ucd94\uac00", url: "#_4", children: [
          ]},
          {title: "\ucee4\uc2a4\ud140 \ud544\ud130 \uad6c\ud604", url: "#_5", children: [
          ]},
          {title: "\uace0\ucc28\uc6d0 \ub370\uc774\ud130 \ucc98\ub9ac", url: "#_6", children: [
          ]},
          {title: "\ub3d9\uc801 \uba54\ubaa8\ub9ac \uad00\ub9ac\uc640 \ucd5c\uc801\ud654", url: "#_7", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub370\uc774\ud130 \ubcd1\ud569 \ubc0f \uc815\ud569", url: "#_8", children: [
          ]},
          {title: "\uace0\uc720 \ud568\uc218 \ubc0f \ucee4\uc2a4\ud140 \uc720\ud2f8\ub9ac\ud2f0 \ucd94\uac00", url: "#_9", children: [
              {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc758 \uc911\uc2ec \uacc4\uc0b0", url: "#_10" },
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ud074\ub7ec\uc2a4\ud130\ub9c1 \uc54c\uace0\ub9ac\uc998 \ud655\uc7a5", url: "#_11", children: [
          ]},
          {title: "\uc0c1\ud638\uc791\uc6a9 \ubc0f \uc2dc\uac01\ud654 \ud655\uc7a5", url: "#_12", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../3003/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../3003/" class="btn btn-xs btn-link">
        사용자 정의 필터와 알고리즘 구현
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../3001/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../3001/" class="btn btn-xs btn-link">
        PCL 모듈 커스터마이징 기법
      </a>
    </div>
    
  </div>

    

    <p>C++는 PCL(Point Cloud Library)의 기본 구현 언어로, 이를 통해 고성능의 커스터마이징 및 확장이 가능한다. PCL 자체가 모듈화되어 있어 사용자 정의 필터, 클러스터링, 매칭 및 여러 가지 알고리즘을 구현하는 데 매우 유연한다. 이 절에서는 PCL의 구조와 이를 C++로 확장하는 방법을 엄밀하게 다룬다.</p>
<h3 id="pcl">PCL 모듈 구조와 확장의 필요성</h3>
<p>PCL의 모듈들은 각각 특정 기능을 담당하며, 이러한 모듈들은 독립적으로 동작하지만 서로 통합될 수 있다. 예를 들어, 필터링 모듈은 점 데이터의 특정 부분을 제거하거나 강조하는 데 사용되며, 매칭 모듈은 여러 포인트 클라우드를 정합하는 데 도움을 준다. 사용자는 이 모듈의 기능을 확장하거나 사용자 정의 기능을 추가할 수 있다.</p>
<p>PCL을 C++로 확장해야 하는 경우는 보통 다음과 같은 상황에서 발생한다:</p>
<ol>
<li>PCL에서 제공하지 않는 새로운 알고리즘을 구현하고자 할 때.</li>
<li>기존 알고리즘을 최적화하거나 특정 요구 사항에 맞게 수정해야 할 때.</li>
<li>고유한 센서 데이터 처리 방식이나 특수한 포인트 클라우드 데이터를 다루어야 할 때.</li>
</ol>
<h3 id="_1">사용자 정의 클래스와 메소드 추가</h3>
<p>PCL의 구조는 클래스 기반으로 되어 있어, 기본적으로 제공되는 클래스들(PointCloud, Filter, KdTree 등)을 상속하여 새로운 기능을 쉽게 추가할 수 있다. 예를 들어, 사용자 정의 필터를 추가하려면 <code>pcl::Filter</code> 클래스를 상속받아 <code>applyFilter</code> 메소드를 오버라이드하는 방식으로 확장할 수 있다.</p>
<pre><code class="language-cpp">template &lt;typename PointT&gt;
class CustomFilter : public pcl::Filter&lt;PointT&gt;
{
  using pcl::Filter&lt;PointT&gt;::filter_name_;

public:
  CustomFilter() { filter_name_ = &quot;CustomFilter&quot;; }

protected:
  void applyFilter(pcl::PointCloud&lt;PointT&gt;&amp; output) override
  {
    // 사용자 정의 필터링 알고리즘 구현
  }
};
</code></pre>
<p>위의 코드는 <code>pcl::Filter</code> 클래스를 상속받아 사용자 정의 필터를 구현하는 예시이다. 여기서 <code>applyFilter</code> 메소드는 필터링 알고리즘을 구현할 수 있는 장소이며, <code>PointT</code>는 템플릿 매개변수로, 다양한 포인트 타입을 처리할 수 있게 해준다.</p>
<h3 id="_2">수학적 확장: 사용자 정의 함수 적용</h3>
<p>PCL에서는 여러 수학적 함수가 사용되며, 이러한 함수는 점 간의 거리 계산, 곡률 계산, 법선 벡터 추출 등에 사용된다. 사용자 정의 수학적 함수를 추가하는 경우, 이러한 기본 구조를 활용하거나 새로운 알고리즘을 C++로 직접 구현할 수 있다.</p>
<p>예를 들어, 포인트 클라우드에서 두 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_1} = [x_1, y_1, z_1]</span><script type="math/tex">\mathbf{p_1} = [x_1, y_1, z_1]</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_2} = [x_2, y_2, z_2]</span><script type="math/tex">\mathbf{p_2} = [x_2, y_2, z_2]</script></span> 사이의 유클리드 거리를 계산하는 공식은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{p_1}, \mathbf{p_2}) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}
</div>
<script type="math/tex; mode=display">
d(\mathbf{p_1}, \mathbf{p_2}) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}
</script>
</div>
<p>C++로 이와 같은 사용자 정의 함수를 추가하려면 다음과 같이 구현할 수 있다:</p>
<pre><code class="language-cpp">float calculateDistance(const pcl::PointXYZ&amp; p1, const pcl::PointXYZ&amp; p2)
{
  return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2) + std::pow(p2.z - p1.z, 2));
}
</code></pre>
<p>이 함수는 두 개의 <code>pcl::PointXYZ</code> 타입의 포인트 간 거리를 계산하며, 확장된 수학적 알고리즘을 추가할 때 매우 유용하게 사용될 수 있다.</p>
<h3 id="_3">병렬 처리와 성능 최적화</h3>
<p>PCL은 대용량 데이터 처리를 위해 설계되었으며, 병렬 처리를 이용한 성능 최적화가 가능한다. C++에서 병렬 처리 기능을 사용하여 PCL의 알고리즘을 확장할 수 있는데, 특히 필터링과 클러스터링 알고리즘에서 이러한 접근이 유용하다. C++11의 <code>std::thread</code>나 OpenMP를 사용하여 병렬 처리를 쉽게 구현할 수 있다.</p>
<p>필터링 예제에서 병렬 처리를 구현하는 방법은 다음과 같다:</p>
<pre><code class="language-cpp">#include &lt;omp.h&gt;

void parallelFilter(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud)
{
  #pragma omp parallel for
  for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i)
  {
    // 필터링 알고리즘 적용
  }
}
</code></pre>
<p>이 코드는 OpenMP를 이용하여 점 데이터를 병렬로 필터링하는 예시이다. 큰 포인트 클라우드를 처리할 때 성능 향상을 기대할 수 있다.</p>
<h3 id="_4">사용자 정의 포인트 타입 추가</h3>
<p>PCL에서는 기본적으로 여러 가지 포인트 타입을 제공하지만, 사용자가 필요로 하는 데이터가 추가적으로 요구될 수 있다. 예를 들어, 포인트에 RGB 색상 정보나 강도(intensity) 값을 추가할 필요가 있다면 사용자 정의 포인트 타입을 정의할 수 있다. C++에서는 <code>PCL_ADD_POINT4D</code> 매크로와 같은 기능을 이용해 손쉽게 확장된 포인트 타입을 정의할 수 있다.</p>
<p>다음은 RGB 색상과 강도 값을 포함하는 사용자 정의 포인트 타입의 예시이다.</p>
<pre><code class="language-cpp">struct PointXYZRGBI
{
  PCL_ADD_POINT4D;  // x, y, z 필드를 추가
  float rgb;        // RGB 색상 정보를 위한 필드
  float intensity;  // 강도 정보를 위한 필드

  EIGEN_MAKE_ALIGNED_OPERATOR_NEW   // 메모리 정렬을 위한 매크로
} EIGEN_ALIGN16;  // 16바이트 정렬을 지정

POINT_CLOUD_REGISTER_POINT_STRUCT(PointXYZRGBI,           // 등록할 구조체
  (float, x, x)                                           // x 좌표
  (float, y, y)                                           // y 좌표
  (float, z, z)                                           // z 좌표
  (float, rgb, rgb)                                       // RGB 색상
  (float, intensity, intensity))                          // 강도
</code></pre>
<p>위 코드에서 <code>PCL_ADD_POINT4D</code>는 기본 3D 좌표(x, y, z)와 함께 동차 좌표계(homogeneous coordinates)를 추가한다. 이후 사용자는 이 구조체를 PCL 내의 기존 함수에서 새로운 포인트 타입으로 사용할 수 있다.</p>
<h3 id="_5">커스텀 필터 구현</h3>
<p>PCL에서 제공되는 필터는 주로 범위 기반 또는 좌표 기반 필터링이 많다. 하지만 사용자가 필요로 하는 복잡한 조건에 맞는 필터링이 필요할 경우, 사용자 정의 필터를 C++로 구현할 수 있다.</p>
<p>예를 들어, 특정 색상 범위에 해당하는 점들만 필터링하는 기능을 추가한다고 가정해봅시다. 이 경우 <code>CustomColorFilter</code> 클래스를 만들어 원하는 조건의 점들만 남기는 필터를 구현할 수 있다.</p>
<pre><code class="language-cpp">template &lt;typename PointT&gt;
class CustomColorFilter : public pcl::Filter&lt;PointT&gt;
{
  using pcl::Filter&lt;PointT&gt;::filter_name_;

public:
  CustomColorFilter() { filter_name_ = &quot;CustomColorFilter&quot;; }

protected:
  void applyFilter(pcl::PointCloud&lt;PointT&gt;&amp; output) override
  {
    for (const auto&amp; point : *this-&gt;input_)
    {
      if (point.rgb &gt;= min_rgb_ &amp;&amp; point.rgb &lt;= max_rgb_)
      {
        output.points.push_back(point);
      }
    }
    output.width = static_cast&lt;uint32_t&gt;(output.points.size());
    output.height = 1;
    output.is_dense = true;
  }

private:
  float min_rgb_;
  float max_rgb_;
};
</code></pre>
<p>이 코드에서는 필터링 대상이 되는 점의 <code>rgb</code> 값이 미리 설정한 범위에 들어오는지 확인한 후, 해당 점만 출력 포인트 클라우드에 추가하는 방식으로 필터링을 수행한다. 이를 통해 다양한 조건의 사용자 정의 필터링을 C++로 구현할 수 있다.</p>
<h3 id="_6">고차원 데이터 처리</h3>
<p>PCL에서 기본적으로 제공하는 데이터는 3차원 좌표를 기반으로 하지만, 실제 응용에서는 고차원 데이터 처리가 필요한 경우가 많다. 예를 들어, 표면의 곡률이나 법선 벡터, 텍스처 좌표 등 고차원 정보가 포함된 데이터를 처리하려면, PCL의 확장 기능을 활용하여 추가적인 계산을 수행할 수 있다.</p>
<p>포인트 클라우드의 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n} = [n_x, n_y, n_z]</span><script type="math/tex">\mathbf{n} = [n_x, n_y, n_z]</script></span>는 각 점의 곡률과 관련이 있으며, 이 정보를 추가로 계산하는 것은 매우 유용하다. 법선 벡터를 계산하는 공식은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{n} = \frac{\mathbf{p}_i - \mathbf{p}_j}{\|\mathbf{p}_i - \mathbf{p}_j\|}
</div>
<script type="math/tex; mode=display">
\mathbf{n} = \frac{\mathbf{p}_i - \mathbf{p}_j}{\|\mathbf{p}_i - \mathbf{p}_j\|}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span>는 인접한 두 점을 나타낸다. 이 법선 벡터를 구하는 C++ 코드 구현 예시는 다음과 같다:</p>
<pre><code class="language-cpp">#include &lt;pcl/features/normal_3d.h&gt;

void computeNormals(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud)
{
  pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;
  ne.setInputCloud(cloud);

  pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;());
  ne.setSearchMethod(tree);

  pcl::PointCloud&lt;pcl::Normal&gt;::Ptr cloud_normals(new pcl::PointCloud&lt;pcl::Normal&gt;);
  ne.setRadiusSearch(0.03);

  ne.compute(*cloud_normals);
}
</code></pre>
<p>위의 코드는 PCL의 <code>NormalEstimation</code> 클래스를 사용하여 각 점의 법선 벡터를 계산하는 방법을 보여준다. 사용자 정의 확장을 위해서는 이러한 법선 벡터 계산 후 추가적인 처리를 할 수 있다.</p>
<h3 id="_7">동적 메모리 관리와 최적화</h3>
<p>PCL의 포인트 클라우드 데이터는 대용량 데이터를 다루기 때문에 메모리 관리와 최적화가 매우 중요하다. 특히, 다중 쓰레드를 사용하거나 동적 메모리 할당을 줄여 성능을 향상시킬 수 있다.</p>
<p>사용자 정의 알고리즘에서 동적 메모리 할당을 최소화하기 위해, 사전에 메모리를 할당하고 이를 재사용하는 방식을 사용할 수 있다. 예를 들어, <code>std::vector</code>를 사용하여 포인트 데이터를 사전에 저장해 두고, 반복적인 알고리즘에서 재사용할 수 있다.</p>
<pre><code class="language-cpp">std::vector&lt;pcl::PointXYZ&gt; point_storage;
point_storage.reserve(cloud-&gt;points.size());  // 메모리 미리 할당

for (const auto&amp; point : cloud-&gt;points)
{
  point_storage.push_back(point);
  // 추가 처리
}
</code></pre>
<p>이 코드는 <code>std::vector</code>를 사용하여 미리 메모리를 할당한 후, 포인트 데이터를 저장하는 방식으로 메모리 할당의 오버헤드를 줄이는 방법을 보여준다.</p>
<h3 id="_8">포인트 클라우드 데이터 병합 및 정합</h3>
<p>PCL에서 제공하는 기본 기능으로는 여러 포인트 클라우드 데이터를 병합하고 정합하는 것이 있다. 그러나 복잡한 응용 프로그램에서는 사용자 정의 정합 알고리즘이 필요할 수 있다. C++로 PCL을 확장하여 더 정밀한 정합을 구현하거나 새로운 병합 기법을 추가할 수 있다.</p>
<p>정합을 위한 중요한 개념 중 하나는 ICP(Iterative Closest Point) 알고리즘이다. 두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P_1}</span><script type="math/tex">\mathbf{P_1}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P_2}</span><script type="math/tex">\mathbf{P_2}</script></span>를 정합할 때, 각각의 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_1} \in \mathbf{P_1}</span><script type="math/tex">\mathbf{p_1} \in \mathbf{P_1}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_2} \in \mathbf{P_2}</span><script type="math/tex">\mathbf{p_2} \in \mathbf{P_2}</script></span>에 대해 가장 가까운 점을 찾고, 그 차이를 최소화하는 변환 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span>을 구하는 방식이다. ICP 알고리즘의 핵심은 다음과 같은 최적화 문제를 해결하는 것이다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{T}} \sum_{i} \|\mathbf{T} \mathbf{p_1^i} - \mathbf{p_2^i}\|^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{T}} \sum_{i} \|\mathbf{T} \mathbf{p_1^i} - \mathbf{p_2^i}\|^2
</script>
</div>
<p>이때, 변환 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span>는 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 평행 이동 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>로 이루어져 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{T} = \begin{bmatrix} \mathbf{R} &amp; \mathbf{t} \\ 0 &amp; 1 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{T} = \begin{bmatrix} \mathbf{R} & \mathbf{t} \\ 0 & 1 \end{bmatrix}
</script>
</div>
<p>ICP 알고리즘은 PCL에서 기본적으로 제공되지만, 다음과 같이 C++로 사용자 정의 ICP 알고리즘을 구현할 수 있다:</p>
<pre><code class="language-cpp">#include &lt;pcl/registration/icp.h&gt;

void customICP(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_in,
               pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_out)
{
  pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp;
  icp.setInputSource(cloud_in);
  icp.setInputTarget(cloud_out);

  pcl::PointCloud&lt;pcl::PointXYZ&gt; Final;
  icp.align(Final);

  std::cout &lt;&lt; &quot;Converged: &quot; &lt;&lt; icp.hasConverged() &lt;&lt; &quot; Score: &quot; &lt;&lt; icp.getFitnessScore() &lt;&lt; std::endl;
}
</code></pre>
<p>위 코드는 PCL의 ICP 클래스를 확장하여 두 포인트 클라우드를 정합하는 예시이다. 기본적인 ICP를 커스터마이즈하여 더 빠르게 수렴하거나, 특정 상황에 맞게 정합을 최적화할 수 있다.</p>
<h3 id="_9">고유 함수 및 커스텀 유틸리티 추가</h3>
<p>PCL 확장을 진행할 때, 유용한 도구로 커스텀 유틸리티 함수를 추가하는 것이 있다. 예를 들어, 점 집합의 중심을 구하는 함수나 특정 조건에 맞는 점만 필터링하는 함수는 데이터 전처리 단계에서 매우 유용할 수 있다. C++로 이러한 유틸리티를 구현하여 PCL 라이브러리에 통합할 수 있다.</p>
<h4 id="_10">포인트 클라우드의 중심 계산</h4>
<p>포인트 클라우드 데이터의 중심은 각 점 좌표의 평균값으로 정의된다. <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>개의 포인트 클라우드 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i = [x_i, y_i, z_i]</span><script type="math/tex">\mathbf{p}_i = [x_i, y_i, z_i]</script></span>의 중심 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span>는 다음과 같이 계산할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{c} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
\mathbf{c} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</script>
</div>
<p>이를 C++로 구현한 코드는 다음과 같다:</p>
<pre><code class="language-cpp">pcl::PointXYZ computeCentroid(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud)
{
  pcl::PointXYZ centroid(0.0, 0.0, 0.0);
  for (const auto&amp; point : cloud-&gt;points)
  {
    centroid.x += point.x;
    centroid.y += point.y;
    centroid.z += point.z;
  }
  centroid.x /= cloud-&gt;points.size();
  centroid.y /= cloud-&gt;points.size();
  centroid.z /= cloud-&gt;points.size();

  return centroid;
}
</code></pre>
<p>이 함수는 입력된 포인트 클라우드의 중심을 계산하여 반환한다. 특히 대규모 데이터 처리 시 이러한 중심 계산은 데이터를 분석하거나 클러스터링하는 데 중요한 전처리 단계로 사용될 수 있다.</p>
<h3 id="_11">포인트 클라우드 클러스터링 알고리즘 확장</h3>
<p>PCL에는 Euclidean 클러스터링과 같은 기본 클러스터링 알고리즘이 내장되어 있지만, 더 복잡한 조건을 만족하는 클러스터링 알고리즘이 필요한 경우 C++로 이를 확장할 수 있다. 예를 들어, 특정 크기 이상의 클러스터만 추출하는 알고리즘이나, 색상 정보나 강도 정보를 기반으로 클러스터링을 수행하는 알고리즘을 구현할 수 있다.</p>
<p>클러스터 크기에 대한 제한을 추가하는 확장된 클러스터링 예시는 다음과 같다.</p>
<pre><code class="language-cpp">template &lt;typename PointT&gt;
std::vector&lt;pcl::PointIndices&gt; customClustering(pcl::PointCloud&lt;PointT&gt;::Ptr cloud, float tolerance, int min_cluster_size)
{
  pcl::search::KdTree&lt;PointT&gt;::Ptr tree(new pcl::search::KdTree&lt;PointT&gt;);
  tree-&gt;setInputCloud(cloud);

  std::vector&lt;pcl::PointIndices&gt; cluster_indices;
  pcl::EuclideanClusterExtraction&lt;PointT&gt; ec;
  ec.setClusterTolerance(tolerance);
  ec.setMinClusterSize(min_cluster_size);
  ec.setSearchMethod(tree);
  ec.setInputCloud(cloud);
  ec.extract(cluster_indices);

  return cluster_indices;
}
</code></pre>
<p>이 코드에서는 Euclidean 클러스터링을 수행하되, <code>min_cluster_size</code>로 특정 크기 이상의 클러스터만 추출하도록 제한을 두었다. 이러한 사용자 정의 클러스터링 알고리즘은 대규모 포인트 클라우드 데이터를 더 효율적으로 처리할 수 있게 도와준다.</p>
<h3 id="_12">상호작용 및 시각화 확장</h3>
<p>PCL에서 제공하는 기본 시각화 도구는 매우 강력하지만, 이를 더 확장하여 상호작용 기능을 추가할 수 있다. 예를 들어, 특정 조건에 맞는 점을 선택하거나 실시간으로 데이터를 필터링할 수 있는 상호작용 기능을 C++로 추가할 수 있다.</p>
<p>다음은 마우스 이벤트를 활용하여 포인트 클라우드에서 선택된 점을 출력하는 예시이다:</p>
<pre><code class="language-cpp">void pointPickingCallback(const pcl::visualization::PointPickingEvent&amp; event, void* args)
{
  float x, y, z;
  if (event.getPointIndex() != -1)
  {
    event.getPoint(x, y, z);
    std::cout &lt;&lt; &quot;Point selected: (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
  }
}

void addPointPickingCallback(pcl::visualization::PCLVisualizer::Ptr viewer)
{
  viewer-&gt;registerPointPickingCallback(pointPickingCallback);
}
</code></pre>
<p>이 코드는 PCL 시각화 도구에서 특정 점을 선택할 수 있는 기능을 추가한 예시이다. 사용자가 포인트 클라우드에서 직접 상호작용하며 데이터를 분석할 수 있도록 기능을 확장할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../3003/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../3003/" class="btn btn-xs btn-link">
        사용자 정의 필터와 알고리즘 구현
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../3001/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../3001/" class="btn btn-xs btn-link">
        PCL 모듈 커스터마이징 기법
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>