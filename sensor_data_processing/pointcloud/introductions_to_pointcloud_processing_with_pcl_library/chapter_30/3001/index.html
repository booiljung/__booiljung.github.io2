<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introductions_to_pointcloud_processing_with_pcl_library/chapter_30/3001/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>PCL 모듈 커스터마이징 기법 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ubaa8\ub4c8 \uc544\ud0a4\ud14d\ucc98 \uc774\ud574", url: "#_top", children: [
          ]},
          {title: "\ucee4\uc2a4\ud130\ub9c8\uc774\uc9d5\uc758 \uc77c\ubc18\uc801 \uacfc\uc815", url: "#_2", children: [
              {title: "\uc608\uc2dc: \ud544\ud130 \ubaa8\ub4c8 \ucee4\uc2a4\ud130\ub9c8\uc774\uc9d5", url: "#_3" },
          ]},
          {title: "PCL \uc18c\uc2a4 \ucf54\ub4dc \ud655\uc7a5", url: "#pcl", children: [
          ]},
          {title: "\ud655\uc7a5 \ubaa8\ub4c8 \ud1b5\ud569 \ubc29\ubc95", url: "#_4", children: [
              {title: "\ud544\ud130 \ud30c\uc774\ud504\ub77c\uc778\uc5d0 \ud1b5\ud569", url: "#_5" },
              {title: "\ud655\uc7a5 \ubaa8\ub4c8\uc758 \uc131\ub2a5 \ud3c9\uac00", url: "#_6" },
          ]},
          {title: "\ub370\uc774\ud130 \uad6c\uc870\uc640 \uba54\ubaa8\ub9ac \uad00\ub9ac", url: "#_7", children: [
          ]},
          {title: "\uc2a4\ub808\ub4dc \ubcd1\ub82c\ud654 \ubc0f \uc131\ub2a5 \ucd5c\uc801\ud654", url: "#_8", children: [
              {title: "\ubcd1\ub82c \ucc98\ub9ac\ub97c \ud1b5\ud55c \uc131\ub2a5 \ud5a5\uc0c1", url: "#_9" },
              {title: "\ubcd1\ub82c\ud654\uac00 \uc801\uc6a9 \uac00\ub2a5\ud55c \uc601\uc5ed", url: "#_10" },
          ]},
          {title: "\ucee4\uc2a4\ud130\ub9c8\uc774\uc9d5\ud55c \ubaa8\ub4c8\uc758 \ubcd1\ub82c\ud654 \uace0\ub824 \uc0ac\ud56d", url: "#_11", children: [
          ]},
          {title: "GPU \uac00\uc18d\uc744 \ud1b5\ud55c \ucd5c\uc801\ud654", url: "#gpu", children: [
              {title: "GPU \ubcd1\ub82c \ucc98\ub9ac\uc640 CPU \ubcd1\ub82c \ucc98\ub9ac \ube44\uad50", url: "#gpu-cpu" },
          ]},
          {title: "\ucee4\uc2a4\ud130\ub9c8\uc774\uc9d5\uacfc \ubcd1\ub82c\ud654\uc758 \ud1b5\ud569", url: "#_12", children: [
          ]},
          {title: "\ubaa8\ub4c8 \ucd5c\uc801\ud654\uc640 PCL \ucee4\uc2a4\ud130\ub9c8\uc774\uc9d5 \uc0ac\ub840", url: "#pcl_1", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../3002/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../3002/" class="btn btn-xs btn-link">
        C++를 이용한 PCL 확장
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_29/2905/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_29/2905/" class="btn btn-xs btn-link">
        수중 로봇의 포인트 클라우드 활용 사례
      </a>
    </div>
    
  </div>

    

    <p>PCL(Point Cloud Library)은 매우 모듈화된 구조로 설계되어 있어 다양한 환경과 요구사항에 맞춰 손쉽게 확장하거나 커스터마이징할 수 있다. PCL 모듈을 커스터마이징하는 과정에서는 모듈화된 구조를 잘 이해하고, 필요한 부분을 효율적으로 수정하거나 확장하는 것이 중요하다.</p>
<h3 id="_1">모듈 아키텍처 이해</h3>
<p>PCL은 크게 다음과 같은 모듈들로 나뉜다:
- <strong>Filters</strong>: 데이터 전처리, 노이즈 제거, 샘플링 등을 담당한다.
- <strong>Features</strong>: 각 점의 기하학적 특징을 계산한다.
- <strong>Segmentation</strong>: 점군 데이터를 클러스터링하여 의미 있는 부분으로 분리한다.
- <strong>Registration</strong>: 서로 다른 포인트 클라우드 데이터를 정합하여 하나의 데이터로 통합한다.</p>
<p>각 모듈은 기본적으로 상호 독립적이지만, 특정 기능을 위해 상호작용할 수 있다. 커스터마이징의 핵심은 이러한 모듈 간의 의존성을 이해하고, 필요한 부분에서 새로운 기능을 추가하거나 기존 기능을 수정하는 것이다.</p>
<h3 id="_2">커스터마이징의 일반적 과정</h3>
<ol>
<li><strong>모듈 분석</strong>: 커스터마이징할 모듈을 선택한 후, 해당 모듈의 소스 코드를 분석하여 내부 구조와 상호작용을 이해한다.</li>
<li><strong>기능 추가 또는 수정</strong>: 기존 기능을 바탕으로 새로운 알고리즘을 추가하거나, 모듈 내부의 특정 동작을 변경한다.</li>
<li><strong>빌드 및 테스트</strong>: 수정된 모듈을 PCL 환경에서 빌드하고, 포인트 클라우드 데이터를 이용하여 성능과 정확도를 테스트한다.</li>
</ol>
<h4 id="_3">예시: 필터 모듈 커스터마이징</h4>
<p>필터 모듈은 포인트 클라우드 데이터를 전처리하는데 매우 중요한 역할을 한다. 이를 커스터마이징하여, 예를 들어 더욱 정교한 노이즈 제거 알고리즘을 구현할 수 있다.</p>
<p>기존의 <code>pcl::StatisticalOutlierRemoval</code> 필터는 특정 반경 내의 점들의 분포를 바탕으로 이상점을 제거한다. 이를 커스터마이징하여 새로운 기준을 적용할 수 있다. 예를 들어, 포인트의 기하학적 특성을 활용한 이상점 제거 알고리즘을 추가할 수 있다. 이를 수식으로 나타내면, 특정 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span> 주변의 점들을 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_j</span><script type="math/tex">\mathbf{q}_j</script></span>라 할 때, 기존 필터에서는 거리 기반으로 노이즈를 제거한다. 이를 기하학적 특징으로 확장하려면 다음과 같은 계산이 필요하다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d_{i,j} = \|\mathbf{p}_i - \mathbf{q}_j\|
</div>
<script type="math/tex; mode=display">
d_{i,j} = \|\mathbf{p}_i - \mathbf{q}_j\|
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 기준점이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_j</span><script type="math/tex">\mathbf{q}_j</script></span>는 반경 내의 다른 점이다. 이를 변형하여, 특정 각도 <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>를 기준으로 포인트의 분포를 고려한 필터링 알고리즘을 만들 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\theta_{i,j} = \arccos\left(\frac{\mathbf{n}_i \cdot (\mathbf{p}_i - \mathbf{q}_j)}{\|\mathbf{p}_i - \mathbf{q}_j\|}\right)
</div>
<script type="math/tex; mode=display">
\theta_{i,j} = \arccos\left(\frac{\mathbf{n}_i \cdot (\mathbf{p}_i - \mathbf{q}_j)}{\|\mathbf{p}_i - \mathbf{q}_j\|}\right)
</script>
</div>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_i</span><script type="math/tex">\mathbf{n}_i</script></span>는 기준점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에서의 노말 벡터이다. 이와 같이 기하학적 특성을 반영한 커스터마이징 필터를 구현할 수 있다.</p>
<h3 id="pcl">PCL 소스 코드 확장</h3>
<p>PCL의 모듈을 확장하려면, 필요한 알고리즘을 기반으로 새로운 클래스를 정의해야 한다. PCL은 C++로 작성되었으며, 이를 기반으로 커스터마이징하는 것이 권장된다. 예를 들어 새로운 필터를 추가하고자 할 때, <code>pcl::Filter</code> 클래스를 상속받아 새로운 필터 클래스를 정의하고, 기존의 필터 파이프라인과 통합할 수 있다.</p>
<pre><code class="language-cpp">#include &lt;pcl/filters/filter.h&gt;

template &lt;typename PointT&gt;
class MyCustomFilter : public pcl::Filter&lt;PointT&gt; {
public:
    using pcl::Filter&lt;PointT&gt;::filter_name_;
    using pcl::Filter&lt;PointT&gt;::input_;

    MyCustomFilter() {
        filter_name_ = &quot;MyCustomFilter&quot;;
    }

    void applyFilter(pcl::PointCloud&lt;PointT&gt;&amp; output) override {
        // 사용자 정의 필터 로직을 여기에 작성
    }
};
</code></pre>
<h3 id="_4">확장 모듈 통합 방법</h3>
<p>PCL에서 커스터마이징한 모듈을 통합하는 과정은 기존의 모듈과 새로 작성한 모듈 간의 상호작용을 고려하여 진행해야 한다. 예를 들어, 새로운 필터를 작성한 후, 이를 기존 파이프라인에 어떻게 연결할지에 대한 구조적인 설계가 필요하다.</p>
<h4 id="_5">필터 파이프라인에 통합</h4>
<p>포인트 클라우드 처리에서 필터는 여러 단계로 연결될 수 있으며, 각 필터는 순차적으로 데이터를 변환한다. 새롭게 작성한 필터를 기존 파이프라인에 추가하기 위해서는 필터 체인에 통합하는 방법을 고려해야 한다. </p>
<p>기존의 필터 파이프라인이 다음과 같다고 가정한다:</p>
<pre><code class="language-cpp">pcl::PassThrough&lt;PointT&gt; pass_filter;
pcl::VoxelGrid&lt;PointT&gt; voxel_filter;
pcl::StatisticalOutlierRemoval&lt;PointT&gt; sor_filter;
</code></pre>
<p>이러한 구조에서 새로운 커스터마이징 필터를 추가하려면, 동일한 데이터 흐름에 맞추어 적용할 수 있다:</p>
<pre><code class="language-cpp">MyCustomFilter&lt;PointT&gt; custom_filter;
pass_filter.setInputCloud(input_cloud);
pass_filter.filter(*cloud_filtered);

voxel_filter.setInputCloud(cloud_filtered);
voxel_filter.filter(*cloud_filtered);

custom_filter.setInputCloud(cloud_filtered);  // 커스터마이징된 필터 적용
custom_filter.filter(*cloud_filtered);

sor_filter.setInputCloud(cloud_filtered);
sor_filter.filter(*cloud_filtered);
</code></pre>
<p>위의 코드에서는 <code>MyCustomFilter</code>가 기존의 필터 흐름에 추가된 것을 볼 수 있다. 이처럼 PCL 모듈은 필터 간의 데이터 흐름을 유지하면서도 손쉽게 확장된 기능을 추가할 수 있다.</p>
<h4 id="_6">확장 모듈의 성능 평가</h4>
<p>새로 작성한 모듈이 기존의 알고리즘과 비교해 얼마나 성능이 향상되었는지, 혹은 새로운 기능이 어떻게 동작하는지 평가하는 것도 중요하다. 성능 평가를 위해서는 여러 기준을 세워야 하며, 일반적으로 다음과 같은 요소를 고려한다:</p>
<ol>
<li><strong>계산 효율성</strong>: 새로 작성한 알고리즘이 얼마나 빠르게 동작하는가?</li>
<li><strong>정확도</strong>: 포인트 클라우드 처리 후 결과가 얼마나 정확한가?</li>
<li><strong>메모리 사용량</strong>: 대규모 데이터를 처리할 때, 메모리 사용량은 어떠한가?</li>
</ol>
<p>예를 들어, 새로운 필터의 처리 시간이 기존 필터와 비교하여 얼마나 단축되었는지 측정할 수 있다. 이를 통해 실시간 처리 환경에서도 효율적으로 동작하는지 평가할 수 있다.</p>
<pre><code class="language-cpp">// 시간 측정을 위한 예시 코드
auto start = std::chrono::high_resolution_clock::now();
custom_filter.setInputCloud(cloud_filtered);
custom_filter.filter(*cloud_filtered);
auto end = std::chrono::high_resolution_clock::now();
std::chrono::duration&lt;double&gt; elapsed = end - start;
std::cout &lt;&lt; &quot;필터 처리 시간: &quot; &lt;&lt; elapsed.count() &lt;&lt; &quot;초&quot; &lt;&lt; std::endl;
</code></pre>
<h3 id="_7">데이터 구조와 메모리 관리</h3>
<p>PCL의 성능 최적화와 관련된 중요한 요소 중 하나는 포인트 클라우드 데이터의 효율적인 메모리 관리이다. 커스터마이징한 모듈에서도 포인트 클라우드 데이터를 효율적으로 처리할 수 있도록 메모리 구조를 잘 관리하는 것이 중요하다.</p>
<p>포인트 클라우드는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P} = \{\mathbf{p}_1, \mathbf{p}_2, ..., \mathbf{p}_n\}</span><script type="math/tex">\mathbf{P} = \{\mathbf{p}_1, \mathbf{p}_2, ..., \mathbf{p}_n\}</script></span> 형태의 3차원 좌표로 이루어진 데이터로, 각 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 다음과 같은 속성을 갖는다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i = (x_i, y_i, z_i, r_i, g_i, b_i)
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i = (x_i, y_i, z_i, r_i, g_i, b_i)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">x_i, y_i, z_i</span><script type="math/tex">x_i, y_i, z_i</script></span>는 공간 좌표를 나타내고, <span class="arithmatex"><span class="MathJax_Preview">r_i, g_i, b_i</span><script type="math/tex">r_i, g_i, b_i</script></span>는 색 정보를 나타낸다. 이러한 구조는 매우 크기가 클 수 있으므로, 커스터마이징 과정에서는 포인트 클라우드 데이터의 메모리 관리에 주의를 기울여야 한다.</p>
<p>PCL에서는 <strong>PointCloud</strong> 클래스를 사용하여 데이터를 관리하며, 필요에 따라 <strong>boost::shared_ptr</strong>와 같은 스마트 포인터를 활용하여 메모리 관리를 자동화할 수 있다. 커스터마이징한 모듈에서도 이러한 메모리 관리 기법을 활용하여 대규모 데이터를 처리할 때의 효율성을 유지하는 것이 좋다.</p>
<pre><code class="language-cpp">pcl::PointCloud&lt;PointT&gt;::Ptr cloud(new pcl::PointCloud&lt;PointT&gt;());
</code></pre>
<p>이와 같이 스마트 포인터를 사용하면, 메모리 누수 문제를 줄일 수 있고, 다중 스레드 환경에서도 안전한 메모리 접근이 가능한다.</p>
<h3 id="_8">스레드 병렬화 및 성능 최적화</h3>
<p>포인트 클라우드 처리에서 대용량 데이터를 다룰 경우, 성능 최적화는 필수적이다. 특히 커스터마이징한 모듈이 실시간 환경에서 동작해야 할 경우, 스레드 병렬화를 통해 성능을 크게 향상시킬 수 있다. PCL에서는 OpenMP와 같은 라이브러리를 사용하여 병렬 처리를 지원한다.</p>
<h4 id="_9">병렬 처리를 통한 성능 향상</h4>
<p>필터링, 정렬 또는 특징 계산과 같은 반복적인 작업을 병렬로 처리할 수 있다. 예를 들어, 포인트 클라우드에서 각 점의 기하학적 특징을 계산하는 과정에서 각 점에 대한 계산을 병렬로 분할하여 처리할 수 있다.</p>
<p>다음은 OpenMP를 사용하여 병렬 처리를 구현하는 간단한 예이다.</p>
<pre><code class="language-cpp">#pragma omp parallel for
for (int i = 0; i &lt; cloud-&gt;points.size(); i++) {
    // 각 포인트에 대해 처리 수행
    processPoint(cloud-&gt;points[i]);
}
</code></pre>
<p>OpenMP 지시어인 <code>#pragma omp parallel for</code>는 루프 내에서 각 반복을 병렬로 처리하도록 지시한다. 이 방법은 대규모 데이터를 처리하는 데 있어서 상당한 성능 향상을 가져올 수 있다.</p>
<h4 id="_10">병렬화가 적용 가능한 영역</h4>
<ol>
<li>
<p><strong>필터링</strong>: 포인트 클라우드에서 각 점에 대한 필터링 작업은 병렬 처리가 가능한다. 예를 들어, <strong>Voxel Grid</strong>와 같은 필터는 그리드 내의 점들을 병렬로 처리하여 더 빠른 성능을 얻을 수 있다.</p>
</li>
<li>
<p><strong>특징 계산</strong>: 포인트 클라우드의 특징을 계산할 때, 각 점의 노말 벡터나 커브처(curvature) 등의 계산은 독립적으로 이루어지기 때문에 병렬화가 가능한다.</p>
</li>
<li>
<p><strong>정렬 및 정합</strong>: 포인트 클라우드 데이터 간의 정합(registration) 과정에서 각각의 점에 대한 좌표 변환이나 매칭 과정도 병렬화할 수 있다.</p>
</li>
</ol>
<h3 id="_11">커스터마이징한 모듈의 병렬화 고려 사항</h3>
<p>병렬화 작업에서는 다음과 같은 사항을 고려해야 한다:</p>
<ol>
<li>
<p><strong>데이터 의존성</strong>: 병렬 처리 중에도 각 스레드가 같은 데이터를 수정하지 않도록 해야 한다. 이를 위해 <strong>스레드 안전성(thread safety)</strong>을 보장하는 데이터 구조를 사용하거나, 특정 부분에서 스레드 간 동기화를 적절히 관리해야 한다.</p>
</li>
<li>
<p><strong>작업 분할</strong>: 데이터 크기에 따라 병렬로 처리할 수 있는 작업 단위를 적절히 분할해야 한다. 너무 작은 작업 단위로 병렬화를 적용하면 오버헤드가 발생할 수 있고, 너무 큰 단위로 적용하면 병렬화의 이점을 제대로 살리지 못할 수 있다.</p>
</li>
<li>
<p><strong>스레드 수 관리</strong>: 시스템의 CPU 코어 수에 맞춰 적절한 스레드 수를 설정하는 것이 중요하다. 일반적으로 <code>omp_set_num_threads()</code> 함수를 사용하여 OpenMP에서 사용할 스레드 수를 명시할 수 있다.</p>
</li>
</ol>
<pre><code class="language-cpp">omp_set_num_threads(4);  // 4개의 스레드 사용
</code></pre>
<h3 id="gpu">GPU 가속을 통한 최적화</h3>
<p>PCL은 CPU 기반으로 주로 동작하지만, GPU를 활용한 가속화도 가능한다. <strong>PCL GPU 모듈</strong>을 활용하면 CUDA를 이용한 GPU 병렬 처리가 가능하며, 대용량 데이터에 대한 실시간 처리 성능을 극대화할 수 있다.</p>
<p>GPU를 사용하여 가속할 수 있는 주요 작업은 다음과 같다:</p>
<ul>
<li><strong>Voxel Grid</strong> 필터링</li>
<li><strong>Outlier Removal</strong> (이상점 제거)</li>
<li><strong>Normal Estimation</strong> (노말 벡터 계산)</li>
</ul>
<p>GPU를 사용한 커스터마이징 모듈을 작성할 때는 CUDA 코드를 직접 작성하거나, PCL의 GPU 모듈을 확장하여 사용할 수 있다. 다음은 PCL GPU 모듈을 사용한 필터링의 예시이다.</p>
<pre><code class="language-cpp">pcl::gpu::VoxelGrid voxel_filter_gpu;
voxel_filter_gpu.setInputCloud(cloud_gpu);
voxel_filter_gpu.setLeafSize(0.01f, 0.01f, 0.01f);
voxel_filter_gpu.filter(output_cloud_gpu);
</code></pre>
<h4 id="gpu-cpu">GPU 병렬 처리와 CPU 병렬 처리 비교</h4>
<p>GPU 병렬 처리는 수천 개의 스레드가 병렬로 연산을 수행할 수 있어, 대규모 포인트 클라우드 데이터 처리에 적합한다. 그러나 모든 작업이 GPU에서 효율적인 것은 아니므로, 작업의 특성에 따라 GPU와 CPU 간의 적절한 선택이 필요하다. 예를 들어, 단순한 필터링 작업은 GPU를 사용하는 것이 효율적일 수 있지만, 복잡한 데이터 의존성을 갖는 알고리즘은 CPU 기반의 병렬 처리가 더 적합할 수 있다.</p>
<h3 id="_12">커스터마이징과 병렬화의 통합</h3>
<p>병렬화와 커스터마이징을 통합하면 매우 강력한 포인트 클라우드 처리 시스템을 구축할 수 있다. 특히 대규모 데이터를 처리하는 산업 환경에서는 실시간으로 데이터를 처리하고 분석하는 것이 중요한데, 이를 위해 커스터마이징된 모듈에 병렬 처리를 추가하여 성능을 극대화할 수 있다.</p>
<h3 id="pcl_1">모듈 최적화와 PCL 커스터마이징 사례</h3>
<p>마지막으로, PCL 모듈을 커스터마이징한 실제 사례로 <strong>대규모 점군 데이터를 실시간으로 필터링하고 정합하는 시스템</strong>을 들 수 있다. 이 시스템은 수백만 개의 포인트를 포함하는 데이터를 처리해야 했기 때문에, 각 필터 모듈을 병렬화하고 GPU 가속을 사용하여 처리 시간을 획기적으로 줄였다. 또한, 특정 도메인에 맞는 알고리즘을 커스터마이징하여 기존 PCL 모듈보다 훨씬 더 높은 정확도를 얻을 수 있었다.</p>
<p>이를 통해 다양한 산업에서 PCL 커스터마이징 기법이 실질적인 성능 향상과 함께 적용될 수 있음을 확인할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../3002/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../3002/" class="btn btn-xs btn-link">
        C++를 이용한 PCL 확장
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_29/2905/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_29/2905/" class="btn btn-xs btn-link">
        수중 로봇의 포인트 클라우드 활용 사례
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>