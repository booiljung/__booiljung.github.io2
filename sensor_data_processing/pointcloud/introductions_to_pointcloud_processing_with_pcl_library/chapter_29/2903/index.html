<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introductions_to_pointcloud_processing_with_pcl_library/chapter_29/2903/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>수중 환경에서의 정규화 및 정합 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc218\uc911 \ub370\uc774\ud130\uc758 \ud2b9\uc131\uacfc \uc815\uaddc\ud654 \ud544\uc694\uc131", url: "#_top", children: [
          ]},
          {title: "\uc88c\ud45c\uacc4 \ubcc0\ud658\uacfc \uc2a4\ucf00\uc77c \uc815\uaddc\ud654", url: "#_2", children: [
          ]},
          {title: "\uc218\uc911 \ud658\uacbd\uc5d0\uc11c\uc758 \uc815\ud569 \uae30\ubc95", url: "#_3", children: [
          ]},
          {title: "\uc218\uc911 \ub370\uc774\ud130\uc758 \uc815\ud569\uc744 \uc704\ud55c \ud2b9\uc218 \uace0\ub824 \uc0ac\ud56d", url: "#_4", children: [
          ]},
          {title: "\ub2e4\uc911 \uc13c\uc11c \ub370\uc774\ud130\uc758 \uc815\ud569", url: "#_5", children: [
              {title: "\uc0c1\ub300\uc801 \uc88c\ud45c\uacc4 \ubcc0\ud658", url: "#_6" },
              {title: "\uc808\ub300 \uc88c\ud45c\uacc4 \uc815\ud569", url: "#_7" },
          ]},
          {title: "\ub178\uc774\uc988 \ud544\ud130\ub9c1\uacfc \uc815\uaddc\ud654\uc758 \ud1b5\ud569", url: "#_8", children: [
          ]},
          {title: "\ud658\uacbd \ubcf4\uc815\uc744 \ud1b5\ud55c \uc815\uaddc\ud654 \uac15\ud654", url: "#_9", children: [
              {title: "\uc218\uc2ec\uc5d0 \ub530\ub978 \ubcf4\uc815", url: "#_10" },
              {title: "\uc628\ub3c4\uc640 \uc5fc\ub3c4 \ubcf4\uc815", url: "#_11" },
          ]},
          {title: "\ub370\uc774\ud130 \uc815\ud569\uc744 \uc704\ud55c ICP \uc54c\uace0\ub9ac\uc998\uc758 \ud655\uc7a5", url: "#icp", children: [
              {title: "\uac00\uc911\uce58 \uae30\ubc18 ICP", url: "#icp_1" },
              {title: "\uac15\uac74\ud55c ICP", url: "#icp_2" },
          ]},
          {title: "\uc815\uaddc\ud654\uc640 \uc815\ud569\uc758 \ubc18\ubcf5\uc801 \uc801\uc6a9", url: "#_12", children: [
              {title: "\uc2a4\ucf00\uc77c \uc815\ud569\uacfc \ubcf4\uc815", url: "#_13" },
          ]},
          {title: "\uc2e4\uc2dc\uac04 \uc815\ud569\uc744 \uc704\ud55c \ucd5c\uc801\ud654 \uae30\ubc95", url: "#_14", children: [
              {title: "\ub2e4\uc6b4\uc0d8\ud50c\ub9c1\uacfc \uc815\ud569\uc758 \uacb0\ud569", url: "#_15" },
              {title: "\ubcd1\ub82c \ucc98\ub9ac\uc640 GPU \uac00\uc18d", url: "#gpu" },
          ]},
          {title: "\ub2e4\uc911 \uc2a4\ucf00\uc77c \uc815\ud569\uc744 \uc704\ud55c \uba40\ud2f0 \ub808\ubca8 \uc811\uadfc", url: "#_16", children: [
          ]},
          {title: "\uc218\uc911 \ud658\uacbd\uc5d0\uc11c\uc758 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc815\ud569\uc758 \ucd94\uac00 \uae30\ubc95", url: "#_17", children: [
          ]},
          {title: "\ud2b9\uc9d5 \uae30\ubc18 \uc815\ud569 (Feature-Based Registration)", url: "#feature-based-registration", children: [
              {title: "\ud2b9\uc9d5 \ucd94\ucd9c", url: "#_18" },
              {title: "\ud2b9\uc9d5 \uc815\ud569", url: "#_19" },
          ]},
          {title: "\uc218\uc911 \ud658\uacbd\uc5d0\uc11c\uc758 \uc815\uaddc\ud654 \ubc0f \uc815\ud569 \ucd5c\uc801\ud654 \uae30\ubc95", url: "#_20", children: [
              {title: "\ub3d9\uc801 \ud544\ud130\ub9c1\uacfc \uc815\ud569", url: "#_21" },
              {title: "\ubc18\ubcf5\uc801 \uc815\ud569(Iterative Registration)\uacfc \uac80\uc99d", url: "#iterative-registration" },
              {title: "\uc815\ud569 \ud488\uc9c8 \uac1c\uc120\uc744 \uc704\ud55c \uae30\ubc95", url: "#_22" },
          ]},
          {title: "\ucd5c\uc801\ud654\ub41c \uc815\ud569\uc744 \uc704\ud55c \uacc4\uc0b0 \ubcf5\uc7a1\ub3c4 \uac10\uc18c \uae30\ubc95", url: "#_23", children: [
              {title: "\ubcfc\ub85d \ub9e4\uce6d \uae30\ubc95", url: "#_24" },
              {title: "\ubc18\ubcf5 \uac10\uc18c \uae30\ubc95", url: "#_25" },
              {title: "\ub2e4\uc911 \ud574\uc0c1\ub3c4 \uc815\ud569", url: "#_26" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2904/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2904/" class="btn btn-xs btn-link">
        해양 구조물의 상태 모니터링
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2902/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2902/" class="btn btn-xs btn-link">
        소나와 라이다를 통한 데이터 수집
      </a>
    </div>
    
  </div>

    

    <p>수중 환경에서의 포인트 클라우드 데이터 처리는 일반적인 환경에서의 처리와는 다른 여러 난관을 수반한다. 특히 수중에서 발생하는 다양한 잡음 요소, 신호 감쇠, 물리적 장애물들이 포인트 클라우드의 정규화 및 정합에 상당한 영향을 미친다. 이러한 문제를 극복하기 위해 정규화(normalization) 및 정합(alignment) 기술을 적절히 적용해야 한다.</p>
<h3 id="_1">수중 데이터의 특성과 정규화 필요성</h3>
<p>수중 환경에서는 수집된 포인트 클라우드 데이터가 불균일한 분포를 가질 가능성이 높다. 이는 주로 다음과 같은 요인에 기인한다:
- <strong>수중 매체의 밀도 변화</strong>: 수심에 따른 수온, 염도, 압력 변화는 센서 신호에 영향을 미친다.
- <strong>잡음과 외부 방해 요소</strong>: 물의 흐름, 부유물, 해양 생물 등이 포인트 클라우드 데이터에 잡음을 추가한다.
- <strong>신호 감쇠</strong>: 특히 소나와 같은 수중 센서에서 발생하는 신호 감쇠는 깊이에 따른 데이터 손실을 유발할 수 있다.</p>
<p>이러한 요인들로 인해 포인트 클라우드 데이터는 수집 시 다양한 스케일이나 좌표계 왜곡을 가지게 된다. 따라서 데이터를 분석하거나 정합을 시도하기 전에 정규화가 필수적이다.</p>
<h3 id="_2">좌표계 변환과 스케일 정규화</h3>
<p>수중 포인트 클라우드 데이터를 정규화하기 위해서는 우선적으로 좌표계를 일관되게 변환하고, 포인트 클라우드 내의 모든 점들이 동일한 스케일을 유지하도록 해야 한다. 일반적으로 스케일 정규화는 모든 포인트를 특정 단위 범위 내에 맞추는 방식으로 수행된다.</p>
<p>포인트 클라우드의 스케일 정규화는 다음과 같은 방정식을 통해 수행할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{\text{norm}} = \frac{\mathbf{P} - \mathbf{P}_{\text{min}}}{\mathbf{P}_{\text{max}} - \mathbf{P}_{\text{min}}}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{\text{norm}} = \frac{\mathbf{P} - \mathbf{P}_{\text{min}}}{\mathbf{P}_{\text{max}} - \mathbf{P}_{\text{min}}}
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>는 원본 포인트 클라우드 데이터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{min}}</span><script type="math/tex">\mathbf{P}_{\text{min}}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{max}}</span><script type="math/tex">\mathbf{P}_{\text{max}}</script></span>는 각각 포인트 클라우드에서의 최소 및 최대 좌표 값이다,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{norm}}</span><script type="math/tex">\mathbf{P}_{\text{norm}}</script></span>은 정규화된 포인트 클라우드 데이터를 의미한다.</p>
<p>이 과정은 포인트 클라우드의 전체 크기를 0에서 1 사이로 변환함으로써, 이후의 정합 및 분석 단계에서 데이터 처리의 일관성을 확보한다.</p>
<h3 id="_3">수중 환경에서의 정합 기법</h3>
<p>정합 기법은 수중 환경에서 매우 중요하다. 여러 개의 센서나 스캔 데이터를 통합하기 위해서는 각 데이터의 좌표계를 일치시켜야 한다. 일반적으로 사용되는 방법은 두 가지로 나눌 수 있다:</p>
<ol>
<li><strong>초기 정합(Initial Alignment)</strong>: 두 포인트 클라우드 간의 대략적인 일치를 이루는 단계로, 보통 다음과 같은 기법을 사용한다:</li>
<li><strong>중심 정렬(Centering Alignment)</strong>: 각 포인트 클라우드의 중심을 원점에 맞추는 방식이다. 중심 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 다음과 같이 계산된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{C} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
   \mathbf{C} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 포인트의 수, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 각 포인트의 좌표이다.</p>
<ol>
<li><strong>정밀 정합(Fine Alignment)</strong>: 초기 정합 후 미세한 차이를 보정하기 위한 단계이다. 보통 다음 기법을 활용한다:</li>
<li><strong>ICP(Iterative Closest Point)</strong> 알고리즘: 두 포인트 클라우드 간의 대응점을 반복적으로 계산하여 정밀 정합을 수행한다. ICP 알고리즘의 기본 수식은 다음과 같다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \| \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \|^2
</div>
<script type="math/tex; mode=display">
   \min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \| \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \|^2
</script>
</div>
<p>여기서,
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 회전 행렬,
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>는 변환 벡터,
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span>는 각각 정합하고자 하는 두 포인트 클라우드의 대응점이다.</p>
<h3 id="_4">수중 데이터의 정합을 위한 특수 고려 사항</h3>
<p>수중에서의 데이터 정합은 일반적인 환경보다 몇 가지 추가적인 고려 사항이 필요하다:
- <strong>환경 잡음 보정</strong>: 수중 환경에서의 외부 잡음(물 속 부유물, 조류 등)은 데이터를 오염시킬 수 있다. 이러한 잡음을 제거하기 위해서는 노이즈 필터링을 정합 전후에 적용할 필요가 있다. 보통, 가우시안 필터 또는 매드(Median Absolute Deviation)와 같은 통계적 방법을 사용할 수 있다.</p>
<ul>
<li><strong>신호 감쇠에 대한 보상</strong>: 수중 센서에서 발생하는 신호 감쇠는 포인트 클라우드의 일부 영역에서 데이터 밀도가 낮아지게 만든다. 이를 보완하기 위해 거리 기반 보정(weighted distance compensation)을 사용할 수 있다. 감쇠 현상을 보상하는 보정 방정식은 다음과 같이 정의될 수 있다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i' = \mathbf{p}_i \cdot f(d)
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i' = \mathbf{p}_i \cdot f(d)
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 원본 포인트 좌표,
- <span class="arithmatex"><span class="MathJax_Preview">f(d)</span><script type="math/tex">f(d)</script></span>는 거리 <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>에 따른 보정 함수이다. 일반적으로 <span class="arithmatex"><span class="MathJax_Preview">f(d)</span><script type="math/tex">f(d)</script></span>는 거리와 반비례하는 함수로 설정된다.</p>
<h3 id="_5">다중 센서 데이터의 정합</h3>
<p>수중 환경에서 포인트 클라우드 데이터를 수집할 때, 여러 개의 센서를 사용하는 경우가 많다. 각 센서의 위치와 각도가 다르기 때문에 수집된 데이터는 서로 다른 좌표계를 가질 수 있으며, 이러한 데이터를 효과적으로 통합하려면 센서 간 정합을 수행해야 한다. 이때 사용되는 주요 기법은 <strong>상대적 좌표계 변환</strong>과 <strong>절대 좌표계 정합</strong>이다.</p>
<h4 id="_6">상대적 좌표계 변환</h4>
<p>각 센서의 포인트 클라우드는 자신의 로컬 좌표계에서 데이터를 제공한다. 이러한 로컬 좌표계를 통합하기 위해서는 각 센서의 상대적 위치 및 방향을 고려하여 변환 행렬을 구성해야 한다. 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>의 각 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>를 변환하는 방법은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i' = \mathbf{R}_{\text{sensor}} \mathbf{p}_i + \mathbf{t}_{\text{sensor}}
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i' = \mathbf{R}_{\text{sensor}} \mathbf{p}_i + \mathbf{t}_{\text{sensor}}
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_{\text{sensor}}</span><script type="math/tex">\mathbf{R}_{\text{sensor}}</script></span>는 센서의 회전 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}_{\text{sensor}}</span><script type="math/tex">\mathbf{t}_{\text{sensor}}</script></span>는 센서의 변환 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i'</span><script type="math/tex">\mathbf{p}_i'</script></span>는 글로벌 좌표계에서의 포인트 좌표이다.</p>
<p>이를 통해 여러 개의 센서에서 얻은 포인트 클라우드 데이터를 동일한 좌표계로 변환할 수 있다.</p>
<h4 id="_7">절대 좌표계 정합</h4>
<p>다중 센서 데이터를 정합할 때, 절대 좌표계를 기준으로 데이터를 맞추는 방법이 필요하다. 이를 위해 각 센서의 위치와 방향을 정확히 알아야 하며, 이를 기반으로 각 포인트 클라우드를 절대 좌표계로 변환한다. 이 과정에서 ICP 알고리즘을 활용하여 각 포인트 클라우드 간의 미세한 오차를 줄일 수 있다.</p>
<p>특히, 수중에서는 외부 참조점(external reference points)을 활용하여 정합 정확도를 높일 수 있다. 이러한 참조점은 부표, 해저 구조물, 또는 미리 설정된 기준점을 사용하여 각 포인트 클라우드를 절대 좌표계로 정합하는데 유용하다.</p>
<h3 id="_8">노이즈 필터링과 정규화의 통합</h3>
<p>수중 환경에서의 포인트 클라우드 데이터는 잡음이 많기 때문에, 정규화와 정합 전에 반드시 노이즈 필터링이 필요하다. 일반적으로 사용되는 필터링 기법은 다음과 같다:</p>
<ol>
<li><strong>통계적 필터링(Statistical Outlier Removal)</strong>: 통계적 방법을 사용하여 평균 및 표준편차에 따라 이상점을 제거하는 방식이다. 각 포인트의 이웃 간 거리 분포를 기반으로 잡음을 제거한다. 수식은 다음과 같다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mu_d = \frac{1}{N} \sum_{i=1}^{N} d_i, \quad \sigma_d = \sqrt{\frac{1}{N} \sum_{i=1}^{N} (d_i - \mu_d)^2}
</div>
<script type="math/tex; mode=display">
\mu_d = \frac{1}{N} \sum_{i=1}^{N} d_i, \quad \sigma_d = \sqrt{\frac{1}{N} \sum_{i=1}^{N} (d_i - \mu_d)^2}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mu_d</span><script type="math/tex">\mu_d</script></span>는 이웃 간 거리의 평균, <span class="arithmatex"><span class="MathJax_Preview">\sigma_d</span><script type="math/tex">\sigma_d</script></span>는 표준편차, <span class="arithmatex"><span class="MathJax_Preview">d_i</span><script type="math/tex">d_i</script></span>는 각 포인트의 이웃과의 거리이다. 거리가 <span class="arithmatex"><span class="MathJax_Preview">\mu_d + k\sigma_d</span><script type="math/tex">\mu_d + k\sigma_d</script></span> 이상인 포인트는 잡음으로 간주되어 제거된다.</p>
<ol>
<li><strong>통과 필터(Pass Through Filter)</strong>: 특정 범위 내의 포인트만을 유지하는 방식으로, 수중에서는 주로 수심이나 거리에 따른 필터링이 적용된다. 예를 들어, 수심 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>에 대해 다음과 같은 조건을 설정할 수 있다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
z_{\text{min}} \leq z_i \leq z_{\text{max}}
</div>
<script type="math/tex; mode=display">
z_{\text{min}} \leq z_i \leq z_{\text{max}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">z_i</span><script type="math/tex">z_i</script></span>는 각 포인트의 수심 좌표이며, 이 범위를 벗어나는 포인트는 제거된다.</p>
<h3 id="_9">환경 보정을 통한 정규화 강화</h3>
<p>수중 환경의 특성에 따른 보정 작업은 매우 중요하다. 물 속에서 신호는 주파수에 따라 다르게 감쇠되기 때문에, 포인트 클라우드 데이터는 깊이에 따라 다르게 왜곡될 수 있다. 이러한 현상을 보정하기 위해서 환경적 요인들을 분석하여 보정 매개변수를 설정해야 한다.</p>
<h4 id="_10">수심에 따른 보정</h4>
<p>수심에 따라 신호가 감쇠되는 경우, 보정 매개변수는 수심과 신호 강도 간의 관계를 기반으로 설정된다. 수심 <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>에 따른 보정 함수는 일반적으로 다음과 같은 형태를 가진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(d) = e^{-\alpha d}
</div>
<script type="math/tex; mode=display">
f(d) = e^{-\alpha d}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 감쇠 계수이며, 수심에 따라 다르게 설정될 수 있다. 이러한 보정 함수를 포인트 클라우드의 각 포인트에 적용하여 감쇠된 데이터를 보정한다.</p>
<h4 id="_11">온도와 염도 보정</h4>
<p>수중에서는 온도와 염도 역시 신호 전파에 영향을 미친다. 이를 보정하기 위해서는 해당 지역의 물리적 특성을 분석하고, 각 물리적 변수가 포인트 클라우드 데이터에 미치는 영향을 평가한 후, 이를 보정할 수 있는 모델을 적용해야 한다.</p>
<h3 id="icp">데이터 정합을 위한 ICP 알고리즘의 확장</h3>
<p>수중 환경에서 포인트 클라우드 데이터를 정합하는 데 가장 널리 사용되는 알고리즘 중 하나는 <strong>ICP(Iterative Closest Point)</strong>이다. 기본적인 ICP 알고리즘은 두 포인트 클라우드 사이의 대응점을 찾아내고, 이를 통해 회전과 변환 행렬을 계산하여 두 클라우드를 정합한다. 수중 환경에서는 ICP 알고리즘을 다양한 상황에 맞춰 확장해야 할 필요가 있다.</p>
<h4 id="icp_1">가중치 기반 ICP</h4>
<p>수중 환경에서는 특정 영역의 포인트 클라우드 데이터가 다른 영역보다 신뢰성이 떨어질 수 있다. 예를 들어, 신호 감쇠가 심한 깊은 영역의 데이터는 얕은 영역보다 정확도가 떨어질 수 있다. 이러한 상황을 고려하기 위해 <strong>가중치 기반 ICP(Weighted ICP)</strong> 알고리즘을 사용할 수 있다. 이 기법은 각 포인트에 가중치를 부여하여, 신뢰도가 높은 영역의 포인트가 정합 과정에서 더 큰 영향을 미치도록 한다.</p>
<p>가중치 기반 ICP의 목적 함수는 다음과 같이 수정된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} w_i \| \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \|^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} w_i \| \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \|^2
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">w_i</span><script type="math/tex">w_i</script></span>는 각 포인트의 가중치로, 수중 환경에서는 신호 감쇠, 노이즈 수준, 데이터 밀도 등을 기반으로 설정된다.</p>
<h4 id="icp_2">강건한 ICP</h4>
<p>수중 환경에서는 잡음이나 이상치(outliers)가 빈번하게 발생한다. 이러한 이상치들은 일반적인 ICP 알고리즘의 성능을 저하시킬 수 있다. 이를 해결하기 위해, <strong>강건한 ICP(Robust ICP)</strong> 알고리즘을 적용할 수 있다. 강건한 ICP는 이상치의 영향을 최소화하기 위해, 거리 함수에 <strong>M-추정(M-estimator)</strong> 또는 <strong>허브(Huber) 손실 함수</strong>와 같은 강건한 손실 함수를 적용한다.</p>
<p>허브 손실 함수는 다음과 같은 형태를 가진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
L(r) =
\begin{cases} 
    \frac{1}{2} r^2 &amp; \text{if } |r| \leq \delta \\
    \delta (|r| - \frac{1}{2} \delta) &amp; \text{if } |r| &gt; \delta 
\end{cases}
</div>
<script type="math/tex; mode=display">
L(r) =
\begin{cases} 
    \frac{1}{2} r^2 & \text{if } |r| \leq \delta \\
    \delta (|r| - \frac{1}{2} \delta) & \text{if } |r| > \delta 
\end{cases}
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">r = \| \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \|</span><script type="math/tex">r = \| \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \|</script></span>는 포인트 간의 거리이며,
- <span class="arithmatex"><span class="MathJax_Preview">\delta</span><script type="math/tex">\delta</script></span>는 임계값으로, 잡음에 의한 이상치를 억제하는 데 사용된다.</p>
<p>이와 같은 방법을 사용하여, 잡음이 많은 수중 환경에서도 안정적인 정합을 수행할 수 있다.</p>
<h3 id="_12">정규화와 정합의 반복적 적용</h3>
<p>수중 환경에서의 포인트 클라우드 처리 과정에서 정규화와 정합은 반복적으로 적용되어야 한다. 특히, 데이터를 정합한 후에는 다시 한 번 정규화를 통해 스케일과 좌표계를 조정할 필요가 있다. 이러한 반복적인 적용은 데이터의 일관성을 유지하고, 정밀도를 높이는 데 필수적이다.</p>
<h4 id="_13">스케일 정합과 보정</h4>
<p>정합 과정에서 회전 및 변환뿐만 아니라, 데이터의 스케일 차이를 보정하는 것이 필요할 수 있다. 특히, 수중 환경에서는 센서의 종류와 위치에 따라 동일한 객체라도 포인트 클라우드 간에 스케일 차이가 발생할 수 있다. 이를 보정하기 위해, 각 포인트 클라우드의 스케일 변환을 추가로 고려하는 정합 방법을 사용할 수 있다.</p>
<p>스케일 변환을 포함한 정합 문제는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{R}, \mathbf{t}, s} \sum_{i=1}^{N} \| s \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \|^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{R}, \mathbf{t}, s} \sum_{i=1}^{N} \| s \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \|^2
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>는 스케일 계수로, 정합 과정에서 계산되어야 한다.</p>
<p>이 문제를 해결하기 위해서는 스케일 계수를 동적으로 업데이트하는 방법을 적용하며, 이를 통해 다양한 센서 데이터 간의 크기 차이를 해결할 수 있다.</p>
<h3 id="_14">실시간 정합을 위한 최적화 기법</h3>
<p>수중 데이터 처리는 실시간으로 이루어질 필요가 있을 때가 많다. 예를 들어, 자율 잠수정(AUV)이나 해양 탐사 로봇에서 실시간으로 포인트 클라우드를 수집하고 처리해야 하는 경우가 그러하다. 이러한 실시간 정합을 위해서는 계산 복잡도를 줄이고, 정합 과정을 가속화하기 위한 다양한 최적화 기법이 필요하다.</p>
<h4 id="_15">다운샘플링과 정합의 결합</h4>
<p>실시간 데이터 처리에서는 다운샘플링을 통해 포인트 클라우드의 크기를 줄이는 것이 중요한 기법 중 하나이다. <strong>Voxel Grid</strong>나 <strong>Octree 기반 다운샘플링</strong>을 적용하여 포인트 클라우드의 밀도를 줄인 후, 다운샘플된 데이터를 기준으로 정합을 수행할 수 있다.</p>
<p>다운샘플링된 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{ds}}</span><script type="math/tex">\mathbf{P}_{\text{ds}}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}_{\text{ds}}</span><script type="math/tex">\mathbf{Q}_{\text{ds}}</script></span>에 대해 먼저 정합을 수행하고, 이후 원본 데이터에 대해 세부 정합을 수행하는 방식은 실시간 성능을 향상시키는 데 매우 유용하다. 이를 통해 전체 정합 프로세스의 효율성을 극대화할 수 있다.</p>
<h4 id="gpu">병렬 처리와 GPU 가속</h4>
<p>포인트 클라우드 정합 과정은 많은 계산을 수반하므로, <strong>병렬 처리</strong>와 <strong>GPU 가속</strong>을 통해 처리 시간을 줄일 수 있다. 특히 ICP 알고리즘은 각 반복에서 많은 대응점 계산이 필요한데, 이러한 계산은 각 포인트에 대해 독립적으로 이루어지므로 병렬 처리가 가능하다.</p>
<p>다음과 같은 방법을 적용할 수 있다:
- <strong>OpenMP</strong> 또는 <strong>CUDA</strong>를 이용한 병렬화
- <strong>PCL(PCL::gpu::ICP)</strong>와 같은 GPU 기반 ICP 구현체 사용</p>
<p>이와 같은 최적화 기법을 활용하면 실시간 정합이 가능해지며, 자율 탐사 시스템에서의 활용성이 높아진다.</p>
<h3 id="_16">다중 스케일 정합을 위한 멀티 레벨 접근</h3>
<p>수중 환경에서 포인트 클라우드의 복잡한 구조를 처리하기 위해 <strong>다중 스케일 정합(Multi-Scale Registration)</strong> 기법을 적용할 수 있다. 이 방법은 포인트 클라우드를 여러 해상도로 분해한 후, 저해상도부터 고해상도까지 순차적으로 정합을 수행하는 방식이다.</p>
<ol>
<li><strong>저해상도 정합</strong>: 저해상도로 다운샘플된 포인트 클라우드를 먼저 정합하여 대략적인 변환을 계산한다.</li>
<li><strong>고해상도 정합</strong>: 고해상도 포인트 클라우드에 대해 세부 정합을 수행한다. 이 단계에서 추가적인 세부 조정이 이루어진다.</li>
</ol>
<p>다중 스케일 정합은 복잡한 수중 환경에서 대규모 데이터를 효율적으로 처리하는 데 매우 유용하며, 정밀도와 계산 효율성 간의 균형을 유지할 수 있다.</p>
<h3 id="_17">수중 환경에서의 포인트 클라우드 정합의 추가 기법</h3>
<p>수중 환경에서의 정합 과정은 다양한 기법을 결합하여 이루어진다. 이 과정에서는 노이즈를 제거하고, 센서 데이터의 특성을 보정하며, 정합의 정확도를 높이기 위해 여러 단계를 거치게 된다. 아래에서는 그 밖의 중요한 정합 기법과 보정 전략에 대해 설명한다.</p>
<h3 id="feature-based-registration">특징 기반 정합 (Feature-Based Registration)</h3>
<p>특징 기반 정합은 두 포인트 클라우드 사이의 특정 지형적 또는 기하학적 특징을 추출하고, 이러한 특징을 기반으로 정합을 수행하는 방식이다. 수중 환경에서의 포인트 클라우드는 대개 동일한 물체라도 신호 감쇠와 노이즈로 인해 불완전하거나 왜곡된 데이터로 나타나기 때문에, 특징 기반 정합을 사용하는 것이 특히 유리하다.</p>
<h4 id="_18">특징 추출</h4>
<p>특징 추출은 각 포인트 클라우드에서 고유한 구조적 요소나 형태적 변화를 감지하여, 이를 정합의 기준으로 삼는 과정이다. 수중 환경에서는 복잡한 지형이나 인공 구조물이 많기 때문에, 이러한 특징을 효과적으로 추출할 수 있는 방법이 필요하다. 주로 사용되는 특징은 다음과 같다:
- <strong>SIFT(Scale-Invariant Feature Transform)</strong>: 이미지 처리에서 널리 사용되는 SIFT 알고리즘은 포인트 클라우드에서도 유사한 방식으로 특징점을 감지하는 데 사용할 수 있다. 이 방법은 스케일과 회전에 강인한 특징을 추출하여, 포인트 클라우드 사이의 정합에 활용한다.
- <strong>FPFH(Fast Point Feature Histograms)</strong>: PCL에서 제공하는 이 알고리즘은 각 포인트 주변의 기하학적 구조를 빠르게 분석하고 특징 벡터를 생성한다. FPFH를 이용하면 두 포인트 클라우드 사이의 대응점을 효과적으로 찾을 수 있다.</p>
<h4 id="_19">특징 정합</h4>
<p>특징 추출이 완료되면, 각 포인트 클라우드에서 추출된 특징 벡터들 사이의 대응점을 찾아내고, 이를 바탕으로 정합을 수행한다. 특징 정합은 아래와 같은 방법으로 이루어진다:</p>
<ol>
<li><strong>특징 대응점 찾기</strong>: 두 포인트 클라우드에서 추출된 특징 벡터들 중에서 가장 유사한 특징을 대응시킨다. 유사성은 주로 유클리드 거리나 코사인 유사도를 이용하여 계산할 수 있다.</li>
<li><strong>변환 행렬 계산</strong>: 대응된 특징점들을 바탕으로, 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 변환 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>를 추정한다. 일반적인 방법은 최소제곱법을 사용하여 최적의 변환 행렬을 계산하는 것이다. 이 과정에서 다음과 같은 방식으로 변환을 추정할 수 있다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{M} \| \mathbf{f}_i - (\mathbf{R} \mathbf{g}_i + \mathbf{t}) \|^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{M} \| \mathbf{f}_i - (\mathbf{R} \mathbf{g}_i + \mathbf{t}) \|^2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}_i</span><script type="math/tex">\mathbf{f}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{g}_i</span><script type="math/tex">\mathbf{g}_i</script></span>는 각각 두 포인트 클라우드에서 추출된 특징점이다.</p>
<ol>
<li><strong>정밀 정합 수행</strong>: 초기 정합 후에는 ICP와 같은 기법을 추가로 적용하여 미세 조정을 수행할 수 있다.</li>
</ol>
<h3 id="_20">수중 환경에서의 정규화 및 정합 최적화 기법</h3>
<p>수중 환경에서는 센서의 한계로 인해 포인트 클라우드의 데이터 품질이 떨어질 수 있다. 이를 보정하고 정합의 정확도를 높이기 위해, 다음과 같은 최적화 기법을 추가로 적용할 수 있다.</p>
<h4 id="_21">동적 필터링과 정합</h4>
<p>수중에서 수집된 데이터는 특정 시간이나 공간에서 데이터 품질이 급격히 떨어질 수 있다. 이러한 경우에는 <strong>동적 필터링(Dynamic Filtering)</strong> 기법을 적용하여, 시간에 따른 포인트 클라우드의 변화를 반영하면서 정합을 수행할 수 있다. 동적 필터링은 데이터를 실시간으로 분석하고, 특정 시간대나 위치에서 발생하는 노이즈나 왜곡을 실시간으로 제거하여 데이터의 일관성을 유지하는 방식이다.</p>
<h4 id="iterative-registration">반복적 정합(Iterative Registration)과 검증</h4>
<p>포인트 클라우드의 정합은 한 번의 과정으로 끝나지 않는 경우가 많다. 특히, 수중 데이터는 여러 센서와 위치에서 수집된 데이터를 통합해야 하므로, 정합이 여러 번 반복적으로 수행될 수 있다. 이를 위해 각 정합 단계에서 결과를 검증하고, 필요 시 다시 정규화 및 정합을 수행하는 <strong>반복적 정합 기법</strong>을 사용한다.</p>
<p>반복적 정합은 다음의 절차로 이루어진다:
1. <strong>초기 정합 수행</strong>: 각 센서 데이터 간의 초기 정합을 수행한다.
2. <strong>검증 단계</strong>: 정합 결과를 검증하여, 데이터 간의 오차 또는 일치 정도를 평가한다. 보통 이 과정은 정합 후 두 포인트 클라우드 사이의 남은 차이를 측정하는 RMS(root mean square) 오차로 평가한다.
3. <strong>오차 기반 재정합</strong>: 오차가 특정 기준 이상일 경우, 초기 정합 결과를 바탕으로 다시 정합을 수행하며, 이 과정은 필요할 때까지 반복된다.</p>
<h4 id="_22">정합 품질 개선을 위한 기법</h4>
<p>정합의 품질을 개선하기 위해 사용할 수 있는 몇 가지 추가적인 기법이 있다:</p>
<ul>
<li><strong>멀티 센서 데이터 융합</strong>: 여러 종류의 센서에서 수집된 데이터를 결합하여 정합 품질을 높이는 방법이다. 예를 들어, 소나 데이터와 라이다 데이터를 동시에 사용하여, 수중 지형을 보다 정확하게 모델링할 수 있다.</li>
<li><strong>대칭성 기반 정합(Symmetry-Based Registration)</strong>: 수중 구조물이나 자연물은 종종 대칭성을 가지고 있다. 이러한 대칭성을 이용하여, 포인트 클라우드의 정합을 보다 쉽게 수행할 수 있다. 대칭성을 고려한 정합은 두 데이터 간의 대응점을 찾는 과정을 단순화하고, 정합 정확도를 높이는 데 도움을 준다.</li>
</ul>
<h3 id="_23">최적화된 정합을 위한 계산 복잡도 감소 기법</h3>
<p>수중 포인트 클라우드 데이터는 매우 방대할 수 있으며, 이를 실시간으로 처리하는 것은 계산 비용이 많이 든다. 따라서 정합 과정에서 계산 복잡도를 줄이기 위한 최적화 기법이 필요하다.</p>
<h4 id="_24">볼록 매칭 기법</h4>
<p>일반적인 ICP 알고리즘은 비선형 최적화 문제로, 계산 비용이 높을 수 있다. 이를 개선하기 위해, 포인트 클라우드 데이터가 비교적 평탄하거나 볼록한 영역에서 수집된 경우, <strong>볼록 매칭(Convex Matching)</strong> 기법을 적용할 수 있다. 이 방법은 주어진 영역에서의 변환을 볼록 형태의 모델로 근사하여, 계산 복잡도를 크게 줄일 수 있다.</p>
<h4 id="_25">반복 감소 기법</h4>
<p>ICP와 같은 알고리즘은 반복 과정에서 많은 계산을 수행한다. 이를 효율적으로 처리하기 위해서는 <strong>반복 감소(Iteration Reduction)</strong> 기법을 적용할 수 있다. 이 기법은 초기 단계에서 상대적으로 큰 변환을 빠르게 찾아내고, 이후 단계에서 점차 작은 변환을 적용하여 정밀도를 높이는 방식이다. 이를 통해 초기 반복에서 많은 계산 비용을 줄일 수 있다.</p>
<h4 id="_26">다중 해상도 정합</h4>
<p>앞서 설명한 다중 스케일 정합과 유사하게, 포인트 클라우드를 여러 해상도로 나누어 처리하는 기법은 계산 복잡도를 크게 줄일 수 있다. 특히, 고해상도 데이터를 전부 사용하지 않고, 먼저 저해상도에서 빠르게 대략적인 정합을 수행한 후, 점차 해상도를 높여가며 세밀한 정합을 수행하는 방식은 매우 효율적이다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2904/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2904/" class="btn btn-xs btn-link">
        해양 구조물의 상태 모니터링
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2902/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2902/" class="btn btn-xs btn-link">
        소나와 라이다를 통한 데이터 수집
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>