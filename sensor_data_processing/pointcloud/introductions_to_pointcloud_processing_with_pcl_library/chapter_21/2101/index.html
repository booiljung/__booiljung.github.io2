<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introductions_to_pointcloud_processing_with_pcl_library/chapter_21/2101/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>다양한 스캐너의 포인트 클라우드 통합 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc2a4\uce90\ub108\uc758 \uc885\ub958\uc5d0 \ub530\ub978 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ucc28\uc774\uc810", url: "#_top", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc88c\ud45c\uacc4 \ubcc0\ud658", url: "#_2", children: [
          ]},
          {title: "ICP(Iterative Closest Point) \uc54c\uace0\ub9ac\uc998\uc744 \ud1b5\ud55c \uc815\ud569", url: "#icpiterative-closest-point", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub370\uc774\ud130\uc758 \uc2a4\ucf00\uc77c \uc870\uc815", url: "#_3", children: [
          ]},
          {title: "\uc2a4\uce94 \uac01\ub3c4\uc758 \ucc28\uc774\uc5d0 \ub530\ub978 \ub370\uc774\ud130 \uc815\ud569", url: "#_4", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ud1b5\ud569 \uc2dc \ubc1c\uc0dd\ud558\ub294 \ub178\uc774\uc988 \ucc98\ub9ac", url: "#_5", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc815\ud569\uc758 \ud488\uc9c8 \ud3c9\uac00", url: "#_6", children: [
          ]},
          {title: "\uc5ec\ub7ec \uc2a4\uce90\ub108 \ub370\uc774\ud130 \ud1b5\ud569\uc744 \uc704\ud55c \ud544\ud130\ub9c1 \uae30\ubc95", url: "#_7", children: [
          ]},
          {title: "\ub2e4\uc591\ud55c \ud574\uc0c1\ub3c4\uc758 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ud1b5\ud569", url: "#_8", children: [
          ]},
          {title: "\ud1b5\ud569 \uacb0\uacfc\uc758 \uac80\uc99d\uacfc \ud6c4\ucc98\ub9ac", url: "#_9", children: [
          ]},
          {title: "\uc5ec\ub7ec \uc2a4\uce90\ub108\uc758 \ub370\uc774\ud130 \ud1b5\ud569\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc2dc\uac04 \ubcf5\uc7a1\ub3c4 \ubb38\uc81c", url: "#_10", children: [
              {title: "\ub370\uc774\ud130 \ubd84\ud560 \ubc0f \ubcd1\ub82c \ucc98\ub9ac", url: "#_11" },
              {title: "\ud6a8\uc728\uc801\uc778 \uadfc\uc811 \uac80\uc0c9 \uc54c\uace0\ub9ac\uc998", url: "#_12" },
          ]},
          {title: "\ub2e4\uc911 \uc2a4\uce90\ub108 \ud1b5\ud569 \uc2dc \ubcc0\ud658 \ud30c\ub77c\ubbf8\ud130 \ucd5c\uc801\ud654", url: "#_13", children: [
              {title: "Levenberg-Marquardt \uc54c\uace0\ub9ac\uc998", url: "#levenberg-marquardt" },
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ud1b5\ud569\uc758 \ub300\uaddc\ubaa8 \ub370\uc774\ud130 \ucc98\ub9ac", url: "#_14", children: [
          ]},
          {title: "\ub2e4\uc911 \uc2a4\uce90\ub108 \ud1b5\ud569\uc758 \uc751\uc6a9 \ubd84\uc57c", url: "#_15", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2102/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2102/" class="btn btn-xs btn-link">
        다중 뷰에서의 데이터 취합 및 정렬
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_20/2005/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_20/2005/" class="btn btn-xs btn-link">
        로봇 응용 사례 연구
      </a>
    </div>
    
  </div>

    

    <p>3D 스캔 데이터를 처리하는 과정에서 여러 종류의 스캐너에서 생성된 포인트 클라우드를 통합하는 문제는 매우 중요한 기술적 도전 중 하나이다. 각 스캐너는 고유의 하드웨어 및 소프트웨어 특성을 가지고 있기 때문에, 동일한 객체나 장면을 스캔하더라도 포인트 클라우드 데이터의 형식, 정밀도, 해상도 등에 차이가 발생한다. 따라서 다양한 스캐너의 포인트 클라우드를 통합하려면 각 데이터의 정합성 및 일관성을 유지하면서 정확한 처리가 이루어져야 한다.</p>
<h3 id="_1">스캐너의 종류에 따른 포인트 클라우드 차이점</h3>
<p>다양한 스캐너는 서로 다른 기술적 기반을 바탕으로 포인트 클라우드를 생성한다. 대표적인 스캐너로는 LiDAR, 구조광 스캐너, 시간 비행(ToF) 스캐너 등이 있으며, 이들 스캐너의 주요 차이는 다음과 같다.</p>
<ol>
<li><strong>해상도 차이</strong>: 고해상도 스캐너는 매우 정밀한 포인트 클라우드를 제공하지만, 데이터 양이 크고 처리 비용이 높다. 반면 저해상도 스캐너는 상대적으로 적은 포인트로 표현되므로 데이터의 크기가 작고 실시간 처리에 적합하다.</li>
<li><strong>정확도 및 노이즈</strong>: 스캐너의 정확도는 장비의 기술적 한계와 관련이 있으며, 다양한 환경적 요인(예: 조명, 표면 반사율)에 의해 영향을 받는다. 특히, LiDAR 스캐너는 비교적 정확도가 높은 반면, 구조광 기반 스캐너는 노이즈가 더 많을 수 있다.</li>
<li><strong>좌표계 차이</strong>: 서로 다른 스캐너에서 얻은 데이터는 각각의 고유 좌표계에 따라 포인트들이 배치되기 때문에 이를 통합하려면 공통의 좌표계로 변환해야 한다.</li>
</ol>
<h3 id="_2">포인트 클라우드 좌표계 변환</h3>
<p>서로 다른 스캐너의 데이터를 통합하려면 각각의 포인트 클라우드가 동일한 참조 좌표계 안에서 표현되도록 변환해야 한다. 변환은 보통 회전과 평행이동을 포함하는 선형 변환으로 표현된다. </p>
<p>포인트 클라우드의 좌표 변환은 다음과 같은 수식으로 정의된다. 
어떤 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i = (x_i, y_i, z_i)</span><script type="math/tex">\mathbf{p}_i = (x_i, y_i, z_i)</script></span> 가 있다고 가정하자. 이를 다른 좌표계로 변환하기 위한 선형 변환은 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 평행이동 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i' = \mathbf{R} \mathbf{p}_i + \mathbf{t}
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i' = \mathbf{R} \mathbf{p}_i + \mathbf{t}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R} \in \mathbb{R}^{3 \times 3}</span><script type="math/tex">\mathbf{R} \in \mathbb{R}^{3 \times 3}</script></span> 는 3D 공간에서의 회전을 나타내는 행렬이며, 직교 행렬로서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}^T \mathbf{R} = \mathbf{I}</span><script type="math/tex">\mathbf{R}^T \mathbf{R} = \mathbf{I}</script></span> 을 만족한다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t} \in \mathbb{R}^3</span><script type="math/tex">\mathbf{t} \in \mathbb{R}^3</script></span> 는 평행 이동 벡터이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i'</span><script type="math/tex">\mathbf{p}_i'</script></span> 는 변환된 좌표계에서의 새로운 점의 좌표이다.</p>
<p>이 변환을 모든 포인트에 적용하여 각 포인트 클라우드를 동일한 좌표계로 일관되게 변환한 후에 통합을 진행하게 된다.</p>
<h3 id="icpiterative-closest-point">ICP(Iterative Closest Point) 알고리즘을 통한 정합</h3>
<p>좌표계 변환이 이루어지면, 포인트 클라우드를 보다 정확하게 정합하기 위해 <strong>ICP 알고리즘</strong>이 사용된다. ICP는 두 개의 포인트 클라우드 사이의 대응점들을 찾아내고, 이를 통해 두 데이터 집합을 정밀하게 정렬하는 알고리즘이다. ICP는 다음과 같은 반복 과정으로 수행된다.</p>
<ol>
<li>소스 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_s</span><script type="math/tex">\mathbf{P}_s</script></span> 와 타겟 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_t</span><script type="math/tex">\mathbf{P}_t</script></span>에서 가장 가까운 대응점들을 찾는다.</li>
<li>두 포인트 클라우드 사이의 변환(회전 및 평행이동)을 계산한다.</li>
<li>변환을 적용하여 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_s</span><script type="math/tex">\mathbf{P}_s</script></span>를 업데이트한다.</li>
<li>원하는 오차 기준에 도달할 때까지 반복한다.</li>
</ol>
<p>ICP 알고리즘의 수식적 정의는 두 포인트 클라우드 사이의 오차를 최소화하는 변환을 찾는 문제로 표현된다. 여기서 오차는 다음과 같은 최적화 문제로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \|\mathbf{R} \mathbf{p}_{s_i} + \mathbf{t} - \mathbf{p}_{t_i}\|^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \|\mathbf{R} \mathbf{p}_{s_i} + \mathbf{t} - \mathbf{p}_{t_i}\|^2
</script>
</div>
<p>이때 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{s_i}</span><script type="math/tex">\mathbf{p}_{s_i}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{t_i}</span><script type="math/tex">\mathbf{p}_{t_i}</script></span>는 각각 소스와 타겟 포인트 클라우드의 대응점이며, N은 대응점의 개수이다.</p>
<h3 id="_3">포인트 클라우드 데이터의 스케일 조정</h3>
<p>서로 다른 스캐너에서 얻은 포인트 클라우드는 동일한 좌표계로 변환된 후에도 크기(scale)가 다를 수 있다. 이러한 경우, <strong>스케일 변환</strong>을 통해 포인트 클라우드 데이터를 일관된 크기로 조정해야 한다. 스케일 변환은 각 포인트에 동일한 비율을 적용하여 크기를 변경하는 방식으로 이루어진다.</p>
<p>포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i = (x_i, y_i, z_i)</span><script type="math/tex">\mathbf{p}_i = (x_i, y_i, z_i)</script></span> 에 대해 스케일 변환은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i' = s \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i' = s \mathbf{p}_i
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>는 스케일 팩터이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i'</span><script type="math/tex">\mathbf{p}_i'</script></span>는 스케일 변환 후의 새로운 포인트 좌표이다.</p>
<p>스케일 변환을 통해 서로 다른 크기를 가진 포인트 클라우드를 통합할 수 있으며, 이는 특히 다양한 해상도의 스캐너에서 생성된 데이터를 처리할 때 중요한 역할을 한다.</p>
<h3 id="_4">스캔 각도의 차이에 따른 데이터 정합</h3>
<p>다양한 스캐너는 서로 다른 각도에서 동일한 객체나 장면을 스캔할 수 있다. 이 경우, 서로 다른 각도로 인해 발생하는 데이터 차이를 보정하는 것이 필요하다. 이를 해결하기 위해 <strong>상대적인 각도 차이를 계산</strong>하고, 포인트 클라우드를 회전시켜 정합한다.</p>
<p>포인트 클라우드를 회전하는 방법은 회전 행렬을 사용하는 방식으로 표현된다. 앞서 제시한 회전 변환 수식을 다시 상기하면, 각도 차이에 따라 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_s</span><script type="math/tex">\mathbf{P}_s</script></span>를 다음과 같이 회전시킬 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i' = \mathbf{R}_{\theta} \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i' = \mathbf{R}_{\theta} \mathbf{p}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_{\theta}</span><script type="math/tex">\mathbf{R}_{\theta}</script></span>는 특정 축에 대한 회전 행렬이다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>-축을 기준으로 회전할 경우 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_{\theta}</span><script type="math/tex">\mathbf{R}_{\theta}</script></span>는 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{R}_{\theta} = \begin{bmatrix}
\cos{\theta} &amp; -\sin{\theta} &amp; 0 \\
\sin{\theta} &amp; \cos{\theta} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{R}_{\theta} = \begin{bmatrix}
\cos{\theta} & -\sin{\theta} & 0 \\
\sin{\theta} & \cos{\theta} & 0 \\
0 & 0 & 1
\end{bmatrix}
</script>
</div>
<p><span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>는 회전 각도를 나타내며, 이를 통해 포인트 클라우드를 정합할 수 있다. 특히, 이와 같은 회전 변환은 ICP와 함께 사용될 수 있다. 포인트 클라우드 간의 회전 차이를 줄이면서 정밀한 정합을 수행하는 데 효과적이다.</p>
<h3 id="_5">포인트 클라우드 통합 시 발생하는 노이즈 처리</h3>
<p>여러 스캐너의 데이터를 통합할 때는 노이즈 제거가 필수적이다. 스캐너의 정확도와 해상도에 따라 포인트 클라우드에 노이즈가 발생할 수 있으며, 이러한 노이즈는 데이터 통합 과정에서 품질 저하를 유발한다. 노이즈 제거는 보통 필터링 기법을 통해 이루어지며, 대표적인 기법으로 <strong>Statistical Outlier Removal (SOR)</strong> 및 <strong>Voxel Grid 필터</strong>가 사용된다.</p>
<ol>
<li><strong>Statistical Outlier Removal (SOR)</strong>: 이 필터는 각 포인트 주변의 이웃 점들을 분석하여, 이웃과의 거리가 일정 임계값을 벗어나는 포인트를 제거하는 방식으로 동작한다. SOR의 수식적 정의는 다음과 같다. 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 이웃 점들의 평균 거리 <span class="arithmatex"><span class="MathJax_Preview">\bar{d}_i</span><script type="math/tex">\bar{d}_i</script></span>를 계산하고, 이 값이 임계값 <span class="arithmatex"><span class="MathJax_Preview">d_{threshold}</span><script type="math/tex">d_{threshold}</script></span>를 넘는 포인트들은 노이즈로 간주되어 제거된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\bar{d}_i = \frac{1}{k} \sum_{j=1}^{k} \|\mathbf{p}_i - \mathbf{p}_{j}\|
</div>
<script type="math/tex; mode=display">
\bar{d}_i = \frac{1}{k} \sum_{j=1}^{k} \|\mathbf{p}_i - \mathbf{p}_{j}\|
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>는 이웃 점의 수이다.</p>
<ol>
<li><strong>Voxel Grid 필터</strong>: 이 필터는 포인트 클라우드를 공간적으로 그리드 형태로 분할하여, 각 그리드 셀 내에서 대표 포인트를 선택하는 방식으로 동작한다. 이 과정을 통해 포인트 클라우드를 다운샘플링할 수 있으며, 동시에 노이즈도 제거된다. Voxel Grid 필터의 기본 아이디어는 공간을 여러 격자로 나누고, 각 격자 내에서 포인트들의 평균 위치를 구해 대표점을 선정하는 것이다.</li>
</ol>
<h3 id="_6">포인트 클라우드 정합의 품질 평가</h3>
<p>포인트 클라우드를 통합할 때, 정합의 품질을 평가하는 것이 필수적이다. 이를 위해 다양한 정량적 평가 지표가 사용될 수 있다. 주로 사용하는 평가 기준으로는 <strong>루트 평균 제곱 오차(RMSE)</strong>와 <strong>최소 평균 거리(MSD)</strong>가 있다.</p>
<ol>
<li><strong>루트 평균 제곱 오차 (RMSE)</strong>: 두 포인트 클라우드 사이의 오차를 측정하는 대표적인 지표이다. ICP와 같은 정합 알고리즘의 최적화 과정에서 자주 사용되며, 두 데이터 셋 사이의 대응점들 간의 거리 차이를 계산한다. RMSE는 다음과 같이 정의된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
RMSE = \sqrt{\frac{1}{N} \sum_{i=1}^{N} \|\mathbf{p}_{s_i}' - \mathbf{p}_{t_i}\|^2}
</div>
<script type="math/tex; mode=display">
RMSE = \sqrt{\frac{1}{N} \sum_{i=1}^{N} \|\mathbf{p}_{s_i}' - \mathbf{p}_{t_i}\|^2}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{s_i}'</span><script type="math/tex">\mathbf{p}_{s_i}'</script></span>는 변환 후의 소스 포인트 클라우드의 점이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{t_i}</span><script type="math/tex">\mathbf{p}_{t_i}</script></span>는 타겟 포인트 클라우드의 대응점이다.
- N은 대응점의 수이다.</p>
<p>RMSE 값이 낮을수록 두 포인트 클라우드가 잘 정합되었다고 평가할 수 있다.</p>
<ol>
<li><strong>최소 평균 거리(MSD)</strong>: MSD는 정합 후 두 포인트 클라우드 간의 평균 거리 차이를 측정하는 방법으로, 오차가 어떻게 분포하는지 파악할 수 있다. 특히, 특정 영역에서 오차가 집중되었는지, 혹은 전체적으로 균등하게 분포했는지를 확인할 수 있다. MSD는 다음과 같이 정의된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
MSD = \frac{1}{N} \sum_{i=1}^{N} \|\mathbf{p}_{s_i}' - \mathbf{p}_{t_i}\|
</div>
<script type="math/tex; mode=display">
MSD = \frac{1}{N} \sum_{i=1}^{N} \|\mathbf{p}_{s_i}' - \mathbf{p}_{t_i}\|
</script>
</div>
<p>MSD는 RMSE보다 더 직관적으로 오차 분포를 이해할 수 있는 지표이다.</p>
<h3 id="_7">여러 스캐너 데이터 통합을 위한 필터링 기법</h3>
<p>다양한 스캐너의 데이터를 통합할 때, 노이즈를 줄이고 일관된 포인트 클라우드를 얻기 위해 다양한 필터링 기법이 적용된다. 앞서 언급한 SOR 및 Voxel Grid 필터 외에도, <strong>MLS(Moving Least Squares)</strong> 필터와 <strong>Bilateral 필터</strong> 같은 더 정교한 방법들이 사용될 수 있다.</p>
<ol>
<li>
<p><strong>Moving Least Squares (MLS) 필터</strong>: MLS는 포인트 클라우드의 표면을 부드럽게 하기 위한 기법으로, 각 포인트 주변의 국소 표면을 추정한 후, 해당 표면에 맞춰 포인트의 위치를 보정하는 방식이다. 이 필터는 주로 표면의 연속성을 유지하면서 노이즈를 줄이는 데 사용된다. </p>
</li>
<li>
<p><strong>Bilateral 필터</strong>: Bilateral 필터는 이미지 처리에서 자주 사용되는 방법이지만, 포인트 클라우드에서도 효과적으로 적용될 수 있다. 이 필터는 포인트 간의 거리뿐만 아니라, 속성(예: 색상이나 밀도) 간의 차이를 기반으로 필터링을 수행하며, 경계를 보존하면서 노이즈를 제거하는 데 적합하다.</p>
</li>
</ol>
<h3 id="_8">다양한 해상도의 포인트 클라우드 통합</h3>
<p>포인트 클라우드를 통합할 때 또 다른 중요한 문제는 <strong>해상도 차이</strong>이다. 다양한 스캐너는 각기 다른 해상도로 데이터를 수집하므로, 이 차이를 해결해야 통합 후 일관된 데이터 세트를 얻을 수 있다. 해상도 차이를 해결하기 위해 다음과 같은 방법들이 사용될 수 있다.</p>
<ol>
<li>
<p><strong>포인트 클라우드 다운샘플링</strong>: 고해상도 포인트 클라우드를 저해상도 스캐너의 데이터에 맞추기 위해 다운샘플링을 수행한다. 이를 위해 <strong>Voxel Grid 필터</strong> 또는 <strong>랜덤 샘플링</strong> 기법이 사용된다. 다운샘플링을 통해 두 데이터 셋의 해상도를 맞출 수 있다.</p>
</li>
<li>
<p><strong>포인트 클라우드 업샘플링</strong>: 저해상도 포인트 클라우드를 보간법을 사용해 고해상도로 변환하는 방식이다. 대표적인 방법으로 <strong>Nearest Neighbor Interpolation</strong>과 <strong>Bilinear Interpolation</strong>이 있으며, 업샘플링을 통해 해상도 차이를 줄일 수 있다.</p>
</li>
<li>
<p><strong>멀티 해상도 통합 기법</strong>: 특정 영역에서 고해상도 데이터를 유지하면서도, 나머지 영역에서는 저해상도로 처리하는 방식이다. 이를 통해 데이터의 중요도가 높은 영역에서만 고해상도로 처리하고, 나머지 영역에서는 처리 성능을 최적화할 수 있다.</p>
</li>
</ol>
<h3 id="_9">통합 결과의 검증과 후처리</h3>
<p>통합된 포인트 클라우드는 후처리 과정을 통해 최종 품질을 개선할 수 있다. 이 후처리 단계에서는 주로 포인트 클라우드를 정리하고, 불필요한 데이터를 제거하며, 결과물을 시각적으로 검증하는 작업이 이루어진다. 후처리 단계의 핵심 작업으로는 다음이 있다.</p>
<ol>
<li>
<p><strong>중복 포인트 제거</strong>: 통합 과정에서 중복된 포인트가 발생할 수 있다. 이를 제거하는 과정은 데이터의 품질과 처리 속도를 향상시키는 데 필수적이다.</p>
</li>
<li>
<p><strong>경계점 보정</strong>: 다양한 스캐너에서 얻어진 데이터는 경계 부분에서 불일치가 발생할 수 있다. 경계 영역을 보정하는 작업을 통해 일관성을 유지할 수 있다.</p>
</li>
<li>
<p><strong>정밀도 평가</strong>: 앞서 언급한 RMSE, MSD와 같은 정량적 지표를 사용하여 통합된 결과를 평가하고, 필요시 추가적인 정합이나 필터링을 수행한다.</p>
</li>
</ol>
<h3 id="_10">여러 스캐너의 데이터 통합에서 발생하는 시간 복잡도 문제</h3>
<p>다양한 스캐너에서 수집된 포인트 클라우드 데이터를 통합할 때, 계산 시간 복잡도는 중요한 문제로 대두된다. 특히, 데이터의 크기가 클수록 처리 시간과 메모리 소비가 기하급수적으로 증가할 수 있다. 이에 대한 해결책으로 여러 가지 최적화 기법이 존재하며, 주요 기술로는 <strong>데이터 분할 및 병렬 처리</strong>와 <strong>효율적인 근접 검색 알고리즘</strong>이 있다.</p>
<h4 id="_11">데이터 분할 및 병렬 처리</h4>
<p>포인트 클라우드 데이터를 여러 개의 작은 부분으로 나누어 병렬로 처리하면, 전체 처리 시간을 크게 줄일 수 있다. 이를 위해 <strong>KD-트리(K-Dimensional Tree)</strong>와 같은 공간 분할 기법이 자주 사용된다. KD-트리는 고차원 공간에서 포인트를 효율적으로 검색하고, 데이터 처리를 병렬화하는 데 유용하다.</p>
<p>KD-트리는 포인트 클라우드의 각 점을 <strong>계층적 분할</strong>을 통해 저장하며, 검색, 정렬, 범위 쿼리 등의 연산에서 유리한 성능을 제공한다. KD-트리의 구축 및 검색의 시간 복잡도는 일반적으로 <span class="arithmatex"><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>으로, 대규모 데이터 처리에 적합하다.</p>
<p>포인트 클라우드의 각 부분을 병렬로 처리하기 위한 과정은 다음과 같다:</p>
<ol>
<li><strong>데이터 분할</strong>: 포인트 클라우드 데이터를 KD-트리 등의 분할 기법을 사용해 여러 개의 부분으로 나눈다. 각 부분은 독립적으로 처리될 수 있다.</li>
<li><strong>병렬 처리</strong>: 각 분할된 데이터는 여러 스레드 또는 프로세스에서 병렬로 처리된다. 이 과정에서 노이즈 제거, 좌표 변환, 정합 등의 작업을 수행할 수 있다.</li>
<li><strong>결과 통합</strong>: 병렬 처리된 결과는 최종적으로 통합되어 하나의 포인트 클라우드로 재구성된다.</li>
</ol>
<h4 id="_12">효율적인 근접 검색 알고리즘</h4>
<p>ICP와 같은 알고리즘에서 포인트 클라우드 간의 대응점을 찾는 작업은 포인트 수가 많을수록 시간이 많이 소요된다. 이를 해결하기 위해 <strong>Nearest Neighbor Search(근접점 검색)</strong> 알고리즘이 사용되며, 이 알고리즘의 효율성을 높이기 위해 KD-트리와 같은 공간 분할 기법이 도입된다.</p>
<p>근접점 검색에서 가장 중요한 문제는 각 포인트에 대해 타겟 포인트 클라우드에서 가장 가까운 대응점을 찾는 것이다. KD-트리를 활용하면 근접점 검색의 시간 복잡도를 <span class="arithmatex"><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>로 낮출 수 있으며, 이는 브루트 포스 방식의 <span class="arithmatex"><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span>와 비교했을 때 매우 효율적이다.</p>
<p>근접점 검색은 다음과 같은 단계로 이루어진다:</p>
<ol>
<li><strong>KD-트리 구축</strong>: 타겟 포인트 클라우드에 대한 KD-트리를 구축한다.</li>
<li><strong>근접점 검색</strong>: 소스 포인트 클라우드의 각 포인트에 대해 KD-트리를 사용해 가장 가까운 대응점을 검색한다.</li>
<li><strong>결과 반환</strong>: 검색된 근접점 정보를 사용해 정합 및 변환 작업을 수행한다.</li>
</ol>
<p>이 방식은 특히 대용량 데이터에서 효율적인 처리를 가능하게 한다.</p>
<h3 id="_13">다중 스캐너 통합 시 변환 파라미터 최적화</h3>
<p>다양한 스캐너에서 얻은 포인트 클라우드를 정합할 때, 최적의 변환 파라미터(회전, 평행 이동, 스케일)를 찾는 것이 매우 중요하다. 이를 위해 <strong>최적화 알고리즘</strong>이 사용되며, 일반적으로 사용되는 기법으로는 <strong>Levenberg-Marquardt 알고리즘</strong>과 같은 비선형 최소 제곱 기법이 있다.</p>
<h4 id="levenberg-marquardt">Levenberg-Marquardt 알고리즘</h4>
<p>Levenberg-Marquardt 알고리즘은 비선형 함수 최적화를 위해 자주 사용되며, ICP와 같은 정합 알고리즘에서 두 포인트 클라우드 사이의 변환 행렬을 추정하는 데 사용된다. 이 알고리즘은 <strong>최소 제곱 문제</strong>를 풀기 위한 기법으로, 아래와 같은 목적 함수를 최소화한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
E(\mathbf{R}, \mathbf{t}) = \sum_{i=1}^{N} \|\mathbf{R} \mathbf{p}_{s_i} + \mathbf{t} - \mathbf{p}_{t_i}\|^2
</div>
<script type="math/tex; mode=display">
E(\mathbf{R}, \mathbf{t}) = \sum_{i=1}^{N} \|\mathbf{R} \mathbf{p}_{s_i} + \mathbf{t} - \mathbf{p}_{t_i}\|^2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>는 회전 행렬과 평행 이동 벡터이며, 최적화 대상이다. Levenberg-Marquardt 알고리즘은 이 목적 함수를 반복적으로 미분하고, 뉴턴 방법과 경사 하강법을 혼합하여 빠르게 수렴할 수 있도록 한다.</p>
<h3 id="_14">포인트 클라우드 통합의 대규모 데이터 처리</h3>
<p>다중 스캐너의 데이터를 통합할 때는 데이터의 크기가 커질 수밖에 없다. 이러한 대규모 데이터를 처리하는 데 있어 가장 중요한 문제는 <strong>메모리 사용량</strong>과 <strong>처리 속도</strong>이다. 이를 해결하기 위한 여러 가지 기법이 존재한다.</p>
<ol>
<li>
<p><strong>포인트 클라우드 압축</strong>: 대용량 포인트 클라우드는 압축 기법을 통해 메모리 사용량을 줄일 수 있다. 압축 알고리즘으로는 <strong>Octree</strong> 기반 압축이 자주 사용되며, 이는 포인트 클라우드를 공간적으로 분할하여 트리 구조로 저장한다. Octree 압축은 데이터의 중요도에 따라 세밀하게 분할할 수 있어, 데이터 손실을 최소화하면서도 메모리를 절약할 수 있다.</p>
</li>
<li>
<p><strong>스트리밍 기법</strong>: 대규모 데이터를 처리할 때, 모든 데이터를 한꺼번에 메모리에 로드하지 않고 <strong>스트리밍 방식</strong>으로 처리할 수 있다. 이 방식에서는 데이터를 일정한 크기로 나누어 처리하며, 필요한 부분만 실시간으로 메모리에 로드하여 처리 성능을 최적화할 수 있다.</p>
</li>
<li>
<p><strong>GPU 가속</strong>: 대규모 데이터의 병렬 처리를 위해 GPU 가속을 사용하는 것도 효과적이다. GPU는 대량의 연산을 병렬로 수행할 수 있어, 포인트 클라우드의 정합, 필터링, 근접 검색 등의 작업에서 처리 속도를 크게 향상시킬 수 있다.</p>
</li>
</ol>
<h3 id="_15">다중 스캐너 통합의 응용 분야</h3>
<p>다양한 스캐너에서 얻은 데이터를 통합하는 기술은 여러 산업 분야에서 활용될 수 있다. 특히, <strong>건축</strong>, <strong>로봇 공학</strong>, <strong>자율 주행</strong>과 같은 분야에서는 다중 스캐너의 통합을 통해 정확하고 일관된 3D 모델을 생성하는 것이 중요하다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2102/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2102/" class="btn btn-xs btn-link">
        다중 뷰에서의 데이터 취합 및 정렬
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_20/2005/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_20/2005/" class="btn btn-xs btn-link">
        로봇 응용 사례 연구
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>