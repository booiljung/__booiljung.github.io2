<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introductions_to_pointcloud_processing_with_pcl_library/chapter_24/2401/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>시뮬레이션 환경에서의 PCL 활용 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uac00\uc0c1 \uc13c\uc11c \ub370\uc774\ud130 \uc0dd\uc131", url: "#_top", children: [
          ]},
          {title: "\ucda9\ub3cc \uac10\uc9c0 \ubc0f \uacbd\ub85c \uacc4\ud68d \uc2dc\ubbac\ub808\uc774\uc158", url: "#_2", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ud544\ud130\ub9c1 \ubc0f \uc804\ucc98\ub9ac", url: "#_3", children: [
          ]},
          {title: "\uc2dc\ubbac\ub808\uc774\uc158 \ud658\uacbd\uc5d0\uc11c\uc758 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc815\ud569", url: "#_4", children: [
          ]},
          {title: "\ub3d9\uc801 \ud658\uacbd \uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c\uc758 PCL \ud65c\uc6a9", url: "#pcl", children: [
          ]},
          {title: "\uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c\uc758 \ud45c\uba74 \uc7ac\uad6c\uc131", url: "#_5", children: [
          ]},
          {title: "\uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c\uc758 \uac1d\uccb4 \ucd94\uc801", url: "#_6", children: [
          ]},
          {title: "\uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c\uc758 \ud074\ub7ec\uc2a4\ud130\ub9c1\uacfc \uac1d\uccb4 \ubd84\ub9ac", url: "#_7", children: [
          ]},
          {title: "\uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c\uc758 \ub77c\ubca8\ub9c1 \ubc0f \ubd84\ub958", url: "#_8", children: [
          ]},
          {title: "\uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c\uc758 \ub85c\ubd07 \uacbd\ub85c \ucd5c\uc801\ud654", url: "#_9", children: [
          ]},
          {title: "\uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c\uc758 \uba54\uc2dc\uc640 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc758 \ud1b5\ud569", url: "#_10", children: [
          ]},
          {title: "\uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c\uc758 \ubb3c\ub9ac\uc801 \uc0c1\ud638\uc791\uc6a9", url: "#_11", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2402/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2402/" class="btn btn-xs btn-link">
        가상 환경에서의 포인트 클라우드 생성
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_23/2305/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_23/2305/" class="btn btn-xs btn-link">
        원격 로봇 제어를 위한 데이터 스트리밍 사례
      </a>
    </div>
    
  </div>

    

    <p>PCL(Point Cloud Library)은 포인트 클라우드 데이터를 처리하는 데 있어 매우 중요한 라이브러리로, 시뮬레이션 환경에서도 유용하게 활용된다. 시뮬레이션 환경에서 PCL을 사용하는 것은 다양한 시나리오에서 가상 데이터를 생성하고 이를 기반으로 분석하거나 처리하는 데 도움을 준다. 이러한 시뮬레이션 환경은 실제 하드웨어가 필요하지 않으며, 가상 데이터를 통해 알고리즘의 성능을 테스트하거나 시스템을 검증할 수 있다.</p>
<h3 id="_1">가상 센서 데이터 생성</h3>
<p>시뮬레이션 환경에서 PCL을 사용하는 가장 일반적인 방법 중 하나는 가상 센서를 통해 포인트 클라우드를 생성하는 것이다. 이러한 가상 센서는 실제 환경에서 사용하는 라이다(LiDAR), 카메라, 심도 센서와 유사한 데이터를 생성할 수 있다. 이를 통해 실제 환경에서의 데이터를 모사하고, 다양한 상황에 대한 실험을 수행할 수 있다.</p>
<p>라이다 센서를 예로 들면, 라이다의 스캔 패턴을 수학적으로 정의할 수 있다. 라이다 센서가 특정 각도로 360도를 회전하면서 레이저를 방출하고 반사된 신호를 수신하여 거리를 계산하는 과정은 아래와 같이 모델링할 수 있다.</p>
<p>레이저 빔이 방출되는 각도 <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>와 거리를 <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>라 할 때, 포인트 클라우드 상의 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p} = 
\begin{bmatrix}
x \\
y \\
z
\end{bmatrix}
=
\begin{bmatrix}
d \cos(\theta) \\
d \sin(\theta) \\
h
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{p} = 
\begin{bmatrix}
x \\
y \\
z
\end{bmatrix}
=
\begin{bmatrix}
d \cos(\theta) \\
d \sin(\theta) \\
h
\end{bmatrix}
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span>는 센서의 높이에 해당한다. 이러한 방식으로 시뮬레이션에서 각 포인트에 대한 좌표를 생성할 수 있다. PCL은 이러한 데이터를 기반으로 다양한 필터링, 분할, 클러스터링 작업을 수행할 수 있게 해준다.</p>
<h3 id="_2">충돌 감지 및 경로 계획 시뮬레이션</h3>
<p>PCL은 로봇의 경로 계획과 충돌 감지에도 사용될 수 있다. 시뮬레이션 환경에서 로봇의 주행 경로를 계획할 때, 주변 환경을 포인트 클라우드 데이터로 모델링하여 실시간으로 충돌을 감지하고 경로를 수정하는 방식으로 활용된다. 이러한 과정은 아래와 같은 수학적 모델로 표현된다.</p>
<p>로봇이 이동할 경로를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}(t)</span><script type="math/tex">\mathbf{P}(t)</script></span>라고 정의할 때, 주어진 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서 로봇의 위치는</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}(t) = 
\begin{bmatrix}
x(t) \\
y(t) \\
z(t)
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{P}(t) = 
\begin{bmatrix}
x(t) \\
y(t) \\
z(t)
\end{bmatrix}
</script>
</div>
<p>로 나타낼 수 있다. 로봇이 충돌할 가능성이 있는 물체와의 거리는</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{P}(t), \mathbf{O}) = \|\mathbf{P}(t) - \mathbf{O}\|
</div>
<script type="math/tex; mode=display">
d(\mathbf{P}(t), \mathbf{O}) = \|\mathbf{P}(t) - \mathbf{O}\|
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}</span><script type="math/tex">\mathbf{O}</script></span>는 물체의 좌표이다. 만약 이 거리가 일정 임계값 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{min}}</span><script type="math/tex">d_{\text{min}}</script></span>보다 작으면, 충돌 위험이 있다고 판단하고 경로를 수정한다.</p>
<p>PCL을 이용하면, 이러한 시뮬레이션을 통해 로봇의 경로를 실시간으로 업데이트하고 충돌을 회피할 수 있는 알고리즘을 테스트할 수 있다. </p>
<h3 id="_3">포인트 클라우드 필터링 및 전처리</h3>
<p>시뮬레이션 환경에서 생성된 포인트 클라우드 데이터는 일반적으로 노이즈를 포함하고 있을 수 있다. 따라서 시뮬레이션에서 유의미한 데이터를 추출하기 위해서는 포인트 클라우드 필터링 및 전처리 작업이 필요하다. PCL은 다양한 필터링 방법을 제공하며, 이는 실제 환경과 유사하게 시뮬레이션된 데이터를 처리하는 데 매우 유용하다.</p>
<p>필터링 작업에서 자주 사용되는 방법 중 하나는 "평균 필터"로, 각 포인트의 인접한 이웃 포인트들의 값을 평균내어 노이즈를 제거하는 방식이다. 이웃 포인트를 고려한 평균 필터는 다음과 같이 정의될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i^{\text{new}} = \frac{1}{N} \sum_{j=1}^{N} \mathbf{p}_j
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i^{\text{new}} = \frac{1}{N} \sum_{j=1}^{N} \mathbf{p}_j
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i^{\text{new}}</span><script type="math/tex">\mathbf{p}_i^{\text{new}}</script></span>는 새롭게 계산된 포인트, <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 이웃 포인트의 개수, 그리고 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span>는 이웃 포인트들이다. 이러한 필터링은 시뮬레이션된 데이터를 더 안정적으로 만들고, 이후 처리 작업의 정확도를 높이는 데 기여한다.</p>
<p>또한, "자르기(clipping)" 기법은 특정 범위 밖의 포인트들을 제거하는 방식이다. 예를 들어, 관심 영역(Region of Interest, ROI) 내에 있는 포인트들만 남기고 나머지 데이터는 삭제하는 방식이다. 이를 수학적으로 표현하면, 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i = (x_i, y_i, z_i)</span><script type="math/tex">\mathbf{p}_i = (x_i, y_i, z_i)</script></span>가 ROI 내에 있는지를 검사하는 조건은 아래와 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
x_{\text{min}} \leq x_i \leq x_{\text{max}}, \quad y_{\text{min}} \leq y_i \leq y_{\text{max}}, \quad z_{\text{min}} \leq z_i \leq z_{\text{max}}
</div>
<script type="math/tex; mode=display">
x_{\text{min}} \leq x_i \leq x_{\text{max}}, \quad y_{\text{min}} \leq y_i \leq y_{\text{max}}, \quad z_{\text{min}} \leq z_i \leq z_{\text{max}}
</script>
</div>
<p>이 조건을 만족하지 않는 포인트들은 삭제된다. 이러한 방법은 특히 로봇이나 자율 주행 차량의 시뮬레이션에서 유용하게 활용될 수 있다.</p>
<h3 id="_4">시뮬레이션 환경에서의 포인트 클라우드 정합</h3>
<p>시뮬레이션 환경에서 여러 시점에서 얻어진 포인트 클라우드 데이터를 하나의 통합된 데이터로 만드는 과정에서 정합(Registration) 작업이 필요하다. 정합 알고리즘은 서로 다른 좌표계에서 획득된 데이터를 동일한 좌표계로 변환하여 정렬하는 역할을 한다. </p>
<p>일반적으로 사용되는 정합 알고리즘 중 하나는 ICP(Iterative Closest Point) 알고리즘이다. 이 알고리즘은 두 개의 포인트 클라우드를 정렬하기 위해 반복적으로 가장 가까운 포인트를 찾고, 그에 맞추어 변환 행렬을 계산한다. 두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_1</span><script type="math/tex">\mathbf{P}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_2</span><script type="math/tex">\mathbf{P}_2</script></span>를 정합하는 과정은 다음과 같은 변환 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span>로 표현될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i^{\text{new}} = \mathbf{T} \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i^{\text{new}} = \mathbf{T} \mathbf{p}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span>는 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 이동 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>로 이루어진다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{T} = 
\begin{bmatrix}
\mathbf{R} &amp; \mathbf{t} \\
0 &amp; 1
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{T} = 
\begin{bmatrix}
\mathbf{R} & \mathbf{t} \\
0 & 1
\end{bmatrix}
</script>
</div>
<p>ICP 알고리즘은 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span>를 반복적으로 계산하여 두 포인트 클라우드를 최적으로 정합한다. 시뮬레이션 환경에서 이 작업은 매우 중요한데, 예를 들어 자율 주행 차량 시뮬레이션에서 여러 시점에서 수집된 데이터를 정합하여 환경을 3D로 재구성하는 데 활용될 수 있다.</p>
<h3 id="pcl">동적 환경 시뮬레이션에서의 PCL 활용</h3>
<p>동적 환경은 시뮬레이션 중 객체들이 이동하거나 변형되는 환경을 의미한다. 이러한 환경에서는 포인트 클라우드 데이터를 지속적으로 업데이트하고, 변화하는 데이터를 실시간으로 처리해야 한다. PCL은 실시간 데이터 처리 기능을 제공하여, 시뮬레이션된 환경에서 객체의 이동을 추적하거나 동적 변화를 처리하는 데 매우 유용하다.</p>
<p>포인트 클라우드 데이터가 실시간으로 업데이트되면, 각 시점에서의 데이터를 저장하여 동적 객체의 이동을 추적할 수 있다. 이러한 경우, 이동 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>를 사용하여 객체의 새로운 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{new}}</span><script type="math/tex">\mathbf{P}_{\text{new}}</script></span>는 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{\text{new}} = \mathbf{P}_{\text{old}} + \mathbf{v} \Delta t
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{\text{new}} = \mathbf{P}_{\text{old}} + \mathbf{v} \Delta t
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 시간 간격을 나타낸다. PCL은 이러한 동적 데이터를 빠르게 처리하고 분석하는 데 필요한 알고리즘을 제공한다.</p>
<h3 id="_5">시뮬레이션에서의 표면 재구성</h3>
<p>시뮬레이션 환경에서 포인트 클라우드를 활용하는 또 다른 중요한 응용은 표면 재구성(Surface Reconstruction)이다. 포인트 클라우드 데이터는 대개 불규칙적으로 분포된 점들로 구성되기 때문에, 이러한 점들로부터 객체의 표면을 복원하는 과정이 필요하다. 표면 재구성은 특히 가상 환경에서 물체의 형상을 시각화하거나 물리적인 상호작용을 시뮬레이션할 때 필수적인 작업이다.</p>
<p>PCL에서 자주 사용되는 표면 재구성 방법은 삼각 메시(triangulated mesh)를 생성하는 것이다. 이를 위해 PCL은 "Marching Cubes" 알고리즘을 제공하는데, 이 알고리즘은 포인트 클라우드로부터 등고면을 추정하여 3D 표면을 생성하는 방식이다. 이 과정을 수학적으로 설명하면, 주어진 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>에서 표면을 정의하는 함수 <span class="arithmatex"><span class="MathJax_Preview">f(x, y, z)</span><script type="math/tex">f(x, y, z)</script></span>를 찾는 것이다. 함수 <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>는 다음과 같은 등고선 방정식으로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(x, y, z) = 0
</div>
<script type="math/tex; mode=display">
f(x, y, z) = 0
</script>
</div>
<p>Marching Cubes 알고리즘은 공간을 일정한 크기의 큐브로 분할하고, 각 큐브 내에서 포인트 클라우드 데이터를 바탕으로 표면을 추정한다. 각 큐브의 정점에서 함수 <span class="arithmatex"><span class="MathJax_Preview">f(x, y, z)</span><script type="math/tex">f(x, y, z)</script></span>의 값을 계산하고, 그 값을 기반으로 삼각형을 형성하여 메시를 만든다.</p>
<p>표면 재구성은 단순히 시각적인 모델링에 그치지 않고, 시뮬레이션된 객체와의 충돌 감지나 물리적 상호작용에도 사용될 수 있다. 예를 들어, 로봇 시뮬레이션에서 로봇이 물체와 상호작용하는 과정을 시뮬레이션하려면 정확한 표면 정보가 필요하다. PCL의 표면 재구성 기능을 통해 시뮬레이션된 환경에서 객체의 표면을 효과적으로 재구성할 수 있다.</p>
<h3 id="_6">시뮬레이션에서의 객체 추적</h3>
<p>동적 시뮬레이션 환경에서 PCL은 객체 추적에도 활용될 수 있다. 객체 추적은 포인트 클라우드 데이터를 기반으로 특정 객체의 위치를 실시간으로 추적하는 작업을 말한다. PCL에서는 이를 위해 다양한 추적 알고리즘을 제공하며, 특히 칼만 필터(Kalman Filter)를 이용한 추적 방법이 많이 사용된다.</p>
<p>칼만 필터는 객체의 현재 상태(위치, 속도 등)를 예측하고, 실제 측정된 포인트 클라우드 데이터를 이용해 예측값을 보정하는 방식으로 동작한다. 객체의 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = 
\begin{bmatrix}
\mathbf{P}(t) \\
\mathbf{v}(t)
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = 
\begin{bmatrix}
\mathbf{P}(t) \\
\mathbf{v}(t)
\end{bmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}(t)</span><script type="math/tex">\mathbf{P}(t)</script></span>는 객체의 위치, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}(t)</span><script type="math/tex">\mathbf{v}(t)</script></span>는 속도를 나타낸다. 칼만 필터의 기본적인 예측 방정식은 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t+1) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t+1) = \mathbf{A} \mathbf{x}(t) + \mathbf{B} \mathbf{u}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 상태 전이 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 제어 입력 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>는 제어 입력 벡터이다. 이후 측정된 포인트 클라우드 데이터를 이용하여 예측값을 보정하는 업데이트 방정식이 적용된다.</p>
<p>이러한 객체 추적 기법은 시뮬레이션된 환경에서 이동하는 객체의 경로를 추적하거나, 로봇의 위치를 추적하는 데 유용하게 사용될 수 있다. PCL은 이러한 추적 작업을 실시간으로 처리할 수 있도록 다양한 기능을 제공하고 있다.</p>
<h3 id="_7">시뮬레이션에서의 클러스터링과 객체 분리</h3>
<p>시뮬레이션 환경에서 다수의 객체가 존재하는 경우, 포인트 클라우드 데이터를 이용해 각 객체를 분리하는 작업이 필요하다. 이러한 작업은 클러스터링(Clustering) 알고리즘을 통해 수행된다. PCL에서는 다양한 클러스터링 방법을 지원하며, 가장 널리 사용되는 방법 중 하나는 유클리디안 클러스터링(Euclidean Clustering)이다.</p>
<p>유클리디안 클러스터링은 서로 가까운 포인트들을 하나의 클러스터로 묶는 방식으로 동작한다. 이때, 두 포인트 사이의 거리를 계산하는 수식은 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{p}_i, \mathbf{p}_j) = \|\mathbf{p}_i - \mathbf{p}_j\|
</div>
<script type="math/tex; mode=display">
d(\mathbf{p}_i, \mathbf{p}_j) = \|\mathbf{p}_i - \mathbf{p}_j\|
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span>는 두 포인트의 좌표를 나타내며, <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>는 두 포인트 사이의 유클리디안 거리이다. 주어진 임계값 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span> 이하의 거리를 가지는 포인트들은 동일한 클러스터로 묶이게 된다.</p>
<p>클러스터링을 통해 여러 객체가 혼재된 포인트 클라우드 데이터에서 개별 객체를 분리할 수 있으며, 이를 통해 각 객체에 대한 개별적인 분석이나 처리를 수행할 수 있다. 이러한 작업은 시뮬레이션된 로봇 환경에서 물체를 인식하거나, 물체 간의 상호작용을 시뮬레이션하는 데 매우 유용하다.</p>
<h3 id="_8">시뮬레이션에서의 라벨링 및 분류</h3>
<p>시뮬레이션 환경에서 생성된 포인트 클라우드 데이터를 분석하기 위해서는 객체에 대한 라벨링(Labeling) 및 분류(Classification) 작업이 필요하다. PCL은 다양한 분류 알고리즘을 제공하며, 이를 통해 시뮬레이션된 데이터에서 특정 객체를 식별할 수 있다.</p>
<p>분류 작업은 주로 특징(feature) 추출 과정을 거쳐 수행된다. 포인트 클라우드에서 각 포인트 혹은 점 그룹에 대한 특징을 추출한 후, 이를 기반으로 객체를 분류한다. 시뮬레이션 환경에서는 물체의 크기, 형태, 색상과 같은 특징이 포인트 클라우드 상에서 정의될 수 있으며, 이를 수학적으로 모델링하는 과정이 중요하다.</p>
<p>특징 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span>는 여러 개의 특징 값을 포함하는 벡터로, 주어진 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>의 각 점에서 추출할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{f}_i = 
\begin{bmatrix}
f_1(\mathbf{p}_i) \\
f_2(\mathbf{p}_i) \\
\vdots \\
f_n(\mathbf{p}_i)
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{f}_i = 
\begin{bmatrix}
f_1(\mathbf{p}_i) \\
f_2(\mathbf{p}_i) \\
\vdots \\
f_n(\mathbf{p}_i)
\end{bmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">f_1, f_2, \dots, f_n</span><script type="math/tex">f_1, f_2, \dots, f_n</script></span>은 다양한 특징 값들을 나타낸다. 이러한 특징 벡터를 기반으로, 분류 알고리즘은 각 포인트나 객체가 어떤 카테고리에 속하는지 결정하게 된다.</p>
<p>PCL에서 자주 사용되는 분류 기법 중 하나는 k-최근접 이웃(k-Nearest Neighbors, k-NN) 알고리즘이다. 이 알고리즘은 주어진 포인트의 특징 벡터가 어떤 클래스에 속할지를 결정하기 위해, 가장 가까운 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>개의 이웃 포인트를 찾아서 다수결로 분류한다. 두 특징 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}_i</span><script type="math/tex">\mathbf{f}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}_j</span><script type="math/tex">\mathbf{f}_j</script></span> 사이의 거리는 유클리디안 거리로 계산할 수 있으며, 이는 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{f}_i, \mathbf{f}_j) = \|\mathbf{f}_i - \mathbf{f}_j\|
</div>
<script type="math/tex; mode=display">
d(\mathbf{f}_i, \mathbf{f}_j) = \|\mathbf{f}_i - \mathbf{f}_j\|
</script>
</div>
<p>이러한 분류 작업은 시뮬레이션 환경에서 로봇이 특정 물체를 인식하거나, 다양한 객체가 포함된 환경에서 특정한 종류의 객체만을 식별하는 데 활용될 수 있다.</p>
<h3 id="_9">시뮬레이션에서의 로봇 경로 최적화</h3>
<p>PCL은 시뮬레이션 환경에서 로봇의 경로 계획(Path Planning)에도 활용될 수 있다. 로봇 경로 최적화는 로봇이 장애물이나 충돌을 피하면서 목표 지점까지 가장 효율적인 경로를 찾는 작업이다. 시뮬레이션 환경에서 포인트 클라우드 데이터를 기반으로 경로를 계획하면, 로봇이 이동할 수 있는 공간과 장애물 간의 관계를 정확하게 분석할 수 있다.</p>
<p>경로 최적화 문제는 일반적으로 그래프 탐색 문제로 변환하여 풀린다. 포인트 클라우드 데이터를 기반으로 로봇이 이동할 수 있는 공간을 그래프로 모델링하고, 각 노드는 로봇이 이동할 수 있는 특정 지점(좌표)을 나타낸다. 경로 최적화 문제를 해결하기 위한 수학적 모델은 다음과 같다.</p>
<p>로봇의 현재 위치를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{start}}</span><script type="math/tex">\mathbf{P}_{\text{start}}</script></span>, 목표 위치를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{goal}}</span><script type="math/tex">\mathbf{P}_{\text{goal}}</script></span>라고 정의한다. 경로는 일련의 점들 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_1, \mathbf{P}_2, \dots, \mathbf{P}_n</span><script type="math/tex">\mathbf{P}_1, \mathbf{P}_2, \dots, \mathbf{P}_n</script></span>으로 구성되며, 각 점 사이의 이동 비용은 유클리디안 거리로 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{cost}(\mathbf{P}_i, \mathbf{P}_{i+1}) = \|\mathbf{P}_i - \mathbf{P}_{i+1}\|
</div>
<script type="math/tex; mode=display">
\text{cost}(\mathbf{P}_i, \mathbf{P}_{i+1}) = \|\mathbf{P}_i - \mathbf{P}_{i+1}\|
</script>
</div>
<p>경로 최적화의 목적은 총 이동 비용을 최소화하는 경로 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{opt}}</span><script type="math/tex">\mathbf{P}_{\text{opt}}</script></span>를 찾는 것이다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{\text{opt}} = \arg\min_{\mathbf{P}} \sum_{i=1}^{n-1} \text{cost}(\mathbf{P}_i, \mathbf{P}_{i+1})
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{\text{opt}} = \arg\min_{\mathbf{P}} \sum_{i=1}^{n-1} \text{cost}(\mathbf{P}_i, \mathbf{P}_{i+1})
</script>
</div>
<p>이를 위해 A* 알고리즘이나 Dijkstra 알고리즘과 같은 경로 탐색 알고리즘이 사용될 수 있다. PCL은 이러한 경로 계획 과정에서 포인트 클라우드 데이터를 기반으로 로봇의 이동 가능 공간을 계산하고, 실시간으로 경로를 업데이트하는 데 도움을 준다.</p>
<h3 id="_10">시뮬레이션에서의 메시와 포인트 클라우드의 통합</h3>
<p>시뮬레이션 환경에서 메시(Mesh)와 포인트 클라우드를 통합하는 작업은 매우 중요하다. 메시는 주로 시각화를 위해 사용되며, 포인트 클라우드는 실제 데이터를 기반으로 객체를 표현하는 데 사용된다. 두 데이터를 통합하면 시뮬레이션 환경에서 더 정밀한 객체의 모델을 생성할 수 있다.</p>
<p>메시와 포인트 클라우드의 통합은 메시의 표면 위에 포인트 클라우드를 매핑하는 과정으로 이루어진다. 이를 위해 각 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>가 메시의 표면에 가장 가까운 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span>를 찾아야 한다. 이 과정은 다음과 같은 최적화 문제로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{q}_i = \arg\min_{\mathbf{q} \in \text{Mesh}} \|\mathbf{p}_i - \mathbf{q}\|
</div>
<script type="math/tex; mode=display">
\mathbf{q}_i = \arg\min_{\mathbf{q} \in \text{Mesh}} \|\mathbf{p}_i - \mathbf{q}\|
</script>
</div>
<p>이렇게 계산된 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span>는 메시 상의 포인트로, 포인트 클라우드 데이터를 메시의 표면에 매핑하는 데 사용된다. 이 과정을 통해 시뮬레이션된 객체의 모델이 더욱 정밀하게 표현되며, 물리적 시뮬레이션이나 시각적 표현이 가능해진다.</p>
<h3 id="_11">시뮬레이션에서의 물리적 상호작용</h3>
<p>PCL을 시뮬레이션 환경에서 물리적 상호작용을 모델링하는 데 활용할 수 있다. 예를 들어, 로봇이 포인트 클라우드를 기반으로 주변 물체와의 상호작용을 시뮬레이션할 수 있다. 이러한 상호작용은 주로 충돌 감지와 물리적 힘 계산을 통해 이루어진다.</p>
<p>포인트 클라우드 상의 객체와 로봇 간의 상호작용을 모델링하기 위해, 물체의 충돌 면적과 힘의 적용 방향을 계산하는 것이 필요하다. 충돌 감지는 각 포인트 클라우드의 점들 사이의 거리를 계산하여 충돌 여부를 결정한다.</p>
<p>충돌 발생 시, 로봇이 물체에 적용하는 힘 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}</span><script type="math/tex">\mathbf{F}</script></span>는 접촉 면의 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>과 로봇의 동작 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>를 기반으로 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{F} = k \mathbf{n} \cdot \mathbf{v}
</div>
<script type="math/tex; mode=display">
\mathbf{F} = k \mathbf{n} \cdot \mathbf{v}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>는 물체의 탄성 계수를 나타내며, 충돌에 의해 발생하는 반발력을 계산하는 데 사용된다.</p>
<p>이러한 물리적 상호작용은 시뮬레이션된 로봇이 실제 환경에서 물체와 상호작용하는 방식과 매우 유사하며, PCL을 사용하여 이러한 상호작용을 정밀하게 시뮬레이션할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2402/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2402/" class="btn btn-xs btn-link">
        가상 환경에서의 포인트 클라우드 생성
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_23/2305/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_23/2305/" class="btn btn-xs btn-link">
        원격 로봇 제어를 위한 데이터 스트리밍 사례
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>