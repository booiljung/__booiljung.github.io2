<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introductions_to_pointcloud_processing_with_pcl_library/chapter_24/2402/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>가상 환경에서의 포인트 클라우드 생성 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "3D \ubaa8\ub378\uc5d0\uc11c\uc758 \uc0d8\ud50c\ub9c1 \uae30\ubc95", url: "#_top", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ubc00\ub3c4 \uc870\uc815", url: "#_1", children: [
          ]},
          {title: "\uac00\uc0c1 \ud658\uacbd\uc758 \uc2a4\uce90\ub2dd \uc2dc\ubbac\ub808\uc774\uc158", url: "#_2", children: [
              {title: "\ub808\uc774\uc800 \uc2a4\uce90\ub2dd \uc2dc\ubbac\ub808\uc774\uc158", url: "#_3" },
              {title: "RGB-D \uce74\uba54\ub77c \uc2dc\ubbac\ub808\uc774\uc158", url: "#rgb-d" },
          ]},
          {title: "\uba40\ud2f0\ubdf0 \uc2a4\uce90\ub2dd \ubc0f \ub370\uc774\ud130 \ud1b5\ud569", url: "#_4", children: [
              {title: "\uc88c\ud45c \ubcc0\ud658\uc744 \ud1b5\ud55c \ub370\uc774\ud130 \uc815\ub82c", url: "#_5" },
              {title: "ICP \uc54c\uace0\ub9ac\uc998\uc744 \uc774\uc6a9\ud55c \uc815\ud569", url: "#icp" },
          ]},
          {title: "\uac00\uc0c1 \ud658\uacbd\uc5d0\uc11c\uc758 \ub178\uc774\uc988 \ubaa8\ub378\ub9c1", url: "#_6", children: [
              {title: "\uac70\ub9ac \uae30\ubc18 \ub178\uc774\uc988", url: "#_7" },
              {title: "\uac10\uc9c0 \ubd88\uac00 \uc601\uc5ed\uacfc \ub178\uc774\uc988", url: "#_8" },
          ]},
          {title: "\ud14d\uc2a4\ucc98\uc640 \uceec\ub7ec \uc815\ubcf4\uc758 \ucd94\uac00", url: "#_9", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ud574\uc0c1\ub3c4 \uc870\uc808", url: "#_10", children: [
              {title: "\ub2e4\uc6b4\uc0d8\ud50c\ub9c1", url: "#_11" },
              {title: "\uc5c5\uc0d8\ud50c\ub9c1", url: "#_12" },
          ]},
          {title: "\uc9c0\uc624\uba54\ud2b8\ub9ac \ubcf4\uc874\uacfc \uc65c\uace1", url: "#_13", children: [
              {title: "\uace1\ub960 \uae30\ubc18 \uc815\uaddc\ud654", url: "#_14" },
              {title: "\uc810\uac04 \uac70\ub9ac \ubcf4\uc815", url: "#_15" },
          ]},
          {title: "\uba40\ud2f0 \uc2a4\uce90\ub108 \ud658\uacbd\uc5d0\uc11c\uc758 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc0dd\uc131", url: "#_16", children: [
              {title: "\uc2a4\uce90\ub108\ubcc4 \ub370\uc774\ud130 \uc815\ud569", url: "#_17" },
              {title: "\ub178\uc774\uc988 \ubaa8\ub378\ub9c1\uacfc \uc2a4\uce90\ub108 \ud2b9\uc131", url: "#_18" },
          ]},
          {title: "\uac00\uc0c1 \uc13c\uc11c \ud30c\ub77c\ubbf8\ud130 \uc124\uc815", url: "#_19", children: [
              {title: "\uc2a4\uce94 \ud574\uc0c1\ub3c4", url: "#_20" },
              {title: "\uc2dc\uc57c\uac01\uacfc \uac10\uc9c0 \ubc94\uc704", url: "#_21" },
          ]},
          {title: "\ubb3c\uccb4 \ud45c\uba74 \ud2b9\uc131\uc758 \uc2dc\ubbac\ub808\uc774\uc158", url: "#_22", children: [
              {title: "\ud45c\uba74 \ubc18\uc0ac\uc728", url: "#_23" },
              {title: "\ud45c\uba74 \uac70\uce60\uae30", url: "#_24" },
              {title: "\ubc18\ud22c\uba85 \ubc0f \ud22c\uacfc\uc131", url: "#_25" },
          ]},
          {title: "\uac00\uc0c1 \ud658\uacbd\uc5d0\uc11c\uc758 \uc13c\uc11c \ubc30\uc5f4", url: "#_26", children: [
              {title: "\uba40\ud2f0 \uc13c\uc11c \ubc30\uc5f4", url: "#_27" },
              {title: "\uc2dc\ubbac\ub808\uc774\uc158\uc758 \uc2dc\uac04\uc801 \uc694\uc18c", url: "#_28" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2403/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2403/" class="btn btn-xs btn-link">
        로봇 시뮬레이션과 센서 데이터 활용
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2401/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2401/" class="btn btn-xs btn-link">
        시뮬레이션 환경에서의 PCL 활용
      </a>
    </div>
    
  </div>

    

    <p>가상 환경에서의 포인트 클라우드 생성은 다양한 시뮬레이션에서 필수적인 요소이다. 이를 통해 실제 환경을 재현하거나 특정 작업에 대한 가상 실험을 수행할 수 있다. 이러한 생성 과정은 주로 가상의 3D 모델을 기반으로 이루어지며, 이를 포인트 클라우드 형식으로 변환하는 여러 가지 기법이 존재한다.</p>
<h3 id="3d">3D 모델에서의 샘플링 기법</h3>
<p>가상 환경에서 포인트 클라우드를 생성하려면 먼저 3D 모델을 정의해야 한다. 이 모델은 주로 다각형 메시 형태로 표현되며, 포인트 클라우드는 이 메시 상에서 샘플링하여 생성된다. 샘플링 방법에는 여러 가지가 있으며, 이 중에서 대표적인 방법은 다음과 같다.</p>
<ol>
<li><strong>균등 샘플링</strong>: 메시의 각 면에서 일정한 밀도로 점을 추출하는 방법이다. 이를 통해 생성된 포인트 클라우드는 메시의 각 면이 동일한 밀도로 표현되며, 특정 부분에 집중되지 않는다. 이를 수식으로 표현하면, 면적을 기반으로 한 균등 샘플링은 다음과 같이 정의된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p_i} = \mathbf{v_1} + \alpha (\mathbf{v_2} - \mathbf{v_1}) + \beta (\mathbf{v_3} - \mathbf{v_1}) \quad \text{where} \quad 0 \leq \alpha, \beta \leq 1 \text{ and } \alpha + \beta \leq 1
</div>
<script type="math/tex; mode=display">
\mathbf{p_i} = \mathbf{v_1} + \alpha (\mathbf{v_2} - \mathbf{v_1}) + \beta (\mathbf{v_3} - \mathbf{v_1}) \quad \text{where} \quad 0 \leq \alpha, \beta \leq 1 \text{ and } \alpha + \beta \leq 1
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v_1}, \mathbf{v_2}, \mathbf{v_3}</span><script type="math/tex">\mathbf{v_1}, \mathbf{v_2}, \mathbf{v_3}</script></span>는 삼각형 메시의 꼭짓점이며, <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span>는 임의의 샘플링 비율이다.</p>
<ol>
<li>
<p><strong>랜덤 샘플링</strong>: 메시 상의 임의의 점을 무작위로 선택하는 방식이다. 이를 통해 포인트 클라우드를 생성하면, 데이터가 비균등하게 분포될 수 있지만, 특정 영역에서의 밀도를 조정하는 데 유리할 수 있다.</p>
</li>
<li>
<p><strong>중심점 샘플링</strong>: 각 메시 면의 중심점에서 포인트를 추출하는 방식이다. 이 방법은 단순하고 계산량이 적지만, 포인트 클라우드가 다각형의 구조를 그대로 반영하므로 자연스러운 곡선형 구조를 표현하기 어려울 수 있다.</p>
</li>
</ol>
<h3 id="_1">포인트 밀도 조정</h3>
<p>포인트 클라우드를 생성할 때, 각 영역의 포인트 밀도는 중요한 요소이다. 가상 환경에서의 포인트 밀도는 주로 메시의 기하학적 특성과 관련이 있으며, 다음과 같은 방법으로 밀도를 조절할 수 있다.</p>
<ol>
<li><strong>면적 가중 샘플링</strong>: 메시 면적이 클수록 더 많은 포인트를 할당하는 방식이다. 이를 통해 넓은 면적은 더 세밀하게 표현되고, 좁은 면적은 포인트 개수를 줄여 효율성을 높일 수 있다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
N_{\text{points}} = k \times A_{\text{face}}
</div>
<script type="math/tex; mode=display">
N_{\text{points}} = k \times A_{\text{face}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">A_{\text{face}}</span><script type="math/tex">A_{\text{face}}</script></span>는 메시 면적이고, <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>는 밀도 조절 상수이다.</p>
<ol>
<li><strong>곡률 기반 샘플링</strong>: 메시의 곡률이 높은 부분에 더 많은 포인트를 할당하는 방식이다. 이를 통해 복잡한 지형이나 곡선 부분이 더 정확하게 표현될 수 있다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
N_{\text{points}} = k \times C_{\text{curvature}}
</div>
<script type="math/tex; mode=display">
N_{\text{points}} = k \times C_{\text{curvature}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">C_{\text{curvature}}</span><script type="math/tex">C_{\text{curvature}}</script></span>는 해당 면의 곡률 값이다.</p>
<h3 id="_2">가상 환경의 스캐닝 시뮬레이션</h3>
<p>가상 환경에서 포인트 클라우드를 생성하는 또 다른 방법은 실제 스캐닝 프로세스를 시뮬레이션하는 것이다. 이는 주로 레이저 스캐너나 RGB-D 카메라 등의 센서를 가상 환경에 배치하여 이루어진다. 스캐너의 위치와 각도, 스캔 해상도 등의 파라미터를 설정하여 가상의 센서가 환경을 스캔하도록 시뮬레이션할 수 있다.</p>
<h4 id="_3">레이저 스캐닝 시뮬레이션</h4>
<p>가상의 레이저 스캐너는 설정된 각도 범위와 거리 내에서 레이저 빔을 방출하고, 각 빔이 물체에 닿는 지점에서 포인트를 생성한다. 이를 수식으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p} = \mathbf{o} + d \cdot \mathbf{\hat{r}}
</div>
<script type="math/tex; mode=display">
\mathbf{p} = \mathbf{o} + d \cdot \mathbf{\hat{r}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 스캔된 포인트의 좌표, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{o}</span><script type="math/tex">\mathbf{o}</script></span>는 스캐너의 원점, <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>는 측정된 거리, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\hat{r}}</span><script type="math/tex">\mathbf{\hat{r}}</script></span>는 레이저 빔의 방향 벡터이다.</p>
<p>이 방식은 실제 스캐너의 작동 방식을 모사하기 때문에, 스캐너의 해상도, 노이즈, 감지 불가 영역(dead zone) 등을 함께 시뮬레이션할 수 있다는 장점이 있다.</p>
<h4 id="rgb-d">RGB-D 카메라 시뮬레이션</h4>
<p>RGB-D 카메라는 깊이 정보와 컬러 정보를 함께 제공하는 장치로, 가상 환경에서 이 장치를 시뮬레이션하여 포인트 클라우드를 생성할 수 있다. 깊이 정보는 카메라의 투영 모델을 기반으로 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p} = \mathbf{K}^{-1} \cdot \mathbf{d}
</div>
<script type="math/tex; mode=display">
\mathbf{p} = \mathbf{K}^{-1} \cdot \mathbf{d}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>는 카메라의 내적 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span>는 깊이 정보이며, 이를 통해 각 픽셀에 대응하는 3D 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>를 계산한다.</p>
<h3 id="_4">멀티뷰 스캐닝 및 데이터 통합</h3>
<p>가상 환경에서 포인트 클라우드를 생성하는 또 다른 중요한 방법은 다중 뷰에서의 스캐닝과 데이터 통합 기법이다. 단일 뷰에서 얻어진 포인트 클라우드는 보통 환경의 일부분만을 포함하므로, 여러 각도에서 스캔하여 전체 환경을 복원하는 방식이 많이 사용된다. 이를 위해서는 각 스캔 데이터를 하나의 포인트 클라우드로 통합하는 과정이 필요하다.</p>
<h4 id="_5">좌표 변환을 통한 데이터 정렬</h4>
<p>다중 뷰에서 스캔된 포인트 클라우드를 정렬하려면 각 스캔이 이루어진 위치와 방향을 기준으로 좌표 변환을 적용해야 한다. 스캐너의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>와 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>을 이용하여 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_i}</span><script type="math/tex">\mathbf{p_i}</script></span>를 변환하는 방식은 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p'_i} = \mathbf{R} \cdot \mathbf{p_i} + \mathbf{t}
</div>
<script type="math/tex; mode=display">
\mathbf{p'_i} = \mathbf{R} \cdot \mathbf{p_i} + \mathbf{t}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_i}</span><script type="math/tex">\mathbf{p_i}</script></span>는 원래 좌표계에서의 포인트 위치, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p'_i}</span><script type="math/tex">\mathbf{p'_i}</script></span>는 변환된 좌표계에서의 위치이다. 이러한 변환을 모든 스캔 데이터에 적용하면, 서로 다른 뷰에서 얻어진 포인트 클라우드 데이터를 하나의 통합된 좌표계로 정렬할 수 있다.</p>
<h4 id="icp">ICP 알고리즘을 이용한 정합</h4>
<p>좌표 변환을 통해 대략적인 정렬이 이루어졌다면, 보다 정밀한 정합을 위해 ICP(Iterative Closest Point) 알고리즘을 사용할 수 있다. 이 알고리즘은 두 포인트 클라우드 간의 대응점을 찾아내고, 이를 바탕으로 정밀한 변환 행렬을 계산하는 방식이다. ICP 알고리즘의 기본 과정은 다음과 같다.</p>
<ol>
<li>
<p>두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>에서 각 포인트 쌍 <span class="arithmatex"><span class="MathJax_Preview">(\mathbf{p}, \mathbf{q})</span><script type="math/tex">(\mathbf{p}, \mathbf{q})</script></span>를 대응시킨다. 이때, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p} \in \mathbf{P}</span><script type="math/tex">\mathbf{p} \in \mathbf{P}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>에서 가장 가까운 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q} \in \mathbf{Q}</span><script type="math/tex">\mathbf{q} \in \mathbf{Q}</script></span>와 짝지어진다.</p>
</li>
<li>
<p>각 대응점 쌍에 대해 변환 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T} = [\mathbf{R}, \mathbf{t}]</span><script type="math/tex">\mathbf{T} = [\mathbf{R}, \mathbf{t}]</script></span>을 계산하여 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>에 정렬시킨다. 변환 행렬은 최소 제곱 오차를 줄이도록 계산된다.</p>
</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i} \lVert \mathbf{R} \cdot \mathbf{p_i} + \mathbf{t} - \mathbf{q_i} \rVert^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i} \lVert \mathbf{R} \cdot \mathbf{p_i} + \mathbf{t} - \mathbf{q_i} \rVert^2
</script>
</div>
<ol>
<li>이 과정을 반복하여 오차가 수렴할 때까지 변환을 반복한다.</li>
</ol>
<p>ICP 알고리즘은 간단하면서도 강력한 방법이지만, 초기 정렬 상태에 따라 수렴 속도와 결과의 품질이 달라질 수 있다. 따라서 초기에 대략적인 정렬이 잘 이루어져 있어야 효과적으로 동작한다.</p>
<h3 id="_6">가상 환경에서의 노이즈 모델링</h3>
<p>실제 스캐너에서는 다양한 형태의 노이즈가 발생할 수 있으며, 가상 환경에서 이를 시뮬레이션하는 것도 중요하다. 노이즈 모델링은 포인트 클라우드의 현실성을 높여주고, 다양한 환경에서 알고리즘의 성능을 평가할 수 있는 중요한 요소가 된다.</p>
<h4 id="_7">거리 기반 노이즈</h4>
<p>레이저 스캐너나 RGB-D 카메라 등의 센서는 거리에 따라 노이즈가 증가하는 경향이 있다. 일반적으로 거리가 멀어질수록 노이즈의 크기가 커지며, 이를 수학적으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p'} = \mathbf{p} + \mathbf{n}(d)
</div>
<script type="math/tex; mode=display">
\mathbf{p'} = \mathbf{p} + \mathbf{n}(d)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}(d)</span><script type="math/tex">\mathbf{n}(d)</script></span>는 거리 <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>에 비례하는 노이즈 값이다. 이 노이즈는 보통 정규분포를 따르며, 분산 <span class="arithmatex"><span class="MathJax_Preview">\sigma^2</span><script type="math/tex">\sigma^2</script></span>는 거리 <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>에 비례하여 증가하는 형태로 설정된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\sigma^2 = \sigma_0^2 + k \cdot d
</div>
<script type="math/tex; mode=display">
\sigma^2 = \sigma_0^2 + k \cdot d
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\sigma_0</span><script type="math/tex">\sigma_0</script></span>는 기준 노이즈, <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>는 거리에 따른 노이즈 증가 계수이다.</p>
<h4 id="_8">감지 불가 영역과 노이즈</h4>
<p>실제 센서에는 감지 불가 영역, 즉 스캔이 불가능한 영역이 존재한다. 가상 환경에서 이를 시뮬레이션하기 위해서는 특정 각도나 거리 범위 내에서 포인트가 생성되지 않도록 설정할 수 있다. 예를 들어, 특정 각도 범위 <span class="arithmatex"><span class="MathJax_Preview">\theta_{\text{min}} \leq \theta \leq \theta_{\text{max}}</span><script type="math/tex">\theta_{\text{min}} \leq \theta \leq \theta_{\text{max}}</script></span>에서 포인트 생성을 차단하는 방식이다.</p>
<p>또한, 물체의 재질이나 표면 반사율에 따라 일부 영역에서 포인트가 왜곡되거나 누락될 수 있으며, 이를 재현하는 노이즈 모델도 포함할 수 있다.</p>
<h3 id="_9">텍스처와 컬러 정보의 추가</h3>
<p>가상 환경에서 생성된 포인트 클라우드는 깊이 정보만이 아니라, 컬러나 텍스처 정보를 포함할 수 있다. 이는 주로 RGB-D 카메라의 시뮬레이션을 통해 얻어지며, 각 포인트에 대응하는 컬러 값을 추가하는 방식으로 처리된다. 텍스처 맵핑은 3D 모델에서 각 포인트가 매핑되는 2D 텍스처 좌표를 계산하여 이루어진다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{c} = \mathbf{T_{uv}}(\mathbf{p})
</div>
<script type="math/tex; mode=display">
\mathbf{c} = \mathbf{T_{uv}}(\mathbf{p})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T_{uv}}</span><script type="math/tex">\mathbf{T_{uv}}</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>에 대응하는 텍스처 좌표 <span class="arithmatex"><span class="MathJax_Preview">(u, v)</span><script type="math/tex">(u, v)</script></span>를 계산하는 함수이다. 이를 통해 가상 환경에서 생성된 포인트 클라우드에 시각적 정보를 더할 수 있다.</p>
<h3 id="_10">포인트 클라우드 해상도 조절</h3>
<p>가상 환경에서 생성된 포인트 클라우드의 해상도는 주로 포인트 간의 간격이나 밀도에 의해 결정된다. 포인트 클라우드 해상도는 다양한 용도로 조절될 수 있으며, 이를 통해 효율적인 데이터 처리를 위한 전략을 설계할 수 있다. 해상도를 조절하는 방법에는 다음과 같은 기법들이 있다.</p>
<h4 id="_11">다운샘플링</h4>
<p>포인트 클라우드의 해상도를 줄이는 대표적인 방법 중 하나는 다운샘플링이다. 다운샘플링은 포인트 클라우드의 전체 포인트 개수를 줄여 데이터의 크기를 줄이는 기법이다. 이를 수행하는 방법 중 하나는 Voxel Grid 필터를 사용하는 것이다. 이 기법은 3D 공간을 작은 격자로 나누고, 각 격자 내에서 하나의 대표 포인트를 선택하는 방식으로 작동한다.</p>
<p>Voxel Grid 필터의 과정은 다음과 같다:</p>
<ol>
<li>3D 공간을 크기 <span class="arithmatex"><span class="MathJax_Preview">l_x \times l_y \times l_z</span><script type="math/tex">l_x \times l_y \times l_z</script></span>인 Voxel로 나눈다.</li>
<li>각 Voxel 내의 포인트를 하나의 대표 포인트로 대체한다. 이 대표 포인트는 보통 Voxel 내 포인트들의 평균값으로 결정된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p_{\text{avg}}} = \frac{1}{n} \sum_{i=1}^{n} \mathbf{p_i}
</div>
<script type="math/tex; mode=display">
\mathbf{p_{\text{avg}}} = \frac{1}{n} \sum_{i=1}^{n} \mathbf{p_i}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>은 해당 Voxel에 속한 포인트의 개수, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_i}</span><script type="math/tex">\mathbf{p_i}</script></span>는 각 포인트의 좌표이다.</p>
<p>다운샘플링은 데이터의 크기를 대폭 줄일 수 있지만, 세밀한 정보를 잃을 가능성이 크기 때문에 사용 목적에 따라 적절한 Voxel 크기를 선택하는 것이 중요하다.</p>
<h4 id="_12">업샘플링</h4>
<p>다운샘플링과 반대로, 업샘플링은 포인트 클라우드의 해상도를 증가시키는 방법이다. 업샘플링은 특히 낮은 해상도의 데이터에 세밀한 정보를 추가할 때 사용된다. 업샘플링의 대표적인 방법 중 하나는 Moving Least Squares (MLS) 알고리즘이다.</p>
<p>MLS 알고리즘은 주어진 포인트 클라우드의 곡면을 추정하고, 그 곡면에 추가적인 포인트를 생성하는 방식으로 동작한다. 이 알고리즘의 과정은 다음과 같다:</p>
<ol>
<li>각 포인트에 대해 로컬 곡면을 추정한다.</li>
<li>그 곡면에 따라 추가적인 포인트를 생성한다.</li>
</ol>
<p>MLS는 포인트 클라우드의 곡면 특성을 보존하면서 해상도를 높이는 데 적합하다. 다만, 추가된 포인트는 원래 포인트 클라우드의 분포에 기반하기 때문에, 새로운 세부 정보를 완전히 생성하지는 않는다.</p>
<h3 id="_13">지오메트리 보존과 왜곡</h3>
<p>가상 환경에서 포인트 클라우드를 생성할 때, 중요한 요소는 지오메트리의 정확한 보존이다. 포인트 클라우드 생성 과정에서 발생할 수 있는 왜곡은 시뮬레이션의 신뢰성을 떨어뜨릴 수 있다. 이를 방지하기 위한 몇 가지 기법은 다음과 같다.</p>
<h4 id="_14">곡률 기반 정규화</h4>
<p>포인트 클라우드에서 곡률이 높은 부분은 보통 더 많은 세부 정보가 필요하다. 곡률 기반 정규화는 이러한 곡면 정보를 보존하는 방법으로, 포인트 밀도를 조절하여 곡률이 높은 부분에 더 많은 포인트를 할당하는 방식이다. 곡률 <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>는 국소적인 곡면에서 계산되며, 포인트 밀도 <span class="arithmatex"><span class="MathJax_Preview">N_{\text{points}}</span><script type="math/tex">N_{\text{points}}</script></span>는 곡률에 따라 조절된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
N_{\text{points}} = f(C)
</div>
<script type="math/tex; mode=display">
N_{\text{points}} = f(C)
</script>
</div>
<p>곡률 기반 정규화는 메시의 구조를 보존하면서 포인트 클라우드를 생성할 수 있게 해주며, 중요한 부분에 더 많은 포인트를 할당할 수 있는 장점이 있다.</p>
<h4 id="_15">점간 거리 보정</h4>
<p>포인트 클라우드를 생성할 때, 특히 다운샘플링 과정에서 포인트 간의 거리가 불균등하게 변할 수 있다. 이를 방지하기 위해서는 포인트 간의 거리를 일정하게 유지하도록 보정하는 기법이 필요하다. 이를 위해 공간 내 포인트 간의 평균 거리를 계산하고, 해당 거리 기준으로 새로운 포인트를 배치한다.</p>
<p>이 방식은 전체 포인트 클라우드의 밀도를 균등하게 만들 수 있어, 후속 처리나 분석에서 더 나은 결과를 도출할 수 있다.</p>
<h3 id="_16">멀티 스캐너 환경에서의 포인트 클라우드 생성</h3>
<p>가상 환경에서 다양한 스캐너를 사용하여 포인트 클라우드를 생성하는 경우, 각 스캐너의 특성을 고려한 생성 과정이 필요하다. 레이저 스캐너, RGB-D 카메라, 그리고 기타 3D 센서들은 각기 다른 해상도, 시야각, 감지 방식 등을 가지고 있다. 이러한 특성을 반영하여 여러 스캐너의 데이터를 하나의 포인트 클라우드로 통합하는 방법은 매우 중요하다.</p>
<h4 id="_17">스캐너별 데이터 정합</h4>
<p>다중 스캐너 환경에서는 각 스캐너에서 얻은 포인트 클라우드가 서로 다른 좌표계에 있을 가능성이 크다. 이를 하나의 좌표계로 통합하려면 각 스캐너의 위치와 방향 정보를 사용하여 정밀한 정합 작업이 필요하다. 스캐너의 위치를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t_s}</span><script type="math/tex">\mathbf{t_s}</script></span>, 방향을 나타내는 회전 행렬을 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R_s}</span><script type="math/tex">\mathbf{R_s}</script></span>라 할 때, 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_s}</span><script type="math/tex">\mathbf{p_s}</script></span>는 다음과 같이 변환된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p_s'} = \mathbf{R_s} \cdot \mathbf{p_s} + \mathbf{t_s}
</div>
<script type="math/tex; mode=display">
\mathbf{p_s'} = \mathbf{R_s} \cdot \mathbf{p_s} + \mathbf{t_s}
</script>
</div>
<p>이러한 방식으로 각 스캐너의 데이터를 동일한 좌표계로 변환한 후, 데이터 통합이 이루어진다.</p>
<h4 id="_18">노이즈 모델링과 스캐너 특성</h4>
<p>각 스캐너의 특성에 따라 발생하는 노이즈가 다를 수 있으며, 이를 고려한 포인트 클라우드 생성이 필요하다. 예를 들어, 레이저 스캐너는 주로 거리 기반 노이즈가 발생하지만, RGB-D 카메라는 깊이 센서의 해상도에 따라 노이즈가 발생한다. 이러한 각기 다른 노이즈 특성을 가상 환경에서 반영하는 것은 현실적인 데이터를 생성하는 데 매우 중요하다.</p>
<h3 id="_19">가상 센서 파라미터 설정</h3>
<p>가상 환경에서 포인트 클라우드를 생성할 때, 사용되는 센서의 파라미터는 포인트 클라우드의 품질과 성능에 중요한 영향을 미친다. 센서의 설정은 일반적으로 다음과 같은 파라미터로 구성된다.</p>
<h4 id="_20">스캔 해상도</h4>
<p>스캔 해상도는 센서가 포인트 클라우드를 생성할 때 측정하는 각 지점의 간격을 결정한다. 높은 해상도는 보다 정밀한 포인트 클라우드를 생성하지만, 그만큼 데이터의 양이 커지고 처리 시간이 길어진다. 반대로 낮은 해상도는 적은 데이터로 빠른 처리 속도를 얻을 수 있지만, 세밀한 정보가 손실될 수 있다.</p>
<p>스캔 해상도는 주로 각도 해상도(angular resolution)와 거리 해상도(range resolution)로 나뉘며, 각기 다른 방식으로 설정된다.</p>
<ol>
<li><strong>각도 해상도</strong>: 스캐너가 회전하는 각도의 간격을 나타낸다. 각도 해상도가 높을수록 스캔된 포인트가 촘촘하게 배열된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\Delta \theta = \frac{\theta_{\text{max}} - \theta_{\text{min}}}{N_{\text{points}}}
</div>
<script type="math/tex; mode=display">
\Delta \theta = \frac{\theta_{\text{max}} - \theta_{\text{min}}}{N_{\text{points}}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\theta_{\text{max}}</span><script type="math/tex">\theta_{\text{max}}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\theta_{\text{min}}</span><script type="math/tex">\theta_{\text{min}}</script></span>는 스캐너의 최대 및 최소 각도, <span class="arithmatex"><span class="MathJax_Preview">N_{\text{points}}</span><script type="math/tex">N_{\text{points}}</script></span>는 스캔된 포인트의 수이다.</p>
<ol>
<li><strong>거리 해상도</strong>: 스캐너가 측정할 수 있는 거리의 최소 단위를 의미하며, 이는 포인트 간의 거리를 결정한다. 거리 해상도가 높을수록 포인트 클라우드의 세밀도가 증가한다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\Delta d = \frac{d_{\text{max}} - d_{\text{min}}}{N_{\text{distance}}}
</div>
<script type="math/tex; mode=display">
\Delta d = \frac{d_{\text{max}} - d_{\text{min}}}{N_{\text{distance}}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{max}}</span><script type="math/tex">d_{\text{max}}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{min}}</span><script type="math/tex">d_{\text{min}}</script></span>은 최대 및 최소 거리, <span class="arithmatex"><span class="MathJax_Preview">N_{\text{distance}}</span><script type="math/tex">N_{\text{distance}}</script></span>는 거리 해상도에 따른 샘플 수이다.</p>
<h4 id="_21">시야각과 감지 범위</h4>
<p>가상의 스캐너는 특정 시야각과 감지 범위를 가진다. 시야각(field of view, FOV)은 스캐너가 한 번에 감지할 수 있는 각도의 범위를 나타내며, 감지 범위는 센서가 감지할 수 있는 최소 및 최대 거리를 의미한다. 이러한 파라미터는 센서의 물리적 한계를 모델링하는 데 사용되며, 포인트 클라우드의 공간적 범위를 결정짓는다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{FOV} = \left( \theta_{\text{FOV}}, \phi_{\text{FOV}} \right)
</div>
<script type="math/tex; mode=display">
\mathbf{FOV} = \left( \theta_{\text{FOV}}, \phi_{\text{FOV}} \right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\theta_{\text{FOV}}</span><script type="math/tex">\theta_{\text{FOV}}</script></span>는 수평 시야각, <span class="arithmatex"><span class="MathJax_Preview">\phi_{\text{FOV}}</span><script type="math/tex">\phi_{\text{FOV}}</script></span>는 수직 시야각을 나타낸다.</p>
<h3 id="_22">물체 표면 특성의 시뮬레이션</h3>
<p>가상 환경에서 포인트 클라우드를 생성할 때, 물체의 표면 특성은 센서가 어떻게 데이터를 수집하는지에 큰 영향을 미친다. 특히 표면의 반사율, 거칠기, 투과성 등의 특성은 실제 환경에서 스캐닝할 때 노이즈의 원인이 될 수 있으며, 이를 시뮬레이션하는 것은 매우 중요하다.</p>
<h4 id="_23">표면 반사율</h4>
<p>포인트 클라우드 생성 시, 표면 반사율(reflectivity)은 레이저나 빛이 어떻게 반사되는지를 결정하는 주요 요소이다. 예를 들어, 반사율이 높은 표면은 명확한 포인트 데이터를 생성하지만, 반사율이 낮은 표면에서는 데이터가 불완전하거나 노이즈가 발생할 수 있다.</p>
<p>반사율을 <span class="arithmatex"><span class="MathJax_Preview">\rho</span><script type="math/tex">\rho</script></span>로 나타낼 때, 반사율에 따라 수집된 포인트의 품질은 다음과 같이 모델링할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p_{\text{measured}}} = \rho \cdot \mathbf{p} + (1 - \rho) \cdot \mathbf{n}
</div>
<script type="math/tex; mode=display">
\mathbf{p_{\text{measured}}} = \rho \cdot \mathbf{p} + (1 - \rho) \cdot \mathbf{n}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_{\text{measured}}}</span><script type="math/tex">\mathbf{p_{\text{measured}}}</script></span>는 측정된 포인트 좌표, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 실제 좌표, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>은 노이즈 성분이다.</p>
<h4 id="_24">표면 거칠기</h4>
<p>표면 거칠기(surface roughness)는 포인트 클라우드에서 얻어지는 데이터의 분산에 영향을 미친다. 표면이 매끄러울수록 포인트가 균일하게 측정되지만, 거칠면 표면의 높낮이에 따라 포인트 간 거리가 달라질 수 있다. 이를 수식으로 표현하면, 표면 거칠기 <span class="arithmatex"><span class="MathJax_Preview">R_s</span><script type="math/tex">R_s</script></span>는 포인트의 위치 변화량으로 모델링된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p_{\text{measured}}} = \mathbf{p} + \mathbf{R_s}(x, y)
</div>
<script type="math/tex; mode=display">
\mathbf{p_{\text{measured}}} = \mathbf{p} + \mathbf{R_s}(x, y)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R_s}(x, y)</span><script type="math/tex">\mathbf{R_s}(x, y)</script></span>는 표면의 위치 <span class="arithmatex"><span class="MathJax_Preview">x, y</span><script type="math/tex">x, y</script></span>에 따른 거칠기 함수이다.</p>
<h4 id="_25">반투명 및 투과성</h4>
<p>반투명 또는 투과성 물질은 포인트 클라우드 생성에 있어 복잡한 문제를 일으킬 수 있다. 레이저 스캐너나 RGB-D 카메라의 경우, 빛이나 레이저가 투과하거나 굴절하여 잘못된 데이터를 생성할 수 있다. 이를 시뮬레이션하려면 투과성 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>를 포함한 모델을 적용할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p_{\text{measured}}} = T \cdot \mathbf{p} + (1 - T) \cdot \mathbf{n}
</div>
<script type="math/tex; mode=display">
\mathbf{p_{\text{measured}}} = T \cdot \mathbf{p} + (1 - T) \cdot \mathbf{n}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 투과성 계수이며, 투과성이 높을수록 포인트 데이터에 왜곡이 발생할 확률이 커진다.</p>
<h3 id="_26">가상 환경에서의 센서 배열</h3>
<p>가상 환경에서 복잡한 포인트 클라우드를 생성하기 위해서는 여러 센서를 배치하여 다양한 각도에서 데이터를 수집할 수 있다. 이를 통해 단일 센서로는 얻을 수 없는 복잡한 형상이나 구조를 복원할 수 있다. 센서 배열의 주요 요소는 다음과 같다.</p>
<h4 id="_27">멀티 센서 배열</h4>
<p>멀티 센서 배열은 여러 대의 센서를 서로 다른 위치에 배치하여 동시에 데이터를 수집하는 방식이다. 각 센서가 서로 다른 시점에서 포인트를 수집하므로, 복잡한 구조물이나 환경을 보다 정확하게 복원할 수 있다. 멀티 센서 배열을 수학적으로 표현하면, 각 센서의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t_i}</span><script type="math/tex">\mathbf{t_i}</script></span>와 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R_i}</span><script type="math/tex">\mathbf{R_i}</script></span>에 따라 각기 다른 좌표 변환을 적용해야 한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p'_i} = \mathbf{R_i} \cdot \mathbf{p_i} + \mathbf{t_i}
</div>
<script type="math/tex; mode=display">
\mathbf{p'_i} = \mathbf{R_i} \cdot \mathbf{p_i} + \mathbf{t_i}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p'_i}</span><script type="math/tex">\mathbf{p'_i}</script></span>는 센서 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>에서 수집된 포인트 클라우드의 변환된 좌표이다.</p>
<h4 id="_28">시뮬레이션의 시간적 요소</h4>
<p>실제 환경에서는 센서가 고정된 상태에서 연속적으로 데이터를 수집하지 않으며, 시간에 따라 센서가 움직이거나 환경이 변화할 수 있다. 이를 시뮬레이션하려면 시간에 따른 동적 변화 요소를 반영해야 한다. 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에 따른 센서 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}(t)</span><script type="math/tex">\mathbf{t}(t)</script></span>와 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}(t)</span><script type="math/tex">\mathbf{R}(t)</script></span>를 이용하여 시간에 따라 변화하는 포인트 클라우드를 생성할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p'(t)} = \mathbf{R}(t) \cdot \mathbf{p} + \mathbf{t}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{p'(t)} = \mathbf{R}(t) \cdot \mathbf{p} + \mathbf{t}(t)
</script>
</div>
<p>이 방식은 로봇이나 드론과 같은 이동하는 플랫폼에서의 포인트 클라우드 생성 시 매우 유용하다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2403/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2403/" class="btn btn-xs btn-link">
        로봇 시뮬레이션과 센서 데이터 활용
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2401/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2401/" class="btn btn-xs btn-link">
        시뮬레이션 환경에서의 PCL 활용
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>