<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introductions_to_pointcloud_processing_with_pcl_library/chapter_23/2305/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>원격 로봇 제어를 위한 데이터 스트리밍 사례 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ub124\ud2b8\uc6cc\ud06c \uc9c0\uc5f0 \ubc0f \ub300\uc5ed\ud3ed \uad00\ub9ac", url: "#_top", children: [
          ]},
          {title: "\ub370\uc774\ud130 \uc555\ucd95\uacfc \uc804\uc1a1 \ud6a8\uc728", url: "#_2", children: [
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ub3d9\uae30\ud654", url: "#_3", children: [
          ]},
          {title: "\ub370\uc774\ud130 \uc190\uc2e4 \ubcf5\uad6c \ubc0f \uc5d0\ub7ec \ucc98\ub9ac", url: "#_4", children: [
          ]},
          {title: "\uc2a4\ud2b8\ub9ac\ubc0d \uc555\ucd95 \uae30\ubc95\uc758 \ud65c\uc6a9", url: "#_5", children: [
          ]},
          {title: "\uc2a4\ud2b8\ub9ac\ubc0d\uc744 \ud1b5\ud55c \ub85c\ubd07 \uacbd\ub85c \uacc4\ud68d", url: "#_6", children: [
          ]},
          {title: "\uc6d0\uaca9 \uc81c\uc5b4 \uc2dc\uc2a4\ud15c\uc5d0\uc11c\uc758 \ub370\uc774\ud130 \uc6b0\uc120 \uc21c\uc704", url: "#_7", children: [
          ]},
          {title: "\ub370\uc774\ud130 \ud328\ud0b7 \ubd84\ud560\uacfc \uc7ac\uc870\ub9bd", url: "#_8", children: [
          ]},
          {title: "\ub370\uc774\ud130 \ud328\ud0b7 \uc804\uc1a1\uc5d0\uc11c\uc758 QoS (Quality of Service) \uc801\uc6a9", url: "#qos-quality-of-service", children: [
          ]},
          {title: "\ub370\uc774\ud130 \uc2a4\ud2b8\ub9ac\ubc0d\uc5d0\uc11c\uc758 \uc555\ucd95-\ubcf5\uc6d0 \uc54c\uace0\ub9ac\uc998 \uc801\uc6a9", url: "#-", children: [
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ucc98\ub9ac \ubc0f \ud53c\ub4dc\ubc31 \uc2dc\uc2a4\ud15c", url: "#_9", children: [
          ]},
          {title: "\uc9c0\ub2a5\ud615 \uc54c\uace0\ub9ac\uc998\uacfc \uc6d0\uaca9 \uc81c\uc5b4\uc758 \uacb0\ud569", url: "#_10", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_24/2401/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_24/2401/" class="btn btn-xs btn-link">
        시뮬레이션 환경에서의 PCL 활용
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2304/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2304/" class="btn btn-xs btn-link">
        스트리밍 환경에서의 실시간 처리 방법
      </a>
    </div>
    
  </div>

    

    <p>원격 로봇 제어에서 포인트 클라우드 데이터를 스트리밍하는 것은 로봇이 실시간으로 환경을 인식하고 제어 명령을 수행하는 데 중요한 역할을 한다. 특히 원격 제어 상황에서는 로봇과 제어 시스템 간의 신속하고 효율적인 데이터 통신이 필수적이다. 이를 위해 다음과 같은 세부 사항을 고려해야 한다.</p>
<h3 id="_1">네트워크 지연 및 대역폭 관리</h3>
<p>원격 제어 로봇의 스트리밍 시스템에서 가장 중요한 문제 중 하나는 네트워크 지연(latency)이다. 지연 시간은 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>로 표현할 수 있으며, 이는 송신 측에서 데이터를 전송한 후 수신 측에서 해당 데이터를 처리하는 데 걸리는 시간이다. 만약 네트워크 지연이 크다면, 로봇의 제어 반응이 느려지며, 이는 원격 조작의 신뢰성을 저하시킬 수 있다.</p>
<p>이를 수식으로 나타내면, 송신된 데이터 패킷의 시간적 지연은 다음과 같이 계산할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\Delta t = t_{\text{recv}} - t_{\text{send}}
</div>
<script type="math/tex; mode=display">
\Delta t = t_{\text{recv}} - t_{\text{send}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t_{\text{recv}}</span><script type="math/tex">t_{\text{recv}}</script></span>는 수신 시간이며, <span class="arithmatex"><span class="MathJax_Preview">t_{\text{send}}</span><script type="math/tex">t_{\text{send}}</script></span>는 송신 시간이다. 대역폭(bandwidth)은 전송 가능한 데이터의 양을 결정하는 중요한 요소로, 데이터 전송량이 제한적일 경우 실시간 제어에 문제가 생길 수 있다. 대역폭 제한 하에서 포인트 클라우드 데이터를 효율적으로 전송하기 위해서는 데이터 압축과 샘플링 기법이 필요하다.</p>
<h3 id="_2">데이터 압축과 전송 효율</h3>
<p>포인트 클라우드 데이터는 일반적으로 매우 많은 양의 정보를 포함하고 있기 때문에, 이를 네트워크를 통해 실시간으로 전송하기 위해서는 압축 알고리즘의 적용이 필수적이다. 압축 후의 데이터 크기 <span class="arithmatex"><span class="MathJax_Preview">C_{\text{compressed}}</span><script type="math/tex">C_{\text{compressed}}</script></span>는 압축 전의 크기 <span class="arithmatex"><span class="MathJax_Preview">C_{\text{original}}</span><script type="math/tex">C_{\text{original}}</script></span>과 압축률 <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>에 의해 결정된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
C_{\text{compressed}} = C_{\text{original}} \times r
</div>
<script type="math/tex; mode=display">
C_{\text{compressed}} = C_{\text{original}} \times r
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>은 <span class="arithmatex"><span class="MathJax_Preview">0 \leq r \leq 1</span><script type="math/tex">0 \leq r \leq 1</script></span>로 정의되며, <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>이 1에 가까울수록 무손실 압축을, 0에 가까울수록 손실 압축을 의미한다. 손실 압축을 적용할 경우, 로봇의 인식 정확도에 영향을 미칠 수 있으므로 상황에 맞게 적절한 압축 기법을 선택해야 한다.</p>
<h3 id="_3">실시간 데이터 동기화</h3>
<p>실시간 데이터 스트리밍 환경에서 중요한 또 다른 요소는 데이터의 동기화(synchronization) 문제이다. 원격 로봇 제어에서는 제어 명령과 로봇이 획득한 센서 데이터 간의 시간적 일치가 필수적이다. 이를 위해서는 양방향 통신 시스템이 필요하며, 데이터의 타임스탬프를 기반으로 동기화를 처리할 수 있다. 로봇이 전송한 포인트 클라우드 데이터의 타임스탬프 <span class="arithmatex"><span class="MathJax_Preview">t_{\text{pc}}</span><script type="math/tex">t_{\text{pc}}</script></span>와 제어 시스템이 발행한 명령의 타임스탬프 <span class="arithmatex"><span class="MathJax_Preview">t_{\text{cmd}}</span><script type="math/tex">t_{\text{cmd}}</script></span>가 서로 맞지 않을 경우, 동기화 오류가 발생할 수 있다.</p>
<p>이를 방지하기 위한 기본적인 동기화 방정식은 다음과 같이 정의할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
| t_{\text{pc}} - t_{\text{cmd}} | \leq \Delta t_{\text{max}}
</div>
<script type="math/tex; mode=display">
| t_{\text{pc}} - t_{\text{cmd}} | \leq \Delta t_{\text{max}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\Delta t_{\text{max}}</span><script type="math/tex">\Delta t_{\text{max}}</script></span>는 허용 가능한 최대 지연 시간을 의미하며, 이를 초과할 경우 제어 신호가 유효하지 않게 된다.</p>
<h3 id="_4">데이터 손실 복구 및 에러 처리</h3>
<p>네트워크 전송 중에 발생할 수 있는 데이터 손실은 포인트 클라우드 기반 원격 제어에서 매우 치명적일 수 있다. 특히, 로봇의 실시간 동작에 필요한 중요한 데이터가 손실될 경우 시스템의 안정성이 저하된다. 이를 해결하기 위해 데이터 전송 중 손실된 데이터를 복구하는 방법이 필요하다. 손실된 데이터의 패킷 번호를 <span class="arithmatex"><span class="MathJax_Preview">P_{\text{lost}}</span><script type="math/tex">P_{\text{lost}}</script></span>로 정의하고, 이를 복구하기 위해 재전송 요청(retransmission)을 보낼 수 있다. </p>
<p>네트워크 에러를 줄이기 위해서, 오류 검출 및 복구 알고리즘을 사용한다. 대표적인 방법으로는 체크섬(checksum) 방식이 있으며, 각 데이터 패킷 <span class="arithmatex"><span class="MathJax_Preview">P_i</span><script type="math/tex">P_i</script></span>에 대해 오류 검출 값을 생성하여 수신 측에서 해당 데이터를 확인할 수 있다. </p>
<p>다음으로, 에러 검출 알고리즘의 예로 체크섬 계산을 수식으로 나타내면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Checksum}(P_i) = \sum_{k=0}^{n} P_i[k]
</div>
<script type="math/tex; mode=display">
\text{Checksum}(P_i) = \sum_{k=0}^{n} P_i[k]
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">P_i[k]</span><script type="math/tex">P_i[k]</script></span>는 패킷 <span class="arithmatex"><span class="MathJax_Preview">P_i</span><script type="math/tex">P_i</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-번째 바이트 데이터를 나타낸다.</p>
<h3 id="_5">스트리밍 압축 기법의 활용</h3>
<p>포인트 클라우드 데이터를 스트리밍하는 과정에서 실시간성을 유지하면서 데이터 전송량을 줄이기 위한 방법으로는 손실 및 무손실 압축 기법이 활용된다. 원격 로봇 제어에서는 특히 손실 압축을 사용할 때 실시간 제어에 미치는 영향을 철저하게 분석해야 한다. 손실 압축에서는 일부 데이터가 제거되므로, 로봇이 감지하는 환경의 세부 정보가 감소할 수 있다. 따라서 이 때 압축 후 복원된 포인트 클라우드 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{decompressed}}</span><script type="math/tex">\mathbf{P}_{\text{decompressed}}</script></span>와 원본 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{original}}</span><script type="math/tex">\mathbf{P}_{\text{original}}</script></span> 간의 차이를 최소화하는 것이 목표이다.</p>
<p>손실 압축 후 복원된 포인트 클라우드와 원본 포인트 클라우드의 차이를 측정하기 위한 일반적인 방법은 각 점의 유클리드 거리 차이로 정의된다. 이 차이는 다음과 같은 수식으로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
D_{\text{error}} = \frac{1}{N} \sum_{i=1}^{N} \left\| \mathbf{p}_{\text{original}, i} - \mathbf{p}_{\text{decompressed}, i} \right\|_2
</div>
<script type="math/tex; mode=display">
D_{\text{error}} = \frac{1}{N} \sum_{i=1}^{N} \left\| \mathbf{p}_{\text{original}, i} - \mathbf{p}_{\text{decompressed}, i} \right\|_2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{\text{original}, i}</span><script type="math/tex">\mathbf{p}_{\text{original}, i}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{\text{decompressed}, i}</span><script type="math/tex">\mathbf{p}_{\text{decompressed}, i}</script></span>는 각각 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-번째 포인트의 원본 좌표와 복원된 좌표이며, <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 총 포인트 수이다. 이러한 거리 차이가 크면 클수록 압축으로 인한 정보 손실이 크다는 것을 의미한다. 실시간 원격 로봇 제어에서는 이 값이 일정 임계값 이하가 되도록 해야 한다.</p>
<h3 id="_6">스트리밍을 통한 로봇 경로 계획</h3>
<p>원격 로봇 제어에서 스트리밍된 포인트 클라우드 데이터는 주로 환경 인식을 위한 입력으로 사용된다. 로봇은 실시간으로 입력받은 포인트 클라우드 데이터를 처리하여 경로 계획(path planning)을 수행한다. 이 과정에서 로봇의 위치와 목표 지점 간의 최적 경로를 찾는 알고리즘이 중요한 역할을 한다. 경로 계획은 주로 장애물 회피와 관련이 있으며, 로봇이 이동할 수 있는 공간을 파악하기 위해 포인트 클라우드 데이터를 분석하게 된다.</p>
<p>이 때 경로 계획 알고리즘에서 사용되는 주요 수식은 비용 함수(cost function)로 정의되며, 주어진 경로의 비용을 최소화하는 것이 목표이다. 경로 상의 비용을 <span class="arithmatex"><span class="MathJax_Preview">C(\mathbf{x})</span><script type="math/tex">C(\mathbf{x})</script></span>로 정의하고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>는 경로 상의 모든 포인트를 나타낸다. 비용 함수는 다음과 같이 정의될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
C(\mathbf{x}) = \sum_{i=1}^{N} f(\mathbf{p}_{i}, \mathbf{g})
</div>
<script type="math/tex; mode=display">
C(\mathbf{x}) = \sum_{i=1}^{N} f(\mathbf{p}_{i}, \mathbf{g})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{p}_{i}, \mathbf{g})</span><script type="math/tex">f(\mathbf{p}_{i}, \mathbf{g})</script></span>는 경로 상의 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-번째 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 목표 지점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{g}</span><script type="math/tex">\mathbf{g}</script></span> 간의 비용을 나타내며, 보통 유클리드 거리를 이용하여 다음과 같이 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(\mathbf{p}_i, \mathbf{g}) = \left\| \mathbf{p}_i - \mathbf{g} \right\|_2
</div>
<script type="math/tex; mode=display">
f(\mathbf{p}_i, \mathbf{g}) = \left\| \mathbf{p}_i - \mathbf{g} \right\|_2
</script>
</div>
<p>이 비용 함수는 로봇이 목표 지점에 도달하기 위해 최소화해야 할 거리 비용을 나타내며, 실시간 포인트 클라우드 데이터를 통해 로봇의 경로가 동적으로 변화할 수 있다.</p>
<h3 id="_7">원격 제어 시스템에서의 데이터 우선 순위</h3>
<p>원격 로봇 제어 시스템에서는 다양한 데이터 유형이 스트리밍된다. 이러한 데이터는 센서 데이터, 제어 명령, 상태 피드백 등으로 구성되며, 실시간 성능을 유지하기 위해 각 데이터의 우선 순위를 고려해야 한다. 예를 들어, 로봇의 제어 명령은 포인트 클라우드 데이터보다 더 높은 우선 순위를 가질 수 있다. 이는 제어 명령이 지연되면 로봇의 동작에 큰 영향을 미치기 때문이다. 반면 포인트 클라우드 데이터는 상대적으로 지연에 덜 민감할 수 있으므로, 더 낮은 우선 순위로 처리될 수 있다.</p>
<p>이를 수식적으로 설명하면, 각 데이터 유형의 전송 우선 순위를 결정하는 함수 <span class="arithmatex"><span class="MathJax_Preview">P(\mathbf{d})</span><script type="math/tex">P(\mathbf{d})</script></span>를 정의할 수 있다. 여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span>는 데이터 유형을 나타내며, 높은 우선 순위일수록 <span class="arithmatex"><span class="MathJax_Preview">P(\mathbf{d})</span><script type="math/tex">P(\mathbf{d})</script></span>의 값이 작다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
P(\mathbf{d}) = \frac{1}{w_{\text{priority}}}
</div>
<script type="math/tex; mode=display">
P(\mathbf{d}) = \frac{1}{w_{\text{priority}}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">w_{\text{priority}}</span><script type="math/tex">w_{\text{priority}}</script></span>는 해당 데이터 유형의 우선 순위 가중치이다. 예를 들어, 제어 명령의 경우 <span class="arithmatex"><span class="MathJax_Preview">w_{\text{priority}} = 1</span><script type="math/tex">w_{\text{priority}} = 1</script></span>, 포인트 클라우드 데이터의 경우 <span class="arithmatex"><span class="MathJax_Preview">w_{\text{priority}} = 10</span><script type="math/tex">w_{\text{priority}} = 10</script></span>과 같이 설정할 수 있다. 우선 순위가 낮은 데이터는 네트워크 혼잡 시 전송이 지연될 수 있지만, 로봇의 실시간 제어에는 큰 영향을 주지 않는다.</p>
<h3 id="_8">데이터 패킷 분할과 재조립</h3>
<p>포인트 클라우드 데이터를 스트리밍할 때, 대용량의 데이터를 작은 패킷으로 나누어 전송하는 것이 일반적이다. 이러한 패킷 분할 및 재조립 과정에서 패킷 손실이나 순서 뒤바뀜 문제가 발생할 수 있다. 이를 해결하기 위해 각 패킷에는 고유한 식별자와 순서 번호가 포함된다. 포인트 클라우드 데이터를 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>개의 패킷으로 분할했을 때, 각 패킷 <span class="arithmatex"><span class="MathJax_Preview">P_i</span><script type="math/tex">P_i</script></span>의 크기는 <span class="arithmatex"><span class="MathJax_Preview">C_{\text{packet}}</span><script type="math/tex">C_{\text{packet}}</script></span>으로 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
C_{\text{packet}} = \frac{C_{\text{original}}}{N}
</div>
<script type="math/tex; mode=display">
C_{\text{packet}} = \frac{C_{\text{original}}}{N}
</script>
</div>
<p>이 패킷들은 전송된 후 수신 측에서 다시 조립되어 원본 포인트 클라우드를 복원하게 된다. 데이터 패킷의 손실을 감지하기 위해 재조립 시 패킷 순서 번호를 확인하며, 순서가 맞지 않거나 손실된 패킷이 있을 경우 재전송을 요청한다.</p>
<p>패킷 분할 및 재조립 알고리즘은 다음과 같이 동작할 수 있다.</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; num_packets; ++i) {
    if (received_packet[i].id != expected_id) {
        request_retransmission(i);
    }
}
</code></pre>
<p>이 과정은 실시간 로봇 제어에서 데이터 일관성을 유지하는 데 중요한 역할을 하며, 특히 포인트 클라우드 데이터의 경우 손실된 패킷이 많아지면 환경 인식 성능이 저하될 수 있다.</p>
<h3 id="qos-quality-of-service">데이터 패킷 전송에서의 QoS (Quality of Service) 적용</h3>
<p>원격 로봇 제어에서 포인트 클라우드 데이터를 전송할 때, 네트워크의 품질이 일정하지 않을 경우 제어 성능이 저하될 수 있다. 이를 방지하기 위해 QoS (Quality of Service) 기법이 사용된다. QoS는 네트워크에서 데이터 전송의 우선순위를 설정하고, 특정 데이터 유형에 대해 보장된 대역폭, 지연 시간, 패킷 손실률 등을 관리하는 기술이다. 예를 들어, 포인트 클라우드 데이터 스트리밍에서는 지연 시간보다는 데이터 손실이 더 중요한 요소가 될 수 있다.</p>
<p>QoS 적용 시 네트워크에서 보장해야 하는 성능 지표는 다음과 같다.</p>
<ul>
<li><strong>지연 시간</strong> (<span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>): 각 데이터 패킷이 송신되고 수신되기까지 걸리는 시간. 이는 최소화되어야 한다.</li>
<li><strong>대역폭</strong> (<span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>): 데이터를 전송할 수 있는 최대 데이터 양. 포인트 클라우드의 경우 대역폭을 많이 차지하므로 효율적으로 사용해야 한다.</li>
<li><strong>패킷 손실률</strong> (<span class="arithmatex"><span class="MathJax_Preview">P_{\text{loss}}</span><script type="math/tex">P_{\text{loss}}</script></span>): 전송 과정에서 손실된 패킷의 비율로, 포인트 클라우드 데이터를 정확히 복원하기 위해서는 손실률이 매우 낮아야 한다.</li>
</ul>
<p>이를 수학적으로 표현하면, QoS를 유지하기 위한 대역폭과 지연 시간의 관계는 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
B \geq \frac{C_{\text{total}}}{\Delta t_{\text{max}}}
</div>
<script type="math/tex; mode=display">
B \geq \frac{C_{\text{total}}}{\Delta t_{\text{max}}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">C_{\text{total}}</span><script type="math/tex">C_{\text{total}}</script></span>은 전송해야 하는 전체 포인트 클라우드 데이터의 크기, <span class="arithmatex"><span class="MathJax_Preview">\Delta t_{\text{max}}</span><script type="math/tex">\Delta t_{\text{max}}</script></span>는 허용 가능한 최대 지연 시간이다. 이 조건을 만족하지 못할 경우 데이터 전송이 지연되거나 일부 데이터가 손실될 수 있다.</p>
<h3 id="-">데이터 스트리밍에서의 압축-복원 알고리즘 적용</h3>
<p>포인트 클라우드 데이터를 실시간으로 스트리밍할 때, 압축과 복원 과정은 매우 중요한 역할을 한다. 특히, 네트워크 대역폭이 제한된 상황에서는 압축률을 최적화하여 전송 시간을 줄이는 것이 필요하다. 그러나 과도한 압축은 데이터의 품질을 저하시킬 수 있기 때문에, 로봇 제어에 적합한 수준으로 압축을 조정해야 한다.</p>
<p>실시간 압축 알고리즘으로 대표적인 방법은 Octree 기반의 압축 기법이다. Octree는 3차원 공간을 8개의 동일한 구역으로 나누어 포인트 클라우드 데이터를 계층적으로 저장하는 방법이다. Octree 기반 압축 기법은 포인트 클라우드 데이터를 트리 구조로 압축하므로, 데이터 크기를 줄이는 동시에 공간적 연속성을 유지할 수 있다.</p>
<p>포인트 클라우드 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>에 대해 Octree 압축을 적용한 후 압축된 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{compressed}}</span><script type="math/tex">\mathbf{P}_{\text{compressed}}</script></span>는 다음과 같이 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{\text{compressed}} = \text{OctreeCompress}(\mathbf{P})
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{\text{compressed}} = \text{OctreeCompress}(\mathbf{P})
</script>
</div>
<p>이 후, 복원 과정은 압축된 데이터를 다시 원래의 포인트 클라우드 데이터로 변환하는 과정으로, 복원된 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{restored}}</span><script type="math/tex">\mathbf{P}_{\text{restored}}</script></span>는 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{\text{restored}} = \text{OctreeDecompress}(\mathbf{P}_{\text{compressed}})
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{\text{restored}} = \text{OctreeDecompress}(\mathbf{P}_{\text{compressed}})
</script>
</div>
<p>복원된 데이터와 원본 데이터 간의 품질 차이는 주로 포인트 간의 좌표 차이로 측정된다. 이 차이를 유클리드 거리로 계산할 수 있으며, 이는 앞서 설명한 대로 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
D_{\text{error}} = \frac{1}{N} \sum_{i=1}^{N} \left\| \mathbf{p}_{\text{original}, i} - \mathbf{p}_{\text{restored}, i} \right\|_2
</div>
<script type="math/tex; mode=display">
D_{\text{error}} = \frac{1}{N} \sum_{i=1}^{N} \left\| \mathbf{p}_{\text{original}, i} - \mathbf{p}_{\text{restored}, i} \right\|_2
</script>
</div>
<p>이 오류 값이 낮을수록 복원된 데이터의 품질이 높다고 할 수 있으며, 실시간 원격 제어에서는 오류 값이 일정 수준 이하로 유지되도록 해야 한다.</p>
<h3 id="_9">실시간 데이터 처리 및 피드백 시스템</h3>
<p>원격 로봇 제어에서는 스트리밍된 데이터를 실시간으로 처리하고, 그에 따라 로봇의 동작을 조정하는 것이 중요하다. 포인트 클라우드 데이터를 기반으로 로봇이 환경을 인식하고, 장애물 회피, 경로 계획 등의 작업을 수행할 때, 센서 데이터가 제어 시스템으로 즉각 피드백 되어야 한다. 실시간 피드백 시스템은 센서 데이터와 제어 명령 간의 상호작용을 빠르게 처리하며, 지연 시간을 최소화하는 것이 핵심이다.</p>
<p>이를 수학적으로 모델링하면, 로봇의 현재 상태를 나타내는 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>가 제어 명령 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>에 의해 갱신된다고 할 수 있다. 이 때 시스템의 상태 변화는 다음과 같은 상태 방정식으로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t+1) = f(\mathbf{x}(t), \mathbf{u}(t)) + \mathbf{w}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t+1) = f(\mathbf{x}(t), \mathbf{u}(t)) + \mathbf{w}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{x}, \mathbf{u})</span><script type="math/tex">f(\mathbf{x}, \mathbf{u})</script></span>는 상태 변화를 나타내는 함수이며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{w}(t)</span><script type="math/tex">\mathbf{w}(t)</script></span>는 시스템에 가해지는 잡음 또는 불확실성을 나타낸다. 피드백 시스템은 로봇이 실시간으로 새로운 제어 명령을 반영할 수 있도록 이 상태 변화를 빠르게 추적하는 역할을 한다.</p>
<p>로봇 제어에서 주로 사용되는 피드백 기법은 PID 제어(PID control)이다. PID 제어는 목표 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{target}}</span><script type="math/tex">\mathbf{x}_{\text{target}}</script></span>와 현재 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span> 간의 차이를 이용하여 제어 명령을 조정하는 방법이다. PID 제어는 다음과 같은 수식으로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(t) = K_P e(t) + K_I \int_0^t e(\tau) d\tau + K_D \frac{de(t)}{dt}
</div>
<script type="math/tex; mode=display">
\mathbf{u}(t) = K_P e(t) + K_I \int_0^t e(\tau) d\tau + K_D \frac{de(t)}{dt}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">e(t) = \mathbf{x}_{\text{target}} - \mathbf{x}(t)</span><script type="math/tex">e(t) = \mathbf{x}_{\text{target}} - \mathbf{x}(t)</script></span>는 오차, <span class="arithmatex"><span class="MathJax_Preview">K_P</span><script type="math/tex">K_P</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_I</span><script type="math/tex">K_I</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_D</span><script type="math/tex">K_D</script></span>는 각각 비례, 적분, 미분 제어 게인이다.</p>
<h3 id="_10">지능형 알고리즘과 원격 제어의 결합</h3>
<p>최근에는 원격 로봇 제어에서 지능형 알고리즘, 특히 딥러닝 기반의 기법이 많이 도입되고 있다. 지능형 알고리즘은 포인트 클라우드 데이터의 실시간 분석과 학습을 통해 로봇의 의사결정을 지원하며, 복잡한 환경에서도 효율적인 제어를 가능하게 한다. 이를 위해 CNN (Convolutional Neural Network)이나 PointNet 같은 네트워크가 포인트 클라우드 데이터를 처리하는 데 적용될 수 있다.</p>
<p>PointNet 기반의 알고리즘은 포인트 클라우드 데이터를 입력으로 받아 각 점의 특성을 학습하고, 이를 기반으로 객체 인식이나 분류 작업을 수행한다. 원격 로봇 제어에서 이 알고리즘을 적용하면, 실시간으로 환경을 분석하여 자율적인 의사결정이 가능해진다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_24/2401/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_24/2401/" class="btn btn-xs btn-link">
        시뮬레이션 환경에서의 PCL 활용
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2304/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2304/" class="btn btn-xs btn-link">
        스트리밍 환경에서의 실시간 처리 방법
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>