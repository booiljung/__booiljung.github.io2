<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/sensor_data_processing/pointcloud/introductions_to_pointcloud_processing_with_pcl_library/chapter_23/2304/" rel="canonical"/>
<link href="../../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>스트리밍 환경에서의 실시간 처리 방법 - 소프트웨어 융합</title>
<link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "1. \ub124\ud2b8\uc6cc\ud06c \ub300\uc5ed\ud3ed \ubc0f \uc9c0\uc5f0 \uc2dc\uac04 \uace0\ub824", url: "#_top", children: [
          ]},
          {title: "2. \ub370\uc774\ud130 \uc555\ucd95 \uae30\ubc95", url: "#2", children: [
          ]},
          {title: "3. \uc2a4\ud2b8\ub9ac\ubc0d \ud30c\uc774\ud504\ub77c\uc778 \uc124\uacc4", url: "#3", children: [
          ]},
          {title: "4. \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ubc84\ud37c\ub9c1 \uae30\ubc95", url: "#4", children: [
          ]},
          {title: "5. \ub370\uc774\ud130 \ubd84\ud560\uacfc \ud328\ud0b7\ud654", url: "#5", children: [
          ]},
          {title: "6. \uc2a4\ud2b8\ub9ac\ubc0d\uc5d0\uc11c\uc758 \ub3d9\uae30\ud654 \ubb38\uc81c", url: "#6", children: [
          ]},
          {title: "7. \uc624\ub958 \ubcf5\uad6c \ubc0f \ud328\ud0b7 \uc190\uc2e4 \ub300\uc751", url: "#7", children: [
          ]},
          {title: "8. \uc2a4\ud2b8\ub9ac\ubc0d \ud658\uacbd\uc5d0\uc11c\uc758 \uc801\uc751\ud615 \ube44\ud2b8\ub808\uc774\ud2b8 \uc870\uc808", url: "#8", children: [
          ]},
          {title: "9. \ud074\ub77c\uc6b0\ub4dc \uae30\ubc18 \uc2e4\uc2dc\uac04 \ucc98\ub9ac", url: "#9", children: [
          ]},
          {title: "10. \uc2e4\uc2dc\uac04 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub370\uc774\ud130\uc758 \uc0ac\ud6c4 \ucc98\ub9ac", url: "#10", children: [
          ]},
          {title: "11. \uc2e4\uc2dc\uac04 \uc2a4\ud2b8\ub9ac\ubc0d\uc5d0\uc11c\uc758 \ub370\uc774\ud130 \uc0d8\ud50c\ub9c1 \uae30\ubc95", url: "#11", children: [
              {title: "\uade0\uc77c \uc0d8\ud50c\ub9c1", url: "#_1" },
              {title: "\uc801\uc751\ud615 \uc0d8\ud50c\ub9c1", url: "#_2" },
          ]},
          {title: "12. \uc2e4\uc2dc\uac04 \ucc98\ub9ac\uc5d0\uc11c\uc758 \ubcd1\ub82c \ubc0f \ubd84\uc0b0 \ucc98\ub9ac", url: "#12", children: [
          ]},
          {title: "13. \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc2a4\ud2b8\ub9ac\ubc0d\uc758 \ud655\uc7a5\uc131 \ubb38\uc81c", url: "#13", children: [
          ]},
          {title: "14. \uc2a4\ud2b8\ub9ac\ubc0d \ud658\uacbd\uc5d0\uc11c\uc758 QoS (Quality of Service) \uad00\ub9ac", url: "#14-qos-quality-of-service", children: [
          ]},
          {title: "15. \uc2e4\uc2dc\uac04 \ub370\uc774\ud130\uc758 \ubcf4\uc548 \ubb38\uc81c", url: "#15", children: [
          ]},
          {title: "16. \uc2e4\uc2dc\uac04 \ucc98\ub9ac\uc5d0\uc11c\uc758 \ud558\ub4dc\uc6e8\uc5b4 \uac00\uc18d", url: "#16", children: [
              {title: "GPU \uae30\ubc18 \ucc98\ub9ac", url: "#gpu" },
              {title: "FPGA \uae30\ubc18 \ucc98\ub9ac", url: "#fpga" },
          ]},
          {title: "17. \uc2e4\uc2dc\uac04 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ucc98\ub9ac\uc5d0\uc11c\uc758 \ub85c\ubd07 \uc751\uc6a9", url: "#17", children: [
              {title: "\uc774\ub3d9 \ub85c\ubd07\uc5d0\uc11c\uc758 \uc2e4\uc2dc\uac04 \ucc98\ub9ac", url: "#_3" },
              {title: "\ub4dc\ub860\uc5d0\uc11c\uc758 \uc2e4\uc2dc\uac04 \ucc98\ub9ac", url: "#_4" },
              {title: "\uc0b0\uc5c5\uc6a9 \ub85c\ubd07\uc5d0\uc11c\uc758 \uc2e4\uc2dc\uac04 \ucc98\ub9ac", url: "#_5" },
          ]},
          {title: "18. \uc2e4\uc2dc\uac04 \uc2a4\ud2b8\ub9ac\ubc0d \ud658\uacbd\uc5d0\uc11c\uc758 \ub370\uc774\ud130 \uc624\ub958 \ucc98\ub9ac", url: "#18", children: [
          ]},
        ];

    </script>
<script src="../../../../../js/base.js"></script>
<script src="../../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../2305/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../2305/">
        원격 로봇 제어를 위한 데이터 스트리밍 사례
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../2303/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../2303/">
        데이터 압축을 통한 전송 효율화
      </a>
</div>
</div>
<p>실시간 데이터 스트리밍 환경에서 포인트 클라우드 데이터를 처리하는 방법은 여러 가지 기술적 요소를 고려해야 한다. 여기서는 네트워크 대역폭, 지연 시간, 데이터 압축, 그리고 스트리밍 파이프라인의 설계에 중점을 두어 설명한다.</p>
<h3 id="1">1. 네트워크 대역폭 및 지연 시간 고려</h3>
<p>실시간 스트리밍에서 가장 중요한 요소 중 하나는 네트워크 대역폭과 지연 시간이다. 포인트 클라우드 데이터는 매우 대용량이므로, 데이터를 전송하는 동안 네트워크의 대역폭을 초과하지 않도록 적절한 압축 기법을 적용해야 한다. </p>
<p>또한 지연 시간(latency)도 실시간 처리에서 중요한 요소다. 지연 시간은 데이터를 수신하고 처리하는 데 걸리는 시간으로, 이를 최소화하기 위해 네트워크 프로토콜과 버퍼링 기법이 사용된다.</p>
<p>지연 시간 <span class="arithmatex"><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span>는 다음과 같이 모델링될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\tau = \frac{L}{B} + T_{proc}
</div>
<script type="math/tex; mode=display">
\tau = \frac{L}{B} + T_{proc}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span>은 데이터 패킷의 크기, <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>는 네트워크 대역폭, <span class="arithmatex"><span class="MathJax_Preview">T_{proc}</span><script type="math/tex">T_{proc}</script></span>은 처리 시간이다. 데이터 패킷의 크기와 대역폭 간의 비율을 줄이면 지연 시간을 줄일 수 있다.</p>
<h3 id="2">2. 데이터 압축 기법</h3>
<p>실시간 스트리밍에서는 데이터를 전송하기 전에 압축하는 것이 필수적이다. 포인트 클라우드 데이터를 효율적으로 압축하는 방법은 크게 두 가지가 있다: 손실 압축과 무손실 압축. </p>
<p>무손실 압축의 경우 데이터의 정밀도가 보장되지만, 압축률이 상대적으로 낮다. 반면 손실 압축은 압축률이 높지만, 정밀도가 떨어질 수 있다. 여기서 중요한 문제는 압축률과 데이터 품질의 균형을 맞추는 것이다. 압축률 <span class="arithmatex"><span class="MathJax_Preview">\eta</span><script type="math/tex">\eta</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\eta = \frac{S_{uncompressed}}{S_{compressed}}
</div>
<script type="math/tex; mode=display">
\eta = \frac{S_{uncompressed}}{S_{compressed}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">S_{uncompressed}</span><script type="math/tex">S_{uncompressed}</script></span>는 압축 전 데이터의 크기, <span class="arithmatex"><span class="MathJax_Preview">S_{compressed}</span><script type="math/tex">S_{compressed}</script></span>는 압축 후 데이터의 크기다. 이상적인 압축 기법은 <span class="arithmatex"><span class="MathJax_Preview">\eta</span><script type="math/tex">\eta</script></span>가 높으면서도 데이터 품질의 손상이 최소화되는 것이다.</p>
<h3 id="3">3. 스트리밍 파이프라인 설계</h3>
<p>포인트 클라우드 스트리밍 환경에서 파이프라인 설계는 처리 속도를 높이는 핵심 요소다. 스트리밍 파이프라인은 데이터를 입력, 처리, 전송하는 일련의 과정으로 구성된다. 각 단계는 실시간으로 병렬 처리(parallel processing)를 통해 속도를 최적화할 수 있다.</p>
<p>파이프라인의 구조는 다음과 같이 정의될 수 있다:</p>
<div class="mermaid">graph LR
    A[데이터 수집] --&gt; B[데이터 압축]
    B --&gt; C[네트워크 전송]
    C --&gt; D[데이터 수신 및 디코딩]
    D --&gt; E[데이터 처리 및 시각화]
</div>
<p>이 과정에서 각 노드는 별도의 스레드나 프로세스로 동작하며, 이로 인해 데이터 처리 속도를 실시간으로 유지할 수 있다. 병렬 처리의 효율성을 높이기 위해서는 각 단계 간의 데이터 흐름을 최적화해야 한다.</p>
<h3 id="4">4. 실시간 데이터 버퍼링 기법</h3>
<p>실시간 포인트 클라우드 스트리밍에서는 데이터 패킷의 손실이나 지연을 보완하기 위해 버퍼링 기법을 사용한다. 버퍼는 데이터를 일시적으로 저장해 네트워크 상에서 발생할 수 있는 지연이나 변동을 흡수하는 역할을 한다. 적절한 버퍼 크기를 설정하는 것이 매우 중요하다.</p>
<p>버퍼링 지연 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{buffer}</span><script type="math/tex">T_{buffer}</script></span>는 다음과 같이 모델링될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{buffer} = \frac{N_{buffer}}{R}
</div>
<script type="math/tex; mode=display">
T_{buffer} = \frac{N_{buffer}}{R}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N_{buffer}</span><script type="math/tex">N_{buffer}</script></span>는 버퍼에 저장된 데이터 양, <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>은 데이터 처리 속도이다. 버퍼가 너무 작으면 패킷 손실이 발생할 수 있고, 너무 크면 시스템에 추가적인 지연을 초래할 수 있다. 따라서, 실시간 스트리밍에서는 동적 버퍼 크기 조절 알고리즘이 사용된다.</p>
<h3 id="5">5. 데이터 분할과 패킷화</h3>
<p>실시간 스트리밍에서는 데이터를 네트워크 패킷으로 나누어 전송하는 것이 필요하다. 이를 위해 포인트 클라우드 데이터를 일정 크기로 분할한 후, 각 패킷에 데이터를 담아 전송한다. 데이터 분할은 주로 공간적으로 이루어지며, 이는 처리 속도를 향상시킨다.</p>
<p>포인트 클라우드 데이터를 패킷화할 때 중요한 요소는 각 패킷의 크기 <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>를 조정하는 것이다. 패킷 크기 <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>는 다음과 같은 요소를 고려해 결정된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
P = \frac{S_{total}}{N_{packets}}
</div>
<script type="math/tex; mode=display">
P = \frac{S_{total}}{N_{packets}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">S_{total}</span><script type="math/tex">S_{total}</script></span>은 전체 데이터 크기, <span class="arithmatex"><span class="MathJax_Preview">N_{packets}</span><script type="math/tex">N_{packets}</script></span>는 패킷 수이다. 패킷 크기가 너무 크면 전송 지연이 증가하고, 너무 작으면 네트워크 부하가 증가할 수 있다.</p>
<h3 id="6">6. 스트리밍에서의 동기화 문제</h3>
<p>실시간 스트리밍에서는 데이터를 전송하는 송신자와 데이터를 처리하는 수신자 간의 동기화가 매우 중요하다. 동기화 문제를 해결하지 않으면 데이터 패킷이 순서대로 처리되지 않거나 일부 패킷이 손실될 수 있다.</p>
<p>동기화는 타임스탬프(timestamp)를 이용해 각 패킷에 시간을 기록하는 방법으로 해결된다. 각 패킷 <span class="arithmatex"><span class="MathJax_Preview">p_i</span><script type="math/tex">p_i</script></span>에 타임스탬프 <span class="arithmatex"><span class="MathJax_Preview">t_i</span><script type="math/tex">t_i</script></span>가 붙고, 수신자는 이를 통해 패킷을 재정렬한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
t_i = T_0 + i \cdot \Delta T
</div>
<script type="math/tex; mode=display">
t_i = T_0 + i \cdot \Delta T
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T_0</span><script type="math/tex">T_0</script></span>는 첫 번째 패킷의 전송 시간, <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>는 패킷 인덱스, <span class="arithmatex"><span class="MathJax_Preview">\Delta T</span><script type="math/tex">\Delta T</script></span>는 각 패킷 간의 전송 간격이다.</p>
<p>동기화 지연 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{sync}</span><script type="math/tex">T_{sync}</script></span>은 다음과 같이 계산될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{sync} = \frac{\sum_{i=1}^{N} (t_{i,recv} - t_{i,send})}{N}
</div>
<script type="math/tex; mode=display">
T_{sync} = \frac{\sum_{i=1}^{N} (t_{i,recv} - t_{i,send})}{N}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t_{i,recv}</span><script type="math/tex">t_{i,recv}</script></span>는 수신 시각, <span class="arithmatex"><span class="MathJax_Preview">t_{i,send}</span><script type="math/tex">t_{i,send}</script></span>는 전송 시각, <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 전체 패킷 수이다. 이 값이 최소화될수록 동기화 상태가 양호하다.</p>
<h3 id="7">7. 오류 복구 및 패킷 손실 대응</h3>
<p>네트워크 상에서 포인트 클라우드 데이터를 전송할 때, 패킷 손실이 발생할 가능성이 있다. 이를 대비하기 위한 방법으로는 재전송(retransmission) 기법과 전진 오류 수정(Forward Error Correction, FEC)이 있다.</p>
<p>재전송 기법은 손실된 패킷을 탐지하고 다시 요청하는 방식으로 동작한다. 반면 FEC는 데이터에 에러 검출 및 수정 코드를 추가하여 손실된 패킷을 복구한다. FEC를 사용하는 경우 패킷 손실율 <span class="arithmatex"><span class="MathJax_Preview">P_{loss}</span><script type="math/tex">P_{loss}</script></span>는 다음과 같이 모델링된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
P_{loss} = \frac{N_{lost}}{N_{total}}
</div>
<script type="math/tex; mode=display">
P_{loss} = \frac{N_{lost}}{N_{total}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N_{lost}</span><script type="math/tex">N_{lost}</script></span>는 손실된 패킷 수, <span class="arithmatex"><span class="MathJax_Preview">N_{total}</span><script type="math/tex">N_{total}</script></span>은 전송된 전체 패킷 수이다.</p>
<h3 id="8">8. 스트리밍 환경에서의 적응형 비트레이트 조절</h3>
<p>실시간 데이터 스트리밍에서 네트워크 상태는 시간이 지남에 따라 변화할 수 있다. 따라서 비트레이트를 적응적으로 조절하는 방법이 필요하다. 적응형 비트레이트(Adaptive Bitrate, ABR) 기법은 네트워크 대역폭의 가용성에 따라 데이터 전송 속도를 동적으로 변경하는 기술이다.</p>
<p>비트레이트 <span class="arithmatex"><span class="MathJax_Preview">R_{bit}</span><script type="math/tex">R_{bit}</script></span>는 전송할 데이터의 양과 네트워크 대역폭에 따라 조절된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
R_{bit} = \min\left( R_{net}, R_{data} \right)
</div>
<script type="math/tex; mode=display">
R_{bit} = \min\left( R_{net}, R_{data} \right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">R_{net}</span><script type="math/tex">R_{net}</script></span>은 현재 네트워크에서 사용할 수 있는 대역폭, <span class="arithmatex"><span class="MathJax_Preview">R_{data}</span><script type="math/tex">R_{data}</script></span>는 데이터의 요구 대역폭이다. 이를 통해 대역폭이 낮아질 경우 비트레이트를 줄여 끊김 없이 데이터를 전송할 수 있고, 대역폭이 넉넉할 때는 비트레이트를 높여 고품질 데이터를 전송할 수 있다.</p>
<p>적응형 비트레이트 조절 알고리즘은 주로 네트워크 상태를 모니터링하는 피드백 루프 구조로 설계된다. 각 패킷 전송 이후 수신된 ACK(acknowledgment) 신호를 기반으로 다음 패킷의 전송 속도를 조정하는 방식이다. 이는 TCP의 혼잡 제어 방식과 유사하다.</p>
<h3 id="9">9. 클라우드 기반 실시간 처리</h3>
<p>클라우드 환경에서는 포인트 클라우드 데이터를 중앙 서버에서 실시간으로 처리하고, 클라이언트는 결과만을 수신하는 구조가 일반적이다. 클라우드 기반 처리의 이점은 클라이언트 장치에서의 연산 부담을 줄이고, 대용량 데이터를 보다 효율적으로 처리할 수 있다는 것이다.</p>
<p>실시간 처리에서 클라우드 기반 접근 방식의 중요한 요소는 지연 시간과 처리 성능이다. 클라우드 서버에서의 처리 지연 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{cloud}</span><script type="math/tex">T_{cloud}</script></span>는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{cloud} = T_{upload} + T_{compute} + T_{download}
</div>
<script type="math/tex; mode=display">
T_{cloud} = T_{upload} + T_{compute} + T_{download}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T_{upload}</span><script type="math/tex">T_{upload}</script></span>는 클라이언트에서 데이터를 클라우드로 업로드하는 시간, <span class="arithmatex"><span class="MathJax_Preview">T_{compute}</span><script type="math/tex">T_{compute}</script></span>는 클라우드 서버에서 데이터를 처리하는 시간, <span class="arithmatex"><span class="MathJax_Preview">T_{download}</span><script type="math/tex">T_{download}</script></span>는 처리 결과를 클라이언트로 다운로드하는 시간이다.</p>
<p>클라우드 기반 실시간 처리를 최적화하려면, 클라이언트와 서버 간의 네트워크 대역폭을 고려한 데이터 압축 및 전송 방식을 사용해야 한다. 또한 클라우드 서버에서의 연산 자원(예: GPU, CPU)의 효율적인 배분이 중요하다.</p>
<h3 id="10">10. 실시간 포인트 클라우드 데이터의 사후 처리</h3>
<p>실시간 스트리밍으로 전송된 포인트 클라우드 데이터는 수신 즉시 처리되지만, 경우에 따라 사후 처리(post-processing)가 필요할 수 있다. 사후 처리는 주로 데이터의 잡음 제거, 보간(interpolation), 이상치(outlier) 탐지 등을 포함한다. 실시간 환경에서는 이러한 사후 처리 과정이 매우 짧은 시간 내에 이루어져야 하므로, 병렬화 및 분산 처리가 중요한 역할을 한다.</p>
<p>사후 처리 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{post}</span><script type="math/tex">T_{post}</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{post} = \frac{1}{N} \sum_{i=1}^{N} t_{post,i}
</div>
<script type="math/tex; mode=display">
T_{post} = \frac{1}{N} \sum_{i=1}^{N} t_{post,i}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t_{post,i}</span><script type="math/tex">t_{post,i}</script></span>는 각 데이터 샘플의 사후 처리 시간, <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 처리할 데이터 샘플의 총 수이다. 이 값을 최소화하기 위해 GPU나 병렬 프로세싱 기술을 활용할 수 있다.</p>
<h3 id="11">11. 실시간 스트리밍에서의 데이터 샘플링 기법</h3>
<p>실시간 처리 환경에서 데이터 전송 속도와 처리 능력을 유지하기 위해 샘플링 기법을 적용하는 것이 필수적이다. 포인트 클라우드 데이터는 일반적으로 고밀도 데이터를 포함하고 있으며, 이 데이터를 전송 및 처리할 때 전부를 사용하지 않고도 유효한 분석을 할 수 있다. 따라서 일부 데이터를 샘플링하여 처리 효율성을 높일 수 있다.</p>
<p>샘플링은 주로 두 가지 방식으로 이루어진다: <strong>균일 샘플링</strong>과 <strong>적응형 샘플링</strong>.</p>
<h4 id="_1">균일 샘플링</h4>
<p>균일 샘플링은 일정한 간격으로 포인트 클라우드에서 데이터를 선택하는 방식이다. 균일 샘플링 비율 <span class="arithmatex"><span class="MathJax_Preview">r_{uniform}</span><script type="math/tex">r_{uniform}</script></span>은 다음과 같이 정의할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
r_{uniform} = \frac{N_{sample}}{N_{total}}
</div>
<script type="math/tex; mode=display">
r_{uniform} = \frac{N_{sample}}{N_{total}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N_{sample}</span><script type="math/tex">N_{sample}</script></span>은 샘플링된 포인트 수, <span class="arithmatex"><span class="MathJax_Preview">N_{total}</span><script type="math/tex">N_{total}</script></span>은 전체 포인트 수이다. 균일 샘플링은 구현이 간단하며, 일정한 샘플링 속도를 유지할 수 있지만, 데이터의 특정 밀도가 높은 부분에서 중요한 세부 정보가 손실될 수 있다.</p>
<h4 id="_2">적응형 샘플링</h4>
<p>적응형 샘플링은 포인트 클라우드 데이터의 밀도나 특성에 따라 샘플링 비율을 동적으로 조정하는 방식이다. 예를 들어, 물체의 경계선이나 고도 변화가 큰 부분에서는 샘플링 비율을 높이고, 균일한 표면에서는 샘플링 비율을 낮춘다.</p>
<p>적응형 샘플링 비율 <span class="arithmatex"><span class="MathJax_Preview">r_{adaptive}(x)</span><script type="math/tex">r_{adaptive}(x)</script></span>은 공간적 좌표 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>에 따라 변화하며, 다음과 같이 정의될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
r_{adaptive}(x) = \frac{1}{1 + \alpha \cdot \left| \nabla f(x) \right|}
</div>
<script type="math/tex; mode=display">
r_{adaptive}(x) = \frac{1}{1 + \alpha \cdot \left| \nabla f(x) \right|}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\nabla f(x)</span><script type="math/tex">\nabla f(x)</script></span>는 포인트 클라우드 데이터의 밀도 변화, <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 조정 계수이다. 밀도 변화가 클수록 샘플링 비율이 커지고, 변화가 적으면 샘플링 비율이 작아진다.</p>
<h3 id="12">12. 실시간 처리에서의 병렬 및 분산 처리</h3>
<p>포인트 클라우드 데이터를 실시간으로 처리하는 데 있어, 병렬 처리(parallel processing)와 분산 처리(distributed processing)의 중요성은 매우 크다. 특히 고해상도 포인트 클라우드 데이터를 다루는 경우, 단일 프로세서에서의 처리 속도로는 실시간 요건을 충족하기 어렵다.</p>
<p>병렬 처리는 주로 데이터의 공간적 분할을 통해 수행된다. 포인트 클라우드 데이터는 3D 공간에 걸쳐 분포되어 있으므로, 공간적으로 데이터를 여러 부분으로 나누어 병렬로 처리할 수 있다. 예를 들어, 공간 내 특정 영역에 해당하는 포인트들을 독립적으로 처리한 후 최종 결과를 결합하는 방식이다.</p>
<p>분산 처리에서는 클러스터링된 컴퓨팅 자원을 이용해 데이터를 여러 노드에 분배하여 처리한다. 이러한 분산 환경에서 중요한 요소는 각 노드 간의 데이터 동기화 및 통신이다. 분산 처리에서의 전체 처리 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{distributed}</span><script type="math/tex">T_{distributed}</script></span>는 다음과 같이 정의될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{distributed} = \max_{i} (T_{compute,i}) + T_{comm}
</div>
<script type="math/tex; mode=display">
T_{distributed} = \max_{i} (T_{compute,i}) + T_{comm}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T_{compute,i}</span><script type="math/tex">T_{compute,i}</script></span>는 각 노드 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>에서의 계산 시간, <span class="arithmatex"><span class="MathJax_Preview">T_{comm}</span><script type="math/tex">T_{comm}</script></span>은 노드 간 통신 시간이다. 따라서 노드 간 통신 지연을 최소화하고, 계산 부하를 고르게 분배하는 것이 실시간 분산 처리의 핵심이다.</p>
<h3 id="13">13. 포인트 클라우드 스트리밍의 확장성 문제</h3>
<p>실시간 포인트 클라우드 스트리밍에서 확장성은 중요한 문제다. 데이터의 양이 증가할수록 처리 속도와 전송 속도는 크게 영향을 받을 수 있다. 확장성을 보장하기 위해서는 데이터 파이프라인의 설계와 네트워크 인프라를 최적화해야 한다.</p>
<p>확장성을 고려한 시스템 설계에서는 <strong>로드 밸런싱</strong>과 <strong>캐싱</strong> 기술을 활용할 수 있다. 로드 밸런싱은 각 처리 노드에 작업 부하를 고르게 분배하여 병목 현상을 방지하는 방법이며, 캐싱은 자주 사용되는 데이터를 메모리에 저장하여 전송 시간을 줄이는 기술이다.</p>
<p>로드 밸런싱 알고리즘의 성능은 작업 부하 분배의 균등성에 의해 측정될 수 있으며, 다음과 같이 정의할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
E_{load} = \frac{\sigma(T_{compute})}{\mu(T_{compute})}
</div>
<script type="math/tex; mode=display">
E_{load} = \frac{\sigma(T_{compute})}{\mu(T_{compute})}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\sigma(T_{compute})</span><script type="math/tex">\sigma(T_{compute})</script></span>는 각 노드의 처리 시간의 표준 편차, <span class="arithmatex"><span class="MathJax_Preview">\mu(T_{compute})</span><script type="math/tex">\mu(T_{compute})</script></span>는 처리 시간의 평균이다. 이 값이 작을수록 작업 부하가 고르게 분배된 것을 의미하며, 확장성 있는 시스템으로 평가된다.</p>
<h3 id="14-qos-quality-of-service">14. 스트리밍 환경에서의 QoS (Quality of Service) 관리</h3>
<p>실시간 포인트 클라우드 데이터 스트리밍에서 <strong>QoS(서비스 품질)</strong>는 매우 중요한 요소이다. QoS는 네트워크 및 시스템이 특정 서비스의 성능을 보장하기 위한 일련의 기술을 의미하며, 특히 실시간 데이터 처리에서는 데이터 전송 속도, 손실률, 지연 시간 등의 성능 기준을 명확히 설정하고 관리해야 한다.</p>
<p>QoS 관리를 위해 사용되는 주요 메트릭은 다음과 같다:</p>
<ul>
<li><strong>대역폭 할당</strong>: 스트리밍에 필요한 최소 대역폭을 보장하기 위해 네트워크 자원을 동적으로 할당하는 기법이다.</li>
<li><strong>패킷 손실률</strong> (<span class="arithmatex"><span class="MathJax_Preview">P_{loss}</span><script type="math/tex">P_{loss}</script></span>): 네트워크에서 발생하는 패킷 손실 비율을 최소화하기 위한 기술을 적용하여, 일정 수준 이상의 손실률을 넘지 않도록 관리한다. 패킷 손실률은 다음과 같이 정의된다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
P_{loss} = \frac{N_{lost}}{N_{total}} \times 100
</div>
<script type="math/tex; mode=display">
P_{loss} = \frac{N_{lost}}{N_{total}} \times 100
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N_{lost}</span><script type="math/tex">N_{lost}</script></span>는 손실된 패킷 수, <span class="arithmatex"><span class="MathJax_Preview">N_{total}</span><script type="math/tex">N_{total}</script></span>은 전송된 패킷의 총 수이다. QoS 기준에 따라 이 값을 제한하는 것이 중요하다.</p>
<ul>
<li><strong>지연 시간</strong> (<span class="arithmatex"><span class="MathJax_Preview">T_{delay}</span><script type="math/tex">T_{delay}</script></span>): 실시간 데이터 스트리밍에서 지연 시간은 서비스의 품질에 큰 영향을 미친다. QoS 관리에서는 지연 시간을 <span class="arithmatex"><span class="MathJax_Preview">T_{max}</span><script type="math/tex">T_{max}</script></span> 이하로 유지하도록 설계된다. 지연 시간은 데이터 패킷이 송신지에서 수신지까지 도달하는 데 걸리는 시간으로, 다음과 같이 정의할 수 있다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{delay} = T_{transmit} + T_{process} + T_{queue}
</div>
<script type="math/tex; mode=display">
T_{delay} = T_{transmit} + T_{process} + T_{queue}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T_{transmit}</span><script type="math/tex">T_{transmit}</script></span>은 전송 시간, <span class="arithmatex"><span class="MathJax_Preview">T_{process}</span><script type="math/tex">T_{process}</script></span>는 처리 시간, <span class="arithmatex"><span class="MathJax_Preview">T_{queue}</span><script type="math/tex">T_{queue}</script></span>는 네트워크 큐에서의 대기 시간을 나타낸다.</p>
<ul>
<li><strong>지터</strong> (<span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>): 지터는 패킷 간의 도착 시간의 변동성을 의미하며, 실시간 처리에서 중요한 요소이다. 지터는 패킷 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>와 패킷 <span class="arithmatex"><span class="MathJax_Preview">i+1</span><script type="math/tex">i+1</script></span>의 도착 시간 차이로 정의된다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
J = |(t_{i+1} - t_i) - (t_{i+1,expected} - t_{i,expected})|
</div>
<script type="math/tex; mode=display">
J = |(t_{i+1} - t_i) - (t_{i+1,expected} - t_{i,expected})|
</script>
</div>
<p>지터 값이 클수록 데이터 흐름의 일관성이 떨어져 실시간 처리에 부정적인 영향을 미친다.</p>
<h3 id="15">15. 실시간 데이터의 보안 문제</h3>
<p>포인트 클라우드 데이터의 실시간 스트리밍은 보안 문제를 동반할 수 있다. 특히 민감한 데이터나 중요한 인프라 데이터를 스트리밍할 때는 전송 중에 데이터가 유출되거나 변조되지 않도록 보안 대책이 필요하다.</p>
<p>주요 보안 기법은 다음과 같다:</p>
<ul>
<li><strong>암호화(Encryption)</strong>: 전송 중인 데이터 패킷을 암호화하여, 외부에서 데이터가 유출되거나 도난당하더라도 이를 해독하지 못하도록 한다. 실시간 스트리밍에서는 속도와 보안을 동시에 고려해야 하므로, 대칭키 암호화 방식이 자주 사용된다. 대칭키 암호화 방식에서 암호화 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{encrypt}</span><script type="math/tex">T_{encrypt}</script></span>는 데이터 크기 <span class="arithmatex"><span class="MathJax_Preview">S_{data}</span><script type="math/tex">S_{data}</script></span>와 암호화 알고리즘의 복잡도에 따라 달라지며, 다음과 같이 모델링된다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{encrypt} = \alpha \cdot S_{data}
</div>
<script type="math/tex; mode=display">
T_{encrypt} = \alpha \cdot S_{data}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 암호화 알고리즘의 성능 계수이다.</p>
<ul>
<li>
<p><strong>인증(Authentication)</strong>: 데이터가 신뢰할 수 있는 송신자로부터 온 것인지 확인하는 절차이다. 이를 통해 악의적인 사용자가 데이터를 위조하거나 변조하는 것을 방지할 수 있다. 인증 절차는 실시간 시스템에서는 속도가 매우 중요하므로, 빠른 인증 알고리즘을 사용하는 것이 일반적이다.</p>
</li>
<li>
<p><strong>무결성 확인(Integrity Check)</strong>: 데이터 전송 중에 데이터가 변조되지 않았는지 확인하기 위한 기술로, 해시 함수를 이용해 전송된 데이터의 무결성을 보장한다. 해시 기반 무결성 확인의 계산 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{hash}</span><script type="math/tex">T_{hash}</script></span>는 데이터 크기 <span class="arithmatex"><span class="MathJax_Preview">S_{data}</span><script type="math/tex">S_{data}</script></span>에 비례하며, 다음과 같이 표현된다:</p>
</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{hash} = \beta \cdot S_{data}
</div>
<script type="math/tex; mode=display">
T_{hash} = \beta \cdot S_{data}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span>는 해시 함수의 계산 복잡도를 나타낸다.</p>
<h3 id="16">16. 실시간 처리에서의 하드웨어 가속</h3>
<p>실시간 포인트 클라우드 스트리밍의 경우, 대용량 데이터를 빠르게 처리하기 위해 하드웨어 가속 기술을 사용하는 것이 필수적이다. GPU(Graphics Processing Unit)나 FPGA(Field-Programmable Gate Array)와 같은 하드웨어는 병렬 연산 능력이 뛰어나므로, 실시간 데이터 처리에 적합하다.</p>
<h4 id="gpu">GPU 기반 처리</h4>
<p>GPU는 다수의 코어를 활용하여 대량의 데이터 병렬 연산을 수행할 수 있다. 포인트 클라우드의 실시간 스트리밍에서는 특히 필터링, 클러스터링, 표면 재구성 등 복잡한 연산을 병렬화하여 처리 속도를 극대화할 수 있다.</p>
<p>GPU에서의 병렬 처리 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{gpu}</span><script type="math/tex">T_{gpu}</script></span>는 GPU 코어 수 <span class="arithmatex"><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>와 데이터 크기 <span class="arithmatex"><span class="MathJax_Preview">S_{data}</span><script type="math/tex">S_{data}</script></span>에 따라 다음과 같이 모델링된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{gpu} = \frac{S_{data}}{C}
</div>
<script type="math/tex; mode=display">
T_{gpu} = \frac{S_{data}}{C}
</script>
</div>
<p>GPU 코어 수가 많을수록 처리 시간이 줄어들며, 실시간 요구 사항을 충족할 가능성이 커진다.</p>
<h4 id="fpga">FPGA 기반 처리</h4>
<p>FPGA는 맞춤형 하드웨어로, 특정 연산을 빠르게 수행할 수 있도록 설계할 수 있다. FPGA 기반 스트리밍 시스템에서는 데이터 전송 및 필터링과 같은 작업을 하드웨어 레벨에서 최적화하여 매우 낮은 지연 시간을 제공할 수 있다.</p>
<p>FPGA에서의 처리 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{fpga}</span><script type="math/tex">T_{fpga}</script></span>는 하드웨어 구조의 최적화 수준에 따라 달라지며, 병렬 처리로 인해 CPU 기반 처리 시간보다 현저히 짧아질 수 있다.</p>
<h3 id="17">17. 실시간 포인트 클라우드 처리에서의 로봇 응용</h3>
<p>포인트 클라우드 데이터를 실시간으로 처리하는 중요한 응용 중 하나는 로봇 시스템에서의 활용이다. 자율 주행차, 드론, 산업용 로봇 등은 실시간으로 주변 환경을 인식하고 대응하기 위해 포인트 클라우드 데이터를 사용한다. 이때 실시간 스트리밍 환경에서 데이터를 처리하는 방법은 로봇의 작업 효율성과 안정성에 직결된다.</p>
<h4 id="_3">이동 로봇에서의 실시간 처리</h4>
<p>이동 로봇은 포인트 클라우드를 통해 주변 환경의 3D 지형을 인식하고, 이를 기반으로 경로를 계획한다. 실시간 경로 계획에서는 로봇이 이동하는 동안 지속적으로 데이터를 처리해야 하므로, 다음과 같은 문제가 발생할 수 있다:</p>
<ul>
<li><strong>경로 재계산 지연</strong>: 실시간 데이터를 기반으로 경로를 재계산하는 과정에서 지연 시간이 발생하면, 로봇이 충돌 위험에 처할 수 있다. 경로 재계산 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{recalc}</span><script type="math/tex">T_{recalc}</script></span>는 실시간 요구 사항을 충족하기 위해 충분히 작아야 하며, 다음과 같이 정의된다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{recalc} = T_{sense} + T_{compute} + T_{act}
</div>
<script type="math/tex; mode=display">
T_{recalc} = T_{sense} + T_{compute} + T_{act}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T_{sense}</span><script type="math/tex">T_{sense}</script></span>는 센서를 통해 데이터를 수집하는 시간, <span class="arithmatex"><span class="MathJax_Preview">T_{compute}</span><script type="math/tex">T_{compute}</script></span>는 경로 재계산 시간, <span class="arithmatex"><span class="MathJax_Preview">T_{act}</span><script type="math/tex">T_{act}</script></span>는 결과를 적용하여 로봇이 행동을 취하는 시간이다.</p>
<p>이러한 시간을 최소화하기 위해 로봇 시스템은 실시간 데이터를 병렬로 처리하는 알고리즘을 적용하며, 주로 GPU나 FPGA를 활용해 경로 계획을 가속화한다.</p>
<h4 id="_4">드론에서의 실시간 처리</h4>
<p>드론은 고속으로 이동하며 다양한 환경에서 장애물을 회피하고 임무를 수행한다. 드론에서 포인트 클라우드 데이터를 실시간으로 처리하는 것은 장애물 회피와 동시에 목표를 추적하는 데 매우 중요하다. 드론은 아래와 같은 실시간 처리 절차를 따른다:</p>
<div class="mermaid">graph TD;
    A[센서 데이터 수집] --&gt; B[실시간 장애물 감지]
    B --&gt; C[경로 계획]
    C --&gt; D[모터 제어 및 비행 경로 수정]
</div>
<p>드론에서의 실시간 처리에서는 데이터를 연속적으로 스트리밍하여 빠른 속도로 변화하는 환경에 즉시 반응해야 한다. 이를 위해 딥러닝 기반의 실시간 객체 감지 알고리즘이 적용될 수 있으며, 이러한 알고리즘은 주로 GPU에서 병렬 처리된다. 객체 감지 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{detect}</span><script type="math/tex">T_{detect}</script></span>는 데이터 크기와 네트워크 구조에 따라 달라지며, 다음과 같이 모델링될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{detect} = \frac{S_{data}}{C_{gpu}} + T_{model}
</div>
<script type="math/tex; mode=display">
T_{detect} = \frac{S_{data}}{C_{gpu}} + T_{model}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">C_{gpu}</span><script type="math/tex">C_{gpu}</script></span>는 GPU 코어 수, <span class="arithmatex"><span class="MathJax_Preview">T_{model}</span><script type="math/tex">T_{model}</script></span>은 모델 추론에 소요되는 시간이다.</p>
<h4 id="_5">산업용 로봇에서의 실시간 처리</h4>
<p>산업용 로봇은 제조 현장에서 물체를 인식하고, 정밀하게 작업을 수행하기 위해 포인트 클라우드 데이터를 활용한다. 실시간 데이터 스트리밍을 통해 로봇은 물체의 위치와 모양을 인식하고, 이에 맞춰 동작을 조정한다. 예를 들어, 로봇 팔은 실시간으로 업데이트된 포인트 클라우드 데이터를 이용해 물체를 집거나 조립 작업을 수행할 수 있다.</p>
<p>산업용 로봇에서의 처리 성능은 주로 <strong>밀리초 단위</strong>의 실시간성을 요구하며, 데이터 수집부터 작업 수행까지의 지연 시간을 최소화하는 것이 중요하다.</p>
<h3 id="18">18. 실시간 스트리밍 환경에서의 데이터 오류 처리</h3>
<p>실시간 데이터 스트리밍에서는 네트워크 혼잡이나 하드웨어 문제로 인해 데이터 오류가 발생할 수 있다. 특히 포인트 클라우드 데이터는 고정밀 데이터를 다루기 때문에, 오류 발생 시 정확한 처리가 필수적이다.</p>
<p>주요 오류 처리 방법은 다음과 같다:</p>
<ul>
<li><strong>패킷 손실 대응</strong>: 패킷 손실이 발생할 경우, 패킷을 재전송하거나 손실된 데이터를 예측하는 방식으로 복구할 수 있다. 재전송 기법은 주로 TCP 기반 통신에서 사용되며, 패킷을 재요청하는 데 따른 지연 시간을 줄이기 위해 손실률이 높은 경우 FEC(Forward Error Correction)와 같은 기법을 적용한다. FEC의 성능은 복원 가능한 패킷 수에 따라 모델링된다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
P_{recover} = P_{total} - P_{lost} \cdot \gamma
</div>
<script type="math/tex; mode=display">
P_{recover} = P_{total} - P_{lost} \cdot \gamma
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">P_{recover}</span><script type="math/tex">P_{recover}</script></span>는 복구된 패킷 수, <span class="arithmatex"><span class="MathJax_Preview">P_{total}</span><script type="math/tex">P_{total}</script></span>은 전송된 총 패킷 수, <span class="arithmatex"><span class="MathJax_Preview">P_{lost}</span><script type="math/tex">P_{lost}</script></span>는 손실된 패킷 수, <span class="arithmatex"><span class="MathJax_Preview">\gamma</span><script type="math/tex">\gamma</script></span>는 FEC 복원 계수이다.</p>
<ul>
<li><strong>데이터 왜곡 방지</strong>: 네트워크 문제로 인해 데이터가 손상되거나 왜곡될 수 있으며, 이를 방지하기 위해 데이터 무결성 체크 및 보정 알고리즘을 사용한다. 데이터 무결성은 해시 함수나 CRC(Cyclic Redundancy Check)를 통해 확인할 수 있으며, 이를 통해 전송 중 변조된 데이터를 탐지할 수 있다.</li>
</ul>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../2305/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../2305/">
        원격 로봇 제어를 위한 데이터 스트리밍 사례
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../2303/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../2303/">
        데이터 압축을 통한 전송 효율화
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>