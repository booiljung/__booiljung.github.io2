<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introduction_to_pointcloud_processing_with_pcl_library/chapter_17/1705/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>실시간 충돌 감지와 응용 사례 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc2e4\uc2dc\uac04 \ucda9\ub3cc \uac10\uc9c0\uc758 \uac1c\uc694", url: "#_top", children: [
              {title: "\ucda9\ub3cc \uac10\uc9c0 \ubaa8\ub378\ub9c1", url: "#_2" },
          ]},
          {title: "KD-\ud2b8\ub9ac \uae30\ubc18 \uac70\ub9ac \uacc4\uc0b0", url: "#kd-", children: [
              {title: "KD-\ud2b8\ub9ac \uad6c\ucd95", url: "#kd-_1" },
              {title: "KD-\ud2b8\ub9ac\uc5d0\uc11c\uc758 \uac70\ub9ac \uac80\uc0c9", url: "#kd-_2" },
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc640 \uba54\uc26c\uc758 \ucda9\ub3cc \uac10\uc9c0", url: "#_3", children: [
              {title: "\uba54\uc26c\uc758 \ud45c\uba74 \uc815\uc758", url: "#_4" },
              {title: "\ud3ec\uc778\ud2b8\uc640 \uba54\uc26c\uc758 \ucda9\ub3cc \uac10\uc9c0", url: "#_5" },
          ]},
          {title: "PCL\uc744 \uc774\uc6a9\ud55c \ucda9\ub3cc \uac10\uc9c0 \uc54c\uace0\ub9ac\uc998", url: "#pcl", children: [
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ucda9\ub3cc \uac10\uc9c0\uc758 \uc751\uc6a9 \ubd84\uc57c", url: "#_6", children: [
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ucda9\ub3cc \uac10\uc9c0\uc758 \ucd94\uac00 \uc751\uc6a9 \ubd84\uc57c", url: "#_7", children: [
          ]},
          {title: "\ud6a8\uc728\uc801\uc778 \ucda9\ub3cc \uac10\uc9c0\ub97c \uc704\ud55c \uc54c\uace0\ub9ac\uc998 \ucd5c\uc801\ud654", url: "#_8", children: [
              {title: "1. Voxelization\uc744 \ud1b5\ud55c \ub370\uc774\ud130 \ucd95\uc18c", url: "#1-voxelization" },
              {title: "2. Octree \uae30\ubc18 \ucda9\ub3cc \uac10\uc9c0", url: "#2-octree" },
              {title: "3. \ud788\uc2a4\ud1a0\uadf8\ub7a8 \uae30\ubc18 \ucd5c\uc801\ud654", url: "#3" },
          ]},
          {title: "GPU \uac00\uc18d\uc744 \ud1b5\ud55c \uc2e4\uc2dc\uac04 \ucda9\ub3cc \uac10\uc9c0", url: "#gpu", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_18/1801/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_18/1801/" class="btn btn-xs btn-link">
        딥러닝을 이용한 포인트 클라우드 처리
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1704/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1704/" class="btn btn-xs btn-link">
        동적 객체의 충돌 회피 전략
      </a>
    </div>
    
  </div>

    

    <p>실시간 충돌 감지는 포인트 클라우드를 처리하는 응용 분야에서 매우 중요한 주제이다. 다양한 산업에서 실시간 충돌 감지는 주로 자율주행, 로봇 공학, 시뮬레이션, 가상 현실, 증강 현실 등의 분야에서 적용되며, 시스템이 빠르고 정확하게 환경을 이해하고 반응하는 데 필요한 기술적 요구 사항을 다룬다.</p>
<h3 id="_1">실시간 충돌 감지의 개요</h3>
<p>포인트 클라우드를 이용한 실시간 충돌 감지에서는 두 가지 주요 과제가 있다: 계산 효율성과 정확성. 실시간으로 데이터가 지속적으로 들어오고 그에 따라 충돌 여부를 판단해야 하기 때문에, 시간 복잡도를 최소화하고 데이터 처리 속도를 극대화하는 것이 중요하다. 동시에 포인트 클라우드의 밀도와 노이즈로 인해 정확한 충돌 감지를 수행하는 것이 필요하다.</p>
<h4 id="_2">충돌 감지 모델링</h4>
<p>충돌 감지에서 주로 사용하는 기본 수학적 개념은 거리 계산이다. 주어진 두 객체 <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>의 충돌 여부를 확인하는 문제는 두 객체 간의 최소 거리를 계산하고, 이 거리가 임계값 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>보다 작은지 여부를 확인하는 방식으로 처리된다.</p>
<p>일반적으로 포인트 클라우드에서 충돌 감지를 수행할 때, 두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_A</span><script type="math/tex">\mathbf{P}_A</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_B</span><script type="math/tex">\mathbf{P}_B</script></span> 간의 모든 포인트 간 거리를 구하는 것이 비현실적이므로, 효율적인 거리 계산 방법이 필요하다. 이를 위해 <strong>KD-트리</strong>와 같은 공간 분할 자료 구조를 사용하여 거리 계산을 최적화한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{p}_A, \mathbf{p}_B) = \min_{\mathbf{p}_A \in \mathbf{P}_A, \mathbf{p}_B \in \mathbf{P}_B} || \mathbf{p}_A - \mathbf{p}_B ||
</div>
<script type="math/tex; mode=display">
d(\mathbf{p}_A, \mathbf{p}_B) = \min_{\mathbf{p}_A \in \mathbf{P}_A, \mathbf{p}_B \in \mathbf{P}_B} || \mathbf{p}_A - \mathbf{p}_B ||
</script>
</div>
<p>위 수식에서 <span class="arithmatex"><span class="MathJax_Preview">d(\mathbf{p}_A, \mathbf{p}_B)</span><script type="math/tex">d(\mathbf{p}_A, \mathbf{p}_B)</script></span>는 두 포인트 클라우드 사이의 최소 거리이며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_A</span><script type="math/tex">\mathbf{p}_A</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_B</span><script type="math/tex">\mathbf{p}_B</script></span>는 각각 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_A</span><script type="math/tex">\mathbf{P}_A</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_B</span><script type="math/tex">\mathbf{P}_B</script></span>에 속한 점이다. 충돌 감지는 이 최소 거리가 미리 정해둔 임계값 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>보다 작을 때 발생한다고 판단한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Collision} \iff d(\mathbf{p}_A, \mathbf{p}_B) &lt; \epsilon
</div>
<script type="math/tex; mode=display">
\text{Collision} \iff d(\mathbf{p}_A, \mathbf{p}_B) < \epsilon
</script>
</div>
<h3 id="kd-">KD-트리 기반 거리 계산</h3>
<p>실시간 충돌 감지에서 가장 중요한 성능 최적화 방법 중 하나는 공간 분할 기법인 <strong>KD-트리(K-Dimensional Tree)</strong>를 활용하는 것이다. KD-트리는 다차원 공간에서의 효율적인 검색을 가능하게 하며, 특히 고차원의 포인트 클라우드에서의 거리 계산 문제를 효율적으로 해결한다.</p>
<h4 id="kd-_1">KD-트리 구축</h4>
<p>KD-트리는 포인트 클라우드를 다차원 공간에서 재귀적으로 분할하는 이진 트리 구조이다. 각 노드는 특정 축을 기준으로 분할되며, 자식 노드에는 해당 축을 기준으로 좌측과 우측 공간에 속하는 포인트들이 포함된다. 이 과정을 반복하여 전체 포인트 클라우드를 여러 개의 부분 영역으로 나누어 저장한다. 트리의 각 노드는 하나의 공간을 정의하며, 트리를 순회하면서 가장 가까운 포인트를 찾는 방식으로 거리 계산이 수행된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T(\mathbf{P}) = \text{KD-Tree}(\mathbf{P})
</div>
<script type="math/tex; mode=display">
T(\mathbf{P}) = \text{KD-Tree}(\mathbf{P})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T(\mathbf{P})</span><script type="math/tex">T(\mathbf{P})</script></span>는 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>로부터 구축된 KD-트리를 나타낸다.</p>
<h4 id="kd-_2">KD-트리에서의 거리 검색</h4>
<p>KD-트리에서 두 포인트 클라우드 간의 최소 거리를 계산할 때는 트리를 탐색하며, 거리가 짧을 가능성이 있는 영역만을 집중적으로 검색한다. 이렇게 하면 전체 포인트 클라우드에 대해 일일이 거리를 계산하지 않아도 되므로 실시간 응답이 가능해진다.</p>
<p>충돌 여부를 판단하는 과정은 KD-트리의 노드를 탐색하며 진행된다. KD-트리의 각 노드는 공간을 정의하므로, 한 포인트 클라우드의 점이 다른 클라우드의 영역과 겹치는지 여부를 확인하는 방식으로 충돌을 감지할 수 있다.</p>
<h3 id="_3">포인트 클라우드와 메쉬의 충돌 감지</h3>
<p>실시간 충돌 감지에서 포인트 클라우드와 메쉬 간의 충돌 감지 또한 중요한 응용 사례이다. 포인트 클라우드는 보통 자율주행차 또는 드론 등의 센서로 수집된 데이터를 기반으로 하며, 메쉬는 정적인 물체를 표현하는 데 주로 사용된다. 포인트 클라우드와 메쉬 간의 충돌을 감지하려면 메쉬의 표면과 포인트 클라우드의 점들 간의 거리 계산이 필요하다.</p>
<h4 id="_4">메쉬의 표면 정의</h4>
<p>메쉬는 다각형, 주로 삼각형으로 구성된 객체의 표면을 나타낸다. 주어진 메쉬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span>는 각 삼각형의 정점을 포함하며, 각 삼각형은 세 개의 정점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}_1, \mathbf{v}_2, \mathbf{v}_3</span><script type="math/tex">\mathbf{v}_1, \mathbf{v}_2, \mathbf{v}_3</script></span>으로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{T}_i = \{ \mathbf{v}_1, \mathbf{v}_2, \mathbf{v}_3 \}, \quad \mathbf{M} = \cup_i \mathbf{T}_i
</div>
<script type="math/tex; mode=display">
\mathbf{T}_i = \{ \mathbf{v}_1, \mathbf{v}_2, \mathbf{v}_3 \}, \quad \mathbf{M} = \cup_i \mathbf{T}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_i</span><script type="math/tex">\mathbf{T}_i</script></span>는 메쉬의 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-번째 삼각형을 의미한다.</p>
<h4 id="_5">포인트와 메쉬의 충돌 감지</h4>
<p>포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 메쉬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span> 간의 충돌 감지를 위해서는 포인트 클라우드의 각 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>와 메쉬의 각 삼각형 간의 거리를 계산한다. 삼각형 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_i</span><script type="math/tex">\mathbf{T}_i</script></span>와 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span> 사이의 거리 <span class="arithmatex"><span class="MathJax_Preview">d(\mathbf{p}, \mathbf{T}_i)</span><script type="math/tex">d(\mathbf{p}, \mathbf{T}_i)</script></span>는 삼각형의 평면에 투영된 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>와 삼각형 내의 가장 가까운 점 사이의 거리로 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{p}, \mathbf{T}_i) = \min_{\mathbf{q} \in \mathbf{T}_i} || \mathbf{p} - \mathbf{q} ||
</div>
<script type="math/tex; mode=display">
d(\mathbf{p}, \mathbf{T}_i) = \min_{\mathbf{q} \in \mathbf{T}_i} || \mathbf{p} - \mathbf{q} ||
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span>는 삼각형 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_i</span><script type="math/tex">\mathbf{T}_i</script></span> 내의 점이다. 충돌 여부는 최소 거리가 임계값 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>보다 작을 때 발생한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Collision} \iff d(\mathbf{p}, \mathbf{T}_i) &lt; \epsilon
</div>
<script type="math/tex; mode=display">
\text{Collision} \iff d(\mathbf{p}, \mathbf{T}_i) < \epsilon
</script>
</div>
<p>이 계산은 KD-트리와 같은 공간 분할 기법을 사용하여 효율적으로 수행될 수 있다. 포인트 클라우드의 각 점에 대해 메쉬의 삼각형을 순차적으로 확인하지 않고, 특정 영역 내에 속하는 삼각형에 대해서만 계산을 수행한다.</p>
<h3 id="pcl">PCL을 이용한 충돌 감지 알고리즘</h3>
<p><strong>Point Cloud Library (PCL)</strong>은 포인트 클라우드를 처리하는 데 있어 강력한 라이브러리로, 실시간 충돌 감지를 위한 여러 알고리즘을 제공한다. 특히 PCL은 KD-트리와 같은 자료 구조를 사용하여 효율적인 거리 계산을 지원한다. PCL에서 제공하는 주요 함수 중 하나는 <strong>pcl::KdTreeFLANN</strong>이다. 이 클래스는 포인트 클라우드의 KD-트리를 구축하고, 가장 가까운 이웃을 효율적으로 검색할 수 있는 기능을 제공한다.</p>
<p>다음은 PCL을 이용하여 실시간 충돌 감지 알고리즘을 구현하는 기본적인 단계이다:</p>
<ol>
<li><strong>포인트 클라우드 데이터 로드 및 KD-트리 구축</strong>: 충돌 감지를 위한 두 포인트 클라우드를 불러오고, 이를 기반으로 KD-트리를 구축한다.</li>
</ol>
<pre><code class="language-cpp">pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_A (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_B (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

pcl::KdTreeFLANN&lt;pcl::PointXYZ&gt; kdtree;
kdtree.setInputCloud(cloud_B);
</code></pre>
<ol>
<li><strong>최소 거리 계산</strong>: KD-트리를 이용하여 각 점에 대한 최근접 이웃을 검색하고, 두 포인트 클라우드 간의 최소 거리를 계산한다.</li>
</ol>
<pre><code class="language-cpp">for (size_t i = 0; i &lt; cloud_A-&gt;points.size(); ++i) {
    std::vector&lt;int&gt; pointIdxNKNSearch(1);
    std::vector&lt;float&gt; pointNKNSquaredDistance(1);

    if (kdtree.nearestKSearch(cloud_A-&gt;points[i], 1, pointIdxNKNSearch, pointNKNSquaredDistance) &gt; 0) {
        float distance = sqrt(pointNKNSquaredDistance[0]);
        if (distance &lt; threshold) {
            // 충돌 감지
        }
    }
}
</code></pre>
<ol>
<li><strong>충돌 여부 판단</strong>: 계산된 최소 거리가 임계값 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>보다 작은지 여부를 확인하여 충돌을 감지한다.</li>
</ol>
<p>이 과정에서 중요한 부분은 KD-트리와 같은 공간 분할 자료 구조를 통해 실시간 처리 성능을 극대화하는 것이다.</p>
<h3 id="_6">실시간 충돌 감지의 응용 분야</h3>
<ol>
<li>
<p><strong>자율주행</strong>: 자율주행차는 라이다(LiDAR) 센서를 통해 주변 환경의 포인트 클라우드를 지속적으로 수집한다. 이를 통해 도로 위의 다른 차량, 보행자, 장애물과의 충돌을 실시간으로 감지하고, 그에 따라 안전한 경로를 설정한다.</p>
</li>
<li>
<p><strong>로봇 공학</strong>: 로봇은 실시간으로 주위 환경을 스캔하여 자신과 장애물 사이의 충돌을 감지하고 회피 동작을 실행한다. 포인트 클라우드를 활용한 충돌 감지 알고리즘은 로봇이 복잡한 환경에서도 원활하게 움직일 수 있도록 한다.</p>
</li>
<li>
<p><strong>증강 현실(AR)</strong>: AR 환경에서는 사용자가 실제 세계와 상호작용할 때 실시간 충돌 감지가 중요하다. AR 장치는 사용자의 움직임을 추적하고 주변 객체와의 충돌을 방지하기 위해 포인트 클라우드를 기반으로 실시간으로 환경을 분석한다.</p>
</li>
</ol>
<h3 id="_7">실시간 충돌 감지의 추가 응용 분야</h3>
<ol>
<li>
<p><strong>가상 현실(VR)</strong>: 가상 현실 시스템에서도 실시간 충돌 감지는 중요한 역할을 한다. 사용자가 가상 환경 내에서 자유롭게 이동할 때, 가상 객체와의 충돌을 감지하고 그에 맞는 피드백을 제공해야 한다. 이를 위해 사용자의 포지션을 포인트 클라우드로 표현하고, 가상 객체의 메쉬와의 충돌 여부를 실시간으로 판단한다.</p>
</li>
<li>
<p><strong>산업 자동화</strong>: 산업 로봇이 작업 공간 내에서 작업을 수행할 때, 실시간 충돌 감지를 통해 사람이나 다른 로봇과의 충돌을 피하는 것이 매우 중요하다. 이 경우, 로봇의 각 부위를 포인트 클라우드로 표현하고 작업 환경의 다른 객체들과의 충돌을 감지한다. 이를 통해 안전한 작업 환경을 보장하며, 실시간으로 장애물을 회피하는 기능을 제공한다.</p>
</li>
<li>
<p><strong>드론 및 무인 항공기(UAV)</strong>: 드론과 같은 무인 항공기는 비행 중에 장애물과의 충돌을 피하기 위해 실시간 충돌 감지 시스템을 활용한다. 특히 도시 환경이나 밀집된 구조물 사이를 비행할 때, 실시간으로 수집되는 포인트 클라우드를 기반으로 장애물을 탐지하고 비행 경로를 조정해야 한다. 드론의 센서에서 실시간으로 들어오는 데이터를 처리하여, 주변 객체와의 거리를 계산하고 충돌 위험이 감지되면 회피 동작을 수행한다.</p>
</li>
<li>
<p><strong>시뮬레이션 및 물리 엔진</strong>: 다양한 시뮬레이션 시스템에서는 가상의 객체 간 충돌을 실시간으로 감지하고 처리할 수 있어야 한다. 예를 들어, 건설 기계의 동작을 시뮬레이션할 때, 포인트 클라우드와 메쉬를 사용하여 기계와 구조물 간의 충돌을 감지하고, 충돌에 따른 피드백을 제공한다. 이러한 시스템은 교육, 훈련, 설계 검증 등에서 중요한 역할을 한다.</p>
</li>
</ol>
<h3 id="_8">효율적인 충돌 감지를 위한 알고리즘 최적화</h3>
<p>실시간으로 충돌을 감지하려면, 계산 성능이 중요한 문제로 대두된다. 포인트 클라우드 데이터가 매우 크거나, 복잡한 객체가 포함된 메쉬와 상호작용하는 경우, 충돌 감지의 성능이 저하될 수 있다. 이를 해결하기 위해 몇 가지 최적화 기법을 사용할 수 있다.</p>
<h4 id="1-voxelization">1. Voxelization을 통한 데이터 축소</h4>
<p>Voxelization은 3차원 공간을 작은 셀, 즉 "Voxel"로 분할하는 과정이다. 이를 통해 포인트 클라우드를 적절한 크기의 격자로 변환하고, 각 Voxel 내의 데이터를 요약함으로써 데이터 양을 줄일 수 있다. 이렇게 축소된 데이터를 사용하면 충돌 감지 알고리즘의 성능을 크게 향상시킬 수 있다. Voxelization은 공간 분할의 일종으로, 비슷한 범위 내에 있는 점들을 한 묶음으로 처리하여 계산을 최적화하는 데 기여한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
V(\mathbf{P}) = \{ V_1, V_2, \dots, V_n \}, \quad V_i = \text{Voxel}(\mathbf{p}_i)
</div>
<script type="math/tex; mode=display">
V(\mathbf{P}) = \{ V_1, V_2, \dots, V_n \}, \quad V_i = \text{Voxel}(\mathbf{p}_i)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">V(\mathbf{P})</span><script type="math/tex">V(\mathbf{P})</script></span>는 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>의 각 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>가 속한 Voxel들의 집합이다.</p>
<p>Voxelization을 통해 포인트 클라우드의 점들을 적절하게 그룹화하면, 각 Voxel 단위에서 충돌 여부를 판단할 수 있어 계산량이 크게 감소한다.</p>
<h4 id="2-octree">2. Octree 기반 충돌 감지</h4>
<p>Octree는 3차원 공간을 8개의 서브 공간으로 재귀적으로 분할하는 자료 구조이다. Octree는 KD-트리와 비슷한 개념으로, 포인트 클라우드를 적은 수의 큰 셀로 나눈 후, 충돌 가능성이 있는 셀만 집중적으로 탐색함으로써 계산 효율성을 높인다. Octree를 사용하면 충돌 가능성이 없는 공간을 빠르게 무시할 수 있다.</p>
<p>Octree는 다음과 같은 방식으로 충돌 감지에 적용된다:</p>
<ol>
<li>포인트 클라우드 데이터를 Octree 구조로 저장.</li>
<li>메쉬 또는 다른 포인트 클라우드와의 충돌 여부를 확인할 때, Octree 노드 간의 거리 계산을 수행.</li>
<li>충돌 가능성이 있는 노드만을 탐색하여 계산을 최소화.</li>
</ol>
<h4 id="3">3. 히스토그램 기반 최적화</h4>
<p>실시간 충돌 감지에서 계산 비용을 줄이기 위한 또 다른 방법은 포인트 클라우드의 밀도 히스토그램을 사용하는 것이다. 이 방법은 포인트 클라우드에서 점들의 분포를 히스토그램으로 표현하고, 밀도가 높은 영역에 대해 우선적으로 계산을 수행하는 방식이다. 밀도가 낮은 영역은 충돌 가능성이 낮다고 가정하고 탐색을 줄이는 방식으로 최적화를 진행할 수 있다.</p>
<h3 id="gpu">GPU 가속을 통한 실시간 충돌 감지</h3>
<p>실시간으로 포인트 클라우드를 처리하기 위해서는 GPU 가속 기법을 사용할 수 있다. 특히 대규모 데이터의 병렬 처리를 위해서는 CUDA와 같은 GPU 기반 프로그래밍 모델을 활용하는 것이 효과적이다. GPU는 수천 개의 코어를 사용하여 동시에 여러 점에 대한 거리 계산을 병렬로 수행할 수 있어, CPU에 비해 훨씬 빠른 속도로 충돌 감지를 실행할 수 있다.</p>
<p>CUDA 기반의 KD-트리 및 Octree 구현은 대규모 포인트 클라우드 데이터 처리 시 성능을 크게 향상시킨다. 특히 자율주행차나 드론과 같은 실시간 시스템에서는 초당 수천 개 이상의 포인트를 처리해야 하므로, GPU 가속은 필수적이다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_18/1801/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_18/1801/" class="btn btn-xs btn-link">
        딥러닝을 이용한 포인트 클라우드 처리
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1704/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1704/" class="btn btn-xs btn-link">
        동적 객체의 충돌 회피 전략
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>