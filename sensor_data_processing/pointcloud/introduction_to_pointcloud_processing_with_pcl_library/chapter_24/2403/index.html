<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introduction_to_pointcloud_processing_with_pcl_library/chapter_24/2403/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>로봇 시뮬레이션과 센서 데이터 활용 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc13c\uc11c \ub370\uc774\ud130\uc758 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ubcc0\ud658", url: "#_top", children: [
          ]},
          {title: "\ub85c\ubd07 \uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c \uc13c\uc11c \ub178\uc774\uc988\uc758 \ucc98\ub9ac", url: "#_2", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uae30\ubc18\uc758 \ud658\uacbd \uc778\uc2dd", url: "#_3", children: [
              {title: "\ud3ec\uc778\ud2b8 \ubc00\ub3c4 \ubd84\uc11d", url: "#_4" },
          ]},
          {title: "\uacbd\ub85c \uacc4\ud68d\uc5d0\uc11c\uc758 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ud65c\uc6a9", url: "#_5", children: [
              {title: "\uc810 \uae30\ubc18 \uacbd\ub85c \uacc4\ud68d", url: "#_6" },
          ]},
          {title: "\ucda9\ub3cc \uac10\uc9c0", url: "#_7", children: [
              {title: "\ucda9\ub3cc \uac10\uc9c0\uc758 \uae30\ud558\ud559\uc801 \ubaa8\ub378\ub9c1", url: "#_8" },
          ]},
          {title: "\uc13c\uc11c \ub370\uc774\ud130\uc758 \ub3d9\uc801 \uc5c5\ub370\uc774\ud2b8", url: "#_9", children: [
              {title: "\ub3d9\uc801 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub370\uc774\ud130 \uad6c\uc870", url: "#_10" },
          ]},
          {title: "\uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c\uc758 \uc2dc\uac04\uc801 \uc694\uc18c \ucc98\ub9ac", url: "#_12", children: [
              {title: "\uc2dc\uac04\uc5d0 \ub530\ub978 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc758 \uac31\uc2e0", url: "#_13" },
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ubd84\uc11d\uacfc \uacbd\ub85c \uc218\uc815", url: "#_14", children: [
              {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc758 \uc2e4\uc2dc\uac04 \uc5c5\ub370\uc774\ud2b8", url: "#_15" },
              {title: "\uacbd\ub85c \uc218\uc815 \uc54c\uace0\ub9ac\uc998", url: "#_16" },
          ]},
          {title: "\uc13c\uc11c \uc735\ud569\uc744 \ud1b5\ud55c \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uac1c\uc120", url: "#_17", children: [
              {title: "\ub77c\uc774\ub2e4\uc640 \uce74\uba54\ub77c \ub370\uc774\ud130 \uc735\ud569", url: "#_18" },
          ]},
          {title: "\ub85c\ubd07\uc758 \uc790\uc728 \uc8fc\ud589 \uc2dc\ubbac\ub808\uc774\uc158", url: "#_19", children: [
              {title: "\uacbd\ub85c \ucd5c\uc801\ud654", url: "#_20" },
          ]},
          {title: "\uc13c\uc11c \uc735\ud569\uc744 \ud1b5\ud55c \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uac1c\uc120", url: "#_21", children: [
              {title: "\uce7c\ub9cc \ud544\ud130\ub97c \uc774\uc6a9\ud55c \uc13c\uc11c \uc735\ud569", url: "#_22" },
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ucc98\ub9ac\uc5d0\uc11c\uc758 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ud544\ud130\ub9c1", url: "#_23", children: [
              {title: "\ub2e4\uc6b4\uc0d8\ud50c\ub9c1", url: "#_24" },
              {title: "\ub178\uc774\uc988 \uc81c\uac70", url: "#_25" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2404/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2404/" class="btn btn-xs btn-link">
        PCL을 이용한 충돌 시뮬레이션
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2402/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2402/" class="btn btn-xs btn-link">
        가상 환경에서의 포인트 클라우드 생성
      </a>
    </div>
    
  </div>

    

    <p>로봇 시뮬레이션에서 포인트 클라우드를 활용하는 것은 주로 환경 인식, 경로 계획, 그리고 충돌 감지 등의 목적으로 사용된다. 센서 데이터는 로봇의 시뮬레이션에서 가상 환경을 실제 환경처럼 동작하도록 만드는 중요한 역할을 한다. 다양한 센서들, 특히 라이다(LiDAR)와 같은 3D 스캐너는 실시간으로 로봇이 주변 환경을 탐지하고 분석하는데 필요한 데이터를 제공한다.</p>
<h2 id="_1">센서 데이터의 포인트 클라우드 변환</h2>
<p>센서에서 얻은 원시 데이터는 보통 거리 정보와 각도 정보로 이루어지며, 이를 포인트 클라우드로 변환하여 3D 공간의 점들을 얻는다. 라이다 센서를 예로 들면, 각 스캔에서 \mathbf{p} = (x, y, z) 좌표를 얻기 위해 거리 <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>과 각도 <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>를 사용하여 다음과 같은 관계를 이용한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i = 
\begin{pmatrix}
x_i \\
y_i \\
z_i
\end{pmatrix}
=
\begin{pmatrix}
r_i \sin \theta_i \cos \phi_i \\
r_i \sin \theta_i \sin \phi_i \\
r_i \cos \theta_i
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i = 
\begin{pmatrix}
x_i \\
y_i \\
z_i
\end{pmatrix}
=
\begin{pmatrix}
r_i \sin \theta_i \cos \phi_i \\
r_i \sin \theta_i \sin \phi_i \\
r_i \cos \theta_i
\end{pmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">r_i</span><script type="math/tex">r_i</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-번째 포인트에 대한 거리, <span class="arithmatex"><span class="MathJax_Preview">\theta_i</span><script type="math/tex">\theta_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\phi_i</span><script type="math/tex">\phi_i</script></span>는 각각 세로 및 가로 방향의 각도를 나타낸다. 이를 통해 로봇은 주변 환경의 3차원 구조를 포인트 클라우드 형식으로 표현할 수 있다.</p>
<h2 id="_2">로봇 시뮬레이션에서 센서 노이즈의 처리</h2>
<p>로봇 시뮬레이션에서는 현실 세계의 불확실성과 비슷한 효과를 구현하기 위해 센서 노이즈를 추가적으로 고려해야 한다. 일반적으로 센서 노이즈는 가우시안 분포를 따르는 랜덤 변동으로 모델링된다. 예를 들어, 거리 <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>의 측정 노이즈는 다음과 같은 형태로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
r_{\text{measured}} = r_{\text{true}} + \mathcal{N}(0, \sigma^2)
</div>
<script type="math/tex; mode=display">
r_{\text{measured}} = r_{\text{true}} + \mathcal{N}(0, \sigma^2)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{N}(0, \sigma^2)</span><script type="math/tex">\mathcal{N}(0, \sigma^2)</script></span>는 평균이 0이고 분산이 <span class="arithmatex"><span class="MathJax_Preview">\sigma^2</span><script type="math/tex">\sigma^2</script></span>인 가우시안 노이즈이다. 시뮬레이션 내에서 이러한 노이즈를 적용하면 더 현실적인 센서 데이터를 생성할 수 있으며, 이를 통해 로봇이 불완전한 정보를 기반으로 작업하는 능력을 테스트할 수 있다.</p>
<h2 id="_3">포인트 클라우드 기반의 환경 인식</h2>
<p>로봇 시뮬레이션에서 포인트 클라우드는 환경 인식의 핵심 데이터로 사용된다. 로봇이 수집한 포인트 클라우드는 주변의 지형, 장애물, 그리고 이동 가능한 영역을 인식하는 데 활용된다. 예를 들어, 특정 범위 내에서 장애물을 탐지하기 위해 포인트 클라우드의 밀집도를 분석하는 방법이 있다. 포인트 클라우드 데이터는 종종 다음과 같은 수학적 방법을 통해 처리된다:</p>
<h3 id="_4">포인트 밀도 분석</h3>
<p>로봇의 시뮬레이션 환경에서 장애물을 탐지하는 데 중요한 요소는 포인트 밀도이다. 특정 영역에서 포인트 밀도가 일정 이상일 경우, 해당 영역이 장애물로 간주될 수 있다. 이를 위해 \mathbf{p}_i = (x_i, y_i, z_i)로 이루어진 포인트 클라우드 집합 \mathcal{P}에서 특정 반경 <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> 내에 포함된 포인트의 개수 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>을 계산할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
N = \sum_{i=1}^{n} \mathbb{I}(\|\mathbf{p}_i - \mathbf{p}_0\| &lt; r)
</div>
<script type="math/tex; mode=display">
N = \sum_{i=1}^{n} \mathbb{I}(\|\mathbf{p}_i - \mathbf{p}_0\| < r)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbb{I}(\cdot)</span><script type="math/tex">\mathbb{I}(\cdot)</script></span>는 인디케이터 함수로, 조건이 참일 때 1을 반환하고, 거짓일 때 0을 반환한다. 이를 통해 특정 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_0</span><script type="math/tex">\mathbf{p}_0</script></span>에서 반경 <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> 내의 밀집도를 평가할 수 있다.</p>
<h2 id="_5">경로 계획에서의 포인트 클라우드 활용</h2>
<p>포인트 클라우드를 기반으로 한 경로 계획은 로봇 시뮬레이션에서 필수적인 역할을 한다. 로봇은 주어진 목표 지점으로 안전하게 이동하기 위해 장애물과의 충돌을 피하면서 최적 경로를 계산해야 한다. 이를 위해 로봇은 실시간으로 수집된 포인트 클라우드 데이터를 분석하고, 이를 통해 환경의 구조를 이해하게 된다.</p>
<h3 id="_6">점 기반 경로 계획</h3>
<p>포인트 클라우드 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{P} = \{ \mathbf{p}_1, \mathbf{p}_2, \ldots, \mathbf{p}_n \}</span><script type="math/tex">\mathcal{P} = \{ \mathbf{p}_1, \mathbf{p}_2, \ldots, \mathbf{p}_n \}</script></span>에서 로봇이 목표 지점까지의 경로를 계획할 때, 로봇의 현재 위치를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}_0 = (x_0, y_0, z_0)</span><script type="math/tex">\mathbf{r}_0 = (x_0, y_0, z_0)</script></span>, 목표 지점을 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{g} = (x_g, y_g, z_g)</span><script type="math/tex">\mathbf{g} = (x_g, y_g, z_g)</script></span>라고 하자. 경로를 찾기 위해서는 장애물과의 최소 거리를 유지하는 동시에 가능한 짧은 경로를 선택해야 한다.</p>
<p>이를 해결하기 위해 A<em> 알고리즘과 같은 경로 탐색 알고리즘을 사용하여 로봇의 이동 경로를 계산할 수 있다. A</em> 알고리즘에서 비용 함수 <span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{r})</span><script type="math/tex">f(\mathbf{r})</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(\mathbf{r}) = g(\mathbf{r}) + h(\mathbf{r})
</div>
<script type="math/tex; mode=display">
f(\mathbf{r}) = g(\mathbf{r}) + h(\mathbf{r})
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">g(\mathbf{r})</span><script type="math/tex">g(\mathbf{r})</script></span>는 출발 지점에서 현재 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}</span><script type="math/tex">\mathbf{r}</script></span>까지의 실제 경로 비용,
- <span class="arithmatex"><span class="MathJax_Preview">h(\mathbf{r})</span><script type="math/tex">h(\mathbf{r})</script></span>는 휴리스틱 함수로, 현재 위치에서 목표 지점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{g}</span><script type="math/tex">\mathbf{g}</script></span>까지의 예상 비용이다.</p>
<p>포인트 클라우드 기반의 경로 계획에서는 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해 장애물 여부를 판단하여, 장애물이 없는 경로를 선택하는 것이 중요하다. 이때 각 포인트에 대해 장애물 여부를 판단하는 함수는 보통 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbb{I}_{\text{obstacle}}(\mathbf{p}_i) =
\begin{cases}
1, &amp; \text{if } \|\mathbf{p}_i - \mathbf{r}\| &lt; \epsilon \\
0, &amp; \text{otherwise}
\end{cases}
</div>
<script type="math/tex; mode=display">
\mathbb{I}_{\text{obstacle}}(\mathbf{p}_i) =
\begin{cases}
1, & \text{if } \|\mathbf{p}_i - \mathbf{r}\| < \epsilon \\
0, & \text{otherwise}
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>은 로봇과 장애물 사이의 최소 거리 기준이다. 이 함수는 주어진 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>가 로봇 경로 상에서 충돌할 가능성이 있는지 여부를 결정하는 데 사용된다.</p>
<h2 id="_7">충돌 감지</h2>
<p>로봇 시뮬레이션에서 중요한 부분 중 하나는 충돌 감지이다. 실시간으로 로봇의 경로와 환경의 포인트 클라우드를 비교하여 충돌 가능성을 미리 예측하는 것이 필요하다. 충돌 감지는 주로 로봇의 크기와 이동 방향을 고려한 볼륨 내에서 포인트 클라우드 데이터를 분석하여 이루어진다.</p>
<h3 id="_8">충돌 감지의 기하학적 모델링</h3>
<p>로봇을 단순한 구 형태의 모델로 가정하고, 로봇의 중심 좌표를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r} = (x_r, y_r, z_r)</span><script type="math/tex">\mathbf{r} = (x_r, y_r, z_r)</script></span>, 반지름을 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>라고 하자. 로봇이 충돌하는지를 판단하기 위해, 로봇의 현재 위치에서 반지름 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span> 이내에 포인트 클라우드 상의 점들이 존재하는지를 확인한다. 이를 수학적으로 표현하면, 충돌 여부는 다음과 같은 함수로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbb{I}_{\text{collision}} = \max_{i=1}^{n} \mathbb{I}(\|\mathbf{p}_i - \mathbf{r}\| &lt; R)
</div>
<script type="math/tex; mode=display">
\mathbb{I}_{\text{collision}} = \max_{i=1}^{n} \mathbb{I}(\|\mathbf{p}_i - \mathbf{r}\| < R)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbb{I}(\cdot)</span><script type="math/tex">\mathbb{I}(\cdot)</script></span>는 충돌이 발생하면 1을 반환하고, 충돌이 없으면 0을 반환하는 인디케이터 함수이다. 만약 <span class="arithmatex"><span class="MathJax_Preview">\|\mathbf{p}_i - \mathbf{r}\| &lt; R</span><script type="math/tex">\|\mathbf{p}_i - \mathbf{r}\| < R</script></span>인 점이 존재하면 충돌이 발생한 것으로 간주한다.</p>
<p>또한, 로봇의 속도를 고려하여 다음과 같은 예측 충돌 모델을 만들 수 있다. 로봇의 속도를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v} = (v_x, v_y, v_z)</span><script type="math/tex">\mathbf{v} = (v_x, v_y, v_z)</script></span>라고 할 때, 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 후 로봇의 위치는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}(t) = \mathbf{r}_0 + \mathbf{v} t</span><script type="math/tex">\mathbf{r}(t) = \mathbf{r}_0 + \mathbf{v} t</script></span>로 표현된다. 따라서 미래의 충돌 여부를 예측하기 위해서는 포인트 클라우드 상의 점들과의 거리를 시간에 따라 계산하여 충돌 가능성을 판단할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbb{I}_{\text{collision}}(t) = \max_{i=1}^{n} \mathbb{I}(\|\mathbf{p}_i - (\mathbf{r}_0 + \mathbf{v} t)\| &lt; R)
</div>
<script type="math/tex; mode=display">
\mathbb{I}_{\text{collision}}(t) = \max_{i=1}^{n} \mathbb{I}(\|\mathbf{p}_i - (\mathbf{r}_0 + \mathbf{v} t)\| < R)
</script>
</div>
<p>이 모델은 로봇의 실시간 경로 계획에 사용되며, 충돌이 예상되는 경우 경로를 즉시 재계산하여 회피 동작을 수행할 수 있다.</p>
<h2 id="_9">센서 데이터의 동적 업데이트</h2>
<p>로봇 시뮬레이션에서 중요한 점 중 하나는 센서 데이터의 동적 업데이트이다. 로봇이 이동하면서 실시간으로 수집되는 포인트 클라우드를 반영하여 경로 계획, 환경 인식, 그리고 충돌 감지 등을 수행해야 한다. 이는 실시간 처리 및 높은 성능의 데이터 구조가 요구되며, 특히 포인트 클라우드를 빠르게 검색하고 업데이트할 수 있는 방법이 필요하다.</p>
<h3 id="_10">동적 포인트 클라우드 데이터 구조</h3>
<p>포인트 클라우드 데이터는 수백만 개 이상의 점으로 이루어져 있어 실시간으로 처리하기에 매우 방대하다. 이를 효율적으로 처리하기 위해 다양한 데이터 구조가 사용되며, 특히 K-D 트리(K-D tree)와 옥트리(Octree)가 널리 사용된다.</p>
<h4 id="k-d">K-D 트리</h4>
<p>K-D 트리는 고차원 공간에서 포인트를 검색하는데 적합한 데이터 구조이다. 포인트 클라우드 데이터를 K-D 트리에 저장하면 특정 영역에서의 포인트를 빠르게 검색할 수 있다. K-D 트리는 각 차원별로 데이터를 분할하여 트리 구조로 구성하며, 다음과 같은 연산을 효율적으로 처리할 수 있다:</p>
<ul>
<li>
<p><strong>최근접 이웃 검색</strong>: 특정 위치에서 가장 가까운 포인트를 검색하는 연산으로, 로봇이 주변 환경에서 가장 가까운 장애물을 탐지할 때 유용하다.</p>
</li>
<li>
<p><strong>범위 검색</strong>: 주어진 반경 내의 포인트들을 검색하는 연산으로, 충돌 감지와 같은 작업에서 사용된다.</p>
</li>
</ul>
<p>K-D 트리를 이용한 최근접 이웃 검색은 다음과 같은 수학적 표현을 가진다. 로봇의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}</span><script type="math/tex">\mathbf{r}</script></span>에서 가장 가까운 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_\text{nearest}</span><script type="math/tex">\mathbf{p}_\text{nearest}</script></span>를 찾기 위한 문제는 다음과 같은 최적화 문제로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_\text{nearest} = \arg \min_{\mathbf{p}_i \in \mathcal{P}} \|\mathbf{p}_i - \mathbf{r}\|
</div>
<script type="math/tex; mode=display">
\mathbf{p}_\text{nearest} = \arg \min_{\mathbf{p}_i \in \mathcal{P}} \|\mathbf{p}_i - \mathbf{r}\|
</script>
</div>
<p>이 최적화 문제는 K-D 트리를 이용하면 빠르게 해결할 수 있다.</p>
<h4 id="_11">옥트리</h4>
<p>옥트리는 3차원 공간을 효율적으로 분할하는데 적합한 데이터 구조이다. 옥트리는 공간을 8개의 균등한 영역으로 분할하며, 각 노드가 다시 8개의 하위 노드로 분할되는 구조를 가진다. 옥트리는 다음과 같은 특성 때문에 로봇 시뮬레이션에서 널리 사용된다:</p>
<ul>
<li>
<p><strong>효율적인 메모리 사용</strong>: 옥트리는 공간 내의 데이터 밀도에 따라 동적으로 크기가 변하므로, 메모리 사용을 최적화할 수 있다.</p>
</li>
<li>
<p><strong>빠른 공간 분할</strong>: 로봇이 이동할 때, 특정 공간 내의 포인트들을 빠르게 검색하고, 충돌 여부를 판단하는 데 적합하다.</p>
</li>
</ul>
<p>옥트리를 이용하여 범위 내 포인트를 검색하는 과정은 특정 영역에 포함된 포인트를 찾는 문제로 표현되며, 이는 다음과 같은 수식으로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathcal{P}_\text{range} = \{ \mathbf{p}_i \in \mathcal{P} \mid \mathbf{r} - r_\text{search} \leq \mathbf{p}_i \leq \mathbf{r} + r_\text{search} \}
</div>
<script type="math/tex; mode=display">
\mathcal{P}_\text{range} = \{ \mathbf{p}_i \in \mathcal{P} \mid \mathbf{r} - r_\text{search} \leq \mathbf{p}_i \leq \mathbf{r} + r_\text{search} \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">r_\text{search}</span><script type="math/tex">r_\text{search}</script></span>는 검색 반경을 의미하며, 이 범위 내에 있는 포인트들을 옥트리를 통해 빠르게 찾을 수 있다.</p>
<h2 id="_12">시뮬레이션에서의 시간적 요소 처리</h2>
<p>로봇 시뮬레이션에서 중요한 또 다른 요소는 시간적 요소이다. 로봇이 이동하면서 시간이 흐름에 따라 포인트 클라우드 데이터가 지속적으로 업데이트되며, 이를 실시간으로 반영해야 한다. 이러한 동적인 시뮬레이션 환경에서 시간의 흐름에 따라 데이터가 어떻게 변하는지를 처리하는 방식이 시뮬레이션의 성능을 결정한다.</p>
<h3 id="_13">시간에 따른 포인트 클라우드의 갱신</h3>
<p>로봇이 시뮬레이션 환경에서 움직이는 동안, 각 센서는 시간에 따라 새로운 포인트 클라우드 데이터를 계속 수집한다. 이를 처리하기 위해서는 주기적으로 포인트 클라우드 데이터를 갱신하고, 기존 데이터를 삭제하거나 새로운 데이터를 추가하는 작업이 필요하다.</p>
<p>센서가 매 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 간격으로 데이터를 수집한다고 가정할 때, 시간 <span class="arithmatex"><span class="MathJax_Preview">t_1, t_2, t_3, \ldots</span><script type="math/tex">t_1, t_2, t_3, \ldots</script></span>에서 얻어진 포인트 클라우드를 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{P}_{t_1}, \mathcal{P}_{t_2}, \mathcal{P}_{t_3}, \ldots</span><script type="math/tex">\mathcal{P}_{t_1}, \mathcal{P}_{t_2}, \mathcal{P}_{t_3}, \ldots</script></span>로 나타낼 수 있다. 시뮬레이션에서는 과거 데이터를 일정 시간 동안 유지하며, 그 이후에는 제거하는 방식으로 데이터를 관리한다. 이러한 데이터 관리는 다음과 같이 수식으로 표현될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathcal{P}(t) = \bigcup_{t_i=t-T}^{t} \mathcal{P}_{t_i}
</div>
<script type="math/tex; mode=display">
\mathcal{P}(t) = \bigcup_{t_i=t-T}^{t} \mathcal{P}_{t_i}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 유지할 시간 범위를 나타낸다. 즉, 시뮬레이션에서는 최근 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> 시간 동안의 포인트 클라우드 데이터만을 유지하며, 이 데이터를 기반으로 경로 계획과 충돌 감지를 수행한다.</p>
<h2 id="_14">실시간 포인트 클라우드 분석과 경로 수정</h2>
<p>실시간으로 수집되는 포인트 클라우드 데이터는 지속적으로 로봇의 경로를 수정하고, 장애물 회피를 위한 동작을 수행하는 데 매우 유용하다. 이를 위해 로봇은 반복적으로 포인트 클라우드를 분석하고, 새롭게 인식된 장애물에 따라 경로를 변경해야 한다. 이 과정은 로봇의 이동 경로가 최적화되면서 동시에 충돌을 방지하도록 동작한다.</p>
<h3 id="_15">포인트 클라우드의 실시간 업데이트</h3>
<p>포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{P}_t = \{ \mathbf{p}_1(t), \mathbf{p}_2(t), \ldots, \mathbf{p}_n(t) \}</span><script type="math/tex">\mathcal{P}_t = \{ \mathbf{p}_1(t), \mathbf{p}_2(t), \ldots, \mathbf{p}_n(t) \}</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에 따라 계속 변화하며, 로봇이 이동하면서 새로운 데이터가 센서로부터 입력된다. 이러한 데이터는 실시간으로 처리되어 로봇의 현재 경로가 업데이트된다. 새로운 포인트 클라우드 데이터는 다음과 같은 절차로 처리된다:</p>
<ol>
<li>포인트 클라우드 수집: 센서로부터 수집된 데이터를 기반으로 실시간 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{P}_t</span><script type="math/tex">\mathcal{P}_t</script></span>가 생성된다.</li>
<li>충돌 감지: 위에서 설명한 충돌 감지 기법을 사용하여 현재 경로 상의 장애물을 탐지한다.</li>
<li>경로 재계산: 충돌이 예상되면, A* 알고리즘과 같은 경로 탐색 알고리즘을 통해 안전한 새로운 경로가 계산된다.</li>
</ol>
<h3 id="_16">경로 수정 알고리즘</h3>
<p>경로 수정 알고리즘은 로봇이 현재의 이동 경로에서 충돌이 감지되었을 때 즉각적으로 작동한다. 이를 위해 장애물이 발견된 구간을 제외하고, 새로운 경로를 계산해야 한다. 이때 사용되는 비용 함수는 기존 경로와의 차이를 최소화하면서 안전한 경로를 찾는 것을 목표로 한다. 이를 수학적으로 표현하면, 새로운 경로 <span class="arithmatex"><span class="MathJax_Preview">f_{\text{new}}(\mathbf{r})</span><script type="math/tex">f_{\text{new}}(\mathbf{r})</script></span>는 기존 경로 <span class="arithmatex"><span class="MathJax_Preview">f_{\text{old}}(\mathbf{r})</span><script type="math/tex">f_{\text{old}}(\mathbf{r})</script></span>와의 차이를 줄이는 비용 함수로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f_{\text{new}}(\mathbf{r}) = f_{\text{old}}(\mathbf{r}) + \lambda \cdot \mathbb{I}_{\text{collision}}(\mathbf{r})
</div>
<script type="math/tex; mode=display">
f_{\text{new}}(\mathbf{r}) = f_{\text{old}}(\mathbf{r}) + \lambda \cdot \mathbb{I}_{\text{collision}}(\mathbf{r})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>는 경로 수정에 대한 가중치를 나타내며, 충돌 가능성이 높은 경로는 높은 비용을 부여하여 경로 선택에서 제외된다.</p>
<h2 id="_17">센서 융합을 통한 포인트 클라우드 개선</h2>
<p>단일 센서만을 사용하는 대신, 여러 센서에서 얻은 데이터를 융합하여 더 정확한 포인트 클라우드를 생성할 수 있다. 예를 들어, 라이다와 카메라 데이터를 융합하면 각 센서의 단점을 보완하여 더 풍부한 환경 정보를 제공할 수 있다.</p>
<h3 id="_18">라이다와 카메라 데이터 융합</h3>
<p>라이다 센서는 거리 정보를 매우 정확하게 제공하지만, 물체의 색상이나 텍스처와 같은 시각적 정보를 제공하지 못한다. 반면, 카메라는 고해상도의 이미지 데이터를 제공하지만 깊이 정보를 직접적으로 측정할 수 없다. 이러한 두 데이터를 융합하면 깊이 정보와 시각 정보를 모두 포함한 포인트 클라우드를 생성할 수 있다.</p>
<p>이를 위해 라이다로부터 얻은 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{P}_{\text{LiDAR}}</span><script type="math/tex">\mathcal{P}_{\text{LiDAR}}</script></span>와 카메라 이미지에서 추출된 특징 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{P}_{\text{Camera}}</span><script type="math/tex">\mathcal{P}_{\text{Camera}}</script></span>를 정렬해야 한다. 이를 수학적으로 표현하면, 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i \in \mathcal{P}_{\text{LiDAR}}</span><script type="math/tex">\mathbf{p}_i \in \mathcal{P}_{\text{LiDAR}}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_j \in \mathcal{P}_{\text{Camera}}</span><script type="math/tex">\mathbf{q}_j \in \mathcal{P}_{\text{Camera}}</script></span>에 대해 정합을 수행하여, 두 데이터 집합이 동일한 3D 공간 상에서 일치하도록 해야 한다. 정합 알고리즘은 다음과 같은 최적화 문제로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{T}} \sum_{i=1}^{n} \| \mathbf{T} \mathbf{p}_i - \mathbf{q}_i \|^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{T}} \sum_{i=1}^{n} \| \mathbf{T} \mathbf{p}_i - \mathbf{q}_i \|^2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span>는 변환 행렬로, 라이다와 카메라 데이터 사이의 좌표 변환을 나타낸다. 이 최적화 문제를 해결함으로써 두 센서의 데이터를 융합하여 더 정확한 포인트 클라우드를 얻을 수 있다.</p>
<h2 id="_19">로봇의 자율 주행 시뮬레이션</h2>
<p>포인트 클라우드와 센서 데이터를 기반으로 한 로봇 시뮬레이션의 주요 응용 중 하나는 자율 주행이다. 자율 주행 시뮬레이션에서는 로봇이 복잡한 환경에서 목표 지점까지 스스로 경로를 계획하고, 장애물을 피하며 이동하는 능력을 테스트한다. 이를 위해 실시간으로 수집된 포인트 클라우드 데이터를 사용하여 경로를 탐색하고, 장애물 감지 및 회피를 수행한다.</p>
<h3 id="_20">경로 최적화</h3>
<p>자율 주행에서 중요한 과제 중 하나는 경로의 최적화이다. 로봇은 가장 짧은 경로뿐만 아니라, 에너지 효율과 안전을 고려한 경로를 선택해야 한다. 이를 위해 비용 함수는 단순히 거리뿐만 아니라, 다음과 같은 요소들도 고려한다:</p>
<ol>
<li><strong>에너지 소비</strong>: 로봇의 이동에 소모되는 에너지 <span class="arithmatex"><span class="MathJax_Preview">E</span><script type="math/tex">E</script></span>는 경로의 기울기나 장애물 회피를 위한 추가적인 움직임에 따라 달라진다. 이를 고려한 비용 함수는 다음과 같다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
f_{\text{energy}}(\mathbf{r}) = \int_0^T E(\mathbf{r}(t), \mathbf{v}(t)) \, dt
</div>
<script type="math/tex; mode=display">
f_{\text{energy}}(\mathbf{r}) = \int_0^T E(\mathbf{r}(t), \mathbf{v}(t)) \, dt
</script>
</div>
<ol>
<li><strong>안전성</strong>: 로봇과 장애물 사이의 거리를 유지하기 위해, 안전성이 낮은 경로에 대해서는 추가 비용이 부여된다. 이는 포인트 클라우드에서 탐지된 장애물과의 거리로 측정할 수 있다.</li>
</ol>
<p>이러한 다양한 요소를 종합적으로 고려하여 로봇이 최적의 경로를 선택할 수 있도록 경로 탐색 알고리즘을 설계한다.</p>
<h2 id="_21">센서 융합을 통한 포인트 클라우드 개선</h2>
<p>로봇 시뮬레이션에서 단일 센서만으로는 충분히 정밀한 환경 데이터를 제공하기 어려울 때가 있다. 이를 해결하기 위해 여러 센서의 데이터를 융합하여 더 정확하고 풍부한 포인트 클라우드를 생성할 수 있다. 예를 들어, LiDAR와 카메라 데이터를 결합하는 방식이 있다. LiDAR는 거리 정보를 제공하고, 카메라는 색상 정보를 제공하므로 이 두 센서를 융합하면 색상 정보가 포함된 포인트 클라우드를 생성할 수 있다.</p>
<h3 id="_22">칼만 필터를 이용한 센서 융합</h3>
<p>센서 융합을 수행할 때는 센서 간의 데이터 불확실성을 처리하는 것이 매우 중요하다. 이를 위해 자주 사용되는 방법 중 하나는 칼만 필터(Kalman Filter)이다. 칼만 필터는 시간에 따라 변화하는 상태를 예측하고, 센서 데이터를 기반으로 상태를 업데이트하는 방식으로 작동한다.</p>
<p>로봇의 상태를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_t = (x_t, y_t, z_t, v_x, v_y, v_z)</span><script type="math/tex">\mathbf{x}_t = (x_t, y_t, z_t, v_x, v_y, v_z)</script></span>라고 하고, 각 센서의 측정값을 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_t</span><script type="math/tex">\mathbf{z}_t</script></span>라고 할 때, 칼만 필터는 다음 두 가지 단계로 구성된다:</p>
<ol>
<li><strong>예측(Prediction)</strong>: 이전 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{t-1}</span><script type="math/tex">\mathbf{x}_{t-1}</script></span>로부터 현재 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_t</span><script type="math/tex">\mathbf{x}_t</script></span>를 예측하는 단계이다. 예측 단계는 다음과 같이 표현된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_t^- = \mathbf{A} \mathbf{x}_{t-1} + \mathbf{B} \mathbf{u}_t
</div>
<script type="math/tex; mode=display">
\mathbf{x}_t^- = \mathbf{A} \mathbf{x}_{t-1} + \mathbf{B} \mathbf{u}_t
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 상태 전이 행렬(State Transition Matrix),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 제어 행렬(Control Matrix),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_t</span><script type="math/tex">\mathbf{u}_t</script></span>는 제어 입력(Control Input)을 나타낸다.</p>
<ol>
<li><strong>갱신(Update)</strong>: 센서로부터 얻은 측정값 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_t</span><script type="math/tex">\mathbf{z}_t</script></span>를 사용하여 예측값을 갱신하는 단계이다. 갱신 단계는 다음과 같이 표현된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_t = \mathbf{x}_t^- + \mathbf{K}_t (\mathbf{z}_t - \mathbf{H} \mathbf{x}_t^-)
</div>
<script type="math/tex; mode=display">
\mathbf{x}_t = \mathbf{x}_t^- + \mathbf{K}_t (\mathbf{z}_t - \mathbf{H} \mathbf{x}_t^-)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_t</span><script type="math/tex">\mathbf{K}_t</script></span>는 칼만 이득(Kalman Gain),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}</span><script type="math/tex">\mathbf{H}</script></span>는 측정 행렬(Measurement Matrix)이다.</p>
<p>이를 통해 여러 센서의 데이터를 융합하여 보다 정확한 로봇의 상태를 추정할 수 있다. 특히, 포인트 클라우드의 정밀도를 높이기 위해 다양한 센서 데이터를 융합하면 로봇 시뮬레이션에서 환경 인식 성능을 크게 향상시킬 수 있다.</p>
<h2 id="_23">실시간 처리에서의 포인트 클라우드 필터링</h2>
<p>센서 데이터는 실시간으로 수집되므로 로봇 시뮬레이션에서는 빠르게 포인트 클라우드를 처리해야 한다. 이를 위해 다양한 필터링 기법이 사용되며, 대표적인 예로는 다운샘플링과 노이즈 제거 필터가 있다.</p>
<h3 id="_24">다운샘플링</h3>
<p>실시간으로 수집된 포인트 클라우드 데이터는 매우 큰 용량을 가질 수 있으므로, 이를 효율적으로 처리하기 위해 다운샘플링이 필요하다. 다운샘플링은 포인트 클라우드의 밀도를 줄이는 방법으로, 대표적인 알고리즘은 Voxel Grid 필터이다. Voxel Grid 필터는 포인트 클라우드를 3차원 그리드로 나누고, 각 그리드 셀 내에서 평균적인 위치를 계산하여 포인트 수를 줄인다. 이를 통해 계산 부담을 줄이면서도 환경의 구조를 유지할 수 있다.</p>
<p>Voxel Grid 필터는 다음과 같이 작동한다:</p>
<ol>
<li>포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{P} = \{ \mathbf{p}_1, \mathbf{p}_2, \ldots, \mathbf{p}_n \}</span><script type="math/tex">\mathcal{P} = \{ \mathbf{p}_1, \mathbf{p}_2, \ldots, \mathbf{p}_n \}</script></span>에서 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i = (x_i, y_i, z_i)</span><script type="math/tex">\mathbf{p}_i = (x_i, y_i, z_i)</script></span>를 그리드 셀에 할당한다.</li>
<li>각 그리드 셀 내의 포인트들의 평균값 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{\text{avg}}</span><script type="math/tex">\mathbf{p}_{\text{avg}}</script></span>를 계산한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_{\text{avg}} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
\mathbf{p}_{\text{avg}} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 해당 그리드 셀 내의 포인트 개수이다.
3. 각 그리드 셀 내의 포인트를 대표하는 하나의 포인트로 대체한다.</p>
<p>이 과정을 통해 실시간 처리에서도 적절한 성능을 유지할 수 있다.</p>
<h3 id="_25">노이즈 제거</h3>
<p>센서 데이터에는 다양한 노이즈가 포함될 수 있기 때문에, 이를 필터링하여 로봇 시뮬레이션에서의 정확성을 높일 수 있다. 대표적인 노이즈 제거 필터로는 Statistical Outlier Removal (SOR) 필터가 있다. SOR 필터는 포인트 클라우드에서 통계적으로 이상치(outlier)를 제거하는 방법으로, 각 포인트의 근처 이웃 포인트들과의 거리를 분석하여 일정 임계값 이상인 포인트를 제거한다.</p>
<p>이러한 필터링 기법을 통해 로봇 시뮬레이션에서 더 깨끗하고 정확한 포인트 클라우드를 실시간으로 처리할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2404/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2404/" class="btn btn-xs btn-link">
        PCL을 이용한 충돌 시뮬레이션
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2402/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2402/" class="btn btn-xs btn-link">
        가상 환경에서의 포인트 클라우드 생성
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>