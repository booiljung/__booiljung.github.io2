<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introduction_to_pointcloud_processing_with_pcl_library/chapter_27/2705/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>산업용 로봇의 환경 인식 응용 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\ub97c \uc774\uc6a9\ud55c \ud658\uacbd \uc778\uc2dd", url: "#_top", children: [
          ]},
          {title: "\uac1d\uccb4 \uc778\uc2dd\uacfc \ubd84\ub958", url: "#_2", children: [
          ]},
          {title: "\uac70\ub9ac \uacc4\uc0b0\uacfc \uacf5\uac04 \ubd84\uc11d", url: "#_3", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\ub97c \uc774\uc6a9\ud55c \ucda9\ub3cc \ud68c\ud53c", url: "#_4", children: [
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ucc98\ub9ac\uc640 \uc751\uc6a9", url: "#_5", children: [
          ]},
          {title: "\uc0b0\uc5c5\uc6a9 \ub85c\ubd07\uc758 \uc790\ub3d9\ud654 \uc791\uc5c5 \uc0ac\ub840", url: "#_6", children: [
          ]},
          {title: "\uba38\uc2e0\ub7ec\ub2dd \uae30\ubc18\uc758 \uac1d\uccb4 \uc778\uc2dd \ubc0f \ubd84\ub958", url: "#_7", children: [
              {title: "\ud2b9\uc9d5 \ucd94\ucd9c\uacfc \ud559\uc2b5", url: "#_8" },
              {title: "\ud559\uc2b5 \uc54c\uace0\ub9ac\uc998", url: "#_9" },
              {title: "\uc2e4\uc2dc\uac04 \uac1d\uccb4 \ubd84\ub958", url: "#_10" },
          ]},
          {title: "\ubcf5\uc7a1\ud55c \ud658\uacbd\uc5d0\uc11c\uc758 \uace0\uae09 \ucc98\ub9ac", url: "#_11", children: [
          ]},
          {title: "\ubcf5\uc7a1\ud55c \ud658\uacbd\uc5d0\uc11c\uc758 \ud074\ub7ec\uc2a4\ud130\ub9c1 \uae30\ubc95", url: "#_12", children: [
              {title: "Euclidean \ud074\ub7ec\uc2a4\ud130\ub9c1", url: "#euclidean" },
              {title: "DBSCAN (Density-Based Spatial Clustering of Applications with Noise)", url: "#dbscan-density-based-spatial-clustering-of-applications-with-noise" },
              {title: "Supervoxel \ud074\ub7ec\uc2a4\ud130\ub9c1", url: "#supervoxel" },
          ]},
          {title: "\uc0b0\uc5c5\uc6a9 \ub85c\ubd07\uc758 \uace0\uae09 \uacbd\ub85c \uacc4\ud68d", url: "#_13", children: [
              {title: "A* \uc54c\uace0\ub9ac\uc998", url: "#a" },
              {title: "RRT (Rapidly-exploring Random Tree)", url: "#rrt-rapidly-exploring-random-tree" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_28/2801/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_28/2801/" class="btn btn-xs btn-link">
        드론을 이용한 포인트 클라우드 수집
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2704/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2704/" class="btn btn-xs btn-link">
        건축 및 인프라 검사
      </a>
    </div>
    
  </div>

    

    <p>산업용 로봇에서 환경 인식은 자율성과 효율성을 극대화하기 위한 핵심 기술로 자리 잡고 있다. 특히, PCL (Point Cloud Library)을 활용한 포인트 클라우드 데이터 처리는 산업용 로봇이 주위 환경을 보다 정확하고 상세하게 이해할 수 있게 한다. 포인트 클라우드는 3D 공간에서 각 점의 좌표와 그 점에서의 속성을 포함하며, 이를 기반으로 로봇은 주변 환경의 구조와 물체의 위치를 파악하고, 실시간으로 상황에 맞게 작업을 수행할 수 있다.</p>
<h3 id="_1">포인트 클라우드를 이용한 환경 인식</h3>
<p>산업용 로봇에서 포인트 클라우드를 이용한 환경 인식은 다음과 같은 단계를 포함한다.</p>
<ol>
<li>
<p><strong>센서를 통한 데이터 획득</strong>: 3D 센서(LiDAR, ToF 카메라 등)를 통해 포인트 클라우드를 실시간으로 획득한다. 이러한 센서들은 로봇이 주변 환경의 3차원 구조를 정확하게 이해할 수 있도록 한다.</p>
</li>
<li>
<p><strong>전처리</strong>: 획득한 포인트 클라우드 데이터는 노이즈 제거, 필터링 등을 통해 전처리된다. 예를 들어, 이상치 제거를 위해 Radius Outlier Removal이나 Statistical Outlier Removal 알고리즘을 적용할 수 있다. 이러한 필터링을 통해 포인트 클라우드의 품질을 향상시키고, 후속 처리의 정확도를 높인다.</p>
</li>
<li>
<p><strong>세그멘테이션</strong>: 포인트 클라우드를 세그멘테이션하여 개별 객체나 관심 영역을 분리한다. 이를 통해 로봇은 환경 내에서 다양한 물체를 구분하고, 각 물체에 대해 독립적인 작업을 수행할 수 있다. 세그멘테이션은 Euclidean Cluster Extraction, Region Growing, Supervoxel Segmentation과 같은 알고리즘을 통해 수행된다.</p>
</li>
</ol>
<h3 id="_2">객체 인식과 분류</h3>
<p>포인트 클라우드를 이용한 환경 인식에서 중요한 부분은 객체 인식과 분류이다. 산업 환경에서는 다양한 물체들이 존재하며, 각 물체를 올바르게 인식하고 분류하는 것이 중요하다. 이를 위해 로봇은 포인트 클라우드 데이터를 활용하여 특정한 객체를 인식하고, 객체의 속성(크기, 형태 등)을 분석한다.</p>
<p>객체 인식은 일반적으로 특징 기반 접근법을 사용한다. 특징 벡터는 각 점 클라우드에서 국소적인 형태 정보를 추출하여 물체의 특정 패턴을 정의한다. 대표적인 3D 특징은 다음과 같다:</p>
<ul>
<li><strong>FPFH (Fast Point Feature Histogram)</strong>: 각 포인트에 대해 국소적 기하학적 특성을 계산하여 해당 포인트가 포함된 표면의 곡률, 방향성 등을 표현한다.</li>
<li><strong>SHOT (Signature of Histograms of Orientations)</strong>: 국소 영역에서 표면 법선 벡터의 방향성을 히스토그램으로 표현하여, 물체의 형태를 설명한다.</li>
</ul>
<p>이를 바탕으로, 로봇은 다양한 물체의 특징을 데이터베이스와 비교하고, 해당 물체를 인식할 수 있다.</p>
<h3 id="_3">거리 계산과 공간 분석</h3>
<p>로봇이 환경에서 정확하게 작업을 수행하려면 객체 간의 거리 계산과 공간 분석이 필수적이다. 포인트 클라우드에서 거리 계산은 주로 유클리드 거리 또는 차원별 거리 측정을 통해 이루어진다. 두 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1 = (x_1, y_1, z_1)</span><script type="math/tex">\mathbf{p}_1 = (x_1, y_1, z_1)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2 = (x_2, y_2, z_2)</span><script type="math/tex">\mathbf{p}_2 = (x_2, y_2, z_2)</script></span>사이의 유클리드 거리는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{p}_1, \mathbf{p}_2) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}
</div>
<script type="math/tex; mode=display">
d(\mathbf{p}_1, \mathbf{p}_2) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}
</script>
</div>
<p>이와 같은 거리 계산을 통해 로봇은 각 객체 간의 공간적 관계를 이해하고, 작업 경로를 최적화할 수 있다.</p>
<h3 id="_4">포인트 클라우드를 이용한 충돌 회피</h3>
<p>산업용 로봇은 작업 환경에서 안전하게 작업을 수행하기 위해 충돌 회피가 필요하다. 포인트 클라우드를 이용한 충돌 회피는 로봇이 주위의 물체를 감지하고, 충돌 가능성을 예측하여 경로를 수정하는 방식으로 이루어진다. 이 과정은 실시간으로 이루어지며, 로봇이 이동하거나 작업을 수행하는 중에도 지속적으로 환경을 분석하고 대응할 수 있다.</p>
<p>포인트 클라우드 기반 충돌 회피는 다음과 같은 절차로 구성된다:</p>
<ol>
<li>
<p><strong>충돌 가능성 계산</strong>: 로봇이 감지한 포인트 클라우드에서, 주변 물체의 좌표를 이용하여 충돌 가능성을 평가한다. 이를 위해 로봇과 각 물체 간의 거리를 계산하고, 사전 정의된 안전 거리 내에 들어오는 물체가 있는지를 확인한다. 만약 안전 거리에 물체가 들어오면 충돌 가능성이 있는 것으로 간주된다.</p>
</li>
<li>
<p><strong>안전 경로 계획</strong>: 충돌 가능성이 있는 경우, 로봇은 즉시 새로운 경로를 계획해야 한다. 이때, 경로 계획 알고리즘은 로봇의 현재 위치와 목표 지점 간의 최단 경로를 찾으면서도, 주변 물체와의 충돌을 회피하도록 최적화된다. 대표적인 경로 계획 알고리즘은 A* 알고리즘이나 RRT (Rapidly-exploring Random Tree) 알고리즘이 있다.</p>
</li>
<li>
<p><strong>로봇의 기하학적 모델링</strong>: 충돌 회피를 위한 로봇의 경로 계획에서 중요한 요소는 로봇의 기하학적 모델이다. 로봇의 팔이나 도구와 같은 움직이는 부분을 포함한 전체 구조가 포인트 클라우드 상에서 모델링되어야 하며, 이를 통해 로봇이 정확하게 자신의 물리적 환경과 상호작용할 수 있다.</p>
</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{robot} = \{ \mathbf{p}_i \in \mathbb{R}^3 | i = 1, 2, \dots, N \}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{robot} = \{ \mathbf{p}_i \in \mathbb{R}^3 | i = 1, 2, \dots, N \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{robot}</span><script type="math/tex">\mathbf{P}_{robot}</script></span>는 로봇의 기하학적 구조를 나타내는 포인트 집합이며, 이를 바탕으로 로봇의 각 부분이 공간 내에서 어떻게 배치되어 있는지 알 수 있다.</p>
<h3 id="_5">실시간 데이터 처리와 응용</h3>
<p>산업용 로봇의 환경 인식에서 중요한 또 다른 측면은 실시간 데이터 처리이다. 포인트 클라우드 데이터는 대량으로 생성되며, 이를 실시간으로 처리하지 않으면 로봇의 작업에 지연이 발생할 수 있다. 이를 해결하기 위해 다음과 같은 기술들이 사용된다:</p>
<ol>
<li>
<p><strong>데이터 스트리밍</strong>: 실시간으로 생성되는 포인트 클라우드 데이터를 스트리밍 방식으로 처리하여 지연을 최소화한다. 로봇은 특정 구역에 대한 포인트 클라우드를 연속적으로 수신하고, 해당 데이터를 즉시 분석하여 작업을 수행한다.</p>
</li>
<li>
<p><strong>병렬 처리</strong>: 다량의 포인트 클라우드를 실시간으로 처리하기 위해서는 병렬 처리가 필수적이다. 여러 프로세서 또는 코어에서 동시에 데이터를 처리함으로써 분석 속도를 향상시킬 수 있다. 특히, PCL의 다양한 필터링 및 세그멘테이션 작업이 병렬로 수행되면 데이터 처리 시간은 크게 단축된다.</p>
</li>
<li>
<p><strong>데이터 압축</strong>: 실시간으로 대규모 데이터를 처리하는 경우, 포인트 클라우드를 압축하여 처리할 수 있다. 무손실 또는 손실 압축 기법을 적용하여 데이터의 크기를 줄이고, 네트워크 전송 속도를 높일 수 있다. 이와 동시에, 로봇은 압축된 데이터를 빠르게 복원하여 처리할 수 있어야 한다.</p>
</li>
</ol>
<h3 id="_6">산업용 로봇의 자동화 작업 사례</h3>
<p>포인트 클라우드를 이용한 환경 인식 기술은 다양한 산업 환경에서 로봇의 자동화 작업에 적용되고 있다. 다음은 대표적인 응용 사례들이다:</p>
<ul>
<li>
<p><strong>자동화된 물류 시스템</strong>: 물류 창고에서 로봇은 포인트 클라우드를 이용하여 선반, 상자, 패키지 등의 위치를 실시간으로 파악하고, 자동으로 물품을 적재하거나 운반할 수 있다. 이 과정에서 로봇은 충돌 회피 알고리즘을 적용하여, 이동 경로 상의 장애물을 감지하고 회피한다.</p>
</li>
<li>
<p><strong>자동 차체 조립</strong>: 자동차 제조업에서, 로봇은 포인트 클라우드를 기반으로 차체 부품을 정확하게 배치하고 조립하는 작업을 수행한다. 특히, 용접 작업이나 페인팅 작업에서 로봇은 3D 포인트 클라우드를 이용하여 물체의 곡면이나 복잡한 형상을 인식하고, 정확하게 작업을 수행할 수 있다.</p>
</li>
<li>
<p><strong>건설 현장 자동화</strong>: 건설 현장에서 로봇은 실시간 포인트 클라우드 데이터를 사용하여 구조물의 상태를 모니터링하고, 필요한 작업을 자동으로 수행한다. 예를 들어, 철근 배치, 벽돌 쌓기, 도장 작업 등을 자동화할 수 있으며, 작업 중에 발생하는 장애물도 실시간으로 감지하여 회피할 수 있다.</p>
</li>
</ul>
<h3 id="_7">머신러닝 기반의 객체 인식 및 분류</h3>
<p>산업용 로봇이 환경을 인식하는 데 있어, 머신러닝 기법은 포인트 클라우드 데이터를 더욱 효율적으로 처리하고 해석하는 데 중요한 역할을 한다. 특히, PCL과 머신러닝의 통합을 통해 객체 인식과 분류가 더욱 정교해질 수 있다. 이때, 머신러닝 모델은 다양한 포인트 클라우드 데이터를 학습하여 새로운 데이터에 대해 높은 정확도로 예측을 수행한다.</p>
<h4 id="_8">특징 추출과 학습</h4>
<p>머신러닝 기반의 객체 인식에서 중요한 단계는 특징 추출이다. 포인트 클라우드에서 의미 있는 3D 특징을 추출하는 과정이 모델의 성능에 큰 영향을 미친다. 대표적인 3D 특징 추출 방법은 앞서 언급한 FPFH, SHOT와 같은 방식이며, 이 외에도 최근에는 딥러닝 기법을 통해 포인트 클라우드의 로우 데이터를 직접 학습하는 방법도 사용되고 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{F} = \{ f_1, f_2, \dots, f_n \}, \quad f_i \in \mathbb{R}^d
</div>
<script type="math/tex; mode=display">
\mathbf{F} = \{ f_1, f_2, \dots, f_n \}, \quad f_i \in \mathbb{R}^d
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}</span><script type="math/tex">\mathbf{F}</script></span>는 포인트 클라우드에서 추출된 특징 벡터의 집합을 나타내며, 각 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}_i</span><script type="math/tex">\mathbf{f}_i</script></span>는 해당 점의 기하학적 특성을 설명하는 d차원의 특징이다.</p>
<h4 id="_9">학습 알고리즘</h4>
<p>포인트 클라우드 데이터를 활용한 객체 인식을 위해 사용되는 대표적인 학습 알고리즘은 다음과 같다:</p>
<ul>
<li>
<p><strong>서포트 벡터 머신 (SVM)</strong>: SVM은 고차원 특징 공간에서 데이터를 선형 또는 비선형으로 분리하는데 효과적인 방법이다. 포인트 클라우드 특징을 기반으로 다양한 클래스(예: 물체의 종류)를 구분하는 데 사용된다.</p>
</li>
<li>
<p><strong>랜덤 포레스트 (Random Forest)</strong>: 여러 개의 결정 트리를 결합한 앙상블 학습 방법으로, 포인트 클라우드 데이터에서 추출된 특징을 바탕으로 객체를 분류한다. 랜덤 포레스트는 대규모 데이터에 대해 강건한 성능을 보이며, 분류뿐 아니라 회귀 작업에도 사용할 수 있다.</p>
</li>
<li>
<p><strong>신경망 기반 모델</strong>: 최근에는 PointNet과 같은 신경망 기반 모델들이 포인트 클라우드 데이터를 직접 입력으로 받아, 객체 인식 및 분류를 수행하는 방법이 널리 사용되고 있다. PointNet은 포인트 클라우드를 각 점의 집합으로 간주하며, 이를 학습해 물체의 형태를 인식한다.</p>
</li>
</ul>
<h4 id="_10">실시간 객체 분류</h4>
<p>산업용 로봇에서 포인트 클라우드 데이터를 이용한 객체 인식과 분류는 실시간으로 이루어져야 한다. 특히, 실시간 작업 환경에서 로봇은 빠르게 새로운 데이터를 수집하고, 즉시 그 결과를 반영해야 하기 때문에 데이터 처리의 효율성이 중요하다. 이를 위해서는 빠른 특징 추출과 경량화된 머신러닝 모델이 요구된다.</p>
<p>실시간 처리 시스템에서는 주로 다음과 같은 최적화가 이루어진다:</p>
<ol>
<li>
<p><strong>특징 추출 속도 최적화</strong>: 특징 추출 알고리즘의 계산 복잡도를 줄여서, 실시간 데이터 수집 및 분석에 걸리는 시간을 단축한다.</p>
</li>
<li>
<p><strong>모델 경량화</strong>: 신경망 기반 모델의 경우, 경량화된 네트워크 구조를 사용하여 계산 부하를 줄이고, 실시간 분류 성능을 향상시킨다. 이를 위해 모델을 압축하거나, 모델의 파라미터 수를 줄이는 방법을 사용한다.</p>
</li>
</ol>
<h3 id="_11">복잡한 환경에서의 고급 처리</h3>
<p>산업 현장에서는 다양한 복잡한 환경에서 로봇이 작업을 수행해야 하므로, 포인트 클라우드 데이터의 해석도 복잡해진다. 예를 들어, 여러 객체가 서로 겹쳐 있거나, 물체의 표면이 복잡하게 구성된 환경에서 로봇이 정확한 인식과 분류를 수행해야 한다.</p>
<p>복잡한 환경에서 포인트 클라우드 데이터의 처리를 최적화하기 위해, 다음과 같은 고급 처리 기법이 사용된다:</p>
<ul>
<li>
<p><strong>다중 센서 통합</strong>: 로봇은 여러 개의 센서를 사용하여 환경을 더 정교하게 인식할 수 있다. 각 센서가 제공하는 포인트 클라우드 데이터를 통합하면, 더 높은 해상도의 3D 모델을 생성할 수 있으며, 다양한 센서 데이터의 상호 보완성을 통해 인식 정확도를 향상시킬 수 있다.</p>
</li>
<li>
<p><strong>적응형 필터링</strong>: 복잡한 환경에서는 단일한 필터링 방법으로는 노이즈를 완전히 제거할 수 없기 때문에, 다양한 필터링 기법을 적응적으로 적용해야 한다. 예를 들어, 물체의 크기나 거리에 따라 필터링 파라미터를 동적으로 조정하는 방식이 있다.</p>
</li>
<li>
<p><strong>클러스터링</strong>: 객체가 복잡한 배경에서 분리되어 있지 않거나, 다른 물체와 겹쳐져 있을 경우 클러스터링 기법을 사용하여 객체를 분리할 수 있다. Euclidean 클러스터링이나 DBSCAN(Density-Based Spatial Clustering of Applications with Noise)과 같은 방법이 이러한 상황에서 효과적이다.</p>
</li>
</ul>
<h3 id="_12">복잡한 환경에서의 클러스터링 기법</h3>
<p>산업용 로봇이 복잡한 환경에서 작업할 때, 포인트 클라우드 데이터를 효과적으로 처리하기 위해서는 클러스터링 기법이 중요한 역할을 한다. 클러스터링은 포인트 클라우드 내에서 서로 가까운 점들을 그룹화하여, 각 그룹을 개별 객체로 분리하는 과정이다. 특히, 복잡한 환경에서는 서로 겹쳐진 객체나 노이즈에 의해 데이터가 왜곡될 수 있는데, 클러스터링 기법은 이러한 문제를 해결하는 데 유용하다.</p>
<h4 id="euclidean">Euclidean 클러스터링</h4>
<p>Euclidean 클러스터링은 가장 널리 사용되는 방법 중 하나로, 주어진 포인트 집합에서 각 점 간의 유클리드 거리를 기반으로 클러스터를 형성한다. 특정 거리 임계값 \epsilon 내에 있는 점들은 같은 클러스터에 속한다고 판단하며, 이를 통해 여러 개의 독립된 객체를 식별할 수 있다.</p>
<p>알고리즘은 다음과 같이 동작한다:</p>
<ol>
<li>첫 번째 포인트 \mathbf{p}_0를 선택하여 클러스터를 시작한다.</li>
<li>\mathbf{p}_0와 유클리드 거리 \epsilon 이내에 있는 모든 점들을 탐색하고, 해당 점들을 같은 클러스터로 그룹화한다.</li>
<li>새로운 점을 기준으로 다시 거리를 계산하고, 추가적으로 클러스터에 포함할 점들을 찾는다.</li>
<li>더 이상 클러스터에 추가할 점이 없을 때, 새로운 포인트에서 위 과정을 반복한다.</li>
</ol>
<p>이 알고리즘은 매우 직관적이면서도 효율적으로 클러스터를 형성할 수 있지만, 거리 임계값 \epsilon의 선택에 따라 결과가 크게 달라질 수 있다. </p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{p}_i, \mathbf{p}_j) \leq \epsilon \implies \mathbf{p}_i, \mathbf{p}_j \text{ are in the same cluster}
</div>
<script type="math/tex; mode=display">
d(\mathbf{p}_i, \mathbf{p}_j) \leq \epsilon \implies \mathbf{p}_i, \mathbf{p}_j \text{ are in the same cluster}
</script>
</div>
<h4 id="dbscan-density-based-spatial-clustering-of-applications-with-noise">DBSCAN (Density-Based Spatial Clustering of Applications with Noise)</h4>
<p>DBSCAN은 밀도 기반 클러스터링 알고리즘으로, 유클리드 거리가 아닌 밀도를 기준으로 클러스터를 형성하는 기법이다. 밀도가 충분히 높은 영역을 클러스터로 간주하고, 밀도가 낮은 영역은 노이즈로 처리한다. 이는 특히, 불균일하게 분포된 데이터나 노이즈가 많은 환경에서 유리하다.</p>
<p>DBSCAN의 주요 개념은 다음과 같다:</p>
<ol>
<li><strong>핵심 포인트</strong>: 주변 반경 \epsilon 내에 최소 포인트 수(minPts)를 만족하는 포인트를 핵심 포인트라고 한다.</li>
<li><strong>밀도 접근성</strong>: 핵심 포인트에서 반경 \epsilon 내에 있는 다른 포인트들을 통해, 서로 연결된 포인트들을 같은 클러스터로 묶는다.</li>
<li><strong>노이즈</strong>: 밀도 접근성 조건을 만족하지 못하는 포인트들은 노이즈로 간주된다.</li>
</ol>
<p>DBSCAN은 복잡한 환경에서도 노이즈를 효과적으로 처리할 수 있으며, 클러스터의 모양에 구애받지 않고 유연하게 적용된다. 이는 산업 현장에서 복잡한 기하학적 구조를 가진 객체나 물체들이 겹쳐 있는 상황에서도 유용하다.</p>
<h4 id="supervoxel">Supervoxel 클러스터링</h4>
<p>Supervoxel 클러스터링은 포인트 클라우드 데이터를 더 고수준의 표현으로 변환하는 과정으로, 주로 객체 인식 및 분류를 위한 전처리 단계로 사용된다. 포인트 클라우드를 voxel이라는 작은 입방체 단위로 분할하고, 이들 voxel을 클러스터링하여 Supervoxel을 형성한다.</p>
<p>Supervoxel 클러스터링은 다음과 같은 특징을 가진다:</p>
<ul>
<li><strong>공간적 연속성</strong>: Supervoxel은 공간적으로 연속적인 점들의 집합으로 형성되며, 이는 각 객체를 더 명확하게 구분하는 데 도움이 된다.</li>
<li><strong>계층적 구조</strong>: Supervoxel은 기본적인 점 클라우드보다 더 추상화된 정보를 제공하므로, 객체의 전체적인 구조를 이해하는 데 유리하다.</li>
</ul>
<p>Supervoxel은 특히 대규모 데이터에서 처리 속도를 향상시키는 데 기여하며, 고해상도 데이터에서 세부 정보를 유지하면서도 더 작은 단위로 나누어 처리할 수 있다. Supervoxel을 통해 클러스터링된 결과는 이후의 세그멘테이션이나 분류 작업에 사용될 수 있다.</p>
<h3 id="_13">산업용 로봇의 고급 경로 계획</h3>
<p>포인트 클라우드를 이용한 환경 인식은 경로 계획에도 중요한 영향을 미친다. 로봇이 작업 환경 내에서 충돌을 회피하면서 목표 지점까지 효율적으로 이동하기 위해서는, 3D 공간 내에서 최적 경로를 찾는 경로 계획 알고리즘이 필요하다. 경로 계획은 주로 다음과 같은 기법들을 사용한다.</p>
<h4 id="a">A* 알고리즘</h4>
<p>A<em> 알고리즘은 최단 경로를 찾기 위한 휴리스틱 기반 알고리즘으로, 공간 내에서 로봇이 이동할 수 있는 최적 경로를 탐색하는 데 효과적이다. A</em> 알고리즘은 각 상태의 휴리스틱 값과 이동 비용을 합산하여, 가장 비용이 적은 경로를 선택한다.</p>
<p>경로 비용 함수는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(\mathbf{p}) = g(\mathbf{p}) + h(\mathbf{p})
</div>
<script type="math/tex; mode=display">
f(\mathbf{p}) = g(\mathbf{p}) + h(\mathbf{p})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 특정 상태(포인트)를 나타내며, <span class="arithmatex"><span class="MathJax_Preview">g(\mathbf{p})</span><script type="math/tex">g(\mathbf{p})</script></span>는 시작점에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>까지의 실제 비용, <span class="arithmatex"><span class="MathJax_Preview">h(\mathbf{p})</span><script type="math/tex">h(\mathbf{p})</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>에서 목표 지점까지의 휴리스틱 비용이다. 이때, A* 알고리즘은 비용 함수 <span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{p})</span><script type="math/tex">f(\mathbf{p})</script></span>가 가장 작은 경로를 선택하여 탐색을 진행한다.</p>
<h4 id="rrt-rapidly-exploring-random-tree">RRT (Rapidly-exploring Random Tree)</h4>
<p>RRT는 복잡한 3D 환경에서의 경로 계획을 위해 주로 사용되는 샘플링 기반 알고리즘이다. RRT는 무작위로 샘플을 생성하여 트리를 확장하며, 목표 지점에 도달하는 경로를 찾는다. RRT는 특히, 로봇이 동적이고 예측할 수 없는 환경에서 경로를 계획해야 할 때 유용하다.</p>
<p>RRT 알고리즘의 기본 단계는 다음과 같다:</p>
<ol>
<li>무작위로 샘플링된 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{rand}</span><script type="math/tex">\mathbf{p}_{rand}</script></span>를 선택한다.</li>
<li>현재 트리에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{rand}</span><script type="math/tex">\mathbf{p}_{rand}</script></span>에 가장 가까운 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{nearest}</span><script type="math/tex">\mathbf{p}_{nearest}</script></span>를 찾는다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{nearest}</span><script type="math/tex">\mathbf{p}_{nearest}</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{rand}</span><script type="math/tex">\mathbf{p}_{rand}</script></span> 방향으로 일정 거리만큼 이동하여 새로운 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{new}</span><script type="math/tex">\mathbf{p}_{new}</script></span>를 생성한다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{new}</span><script type="math/tex">\mathbf{p}_{new}</script></span>를 트리에 추가하고, 이 과정을 목표 지점에 도달할 때까지 반복한다.</li>
</ol>
<p>RRT는 복잡한 환경에서 충돌을 회피하면서도 빠르게 경로를 찾을 수 있으며, 다양한 산업 환경에서 실시간으로 경로 계획을 수행하는 데 효과적이다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_28/2801/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_28/2801/" class="btn btn-xs btn-link">
        드론을 이용한 포인트 클라우드 수집
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2704/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2704/" class="btn btn-xs btn-link">
        건축 및 인프라 검사
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>