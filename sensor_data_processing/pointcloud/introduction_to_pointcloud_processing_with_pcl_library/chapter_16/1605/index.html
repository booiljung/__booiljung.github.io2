<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/sensor_data_processing/pointcloud/introduction_to_pointcloud_processing_with_pcl_library/chapter_16/1605/" rel="canonical"/>
<link href="../../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>PCL을 이용한 실시간 데이터 처리 - 실험 도서관</title>
<link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ucc98\ub9ac\uc758 \ud544\uc694\uc131", url: "#_top", children: [
          ]},
          {title: "PCL\uc5d0\uc11c\uc758 \uc2e4\uc2dc\uac04 \ucc98\ub9ac \uad6c\uc870", url: "#pcl", children: [
              {title: "1. Voxel Grid \ud544\ud130", url: "#1-voxel-grid" },
              {title: "2. Passthrough \ud544\ud130", url: "#2-passthrough" },
              {title: "3. Statistical Outlier Removal", url: "#3-statistical-outlier-removal" },
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \uc2a4\ud2b8\ub9ac\ubc0d \uad6c\uc870", url: "#_2", children: [
              {title: "1. pcl::Grabber\uc758 \uad6c\uc870", url: "#1-pclgrabber" },
          ]},
          {title: "2. \uba40\ud2f0\uc2a4\ub808\ub529\uc744 \uc774\uc6a9\ud55c \ub370\uc774\ud130 \ucc98\ub9ac", url: "#2", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ucc98\ub9ac \ud30c\uc774\ud504\ub77c\uc778", url: "#_3", children: [
              {title: "1. \uc785\ub825 \ub370\uc774\ud130 \uc218\uc9d1", url: "#1" },
              {title: "2. \ud544\ud130\ub9c1 \ubc0f \ub370\uc774\ud130 \ucd95\uc18c", url: "#2_1" },
              {title: "3. \ud2b9\uc9d5 \ucd94\ucd9c", url: "#3" },
              {title: "4. \ud074\ub7ec\uc2a4\ud130\ub9c1 \ubc0f \uc138\uadf8\uba58\ud14c\uc774\uc158", url: "#4" },
              {title: "5. \uacb0\uacfc \uc2dc\uac01\ud654 \ubc0f \uc804\uc1a1", url: "#5" },
          ]},
          {title: "PCL\uc5d0\uc11c\uc758 \ucd5c\uc801\ud654 \uae30\ubc95", url: "#pcl_1", children: [
              {title: "1. \ub370\uc774\ud130 \ubcd1\ub82c \ucc98\ub9ac", url: "#1_1" },
              {title: "2. KD-Tree \uae30\ubc18 \uac00\uc18d", url: "#2-kd-tree" },
              {title: "3. CUDA \uac00\uc18d", url: "#3-cuda" },
          ]},
          {title: "GPU \uac00\uc18d\uc744 \uc774\uc6a9\ud55c \uc2e4\uc2dc\uac04 \ucc98\ub9ac", url: "#gpu", children: [
              {title: "1. CUDA \uae30\ubc18 PCL \ucc98\ub9ac", url: "#1-cuda-pcl" },
              {title: "2. GPU \uac00\uc18d\uc758 \uc7a5\ub2e8\uc810", url: "#2-gpu" },
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ucc98\ub9ac\uc5d0 \ucd5c\uc801\ud654\ub41c \ub370\uc774\ud130 \uad6c\uc870", url: "#_4", children: [
              {title: "1. KD-Tree", url: "#1-kd-tree" },
              {title: "2. Octree", url: "#2-octree" },
              {title: "3. \ud50c\ub7ab \ub370\uc774\ud130 \uad6c\uc870", url: "#3_1" },
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ucc98\ub9ac\uc5d0 \ud544\uc694\ud55c \ud558\ub4dc\uc6e8\uc5b4 \uc694\uad6c \uc0ac\ud56d", url: "#_5", children: [
              {title: "1. \uace0\uc131\ub2a5 CPU", url: "#1-cpu" },
              {title: "2. GPU (CUDA \uc9c0\uc6d0)", url: "#2-gpu-cuda" },
              {title: "3. \uba54\ubaa8\ub9ac (RAM)", url: "#3-ram" },
              {title: "4. \uace0\uc18d \uc800\uc7a5 \uc7a5\uce58", url: "#4_1" },
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ucc98\ub9ac\uc5d0 \uc0ac\uc6a9\ub418\ub294 \uc54c\uace0\ub9ac\uc998", url: "#_6", children: [
              {title: "1. Euclidean \ud074\ub7ec\uc2a4\ud130\ub9c1", url: "#1-euclidean" },
              {title: "2. RANSAC\uc744 \uc774\uc6a9\ud55c \ud3c9\uba74 \ucd94\ucd9c", url: "#2-ransac" },
              {title: "3. \ubc95\uc120 \ucd94\uc815 (Normal Estimation)", url: "#3-normal-estimation" },
              {title: "4. \ub2e4\uc6b4\uc0d8\ud50c\ub9c1", url: "#4_2" },
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ucc98\ub9ac\uc758 \uc751\uc6a9", url: "#_7", children: [
              {title: "1. \uc790\uc728 \uc8fc\ud589 \ucc28\ub7c9", url: "#1_2" },
              {title: "2. \ub85c\ubd07 \uacf5\ud559", url: "#2_2" },
              {title: "3. \uc99d\uac15 \ud604\uc2e4", url: "#3_2" },
              {title: "4. 3D \uc2a4\uce90\ub2dd \ubc0f \ubaa8\ub378\ub9c1", url: "#4-3d" },
          ]},
        ];

    </script>
<script src="../../../../../js/base.js"></script>
<script src="../../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../../chapter_17/1701/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../../chapter_17/1701/">
        포인트 클라우드에서의 충돌 감지
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../1604/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../1604/">
        데이터 축소와 샘플링 기법
      </a>
</div>
</div>
<p>실시간으로 포인트 클라우드 데이터를 처리하는 것은 매우 중요한 주제이며, 특히 대용량 데이터에 대해서 효율적인 알고리즘을 필요로 한다. PCL(Point Cloud Library)은 이러한 실시간 데이터 처리를 지원하기 위한 여러 가지 도구와 알고리즘을 제공한다. 여기서는 PCL을 활용한 실시간 처리의 다양한 측면과 구현 가능성을 논의하겠다.</p>
<h3 id="_1">실시간 데이터 처리의 필요성</h3>
<p>실시간 데이터 처리에서는 연속적으로 들어오는 포인트 클라우드 데이터를 매우 짧은 시간 안에 처리하여 결과를 도출해야 한다. 이러한 요구는 다양한 응용 분야에서 발생한다. 예를 들어 자율 주행 차량은 LiDAR나 3D 카메라로부터 얻은 실시간 포인트 클라우드 데이터를 분석하여 즉각적인 의사 결정을 해야 한다. 이를 위한 알고리즘과 하드웨어는 데이터를 처리하는 데 드는 시간을 최소화하는 데 중점을 둔다.</p>
<p>실시간 처리의 핵심 요소는 다음과 같다:</p>
<ul>
<li><strong>입력 속도</strong>: 센서로부터 연속적인 포인트 클라우드 데이터를 읽어들이는 속도가 중요하다. 이 속도는 일반적으로 센서의 출력 주기에 의해 결정되며, 주로 10Hz에서 100Hz 범위 내에 있다.</li>
<li><strong>처리 지연 시간</strong>: 처리 지연은 데이터를 읽은 후 결과를 내기까지 걸리는 시간이다. 실시간 처리에서는 이 지연 시간이 최소화되어야 한다. PCL에서 제공하는 함수들은 병렬 처리와 최적화를 통해 이러한 지연 시간을 줄일 수 있다.</li>
<li><strong>데이터 크기</strong>: 실시간 포인트 클라우드 데이터의 크기는 매우 클 수 있으며, 이를 적절하게 축소하거나 필터링하는 과정이 필요하다. 데이터의 전처리 과정을 통해 중요한 정보를 유지하면서도 불필요한 데이터를 제거하는 것이 중요하다.</li>
</ul>
<h3 id="pcl">PCL에서의 실시간 처리 구조</h3>
<p>PCL에서 실시간 처리를 구현하기 위해서는 다음과 같은 주요 구조가 사용된다.</p>
<h4 id="1-voxel-grid">1. <strong>Voxel Grid 필터</strong></h4>
<p>Voxel Grid 필터는 포인트 클라우드 데이터를 일정한 크기의 격자로 나누어 각 격자에 있는 포인트들의 평균을 계산하여 데이터를 축소하는 기법이다. 이를 통해 데이터의 크기를 줄이면서 중요한 특징을 유지할 수 있다. 이 과정은 실시간 처리에 있어 매우 유용하다.</p>
<p>포인트의 좌표를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p} = (x, y, z)</span><script type="math/tex">\mathbf{p} = (x, y, z)</script></span>로 정의하고, 격자 크기를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v} = (v_x, v_y, v_z)</span><script type="math/tex">\mathbf{v} = (v_x, v_y, v_z)</script></span>로 설정한 경우, 각 격자 내의 평균 포인트 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p_{avg}}</span><script type="math/tex">\mathbf{p_{avg}}</script></span>는 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p_{avg}} = \frac{1}{n} \sum_{i=1}^{n} \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
\mathbf{p_{avg}} = \frac{1}{n} \sum_{i=1}^{n} \mathbf{p}_i
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 해당 격자 내에 포함된 포인트들이다.</p>
<h4 id="2-passthrough">2. <strong>Passthrough 필터</strong></h4>
<p>Passthrough 필터는 포인트 클라우드 데이터를 특정 축에 따라 필터링하는 기법이다. 예를 들어, Z축을 기준으로 포인트를 필터링할 때는 설정한 범위 내의 포인트들만을 남기고 나머지 포인트들은 제거한다. 이 필터는 간단하면서도 매우 효율적이기 때문에 실시간 처리에서 자주 사용된다.</p>
<p>필터링 범위를 <span class="arithmatex"><span class="MathJax_Preview">[z_{\text{min}}, z_{\text{max}}]</span><script type="math/tex">[z_{\text{min}}, z_{\text{max}}]</script></span>로 설정하면, 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p} = (x, y, z)</span><script type="math/tex">\mathbf{p} = (x, y, z)</script></span>에 대해 필터링 조건은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
z_{\text{min}} \leq z \leq z_{\text{max}}
</div>
<script type="math/tex; mode=display">
z_{\text{min}} \leq z \leq z_{\text{max}}
</script>
</div>
<h4 id="3-statistical-outlier-removal">3. <strong>Statistical Outlier Removal</strong></h4>
<p>Statistical Outlier Removal(SOR) 필터는 각 포인트의 주변 이웃과의 거리 통계를 기반으로 이상치를 제거하는 방법이다. 이 필터는 특히 노이즈가 포함된 데이터에서 유용하며, 실시간 처리에서도 효과적으로 사용될 수 있다.</p>
<p>SOR 필터에서 각 포인트 \mathbf{p}_i에 대해 k개의 가장 가까운 이웃 포인트들과의 평균 거리 \bar{d}를 계산한 후, 거리 값이 평균에서 크게 벗어난 포인트들은 이상치로 간주하여 제거한다. 이 과정은 다음과 같이 표현될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\bar{d} = \frac{1}{k} \sum_{j=1}^{k} d(\mathbf{p}_i, \mathbf{p}_j)
</div>
<script type="math/tex; mode=display">
\bar{d} = \frac{1}{k} \sum_{j=1}^{k} d(\mathbf{p}_i, \mathbf{p}_j)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">d(\mathbf{p}_i, \mathbf{p}_j)</span><script type="math/tex">d(\mathbf{p}_i, \mathbf{p}_j)</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 이웃 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span> 간의 거리이다.</p>
<h3 id="_2">실시간 데이터 스트리밍 구조</h3>
<p>실시간 처리를 위해서는 PCL과 함께 멀티스레딩 및 데이터 스트리밍을 결합하는 것이 필수적이다. PCL에서 제공하는 <strong>pcl::Grabber</strong> 클래스는 다양한 센서로부터 실시간 데이터를 수집할 수 있는 인터페이스를 제공한다. 이 클래스는 특정 센서에 맞는 드라이버와 연결되어 연속적인 포인트 클라우드 데이터를 읽어들이며, 처리 파이프라인으로 데이터를 넘긴다.</p>
<h4 id="1-pclgrabber">1. <strong>pcl::Grabber의 구조</strong></h4>
<p>Grabber 클래스는 센서에서 데이터를 받는 콜백 함수를 설정하고, 이를 통해 실시간으로 데이터를 스트리밍한다. 콜백 함수에서는 입력된 포인트 클라우드 데이터를 필터링하거나 변환하는 등의 작업을 수행할 수 있다. 예를 들어, LiDAR로부터 실시간으로 데이터를 수집하는 경우는 다음과 같은 흐름으로 진행된다:</p>
<ul>
<li>Grabber 인스턴스를 생성하여 센서와 연결한다.</li>
<li>콜백 함수를 정의하여 입력 데이터를 처리한다.</li>
<li>Grabber가 실행되면서 일정 주기마다 콜백 함수가 호출되고, 포인트 클라우드 데이터가 처리된다.</li>
</ul>
<p>PCL을 활용한 실시간 데이터 처리에서는 이러한 스트리밍 구조가 매우 중요한 역할을 한다.</p>
<h3 id="2">2. <strong>멀티스레딩을 이용한 데이터 처리</strong></h3>
<p>실시간 처리에서 중요한 또 다른 요소는 멀티스레딩을 통해 여러 작업을 병렬로 처리하는 것이다. PCL에서는 멀티스레딩을 효율적으로 구현하여 데이터 수집과 처리, 시각화 등을 동시에 진행할 수 있다. 이를 위해 C++의 표준 스레드 라이브러리를 사용할 수 있으며, PCL의 Grabber와 결합하여 구현할 수 있다.</p>
<p>멀티스레딩을 적용한 실시간 포인트 클라우드 처리의 기본 구조는 다음과 같다:</p>
<ul>
<li>
<p><strong>스레드 1: 데이터 수집</strong><br/>
  첫 번째 스레드는 센서로부터 데이터를 수집하는 역할을 한다. Grabber 클래스는 이 스레드 내에서 실행되며, 주기적으로 새로운 포인트 클라우드 데이터를 받아온다.</p>
</li>
<li>
<p><strong>스레드 2: 데이터 처리</strong><br/>
  두 번째 스레드는 수집된 데이터를 실시간으로 처리한다. 필터링, 변환, 이상치 제거 등의 작업이 이 스레드에서 이루어진다. 각 데이터에 대한 처리가 완료되면, 결과를 다른 모듈로 전달하거나 시각화를 위한 데이터로 사용할 수 있다.</p>
</li>
</ul>
<p>멀티스레딩을 적용하여 두 가지 작업을 동시에 수행하면, 데이터 수집과 처리 간의 병목 현상을 줄일 수 있어 실시간 처리가 가능해진다. 이를 통해 데이터가 지속적으로 입력되더라도 처리 지연 시간을 최소화할 수 있다.</p>
<p>멀티스레딩을 이용한 실시간 처리 구조를 나타내면 아래와 같다:</p>
<div class="mermaid">graph LR
    A[Sensor Data Stream] --&gt;|Grabber| B[Thread 1: Data Collection]
    B --&gt; C[Thread 2: Data Processing]
    C --&gt; D[Visualization/Storage]
</div>
<h3 id="_3">포인트 클라우드 처리 파이프라인</h3>
<p>실시간 데이터 처리에서 중요한 개념은 전체 처리 파이프라인을 적절하게 구성하는 것이다. PCL에서는 다양한 필터와 알고리즘을 연결하여 하나의 연속적인 처리 파이프라인을 구성할 수 있다. 이 파이프라인은 데이터가 입력된 순간부터 최종 결과가 나올 때까지의 모든 처리 과정을 포함한다.</p>
<h4 id="1">1. <strong>입력 데이터 수집</strong></h4>
<p>포인트 클라우드 데이터를 실시간으로 센서로부터 읽어온다. 이때 Grabber 클래스가 사용된다.</p>
<h4 id="2_1">2. <strong>필터링 및 데이터 축소</strong></h4>
<p>입력된 데이터는 노이즈와 불필요한 정보를 제거하기 위해 필터링된다. Voxel Grid 필터를 통해 포인트 수를 줄이거나, Passthrough 필터를 이용하여 특정 범위의 데이터만을 남긴다.</p>
<h4 id="3">3. <strong>특징 추출</strong></h4>
<p>필터링된 데이터로부터 중요한 특징을 추출한다. 예를 들어, 표면의 법선 벡터나 곡률 정보를 계산할 수 있다. 특징 추출 단계는 주로 후속 처리에 필요한 정보를 제공하기 위해 사용된다.</p>
<p>특징 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>로부터 다음과 같은 방식으로 추출될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{f} = \varphi(\mathbf{p}, \mathbf{n})
</div>
<script type="math/tex; mode=display">
\mathbf{f} = \varphi(\mathbf{p}, \mathbf{n})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>은 표면 법선 벡터, <span class="arithmatex"><span class="MathJax_Preview">\varphi</span><script type="math/tex">\varphi</script></span>는 특징 추출 함수이다.</p>
<h4 id="4">4. <strong>클러스터링 및 세그멘테이션</strong></h4>
<p>포인트 클라우드를 개별 객체나 영역으로 나누기 위해 클러스터링 알고리즘을 적용한다. 이 과정에서는 Euclidean 클러스터링이나 K-means 알고리즘 등이 사용될 수 있다. 클러스터링은 실시간 처리에서도 효율적으로 동작할 수 있는 방법으로 설계되어야 한다.</p>
<p>포인트 클라우드의 클러스터링은 주어진 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 그 이웃 포인트들의 집합 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{N}</span><script type="math/tex">\mathcal{N}</script></span>을 기반으로 하며, 클러스터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 다음과 같이 정의될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \{ \mathbf{p}_i \ | \ d(\mathbf{p}_i, \mathbf{p}_j) \leq \epsilon, \forall \mathbf{p}_j \in \mathcal{N} \}
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \{ \mathbf{p}_i \ | \ d(\mathbf{p}_i, \mathbf{p}_j) \leq \epsilon, \forall \mathbf{p}_j \in \mathcal{N} \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>은 클러스터링의 거리 임계값이다.</p>
<h4 id="5">5. <strong>결과 시각화 및 전송</strong></h4>
<p>실시간 처리의 마지막 단계에서는 처리된 포인트 클라우드를 시각화하거나 다른 시스템으로 전송한다. 시각화는 OpenGL 기반의 PCLVisualizer 클래스 또는 VTK를 이용하여 구현할 수 있다. 또한, 결과 데이터를 파일로 저장하거나 네트워크를 통해 다른 시스템으로 전송할 수도 있다.</p>
<h3 id="pcl_1">PCL에서의 최적화 기법</h3>
<p>실시간 처리를 위해서는 데이터 처리 속도를 최대화하기 위한 다양한 최적화 기법이 필요하다. PCL에서는 다음과 같은 최적화 기법을 제공한다.</p>
<h4 id="1_1">1. <strong>데이터 병렬 처리</strong></h4>
<p>OpenMP나 TBB(인텔 Threading Building Blocks)를 이용하여 포인트 클라우드의 각 포인트에 대해 병렬로 작업을 수행할 수 있다. 특히, 대용량 데이터에 대해 병렬 처리를 적용하면 속도를 크게 향상시킬 수 있다. 예를 들어, 각 포인트의 법선 벡터를 계산하는 작업을 병렬로 나눌 수 있다.</p>
<h4 id="2-kd-tree">2. <strong>KD-Tree 기반 가속</strong></h4>
<p>포인트 클라우드 데이터에서 최근접 이웃을 찾는 작업은 매우 자주 발생하는데, 이때 KD-Tree를 사용하면 이러한 연산을 효율적으로 처리할 수 있다. KD-Tree는 다차원 공간에서의 최근접 이웃 탐색을 빠르게 수행하는 자료구조로, 실시간 처리에서도 유용하다.</p>
<h4 id="3-cuda">3. <strong>CUDA 가속</strong></h4>
<p>PCL은 CUDA를 이용한 GPU 가속을 지원하여 실시간 처리의 성능을 더욱 향상시킬 수 있다. CUDA 기반의 병렬 처리는 특히 많은 양의 데이터를 동시에 처리해야 하는 상황에서 큰 이점을 제공한다.</p>
<h3 id="gpu">GPU 가속을 이용한 실시간 처리</h3>
<p>PCL은 기본적으로 CPU 기반의 포인트 클라우드 처리 라이브러리이지만, CUDA와 같은 GPU 가속 기법을 적용하여 실시간 처리 성능을 극대화할 수 있다. GPU는 다수의 연산을 병렬로 수행할 수 있기 때문에 포인트 클라우드 데이터와 같은 대규모 3D 데이터를 실시간으로 처리하는 데 적합하다. PCL은 GPU 모듈을 통해 일부 필터링 및 데이터 처리를 GPU 가속 방식으로 수행할 수 있다.</p>
<h4 id="1-cuda-pcl">1. <strong>CUDA 기반 PCL 처리</strong></h4>
<p>CUDA는 NVIDIA GPU에서 병렬 프로그래밍을 수행할 수 있도록 지원하는 프레임워크다. PCL은 CUDA를 이용하여 Voxel Grid 필터, 표면 재구성, 클러스터링 등의 작업을 GPU에서 처리할 수 있는 모듈을 제공한다. 이러한 모듈을 사용하면 CPU만을 사용할 때보다 훨씬 더 빠르게 데이터를 처리할 수 있다.</p>
<p>예를 들어, CUDA를 사용한 Voxel Grid 필터는 다음과 같은 흐름으로 동작한다.</p>
<ol>
<li>포인트 클라우드 데이터를 GPU 메모리로 전송한다.</li>
<li>각 포인트에 대해 격자 공간 상에서의 위치를 계산한다.</li>
<li>같은 격자에 속하는 포인트들의 평균을 계산하여 하나의 포인트로 축소한다.</li>
<li>결과 데이터를 GPU 메모리에서 읽어 CPU 메모리로 다시 전송한다.</li>
</ol>
<p>CUDA 기반의 처리는 주로 다음과 같은 PCL의 모듈을 통해 이루어진다:
- <strong>pcl::gpu::VoxelGrid</strong>: GPU 가속화된 Voxel Grid 필터
- <strong>pcl::gpu::NormalEstimation</strong>: GPU에서 표면 법선 벡터를 계산하는 모듈</p>
<h4 id="2-gpu">2. <strong>GPU 가속의 장단점</strong></h4>
<p>GPU 가속을 사용하면 실시간 처리에서 많은 이점을 얻을 수 있지만, 모든 경우에 GPU를 사용하는 것이 최적의 선택은 아니다. GPU 가속의 장단점은 다음과 같다.</p>
<ul>
<li><strong>장점</strong>:  </li>
<li>다수의 포인트를 병렬로 처리할 수 있어, 대규모 포인트 클라우드 데이터에서 높은 처리 속도를 제공한다.</li>
<li>
<p>CPU와는 별도로 GPU에서 연산을 수행하기 때문에, CPU가 다른 작업을 수행할 수 있어 전반적인 시스템 성능을 향상시킬 수 있다.</p>
</li>
<li>
<p><strong>단점</strong>:  </p>
</li>
<li>모든 작업이 GPU 가속에 적합하지 않으며, GPU 메모리로의 데이터 전송과 같은 추가적인 비용이 발생한다.</li>
<li>GPU를 사용하려면 NVIDIA의 CUDA 지원이 필요하며, GPU의 성능에 따라 처리 속도가 좌우된다.</li>
</ul>
<h3 id="_4">실시간 처리에 최적화된 데이터 구조</h3>
<p>실시간으로 포인트 클라우드 데이터를 처리할 때는 효율적인 데이터 구조를 사용하는 것이 매우 중요하다. PCL에서는 주로 <strong>KD-Tree</strong>, <strong>Octree</strong>와 같은 공간 분할 자료구조를 사용하여 포인트 간의 탐색과 거리 계산을 빠르게 수행한다. 이러한 구조는 실시간 처리의 핵심이 되는 인접 포인트 탐색 및 충돌 검출과 같은 작업에서 큰 역할을 한다.</p>
<h4 id="1-kd-tree">1. <strong>KD-Tree</strong></h4>
<p>KD-Tree는 k차원 공간에서 포인트를 효율적으로 저장하고 탐색하기 위한 자료구조다. 실시간 처리에서 주로 최근접 이웃 탐색(Nearest Neighbor Search)을 빠르게 수행하기 위해 사용된다. 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 이웃 포인트들 간의 거리를 빠르게 계산하여 클러스터링이나 필터링에서 활용된다.</p>
<p>KD-Tree를 이용한 최근접 이웃 탐색은 다음과 같은 방식으로 동작한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{p}_j} d(\mathbf{p}_i, \mathbf{p}_j)
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{p}_j} d(\mathbf{p}_i, \mathbf{p}_j)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">d(\mathbf{p}_i, \mathbf{p}_j)</span><script type="math/tex">d(\mathbf{p}_i, \mathbf{p}_j)</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i와 \mathbf{p}_j</span><script type="math/tex">\mathbf{p}_i와 \mathbf{p}_j</script></span> 간의 거리다.</p>
<h4 id="2-octree">2. <strong>Octree</strong></h4>
<p>Octree는 3D 공간을 8개의 하위 공간으로 반복적으로 분할하여 포인트를 저장하는 자료구조다. 주로 충돌 검출, 영역 분할, 다운샘플링 등에 사용된다. Octree는 특히 공간 내의 객체들이 고르게 분포하지 않는 경우, 효율적으로 탐색 및 분할을 수행할 수 있다.</p>
<p>Octree에서 각 노드에 저장되는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 위치는 다음과 같은 규칙에 의해 결정된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i \in \left[ x_{\text{min}}, x_{\text{max}} \right] \times \left[ y_{\text{min}}, y_{\text{max}} \right] \times \left[ z_{\text{min}}, z_{\text{max}} \right]
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i \in \left[ x_{\text{min}}, x_{\text{max}} \right] \times \left[ y_{\text{min}}, y_{\text{max}} \right] \times \left[ z_{\text{min}}, z_{\text{max}} \right]
</script>
</div>
<p>이러한 분할 과정을 반복함으로써 3D 공간에서의 포인트들을 효율적으로 관리할 수 있다.</p>
<h4 id="3_1">3. <strong>플랫 데이터 구조</strong></h4>
<p>포인트 클라우드 데이터는 플랫 배열 형태로 저장될 수 있으며, 이를 통해 메모리 액세스 속도를 높일 수 있다. PCL에서는 포인트 데이터를 배열로 처리할 수 있는 기능을 제공하며, 이를 통해 데이터 캐싱 및 병렬 처리가 가능하다. 플랫 배열 구조는 CPU 캐시를 효율적으로 사용하여 메모리 접근 시간을 줄이는 데 기여한다.</p>
<h3 id="_5">실시간 처리에 필요한 하드웨어 요구 사항</h3>
<p>PCL을 이용한 실시간 포인트 클라우드 처리는 하드웨어 성능에 크게 의존한다. 특히, 고성능의 하드웨어는 대규모 데이터를 처리할 때 매우 중요한 역할을 한다. 실시간 처리에 적합한 하드웨어 구성 요소는 다음과 같다.</p>
<h4 id="1-cpu">1. <strong>고성능 CPU</strong></h4>
<p>실시간 포인트 클라우드 처리를 위해서는 다중 코어를 지원하는 고성능의 CPU가 필요하다. 특히 병렬 처리를 지원하는 CPU는 데이터 처리 속도를 크게 향상시킨다. 일반적으로 6코어 이상, 높은 클럭 속도의 프로세서가 추천된다.</p>
<h4 id="2-gpu-cuda">2. <strong>GPU (CUDA 지원)</strong></h4>
<p>CUDA를 사용하여 병렬 처리를 수행할 계획이라면, 고성능의 NVIDIA GPU가 필요하다. 특히 최근의 RTX 시리즈 GPU는 실시간 3D 데이터 처리에서 뛰어난 성능을 제공한다. GPU 메모리 용량도 중요하며, 최소 6GB 이상의 GPU 메모리가 필요하다.</p>
<h4 id="3-ram">3. <strong>메모리 (RAM)</strong></h4>
<p>대규모 포인트 클라우드를 실시간으로 처리하기 위해서는 충분한 시스템 메모리가 필요하다. 실시간 데이터 처리 중 많은 양의 데이터를 동시에 처리해야 하므로 최소 16GB 이상의 RAM이 필요하며, 대규모 데이터를 처리할 때는 32GB 이상의 메모리가 권장된다.</p>
<h4 id="4_1">4. <strong>고속 저장 장치</strong></h4>
<p>SSD(Solid State Drive)와 같은 고속 저장 장치는 실시간 데이터 입출력에서 매우 중요한 역할을 한다. 대용량의 포인트 클라우드를 처리할 때 저장 장치의 속도가 전체 처리 속도에 큰 영향을 미칠 수 있다. NVMe SSD는 특히 빠른 속도를 제공하여 실시간 처리에 적합하다.</p>
<h3 id="_6">실시간 데이터 처리에 사용되는 알고리즘</h3>
<p>PCL을 이용한 실시간 포인트 클라우드 처리에서는 특정 작업을 수행하기 위한 여러 알고리즘이 사용된다. 이러한 알고리즘은 주로 데이터의 축소, 정렬, 클러스터링, 특징 추출 등을 목표로 하며, 각각의 알고리즘은 실시간으로 수행될 수 있도록 최적화된다. 여기서는 PCL에서 주로 사용되는 몇 가지 실시간 처리 알고리즘을 다룬다.</p>
<h4 id="1-euclidean">1. <strong>Euclidean 클러스터링</strong></h4>
<p>Euclidean 클러스터링은 포인트 클라우드 데이터에서 공간적으로 가까운 포인트들을 하나의 클러스터로 그룹화하는 알고리즘이다. 이 알고리즘은 각 포인트에 대해 인접한 포인트들을 탐색하여 일정 거리 내의 포인트들을 클러스터로 묶는다. PCL에서는 <strong>pcl::EuclideanClusterExtraction</strong> 클래스를 제공하여 이 알고리즘을 실시간으로 사용할 수 있다.</p>
<p>Euclidean 클러스터링의 기본 알고리즘은 다음과 같다:</p>
<ol>
<li>각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해, 주어진 거리 임계값 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span> 내의 모든 이웃 포인트들을 찾는다.</li>
<li>이러한 이웃 포인트들과 함께 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>를 하나의 클러스터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}_k</span><script type="math/tex">\mathbf{C}_k</script></span>로 묶는다.</li>
<li>클러스터에 속하지 않은 나머지 포인트들에 대해 이 과정을 반복한다.</li>
</ol>
<p>이 과정을 통해 데이터는 여러 클러스터로 분할되며, 클러스터 크기나 밀도에 따라 유동적으로 동작할 수 있다. Euclidean 클러스터링의 거리 기준은 다음과 같이 수식으로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{p}_i, \mathbf{p}_j) \leq \epsilon
</div>
<script type="math/tex; mode=display">
d(\mathbf{p}_i, \mathbf{p}_j) \leq \epsilon
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>은 두 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span> 사이의 거리 임계값이다.</p>
<h4 id="2-ransac">2. <strong>RANSAC을 이용한 평면 추출</strong></h4>
<p>RANSAC(Random Sample Consensus)은 포인트 클라우드 데이터에서 특정한 기하학적 구조를 추출하기 위한 알고리즘이다. 특히, 평면이나 구와 같은 기하학적 구조를 실시간으로 추출하는 데 유용하다. PCL에서는 <strong>pcl::SACSegmentation</strong> 클래스를 통해 RANSAC 기반의 평면 추출 알고리즘을 제공한다.</p>
<p>RANSAC의 기본 원리는 데이터 중 일부 포인트를 무작위로 선택하여 가설 모델을 만들고, 나머지 포인트들이 이 모델에 얼마나 잘 맞는지를 평가하는 것이다. 이를 통해 노이즈나 이상치(outlier)에도 강건하게 동작할 수 있다.</p>
<p>평면 추출의 경우, 주어진 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i = (x_i, y_i, z_i)</span><script type="math/tex">\mathbf{p}_i = (x_i, y_i, z_i)</script></span>에 대해 평면 방정식 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a} \cdot \mathbf{p}_i + d = 0</span><script type="math/tex">\mathbf{a} \cdot \mathbf{p}_i + d = 0</script></span>을 만족하는 포인트들을 찾아야 한다. 여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>는 평면의 법선 벡터이고, d는 평면과 원점 사이의 거리이다.</p>
<p>RANSAC 알고리즘은 다음과 같이 동작한다:
1. 데이터에서 무작위로 3개의 포인트를 선택하여 평면 방정식을 유도한다.
2. 나머지 포인트들이 이 평면 방정식에 얼마나 잘 맞는지(거리 오차를 기준으로) 평가한다.
3. 적합한 포인트들의 집합이 최대가 되는 경우를 찾는다.</p>
<p>수식으로 표현하면, 평면에서 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 평면 사이의 거리가 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span> 이하일 때 이를 적합한 포인트로 간주한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\left| \mathbf{a} \cdot \mathbf{p}_i + d \right| \leq \epsilon
</div>
<script type="math/tex; mode=display">
\left| \mathbf{a} \cdot \mathbf{p}_i + d \right| \leq \epsilon
</script>
</div>
<h4 id="3-normal-estimation">3. <strong>법선 추정 (Normal Estimation)</strong></h4>
<p>포인트 클라우드에서 각 포인트의 표면 법선 벡터를 추정하는 것은 특징 추출이나 평면 분할과 같은 작업에 필수적이다. PCL에서는 <strong>pcl::NormalEstimation</strong> 클래스를 통해 실시간으로 포인트 클라우드의 법선 벡터를 계산할 수 있다.</p>
<p>법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_i</span><script type="math/tex">\mathbf{n}_i</script></span>는 주어진 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 이웃 포인트들을 기반으로 계산된다. 이를 위해 주어진 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 주변 k개의 가장 가까운 이웃 포인트들의 좌표 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>를 정의하고, 이를 기반으로 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>를 계산한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \frac{1}{k} \sum_{j=1}^{k} (\mathbf{p}_j - \bar{\mathbf{p}}) (\mathbf{p}_j - \bar{\mathbf{p}})^\top
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \frac{1}{k} \sum_{j=1}^{k} (\mathbf{p}_j - \bar{\mathbf{p}}) (\mathbf{p}_j - \bar{\mathbf{p}})^\top
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\bar{\mathbf{p}}</span><script type="math/tex">\bar{\mathbf{p}}</script></span>는 이웃 포인트들의 평균 좌표이다. 공분산 행렬의 가장 작은 고유벡터가 해당 포인트의 법선 벡터가 된다. 이를 통해 각 포인트의 기하학적 정보를 실시간으로 추출할 수 있다.</p>
<h4 id="4_2">4. <strong>다운샘플링</strong></h4>
<p>대용량의 포인트 클라우드 데이터를 실시간으로 처리하기 위해서는 데이터를 축소하는 과정이 필수적이다. PCL에서는 <strong>pcl::VoxelGrid</strong> 필터를 통해 포인트 클라우드를 다운샘플링할 수 있다. VoxelGrid 필터는 데이터를 3차원 격자 공간으로 분할하고, 각 격자 내의 포인트들을 하나의 대표 포인트로 축소한다.</p>
<p>다운샘플링 과정을 통해 데이터의 크기를 크게 줄일 수 있으며, 실시간 처리에 필수적인 성능 최적화를 달성할 수 있다.</p>
<p>다운샘플링된 포인트의 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{\text{down}}</span><script type="math/tex">\mathbf{p}_{\text{down}}</script></span>는 격자 공간 내의 모든 포인트의 평균으로 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_{\text{down}} = \frac{1}{n} \sum_{i=1}^{n} \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
\mathbf{p}_{\text{down}} = \frac{1}{n} \sum_{i=1}^{n} \mathbf{p}_i
</script>
</div>
<h3 id="_7">실시간 포인트 클라우드 처리의 응용</h3>
<p>PCL을 이용한 실시간 포인트 클라우드 처리 기법은 다양한 응용 분야에서 활용될 수 있다. 여기서는 주요 응용 분야를 간략하게 살펴본다.</p>
<h4 id="1_2">1. <strong>자율 주행 차량</strong></h4>
<p>LiDAR나 3D 카메라를 사용하는 자율 주행 차량에서는 실시간으로 들어오는 포인트 클라우드 데이터를 분석하여 주행 경로를 계획하고, 장애물을 회피해야 한다. 실시간 처리의 성능이 자율 주행 시스템의 안전성과 직결되기 때문에, PCL을 이용한 고속 필터링 및 클러스터링 기법이 매우 유용하다.</p>
<h4 id="2_2">2. <strong>로봇 공학</strong></h4>
<p>로봇 공학에서는 로봇이 실시간으로 주변 환경을 인식하고, 물체를 탐지하거나 경로를 계획하는 데 포인트 클라우드 데이터가 사용된다. 특히, PCL의 실시간 처리 기능을 이용하면 로봇이 즉각적으로 환경을 인식하고, 이에 맞는 적절한 행동을 수행할 수 있다.</p>
<h4 id="3_2">3. <strong>증강 현실</strong></h4>
<p>증강 현실(AR) 시스템에서는 카메라나 깊이 센서로부터 실시간으로 포인트 클라우드 데이터를 수집하고, 이를 기반으로 가상 객체를 적절히 배치한다. 이러한 응용에서는 매우 빠른 속도로 포인트 클라우드 데이터를 처리해야 하며, PCL의 실시간 처리 능력이 중요한 역할을 한다.</p>
<h4 id="4-3d">4. <strong>3D 스캐닝 및 모델링</strong></h4>
<p>실시간 3D 스캐닝 시스템에서는 포인트 클라우드 데이터를 이용하여 대상 물체의 3D 모델을 즉각적으로 생성하고 시각화할 수 있다. PCL의 실시간 처리 기법은 3D 스캐너가 연속적으로 데이터를 수집하는 동안, 빠르고 정확하게 3D 모델을 생성할 수 있도록 돕는다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../../chapter_17/1701/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../../chapter_17/1701/">
        포인트 클라우드에서의 충돌 감지
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../1604/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../1604/">
        데이터 축소와 샘플링 기법
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>