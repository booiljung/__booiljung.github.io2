<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introduction_to_pointcloud_processing_with_pcl_library/chapter_29/2901/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>수중 포인트 클라우드 데이터의 특성 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "1. \ube5b\uacfc \uc74c\ud30c\uc758 \ud761\uc218 \ubc0f \uc0b0\ub780", url: "#_top", children: [
          ]},
          {title: "2. \uc218\uc911 \ub9e4\uccb4\uc758 \ubd88\uade0\uc77c\uc131", url: "#2", children: [
          ]},
          {title: "3. \uc218\uc911\uc5d0\uc11c\uc758 \uc2e0\ud638 \uac10\uc1e0\uc640 \ub178\uc774\uc988", url: "#3", children: [
          ]},
          {title: "7. \uc218\uc911 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub370\uc774\ud130\uc758 \uc815\ud569 \ubc0f \ubcf4\uc815", url: "#7", children: [
              {title: "(1) \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc815\ud569", url: "#1_1" },
              {title: "(2) \ub370\uc774\ud130 \ubcf4\uc815", url: "#2_1" },
          ]},
          {title: "8. \uc218\uc911 \ud658\uacbd\uc5d0\uc11c\uc758 \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ucc98\ub9ac", url: "#8", children: [
              {title: "(1) \ub370\uc774\ud130 \uc555\ucd95\uacfc \uc804\uc1a1 \ud6a8\uc728\ud654", url: "#1_2" },
              {title: "(2) \ubcd1\ub82c \ucc98\ub9ac\uc640 \ubd84\uc0b0 \uc2dc\uc2a4\ud15c", url: "#2_2" },
              {title: "(3) \uc54c\uace0\ub9ac\uc998 \ucd5c\uc801\ud654", url: "#3_1" },
              {title: "(4) \uc2e4\uc2dc\uac04 \ud544\ud130\ub9c1", url: "#4" },
          ]},
          {title: "9. \uc218\uc911 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc758 \uc815\ubc00 \ubcf4\uc815 \uae30\ubc95", url: "#9", children: [
              {title: "(1) \ub2e4\uc911 \uc13c\uc11c \ub370\uc774\ud130\ub97c \uc774\uc6a9\ud55c \ubcf4\uc815", url: "#1_3" },
              {title: "(2) \uc74c\ud30c \uc13c\uc11c\uc640 \uad11\ud559 \uc13c\uc11c\uc758 \ub370\uc774\ud130 \uc735\ud569", url: "#2_3" },
              {title: "(3) \uc2e4\uc2dc\uac04 \ubcf4\uc815 \ubc0f \ud544\ud130\ub9c1", url: "#3_2" },
              {title: "(4) \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc758 \ud488\uc9c8 \ubd84\uc11d \ubc0f \ud3c9\uac00", url: "#4_1" },
          ]},
          {title: "10. \uc218\uc911 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub370\uc774\ud130\uc758 \uc815\ud655\ub3c4 \ud5a5\uc0c1\uc744 \uc704\ud55c \ucd5c\uc801\ud654", url: "#10", children: [
              {title: "(1) \ucd5c\uc801\ud654\ub41c \uc13c\uc11c \ubc30\uce58", url: "#1_4" },
              {title: "(2) \ub370\uc774\ud130 \ucde8\ud569 \ubc0f \uc911\ubcf5 \uc81c\uac70", url: "#2_4" },
              {title: "(3) \uc801\uc751\uc801 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc0d8\ud50c\ub9c1", url: "#3_3" },
              {title: "(4) \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc758 \uc9c0\uc624\uba54\ud2b8\ub9ac \ubd84\uc11d", url: "#4_2" },
          ]},
          {title: "11. \uc218\uc911 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc758 \uc815\ubc00 \ud544\ud130\ub9c1 \uae30\ubc95", url: "#11", children: [
              {title: "(1) \ud1b5\uacc4\uc801 \ud544\ud130\ub9c1(Statistical Outlier Removal)", url: "#1-statistical-outlier-removal" },
              {title: "(2) \ud328\uc2a4\uc2a4\ub8e8 \ud544\ud130(PassThrough Filter)", url: "#2-passthrough-filter" },
              {title: "(3) \uc774\ub3d9 \ud3c9\uade0 \ud544\ud130(Moving Average Filter)", url: "#3-moving-average-filter" },
              {title: "(4) Bilateral \ud544\ud130", url: "#4-bilateral" },
              {title: "(5) \ucee4\ub110 \uae30\ubc18 \ud544\ud130\ub9c1", url: "#5" },
          ]},
          {title: "12. \uc218\uc911 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub370\uc774\ud130\uc758 \ud6c4\ucc98\ub9ac \uae30\ubc95", url: "#12", children: [
              {title: "(1) \ud074\ub7ec\uc2a4\ud130\ub9c1 \uae30\ubc95", url: "#1_5" },
              {title: "(2) \uc815\ub82c \ubc0f \ub9e4\uce6d(Registration)", url: "#2-registration" },
              {title: "(3) \uba54\uc2dc \uc0dd\uc131 \ubc0f \ubcc0\ud658", url: "#3_4" },
              {title: "(4) \ud45c\uba74 \uc7ac\uad6c\uc131(Surface Reconstruction)", url: "#4-surface-reconstruction" },
              {title: "(5) \ud14d\uc2a4\ucc98 \ub9e4\ud551", url: "#5_1" },
          ]},
          {title: "13. \uc218\uc911 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc758 \ub370\uc774\ud130 \uc815\ud569 \uc624\ub958\uc640 \ubcf4\uc815", url: "#13", children: [
              {title: "(1) \uc815\ud569 \uc624\ub958\uc758 \uc720\ud615", url: "#1_6" },
              {title: "(2) \uc13c\uc11c \ubcf4\uc815 \uae30\ubc95", url: "#2_5" },
              {title: "(3) \ub370\uc774\ud130 \ubcf4\uac04 \ubc0f \ubcf4\uc815", url: "#3_5" },
              {title: "(4) \uc815\ubc00 \uc815\ud569\uc744 \uc704\ud55c \uc54c\uace0\ub9ac\uc998", url: "#4_3" },
              {title: "(5) \ud574\uc591 \ud0d0\uc0ac\uc5d0\uc11c\uc758 \ubcf4\uc815 \uc0ac\ub840", url: "#5_2" },
          ]},
          {title: "14. \uc218\uc911 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub370\uc774\ud130\uc758 \ud488\uc9c8 \ud3c9\uac00 \uc9c0\ud45c", url: "#14", children: [
              {title: "(1) \uc815\ubc00\ub3c4(Precision)\uc640 \uc815\ud655\ub3c4(Accuracy)", url: "#1-precision-accuracy" },
              {title: "(2) \ud574\uc0c1\ub3c4(Resolution)", url: "#2-resolution" },
              {title: "(3) \ub178\uc774\uc988 \ube44\uc728(Noise Ratio)", url: "#3-noise-ratio" },
              {title: "(4) \ub370\uc774\ud130 \ubc00\ub3c4(Density)", url: "#4-density" },
              {title: "(5) \ub370\uc774\ud130 \uc644\uc804\uc131(Completeness)", url: "#5-completeness" },
              {title: "(6) \uc7ac\ud604\uc131(Reproducibility)", url: "#6-reproducibility" },
          ]},
          {title: "15. \uc218\uc911 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub370\uc774\ud130\uc758 \uc2e4\uc2dc\uac04 \ucc98\ub9ac \ubc0f \ucd5c\uc801\ud654", url: "#15", children: [
              {title: "(1) \uc2a4\ud2b8\ub9ac\ubc0d \ub370\uc774\ud130 \ucc98\ub9ac", url: "#1_7" },
              {title: "(2) \ubcd1\ub82c \ucc98\ub9ac \ubc0f GPU \uac00\uc18d", url: "#2-gpu" },
              {title: "(3) \ub370\uc774\ud130 \uc555\ucd95\uc744 \ud1b5\ud55c \uc804\uc1a1 \ucd5c\uc801\ud654", url: "#3_6" },
              {title: "(4) \uc2e4\uc2dc\uac04 \ub178\uc774\uc988 \ud544\ud130\ub9c1", url: "#4_4" },
              {title: "(5) \uc801\uc751\uc801 \uc0d8\ud50c\ub9c1 \uae30\ubc95", url: "#5_3" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2902/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2902/" class="btn btn-xs btn-link">
        소나와 라이다를 통한 데이터 수집
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_28/2805/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_28/2805/" class="btn btn-xs btn-link">
        항공 촬영을 통한 지형 분석 사례
      </a>
    </div>
    
  </div>

    

    <p>수중에서의 포인트 클라우드 데이터는 해양 환경에서의 특수한 조건 때문에 일반적인 육상 데이터와 여러 가지 차이점을 가지고 있다. 이러한 데이터는 주로 수중 스캐너, 음향 탐지기(Acoustic Sonar), 라이다(LiDAR) 등의 센서를 사용하여 획득되며, 물리적인 환경에 따른 몇 가지 중요한 특성을 반영한다.</p>
<h3 id="1">1. 빛과 음파의 흡수 및 산란</h3>
<p>수중 환경에서는 빛과 음파의 전파가 매우 제한적이다. 빛의 경우, 물 속에서는 매우 짧은 거리에서 강하게 흡수되며, 수심이 깊어질수록 가시성은 급격히 떨어진다. 이로 인해 수중 포인트 클라우드 데이터를 얻기 위해 주로 음파 기반 센서가 사용된다. 음파의 경우에는 흡수보다는 산란이 더 큰 문제로 작용한다. 물체의 표면이 고르지 않거나, 수중의 부유물 등이 음파를 산란시켜 데이터의 노이즈를 증가시킨다.</p>
<p>음파의 반사 강도는 일반적으로 수심, 수온, 염도 등에 의해 영향을 받는다. 수중에서 음파의 속도 <span class="arithmatex"><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>는 수온 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>, 염도 <span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>, 그리고 수압에 따라 달라진다. 이를 나타내는 일반적인 식은 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
v(T, S, P) = 1449.2 + 4.6T - 0.055T^2 + 0.00029T^3 + (1.34 - 0.01T)(S - 35) + 0.016P
</div>
<script type="math/tex; mode=display">
v(T, S, P) = 1449.2 + 4.6T - 0.055T^2 + 0.00029T^3 + (1.34 - 0.01T)(S - 35) + 0.016P
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 섭씨 온도, <span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>는 염분 농도(‰), <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>는 수압(kg/cm²)이다. 이러한 변수들로 인해 동일한 수중 환경에서도 음파 기반 포인트 클라우드 데이터는 측정 환경에 따라 달라질 수 있다.</p>
<h3 id="2">2. 수중 매체의 불균일성</h3>
<p>수중 환경은 온도, 염도, 압력 등의 변화로 인해 매우 불균일한 매체를 형성한다. 이 불균일성은 센서에서 발생하는 신호의 왜곡을 유발할 수 있으며, 포인트 클라우드 데이터에 영향을 미친다. 예를 들어, 수온이나 염도가 급격하게 변화하는 경우, 음파의 굴절 현상이 발생하여 실제 물체의 위치와 수집된 포인트 클라우드 데이터 상의 위치가 달라질 수 있다.</p>
<p>이를 보정하기 위한 일반적인 방법은 수온과 염도 변화에 따른 음파의 경로 변화를 모델링하는 것이다. 이를 위해 음파의 굴절률 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>을 나타내는 식은 다음과 같이 주어진다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
n = \frac{c_0}{v(T, S, P)}
</div>
<script type="math/tex; mode=display">
n = \frac{c_0}{v(T, S, P)}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">c_0</span><script type="math/tex">c_0</script></span>는 진공에서의 음속, <span class="arithmatex"><span class="MathJax_Preview">v(T, S, P)</span><script type="math/tex">v(T, S, P)</script></span>는 앞서 정의한 환경 변수에 따른 수중 음속이다. 이러한 굴절 현상은 포인트 클라우드 데이터의 해상도와 정밀도에 큰 영향을 미치며, 수중 환경에서의 정확한 데이터 처리를 위해서는 반드시 고려되어야 한다.</p>
<h3 id="3">3. 수중에서의 신호 감쇠와 노이즈</h3>
<p>수중에서는 신호의 감쇠가 특히 중요한 문제로 대두된다. 음파는 물 속에서 이동하면서 점차적으로 에너지를 잃게 되고, 그로 인해 신호의 세기가 약해진다. 이러한 감쇠는 거리와 주파수에 비례하여 증가한다. 음파의 감쇠 정도는 다음과 같은 식으로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
A(f, d) = A_0 e^{-\alpha(f) d}
</div>
<script type="math/tex; mode=display">
A(f, d) = A_0 e^{-\alpha(f) d}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">A_0</span><script type="math/tex">A_0</script></span>는 초기 신호 세기, <span class="arithmatex"><span class="MathJax_Preview">\alpha(f)</span><script type="math/tex">\alpha(f)</script></span>는 주파수 <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>에 따른 감쇠 계수, <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>는 전파 거리이다. 고주파 음파일수록 감쇠가 심하게 나타나며, 장거리 탐지에서는 저주파가 주로 사용된다.</p>
<p>이 과정에서 데이터에 포함되는 노이즈는 감쇠뿐만 아니라 수중 환경 자체의 복잡성에 의해 더욱 증가된다. 물 속에 존재하는 작은 부유물, 해양 생물, 그리고 다양한 물리적 요인들이 음파에 혼선을 야기하며, 결과적으로 포인트 클라우드 데이터의 품질을 저하시킨다. 이로 인해 수중 데이터 처리 시에는 필터링을 통한 노이즈 제거가 매우 중요하다.</p>
<h3 id="7">7. 수중 포인트 클라우드 데이터의 정합 및 보정</h3>
<p>수중 환경에서 수집된 포인트 클라우드 데이터를 정확하게 활용하려면 정합 및 보정 과정이 필수적이다. 이러한 데이터는 다양한 센서로부터 취합되며, 센서 간의 정렬 불일치가 발생할 수 있기 때문이다. 이를 해결하기 위해서는 다양한 정합 알고리즘과 보정 기법이 사용된다.</p>
<h4 id="1_1">(1) 포인트 클라우드 정합</h4>
<p>포인트 클라우드 정합은 여러 개의 다른 관측지점에서 취득한 데이터들을 하나의 통합된 데이터로 결합하는 과정이다. 가장 널리 사용되는 정합 알고리즘 중 하나는 <strong>Iterative Closest Point (ICP)</strong> 알고리즘이다. 이 알고리즘은 두 포인트 클라우드 간의 대응점을 찾고, 그에 따라 최적의 변환 행렬을 계산하여 두 클라우드를 정합한다.</p>
<p>ICP 알고리즘의 핵심은 다음과 같은 반복적 최적화 과정으로 이루어진다:</p>
<ol>
<li>두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>의 가장 가까운 점쌍을 찾는다.</li>
<li>대응점쌍들 사이의 거리 차이를 최소화하는 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 변위 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>를 계산한다.</li>
<li>이 변환을 이용하여 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>를 정렬한다.</li>
<li>충분한 수렴 조건이 충족될 때까지 과정을 반복한다.</li>
</ol>
<p>수식적으로, 주어진 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>에 대해 ICP는 다음 최적화 문제를 푼다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \| \mathbf{R} \mathbf{p}_i + \mathbf{t} - \mathbf{q}_i \|^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \| \mathbf{R} \mathbf{p}_i + \mathbf{t} - \mathbf{q}_i \|^2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>에서의 점, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span>는 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>에서의 대응점이다. <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>는 변환 매개변수로, 회전 및 변위에 해당한다.</p>
<h4 id="2_1">(2) 데이터 보정</h4>
<p>수중 환경에서 포인트 클라우드를 정확하게 처리하기 위해서는 데이터의 왜곡을 보정하는 작업이 필요하다. 수중에서는 센서의 위치나 환경 조건이 변하면서 데이터에 왜곡이 발생할 수 있다. 이를 해결하기 위해 자주 사용되는 방법은 센서의 자이로스코프와 가속도계 데이터를 활용하여 각 센서의 위치와 자세를 실시간으로 추정하는 것이다.</p>
<p>예를 들어, 수중 드론(ROV)이나 AUV(자율 수중 차량)는 끊임없이 이동하면서 데이터를 수집하는데, 이러한 이동에 따른 위치 및 자세 변화를 실시간으로 추정하기 위해서는 <strong>센서 융합(Fusion of Sensors)</strong> 기법이 사용된다. 여기에는 GPS, 자이로스코프, 가속도계, 그리고 음향 신호 기반의 로컬라이제이션 시스템 등이 포함된다. 이러한 기법은 주로 <strong>Kalman 필터</strong>나 <strong>확장된 칼만 필터 (EKF)</strong>를 사용하여 데이터를 융합한다.</p>
<p>확장된 칼만 필터는 비선형 시스템에서 상태 추정을 수행하는 필터링 알고리즘으로, 수중 환경의 비선형적인 특성을 고려하는 데 적합하다. EKF는 비선형 시스템의 상태 방정식을 선형화하여 칼만 필터 알고리즘을 적용하며, 포인트 클라우드의 위치 및 자세 보정을 위한 실시간 추정에 널리 사용된다.</p>
<p>EKF의 상태 추정 과정은 다음과 같은 수식으로 표현된다:</p>
<ol>
<li>상태 예측:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\hat{\mathbf{x}}_{k|k-1} = f(\hat{\mathbf{x}}_{k-1|k-1}, \mathbf{u}_k)
</div>
<script type="math/tex; mode=display">
\hat{\mathbf{x}}_{k|k-1} = f(\hat{\mathbf{x}}_{k-1|k-1}, \mathbf{u}_k)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k|k-1} = \mathbf{F}_{k} \mathbf{P}_{k-1|k-1} \mathbf{F}_{k}^\top + \mathbf{Q}_{k}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k|k-1} = \mathbf{F}_{k} \mathbf{P}_{k-1|k-1} \mathbf{F}_{k}^\top + \mathbf{Q}_{k}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{x}}_{k|k-1}</span><script type="math/tex">\hat{\mathbf{x}}_{k|k-1}</script></span>은 시간 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>에서의 예측 상태, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k|k-1}</span><script type="math/tex">\mathbf{P}_{k|k-1}</script></span>은 예측 오차 공분산 행렬이다. <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>는 시스템의 비선형 상태 전이 함수, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}_k</span><script type="math/tex">\mathbf{F}_k</script></span>는 상태 전이 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}_k</span><script type="math/tex">\mathbf{Q}_k</script></span>는 시스템 노이즈 공분산 행렬이다.</p>
<ol>
<li>관측 업데이트:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}_k^\top \left( \mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^\top + \mathbf{R}_k \right)^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}_k^\top \left( \mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^\top + \mathbf{R}_k \right)^{-1}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\hat{\mathbf{x}}_{k|k} = \hat{\mathbf{x}}_{k|k-1} + \mathbf{K}_k \left( \mathbf{z}_k - h(\hat{\mathbf{x}}_{k|k-1}) \right)
</div>
<script type="math/tex; mode=display">
\hat{\mathbf{x}}_{k|k} = \hat{\mathbf{x}}_{k|k-1} + \mathbf{K}_k \left( \mathbf{z}_k - h(\hat{\mathbf{x}}_{k|k-1}) \right)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k|k} = \left( \mathbf{I} - \mathbf{K}_k \mathbf{H}_k \right) \mathbf{P}_{k|k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k|k} = \left( \mathbf{I} - \mathbf{K}_k \mathbf{H}_k \right) \mathbf{P}_{k|k-1}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_k</span><script type="math/tex">\mathbf{K}_k</script></span>는 칼만 이득(Kalman Gain), <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}_k</span><script type="math/tex">\mathbf{H}_k</script></span>는 관측 모델 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_k</span><script type="math/tex">\mathbf{R}_k</script></span>는 관측 노이즈 공분산 행렬, <span class="arithmatex"><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span>는 비선형 관측 모델 함수이다.</p>
<p>이와 같은 보정 방법을 통해 수중에서의 센서 움직임으로 인한 데이터 왜곡을 최소화하고, 정확한 포인트 클라우드 데이터를 얻을 수 있다.</p>
<h3 id="8">8. 수중 환경에서의 실시간 데이터 처리</h3>
<p>수중 포인트 클라우드 데이터를 실시간으로 처리하는 것은 일반적으로 매우 도전적인 과제이다. 해양 환경에서는 데이터 전송 속도와 처리가 느리기 때문에, 데이터를 실시간으로 처리하려면 최적화된 알고리즘과 고성능 하드웨어가 필요하다. 특히 수중 로봇이나 AUV에서 실시간으로 환경을 인식하고 의사결정을 해야 하는 상황에서는 실시간 처리 속도가 중요한 요인이 된다.</p>
<h4 id="1_2">(1) 데이터 압축과 전송 효율화</h4>
<p>수중 환경에서의 통신 대역폭은 매우 제한적이다. 일반적으로 수중에서는 무선 통신 대신 음파를 이용한 통신을 사용하지만, 이는 육상에서 사용하는 무선 통신에 비해 속도가 훨씬 느리다. 따라서 실시간 처리를 위해서는 수집된 포인트 클라우드 데이터를 압축하여 전송해야 한다.</p>
<p>포인트 클라우드 데이터를 압축하는 방법은 크게 두 가지로 나눌 수 있다:
- <strong>손실 압축(Lossy Compression)</strong>: 데이터의 일부분을 버려서 압축률을 높이는 방식으로, 전송 속도는 향상되지만 데이터의 정밀도가 떨어질 수 있다.
- <strong>무손실 압축(Lossless Compression)</strong>: 데이터의 손실 없이 압축하는 방법으로, 데이터의 정밀도를 유지할 수 있으나 압축률이 낮고 전송 속도가 느릴 수 있다.</p>
<p>손실 압축에서는 특정 포인트의 위치나 반사 강도 등의 정보를 일부 축소하여 데이터 크기를 줄인다. 일반적으로 손실 압축을 적용할 때는 데이터의 품질과 압축률 사이에서 적절한 균형을 맞추는 것이 중요하다.</p>
<h4 id="2_2">(2) 병렬 처리와 분산 시스템</h4>
<p>수중 환경에서 실시간 데이터를 처리하기 위해서는 병렬 처리와 분산 시스템의 활용이 필수적이다. 포인트 클라우드 데이터는 매우 큰 용량을 갖고 있기 때문에, 이를 빠르게 처리하기 위해서는 여러 개의 처리 장치가 동시에 데이터를 분석할 수 있어야 한다.</p>
<p>병렬 처리를 위해 GPU(그래픽 처리 장치)를 활용하는 것이 일반적이며, 많은 포인트 클라우드 알고리즘이 GPU 가속을 지원한다. 예를 들어, 포인트 클라우드의 필터링이나 클러스터링 알고리즘은 다수의 점을 동시에 처리할 수 있기 때문에 GPU를 활용하면 실시간 처리가 가능해진다.</p>
<p>분산 시스템에서는 여러 대의 컴퓨터나 클러스터가 서로 데이터를 공유하며 동시에 처리 작업을 수행한다. 이러한 분산 처리는 수중 로봇이나 AUV가 수집한 데이터를 실시간으로 분석하기 위한 주요 기술로 사용된다. 이 시스템에서 각 노드는 특정한 부분의 포인트 클라우드를 처리하고, 최종 결과는 전체 데이터로 합쳐진다.</p>
<h4 id="3_1">(3) 알고리즘 최적화</h4>
<p>실시간 처리를 위한 또 다른 중요한 요소는 알고리즘의 최적화이다. 수중에서 사용되는 포인트 클라우드 처리 알고리즘은 제한된 계산 자원과 통신 대역폭 내에서 동작해야 하므로, 효율성을 극대화하는 것이 필요하다. 대표적인 최적화 기법 중 하나는 데이터의 적응적 하향 샘플링이다.</p>
<p>적응적 하향 샘플링에서는 데이터의 복잡성에 따라 처리해야 할 포인트의 수를 동적으로 조절한다. 예를 들어, 복잡한 해양 구조물 근처에서는 높은 해상도의 데이터를 사용하고, 평평한 해저에서는 낮은 해상도의 데이터를 사용하는 방식이다. 이러한 샘플링 기법은 데이터 처리 시간을 줄이고 메모리 사용량을 최적화하는 데 기여한다.</p>
<h4 id="4">(4) 실시간 필터링</h4>
<p>수중 환경에서는 실시간으로 수집된 포인트 클라우드 데이터를 필터링해야 하는 경우가 많다. 수중에는 다양한 노이즈 요인이 존재하며, 부유물, 해양 생물 등의 요소로 인해 데이터가 쉽게 오염된다. 따라서 실시간 필터링은 매우 중요한 처리 과정 중 하나이다.</p>
<p>필터링 알고리즘 중 <strong>Voxel Grid 필터</strong>는 자주 사용되는 기법이다. 이 필터는 포인트 클라우드를 일정한 크기의 격자로 나누고, 각 격자 내에서 하나의 대표 포인트만을 남기며 나머지를 제거한다. 이 과정을 통해 데이터의 크기를 줄이면서도 전체적인 형태는 유지할 수 있다.</p>
<p>Voxel Grid 필터의 수학적 표현은 다음과 같다. 주어진 포인트 클라우드 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>가 있을 때, 격자의 크기를 <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>라고 정의하고, 각 격자 내의 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>들에 대해 평균을 취하여 대표점을 구한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_{\text{avg}} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
\mathbf{p}_{\text{avg}} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 격자 내의 포인트 수, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{\text{avg}}</span><script type="math/tex">\mathbf{p}_{\text{avg}}</script></span>는 해당 격자의 대표 포인트이다. 이러한 방식으로 포인트 클라우드의 크기를 줄이면서도 전체적인 공간 정보를 보존할 수 있다.</p>
<h3 id="9">9. 수중 포인트 클라우드의 정밀 보정 기법</h3>
<p>수중에서 획득된 포인트 클라우드 데이터는 정밀한 보정 과정을 통해서만 정확한 3D 재구성 및 분석이 가능하다. 수중 환경의 특성상 센서의 불안정성, 환경 변화, 그리고 음파 전파 특성으로 인해 원시 데이터에는 다양한 오차가 포함될 수 있다. 이를 보정하는 기술적 접근은 포인트 클라우드의 정밀도를 높이고, 나아가 실용적인 응용에서 활용할 수 있는 데이터를 제공한다.</p>
<h4 id="1_3">(1) 다중 센서 데이터를 이용한 보정</h4>
<p>다중 센서 시스템은 수중 환경에서 데이터의 불확실성을 줄이는 데 중요한 역할을 한다. 예를 들어, 수중 로봇(AUV 또는 ROV)에서는 음파 기반 센서와 광학 기반 센서를 함께 사용하는 경우가 많다. 음파 센서는 비교적 먼 거리를 탐지할 수 있지만 해상도가 낮고 노이즈가 많다. 반면에, 광학 센서는 높은 해상도를 제공하지만, 수심이 깊거나 탁도가 높은 환경에서는 사용이 제한된다.</p>
<p>이 두 센서 데이터를 결합함으로써 보다 정확한 포인트 클라우드를 생성할 수 있다. 다중 센서 데이터를 보정하는 대표적인 방법 중 하나는 <strong>Kalman 필터</strong> 기반의 센서 융합 알고리즘이다. 이 알고리즘은 서로 다른 센서에서 측정한 데이터를 통합하여, 각 센서의 장단점을 보완하고 보다 정밀한 데이터 세트를 구축한다.</p>
<h4 id="2_3">(2) 음파 센서와 광학 센서의 데이터 융합</h4>
<p>음파 센서에서 수집된 포인트 클라우드는 상대적으로 거칠고 노이즈가 많지만, 넓은 영역에 걸친 데이터를 수집할 수 있다는 장점이 있다. 반면에 광학 센서(예: 카메라, LiDAR)는 수중에서 더 높은 해상도의 포인트 클라우드를 제공하지만, 제한된 범위와 불리한 조명 조건에서 성능이 저하될 수 있다. 이러한 두 종류의 센서 데이터를 융합하는 과정은 정밀도를 높이기 위해 필수적이다.</p>
<p>이를 위해 두 센서 간의 보정 과정이 필요하며, 기본적으로 다음과 같은 절차를 따른다:</p>
<ol>
<li>두 센서에서 얻어진 포인트 클라우드 간의 좌표계를 통일하기 위해 변환 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span>를 계산한다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{T} = \begin{pmatrix}
\mathbf{R} &amp; \mathbf{t} \\
0 &amp; 1
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{T} = \begin{pmatrix}
\mathbf{R} & \mathbf{t} \\
0 & 1
\end{pmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 회전 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>는 변위 벡터이다.</p>
<ol>
<li>
<p>변환 행렬을 이용하여 음파 센서에서 수집된 포인트 클라우드를 광학 센서의 좌표계로 변환한다.</p>
</li>
<li>
<p>두 포인트 클라우드를 융합하는 과정에서 음파 센서의 저해상도 데이터를 필터링하고, 광학 센서에서 수집된 고해상도 데이터를 이용해 부족한 부분을 보완한다.</p>
</li>
</ol>
<p>이 융합 과정은 수중 구조물의 3D 형상을 보다 정확하게 재구성할 수 있게 해주며, 특히 해양 탐사나 수중 구조물 검사 등의 응용 분야에서 유용하게 사용된다.</p>
<h4 id="3_2">(3) 실시간 보정 및 필터링</h4>
<p>실시간으로 수집되는 포인트 클라우드 데이터는 필터링과 보정을 통해 정밀도를 향상시킬 수 있다. 수중 환경에서의 실시간 처리는 특히 중요하며, 이러한 필터링 과정은 노이즈 제거, 잘못된 포인트 제거, 그리고 해상도의 최적화를 포함한다.</p>
<ul>
<li>
<p><strong>Moving Least Squares (MLS) 보정</strong>: 이 기법은 점들에 대한 곡면을 추정하여 데이터를 정밀하게 보정하는 데 사용된다. 포인트 클라우드 상의 각 점에 대해 그 주변 점들을 기반으로 지역적인 곡면을 추정하고, 그 곡면을 이용해 점을 재조정하는 방식이다.</p>
</li>
<li>
<p><strong>RANSAC 기반 평면 검출</strong>: 수중 구조물과 같은 평면 형태를 검출할 때는 RANSAC(Random Sample Consensus) 알고리즘이 자주 사용된다. 이 알고리즘은 노이즈와 이상치를 효과적으로 처리하여 평면이나 특정 형상을 추정하는 데 유용하다. RANSAC은 다음과 같은 단계로 이루어진다:</p>
</li>
<li>
<p>포인트 클라우드에서 랜덤하게 샘플을 선택한다.</p>
</li>
<li>샘플을 이용해 평면을 추정하고, 나머지 점들과의 일치 여부를 평가한다.</li>
<li>일정 임계값 이하의 점들만 일치하는 경우 해당 점들을 이상치로 처리한다.</li>
</ul>
<p>수식적으로는 평면을 다음과 같이 정의할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{n} \cdot \mathbf{x} + d = 0
</div>
<script type="math/tex; mode=display">
\mathbf{n} \cdot \mathbf{x} + d = 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>은 평면의 법선 벡터, <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>는 평면의 오프셋, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>는 평면 위의 한 점을 나타낸다. 이 평면 방정식을 기반으로 RANSAC 알고리즘은 각 포인트가 평면에 얼마나 잘 맞는지를 평가하여 평면 형상을 검출한다.</p>
<h4 id="4_1">(4) 포인트 클라우드의 품질 분석 및 평가</h4>
<p>수중에서 수집된 포인트 클라우드 데이터의 품질을 평가하는 것도 중요한 과제 중 하나이다. 수집된 데이터의 품질은 노이즈 수준, 해상도, 데이터의 불완전성 등 여러 요소에 의해 결정되며, 각 요소를 정량적으로 평가하기 위한 다양한 지표가 존재한다.</p>
<ul>
<li>
<p><strong>노이즈 비율</strong>: 데이터의 노이즈는 포인트 클라우드의 정밀도에 직접적인 영향을 미친다. 노이즈 비율은 잘못된 포인트가 전체 데이터에서 차지하는 비율로 정의되며, 이를 최소화하는 것이 중요하다.</p>
</li>
<li>
<p><strong>해상도 평가</strong>: 센서의 해상도는 데이터를 수집할 때 각각의 점이 얼마나 세밀하게 기록되는지를 나타낸다. 해상도가 높을수록 정밀한 데이터를 제공하지만, 노이즈의 양이 증가할 수 있으므로 적절한 해상도를 유지하는 것이 중요하다.</p>
</li>
<li>
<p><strong>오차 분석</strong>: 보정 전후의 데이터를 비교하여 오차를 분석하는 것은 필수적이다. 오차 분석에서는 수집된 포인트 클라우드 데이터와 실제 환경 사이의 차이를 정량화하여 보정 과정이 얼마나 효과적으로 수행되었는지를 평가할 수 있다.</p>
</li>
</ul>
<h3 id="10">10. 수중 포인트 클라우드 데이터의 정확도 향상을 위한 최적화</h3>
<p>수중 환경에서 수집된 포인트 클라우드 데이터의 정확도를 높이기 위한 다양한 최적화 기법들이 존재한다. 이러한 최적화는 주로 데이터 수집 과정, 전처리, 그리고 후처리 단계에서 적용되며, 데이터의 정밀도와 해상도를 유지하면서 노이즈를 최소화하는 데 중점을 둔다.</p>
<h4 id="1_4">(1) 최적화된 센서 배치</h4>
<p>센서 배치는 수중 포인트 클라우드 데이터의 정확도에 직접적인 영향을 미친다. 수중에서는 빛이 약하고 음파의 전파 특성에 따라 수집 가능한 데이터의 양과 질이 크게 달라지므로, 센서의 위치와 각도를 최적화하는 것이 중요하다. 이를 위해, 포인트 클라우드 데이터가 수집될 영역에 대한 사전 분석을 통해 최적의 센서 배치를 설계할 수 있다.</p>
<p>음파 기반의 수중 센서(Sonar)는 일반적으로 360도 스캔이 가능한 장비도 있지만, 경우에 따라 특정 각도에서 사각지대(dead zone)가 생길 수 있다. 이러한 사각지대를 최소화하기 위해 여러 대의 센서를 서로 다른 각도로 배치하여 중복된 데이터 수집을 통해 빈틈을 메우는 방법이 사용된다.</p>
<p>수식적으로, 센서의 탐지 범위를 <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>로 하고, 센서의 탐지 각도가 <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>인 경우, 탐지 각도 내에서 수집되는 점의 밀도 <span class="arithmatex"><span class="MathJax_Preview">D(\theta, r)</span><script type="math/tex">D(\theta, r)</script></span>는 다음과 같이 표현될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
D(\theta, r) = \frac{n(\theta)}{r^2}
</div>
<script type="math/tex; mode=display">
D(\theta, r) = \frac{n(\theta)}{r^2}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">n(\theta)</span><script type="math/tex">n(\theta)</script></span>는 특정 각도 <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>에서 수집된 포인트의 개수, <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>은 탐지 거리를 나타낸다. 이 수식은 센서의 배치와 탐지 각도에 따른 포인트 밀도 변화를 설명하며, 적절한 배치를 통해 포인트 클라우드 데이터의 빈 공간을 최소화할 수 있다.</p>
<h4 id="2_4">(2) 데이터 취합 및 중복 제거</h4>
<p>수중 환경에서 여러 센서를 동시에 사용하면, 동일한 영역을 중복으로 스캔하는 경우가 자주 발생한다. 이러한 중복 데이터는 데이터 크기를 불필요하게 증가시키며, 처리 시간과 메모리 사용량을 증가시킨다. 따라서 중복 데이터를 제거하는 과정이 필요하다.</p>
<p>중복 제거는 일반적으로 <strong>간단한 거리 기반 필터링</strong>을 통해 이루어진다. 각 포인트 클라우드에서 가까운 포인트 간의 거리를 계산하고, 일정 거리 이하의 포인트들은 중복된 데이터로 간주하여 제거한다. 이를 수식적으로 표현하면, 두 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1</span><script type="math/tex">\mathbf{p}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2</span><script type="math/tex">\mathbf{p}_2</script></span> 사이의 거리가 임계값 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span> 이하인 경우, 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2</span><script type="math/tex">\mathbf{p}_2</script></span>는 제거된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{if } \| \mathbf{p}_1 - \mathbf{p}_2 \| \leq \epsilon, \text{ then remove } \mathbf{p}_2
</div>
<script type="math/tex; mode=display">
\text{if } \| \mathbf{p}_1 - \mathbf{p}_2 \| \leq \epsilon, \text{ then remove } \mathbf{p}_2
</script>
</div>
<p>이 과정을 통해 중복된 포인트들을 효율적으로 제거하고, 데이터 처리의 효율성을 높일 수 있다.</p>
<h4 id="3_3">(3) 적응적 포인트 클라우드 샘플링</h4>
<p>수중 포인트 클라우드 데이터의 샘플링은 실시간 처리를 위해 필수적이다. 적응적 샘플링은 포인트 클라우드의 밀도를 동적으로 조절하는 기법으로, 데이터의 중요한 영역에서는 높은 밀도를 유지하고, 덜 중요한 영역에서는 포인트의 수를 줄여 처리 효율을 높인다.</p>
<p>예를 들어, 복잡한 지형이나 구조물 근처에서는 샘플링 비율을 높여서 세부적인 데이터를 유지하고, 평평한 해저면이나 데이터 중요도가 낮은 구역에서는 샘플링 비율을 낮추는 방식이다. 이를 수식적으로 나타내면, 각 영역의 복잡도를 <span class="arithmatex"><span class="MathJax_Preview">C(\mathbf{p})</span><script type="math/tex">C(\mathbf{p})</script></span>로 정의할 때, 샘플링 비율 <span class="arithmatex"><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>는 다음과 같은 함수로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
s = f(C(\mathbf{p}))
</div>
<script type="math/tex; mode=display">
s = f(C(\mathbf{p}))
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>는 복잡도에 따른 샘플링 비율을 결정하는 함수이다. 복잡도가 높은 영역에서는 더 높은 샘플링 비율이 적용되고, 단순한 영역에서는 더 낮은 비율이 적용된다.</p>
<h4 id="4_2">(4) 포인트 클라우드의 지오메트리 분석</h4>
<p>포인트 클라우드 데이터의 정확도를 향상시키기 위한 또 다른 중요한 요소는 지오메트리 분석이다. 수중 환경에서 포인트 클라우드 데이터는 다양한 해양 구조물이나 자연 지형을 포함하며, 이러한 구조물의 형상 정보를 분석하는 것이 매우 중요하다. 이를 위해, 각 포인트의 국부적인 지오메트리를 분석하는 기법들이 사용된다.</p>
<p>대표적으로 <strong>주성분 분석(PCA: Principal Component Analysis)</strong>가 사용되며, 각 포인트의 주변에서 국부적으로 가장 중요한 방향을 추출하여 형상을 분석한다. 주성분 분석을 통해 각 포인트가 어떤 형상(예: 평면, 곡면, 구형 등)에 속하는지를 분류할 수 있다. 이를 수식으로 표현하면, 주성분 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}_1, \mathbf{v}_2, \mathbf{v}_3</span><script type="math/tex">\mathbf{v}_1, \mathbf{v}_2, \mathbf{v}_3</script></span>는 데이터의 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>를 고유값 분해하여 얻을 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \mathbf{V} \mathbf{\Lambda} \mathbf{V}^\top
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \mathbf{V} \mathbf{\Lambda} \mathbf{V}^\top
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 공분산 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}</span><script type="math/tex">\mathbf{V}</script></span>는 고유벡터 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Lambda}</span><script type="math/tex">\mathbf{\Lambda}</script></span>는 고유값 행렬이다. 이를 통해 각 포인트가 국부적으로 어떤 형상을 이루고 있는지 분석할 수 있으며, 이러한 분석은 포인트 클라우드의 정확도 향상에 기여한다.</p>
<h3 id="11">11. 수중 포인트 클라우드의 정밀 필터링 기법</h3>
<p>수중 포인트 클라우드 데이터는 다양한 노이즈와 불완전성으로 인해 정밀한 필터링 기법이 필요하다. 이러한 필터링 기법들은 주로 노이즈 제거, 포인트 클라우드의 해상도 조정, 불완전한 데이터 보완 등에 사용되며, 수중 데이터의 특성에 맞추어 조정된다.</p>
<h4 id="1-statistical-outlier-removal">(1) 통계적 필터링(Statistical Outlier Removal)</h4>
<p>통계적 필터링은 포인트 클라우드에서 이상치를 제거하기 위한 매우 효과적인 기법이다. 수중 환경에서는 노이즈나 이상치가 많이 발생하는데, 이들은 주로 데이터의 밀도가 낮은 구간에서 발생하며, 특정 점 주변의 포인트 수를 기반으로 이상치를 검출할 수 있다.</p>
<p>통계적 필터링은 각 포인트의 주변 이웃 포인트 수를 계산한 후, 이웃 수가 특정 임계값보다 작은 포인트를 제거하는 방식이다. 이를 수식적으로 표현하면, 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해 주변 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-이웃 포인트의 평균 거리 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{mean}}</span><script type="math/tex">d_{\text{mean}}</script></span>를 계산한 후, 임계값 <span class="arithmatex"><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>를 설정하여 다음 조건을 만족하는 포인트를 이상치로 간주하여 제거한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{if } \frac{1}{k} \sum_{j=1}^{k} \|\mathbf{p}_i - \mathbf{p}_j\| &gt; \sigma, \text{ then remove } \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
\text{if } \frac{1}{k} \sum_{j=1}^{k} \|\mathbf{p}_i - \mathbf{p}_j\| > \sigma, \text{ then remove } \mathbf{p}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>는 이웃 포인트 수, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span>는 이웃 포인트를 나타낸다. 이 필터링 방법은 수중에서 발생하는 외부 환경 요인으로 인한 노이즈 제거에 유용하다.</p>
<h4 id="2-passthrough-filter">(2) 패스스루 필터(PassThrough Filter)</h4>
<p>패스스루 필터는 특정 축을 기준으로 포인트 클라우드 데이터를 필터링하는 방식으로, 수중 탐사에서 깊이 정보나 특정 영역에 대한 필터링이 필요할 때 주로 사용된다. 예를 들어, 수중 지형 탐사에서 수심이 일정 범위 안에 있는 데이터만 남기고 나머지는 제거하는 경우가 많다.</p>
<p>패스스루 필터는 주어진 축(예: <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>-축)을 기준으로 데이터를 필터링하며, 특정 범위 <span class="arithmatex"><span class="MathJax_Preview">[z_{\text{min}}, z_{\text{max}}]</span><script type="math/tex">[z_{\text{min}}, z_{\text{max}}]</script></span> 안에 있는 포인트들만 유지한다. 이를 수식으로 표현하면, 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>-좌표가 다음 조건을 만족하는 경우, 해당 포인트는 유지된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
z_{\text{min}} \leq p_{i,z} \leq z_{\text{max}}
</div>
<script type="math/tex; mode=display">
z_{\text{min}} \leq p_{i,z} \leq z_{\text{max}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">p_{i,z}</span><script type="math/tex">p_{i,z}</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>-좌표이다. 이 방법은 수중 데이터에서 관심 있는 특정 깊이나 범위에 있는 데이터만을 선별할 때 매우 유용하다.</p>
<h4 id="3-moving-average-filter">(3) 이동 평균 필터(Moving Average Filter)</h4>
<p>이동 평균 필터는 포인트 클라우드의 각 점에 대해 인접한 포인트들의 평균을 계산하여, 노이즈를 줄이고 보다 부드러운 데이터를 생성하는 기법이다. 수중 환경에서는 음파 기반의 데이터가 노이즈로 인해 흔들리거나 불균일할 수 있으므로, 이동 평균 필터를 사용하여 데이터를 스무딩(smoothing)할 수 있다.</p>
<p>이동 평균 필터는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해, 주변 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-이웃 포인트들의 좌표 평균을 계산하여 필터링된 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i^{\text{filtered}}</span><script type="math/tex">\mathbf{p}_i^{\text{filtered}}</script></span>를 다음과 같이 계산한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i^{\text{filtered}} = \frac{1}{k} \sum_{j=1}^{k} \mathbf{p}_j
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i^{\text{filtered}} = \frac{1}{k} \sum_{j=1}^{k} \mathbf{p}_j
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 이웃 포인트이다. 이 방식은 특히 수중 환경에서 발생하는 소규모 노이즈를 제거하는 데 효과적이다.</p>
<h4 id="4-bilateral">(4) Bilateral 필터</h4>
<p>Bilateral 필터는 노이즈를 제거하면서도 포인트 클라우드의 가장자리를 보존하는 필터링 기법이다. 일반적인 스무딩 필터는 모든 포인트에 대해 동일하게 작용하여, 세밀한 형상이 뭉개지는 경우가 많지만, Bilateral 필터는 거리와 값의 차이에 따라 필터링 강도를 다르게 적용한다. 이를 통해 포인트 클라우드의 구조를 보존하면서 노이즈를 줄일 수 있다.</p>
<p>Bilateral 필터는 주어진 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해, 이웃 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span>와의 거리와 값 차이를 고려하여 필터링 강도를 조절하며, 다음과 같은 가중치 계산을 통해 필터링된 점을 구한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i^{\text{filtered}} = \frac{\sum_{j} w_d(\|\mathbf{p}_i - \mathbf{p}_j\|) \cdot w_r(\|\mathbf{p}_i - \mathbf{p}_j\|) \cdot \mathbf{p}_j}{\sum_{j} w_d(\|\mathbf{p}_i - \mathbf{p}_j\|) \cdot w_r(\|\mathbf{p}_i - \mathbf{p}_j\|)}
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i^{\text{filtered}} = \frac{\sum_{j} w_d(\|\mathbf{p}_i - \mathbf{p}_j\|) \cdot w_r(\|\mathbf{p}_i - \mathbf{p}_j\|) \cdot \mathbf{p}_j}{\sum_{j} w_d(\|\mathbf{p}_i - \mathbf{p}_j\|) \cdot w_r(\|\mathbf{p}_i - \mathbf{p}_j\|)}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">w_d</span><script type="math/tex">w_d</script></span>는 거리 기반 가중치 함수, <span class="arithmatex"><span class="MathJax_Preview">w_r</span><script type="math/tex">w_r</script></span>는 값 차이에 따른 가중치 함수이다. 이 방법은 포인트 클라우드의 중요한 구조를 유지하면서 노이즈를 효과적으로 제거할 수 있다.</p>
<h4 id="5">(5) 커널 기반 필터링</h4>
<p>커널 기반 필터링은 포인트 클라우드의 각 점에 대해 국부적인 커널을 적용하여 필터링을 수행하는 방식이다. 이 방법은 주로 데이터의 세부적인 구조를 유지하면서 노이즈를 줄이는 데 사용된다. 특히, 커널의 형태와 크기를 조절하여 특정 지형이나 구조물에 적합한 필터링을 적용할 수 있다.</p>
<p>포인트 클라우드의 각 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해 커널 함수 <span class="arithmatex"><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>를 적용하여 필터링된 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i^{\text{filtered}}</span><script type="math/tex">\mathbf{p}_i^{\text{filtered}}</script></span>는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i^{\text{filtered}} = \sum_{j} K(\mathbf{p}_i, \mathbf{p}_j) \cdot \mathbf{p}_j
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i^{\text{filtered}} = \sum_{j} K(\mathbf{p}_i, \mathbf{p}_j) \cdot \mathbf{p}_j
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>는 커널 함수로, 포인트 간의 거리나 위치에 따라 가중치를 부여하여 노이즈를 제거한다. 이 방법은 포인트 클라우드 데이터에서 지역적인 패턴을 강조하거나 특정 형상을 추출하는 데 적합하다.</p>
<h3 id="12">12. 수중 포인트 클라우드 데이터의 후처리 기법</h3>
<p>수중 포인트 클라우드 데이터를 실질적으로 활용하기 위해서는 후처리 과정이 매우 중요하다. 후처리는 데이터를 정제하고, 불필요한 정보를 제거하며, 최종적으로 3D 모델링이나 분석에 사용할 수 있는 형태로 가공하는 과정이다. 수중 환경의 특수성으로 인해 후처리 기법은 특히 중요한 역할을 하며, 다양한 알고리즘과 방법론이 적용된다.</p>
<h4 id="1_5">(1) 클러스터링 기법</h4>
<p>수중 포인트 클라우드에서 중요한 요소를 추출하거나, 특정 구조를 분리하기 위해 클러스터링 기법이 자주 사용된다. 클러스터링은 데이터 포인트들을 비슷한 특성을 가진 그룹으로 묶는 작업을 의미하며, 수중 환경에서는 해양 구조물이나 자연 지형을 분리하는 데 유용하다.</p>
<p>대표적인 클러스터링 알고리즘으로 <strong>Euclidean 클러스터링</strong>이 있으며, 이는 각 포인트 간의 유클리드 거리를 기반으로 클러스터를 형성한다. 알고리즘은 다음과 같은 절차로 이루어진다:</p>
<ol>
<li>초기 포인트에서 시작하여, 해당 포인트의 이웃 포인트들을 찾아 클러스터를 형성한다.</li>
<li>이웃 포인트들 중에서도 다시 이웃을 찾고, 이를 반복하여 클러스터가 더 이상 확장되지 않을 때까지 과정을 진행한다.</li>
<li>특정 거리 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{threshold}}</span><script type="math/tex">d_{\text{threshold}}</script></span> 이상 떨어진 포인트들은 새로운 클러스터로 분리한다.</li>
</ol>
<p>이를 수식으로 표현하면, 두 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span> 사이의 거리가 임계값 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{threshold}}</span><script type="math/tex">d_{\text{threshold}}</script></span>보다 작으면, 두 포인트는 동일한 클러스터에 속한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{if } \|\mathbf{p}_i - \mathbf{p}_j\| \leq d_{\text{threshold}}, \text{ then } \mathbf{p}_i \text{ and } \mathbf{p}_j \text{ are in the same cluster.}
</div>
<script type="math/tex; mode=display">
\text{if } \|\mathbf{p}_i - \mathbf{p}_j\| \leq d_{\text{threshold}}, \text{ then } \mathbf{p}_i \text{ and } \mathbf{p}_j \text{ are in the same cluster.}
</script>
</div>
<p>클러스터링은 수중 환경에서 구조물의 경계 파악이나 특정 관심 영역(예: 해양 생물 서식지) 추출 등에 활용될 수 있다.</p>
<h4 id="2-registration">(2) 정렬 및 매칭(Registration)</h4>
<p>여러 개의 수중 포인트 클라우드 데이터를 결합하기 위해서는 <strong>정렬(Registration)</strong> 과정이 필수적이다. 정렬은 서로 다른 위치에서 수집된 포인트 클라우드 데이터를 동일한 좌표계로 맞추는 작업으로, 특히 수중 로봇이나 탐사 장비가 움직이는 동안 여러 번의 스캔을 통해 얻은 데이터를 합치기 위해 필요하다.</p>
<p>가장 널리 사용되는 정렬 방법 중 하나는 <strong>Iterative Closest Point (ICP)</strong> 알고리즘이다. ICP 알고리즘은 두 포인트 클라우드의 가장 가까운 점들을 찾고, 그에 따라 최적의 변환 행렬을 계산하여 정렬을 수행한다. 이를 반복하여 최적화된 정렬 결과를 얻는다.</p>
<p>ICP 알고리즘의 기본 과정은 다음과 같다:
1. 두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>에서 가장 가까운 대응점을 찾는다.
2. 대응점들 사이의 거리 차이를 최소화하는 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 변위 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>를 계산한다.
3. 이 변환을 적용하여 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>를 정렬한다.
4. 충분히 수렴할 때까지 이 과정을 반복한다.</p>
<p>이를 수식으로 나타내면, 최적화 문제는 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \| \mathbf{R} \mathbf{p}_i + \mathbf{t} - \mathbf{q}_i \|^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \| \mathbf{R} \mathbf{p}_i + \mathbf{t} - \mathbf{q}_i \|^2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>의 점, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span>는 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>의 대응점이다. <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 회전 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>는 변위 벡터로, 두 포인트 클라우드를 동일한 좌표계로 맞추기 위한 변환 매개변수이다.</p>
<h4 id="3_4">(3) 메시 생성 및 변환</h4>
<p>수중 포인트 클라우드 데이터를 보다 유용하게 활용하기 위해서는 이를 메시(mesh) 형태로 변환하는 작업이 필요하다. 메시는 점(point)들이 이어져 형성된 다각형(polygons)으로 구성되며, 포인트 클라우드 데이터의 3D 형상을 더 명확하게 표현할 수 있다.</p>
<p>메시 생성 알고리즘 중 가장 널리 사용되는 방법은 <strong>Delaunay 삼각분할(Delaunay Triangulation)</strong>이다. 이 방법은 주어진 포인트 클라우드를 기반으로, 삼각형을 형성하여 메시 구조를 생성하는 방식이다. Delaunay 삼각분할은 주어진 점들에 대해 가장 균일한 삼각형을 생성하는 알고리즘으로, 다음과 같은 특성을 만족하는 삼각형들을 생성한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Circumcircle Condition: For any triangle, the circumcircle does not contain any other points.}
</div>
<script type="math/tex; mode=display">
\text{Circumcircle Condition: For any triangle, the circumcircle does not contain any other points.}
</script>
</div>
<p>Delaunay 삼각분할을 통해 수중 구조물이나 지형을 메시 형태로 변환하면, 데이터를 시각적으로 분석하거나, 후속적인 시뮬레이션이나 3D 모델링에 사용할 수 있다.</p>
<h4 id="4-surface-reconstruction">(4) 표면 재구성(Surface Reconstruction)</h4>
<p>수중 포인트 클라우드 데이터로부터 부드러운 표면을 재구성하는 과정은 데이터 분석에서 중요한 단계이다. 표면 재구성은 주어진 포인트들을 기반으로, 부드러운 곡면을 추정하여 포인트 사이의 공간을 메우고, 더욱 직관적인 형상을 제공한다.</p>
<p>대표적인 표면 재구성 알고리즘 중 하나는 <strong>Poisson Surface Reconstruction</strong>이다. 이 방법은 포인트 클라우드의 법선(normal) 정보를 활용하여, 점들 사이의 공간을 메우고 부드러운 표면을 생성한다. Poisson Surface Reconstruction의 기본 개념은 주어진 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>에서 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_i</span><script type="math/tex">\mathbf{n}_i</script></span>를 이용하여, 포아송 방정식을 풀어 표면을 추정하는 것이다.</p>
<p>포아송 표면 재구성의 기본 수식은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\Delta \mathbf{S} = \nabla \cdot \mathbf{N}
</div>
<script type="math/tex; mode=display">
\Delta \mathbf{S} = \nabla \cdot \mathbf{N}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{S}</span><script type="math/tex">\mathbf{S}</script></span>는 재구성된 표면, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{N}</span><script type="math/tex">\mathbf{N}</script></span>은 포인트 클라우드의 법선 벡터이다. 이 방정식을 풀면, 포인트 사이의 표면을 자연스럽게 연결하는 부드러운 곡면이 생성된다.</p>
<p>이 방식은 수중 환경에서 복잡한 구조물이나 자연 지형을 모델링할 때 매우 유용하며, 후속적인 시각화 및 분석에서 중요한 역할을 한다.</p>
<h4 id="5_1">(5) 텍스처 매핑</h4>
<p>수중 포인트 클라우드 데이터에 텍스처 정보를 추가하는 작업은 데이터의 시각적 품질을 크게 향상시킬 수 있다. 텍스처 매핑은 포인트 클라우드의 각 점에 색상이나 반사 강도(intensity) 정보를 부여하여, 3D 모델의 현실감을 높이는 방법이다.</p>
<p>포인트 클라우드에서 텍스처 매핑을 수행하기 위해서는, 각 포인트에 대응하는 텍스처 좌표를 할당하고, 해당 좌표에 맞는 텍스처 이미지를 적용하는 과정이 필요하다. 이는 주로 카메라 데이터를 함께 활용하여 포인트 클라우드에 텍스처를 입히는 방식으로 이루어진다.</p>
<p>텍스처 매핑의 수학적 모델은 다음과 같이 표현된다. 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 3D 좌표 <span class="arithmatex"><span class="MathJax_Preview">(x_i, y_i, z_i)</span><script type="math/tex">(x_i, y_i, z_i)</script></span>와 텍스처 좌표 <span class="arithmatex"><span class="MathJax_Preview">(u_i, v_i)</span><script type="math/tex">(u_i, v_i)</script></span> 사이의 관계를 정의하고, 이를 텍스처 이미지 <span class="arithmatex"><span class="MathJax_Preview">I(u,v)</span><script type="math/tex">I(u,v)</script></span>에 매핑한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
I(u_i, v_i) \text{ is the color assigned to point } \mathbf{p}_i = (x_i, y_i, z_i)
</div>
<script type="math/tex; mode=display">
I(u_i, v_i) \text{ is the color assigned to point } \mathbf{p}_i = (x_i, y_i, z_i)
</script>
</div>
<p>이 과정은 포인트 클라우드의 시각적 품질을 크게 향상시키며, 특히 수중 구조물의 검사나 3D 시각화를 위한 최종 모델링 단계에서 중요한 역할을 한다.</p>
<h3 id="13">13. 수중 포인트 클라우드의 데이터 정합 오류와 보정</h3>
<p>수중 포인트 클라우드 데이터의 정합 과정에서 발생하는 오류는 정확한 데이터 분석과 3D 모델링을 위해 반드시 해결되어야 한다. 수중 환경의 특성상 센서 오류, 데이터 수집 과정에서의 움직임, 그리고 물리적 조건에 따른 왜곡으로 인해 정합 오류가 발생할 수 있다. 이러한 오류를 식별하고 보정하는 다양한 기법들이 존재하며, 각 단계에서 적용되는 보정 방법은 데이터의 품질을 향상시키는 데 중요한 역할을 한다.</p>
<h4 id="1_6">(1) 정합 오류의 유형</h4>
<p>수중에서 포인트 클라우드를 정합할 때 주로 발생하는 오류는 크게 두 가지로 나눌 수 있다:
1. <strong>지각적 정합 오류</strong>: 센서의 정확도나 물리적 특성에 의해 발생하는 오류로, 센서의 노이즈나 해상도 한계로 인해 정밀한 정합이 어려워지는 경우가 있다. 이는 음파 기반 센서가 넓은 범위를 탐지하지만 낮은 해상도를 가지거나, 광학 센서가 높은 해상도를 제공하지만 수심이 깊어지면 신호가 약해져 발생하는 문제에서 기인한다.</p>
<ol>
<li><strong>위치 정합 오류</strong>: 이동하는 센서가 포인트 클라우드를 수집하는 과정에서 발생하는 오류로, 로봇이나 탐사 장비가 움직이면서 수집된 데이터 간의 상대적인 위치가 불일치할 때 발생한다. 특히 수중에서는 물의 흐름이나 압력 변화로 인해 장비의 위치가 불안정해지면서 정합 오류가 자주 발생한다.</li>
</ol>
<h4 id="2_5">(2) 센서 보정 기법</h4>
<p>정합 오류를 최소화하기 위해서는 센서 보정이 필수적이다. 센서 보정은 주로 센서의 위치와 방향을 정확하게 추정하는 과정에서 이루어지며, 이를 통해 센서로부터 얻어진 데이터 간의 오차를 줄일 수 있다.</p>
<p><strong>내부 보정(Intrinsic Calibration)</strong>과 <strong>외부 보정(Extrinsic Calibration)</strong> 두 가지 보정 방법이 있다:</p>
<ul>
<li>
<p><strong>내부 보정</strong>은 센서 자체의 특성을 보정하는 방법으로, 센서의 왜곡, 초점 거리, 왜곡 계수 등을 조정하여 센서가 정확한 데이터를 수집하도록 한다. 특히 수중에서는 음파 센서의 신호 왜곡을 보정하거나, 카메라의 왜곡된 이미지를 교정하는 것이 중요하다.</p>
</li>
<li>
<p><strong>외부 보정</strong>은 센서의 위치와 방향을 보정하는 과정이다. 이는 특히 여러 대의 센서를 사용할 때 중요하며, 각 센서 간의 상대적인 위치와 방향을 정확하게 맞추어야 한다. 이를 수식으로 표현하면, 각 센서의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}_i</span><script type="math/tex">\mathbf{t}_i</script></span>와 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_i</span><script type="math/tex">\mathbf{R}_i</script></span>는 외부 보정 매개변수로, 두 센서 간의 변환 관계는 다음과 같이 표현된다:</p>
</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_2 = \mathbf{R}_{12} \mathbf{P}_1 + \mathbf{t}_{12}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_2 = \mathbf{R}_{12} \mathbf{P}_1 + \mathbf{t}_{12}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_1</span><script type="math/tex">\mathbf{P}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_2</span><script type="math/tex">\mathbf{P}_2</script></span>는 각각 센서 1과 센서 2에서 수집된 포인트 클라우드, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_{12}</span><script type="math/tex">\mathbf{R}_{12}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}_{12}</span><script type="math/tex">\mathbf{t}_{12}</script></span>는 두 센서 간의 회전 및 변위 관계이다. 이 보정을 통해 두 센서에서 얻은 데이터의 일관성을 높일 수 있다.</p>
<h4 id="3_5">(3) 데이터 보간 및 보정</h4>
<p>수중에서 정합 과정 중 발생하는 데이터 간 불일치를 해결하기 위한 일반적인 방법은 <strong>데이터 보간(Interpolation)</strong>과 <strong>보정(Adjustment)</strong>이다. 데이터 보간은 중간에 누락된 데이터를 예측하여 채우는 과정이며, 주로 빈 공간을 메우기 위해 사용된다. 반면, 데이터 보정은 정합된 데이터 간의 미세한 차이를 줄이기 위한 과정을 의미한다.</p>
<p>데이터 보간은 일반적으로 <strong>선형 보간(Linear Interpolation)</strong> 또는 <strong>스플라인 보간(Spline Interpolation)</strong>을 사용하여 포인트 간의 간격을 조정한다. 수식적으로 선형 보간은 두 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1</span><script type="math/tex">\mathbf{p}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2</span><script type="math/tex">\mathbf{p}_2</script></span> 사이에서 중간 값을 다음과 같이 계산한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_{\text{interp}} = (1 - \lambda) \mathbf{p}_1 + \lambda \mathbf{p}_2
</div>
<script type="math/tex; mode=display">
\mathbf{p}_{\text{interp}} = (1 - \lambda) \mathbf{p}_1 + \lambda \mathbf{p}_2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>는 보간 가중치로, <span class="arithmatex"><span class="MathJax_Preview">0 \leq \lambda \leq 1</span><script type="math/tex">0 \leq \lambda \leq 1</script></span>의 범위를 갖는다. 이 방법은 간단하면서도 수중 환경에서 데이터의 불연속성을 해결하는 데 자주 사용된다.</p>
<h4 id="4_3">(4) 정밀 정합을 위한 알고리즘</h4>
<p>정밀한 정합을 위해 사용하는 알고리즘 중 하나는 <strong>Generalized Iterative Closest Point (GICP)</strong> 알고리즘이다. GICP는 일반적인 ICP보다 더 높은 정밀도를 제공하며, 포인트 클라우드의 국부적인 기하학적 특징을 반영하여 정합 정확도를 높인다. 이는 특히 복잡한 수중 구조물에서 매우 유용하다.</p>
<p>GICP는 각 포인트의 기하학적 분산을 고려하여 회전 및 변위를 최적화하는 방식으로 동작한다. 이를 수식으로 표현하면, 두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span> 사이의 변환을 최소화하는 최적화 문제는 다음과 같이 나타난다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \left( \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \right)^\top \mathbf{\Sigma}^{-1}_i \left( \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \right)
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \left( \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \right)^\top \mathbf{\Sigma}^{-1}_i \left( \mathbf{p}_i - (\mathbf{R} \mathbf{q}_i + \mathbf{t}) \right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span>는 대응하는 두 포인트, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Sigma}_i</span><script type="math/tex">\mathbf{\Sigma}_i</script></span>는 각 포인트의 기하학적 분산을 나타내는 공분산 행렬이다. GICP는 이 공분산 정보를 사용하여 포인트 클라우드의 기하학적 특성을 보존하면서 정밀하게 정합을 수행한다.</p>
<h4 id="5_2">(5) 해양 탐사에서의 보정 사례</h4>
<p>해양 탐사에서의 포인트 클라우드 데이터 정합 및 보정은 다양한 사례를 통해 입증되었다. 예를 들어, 해저의 복잡한 지형을 정밀하게 분석하기 위해서는 여러 대의 수중 드론이나 로봇을 활용하여 데이터를 수집하고, 이 데이터를 정밀하게 정합하는 과정이 필수적이다.</p>
<p>한 사례로, 해양 구조물 검사에서 음파 센서와 광학 센서를 결합한 시스템이 사용되었다. 이 시스템에서는 음파 센서가 넓은 범위를 탐지하고, 광학 센서가 세밀한 부분을 포착하는 방식으로 데이터의 상호 보완이 이루어졌다. 두 센서로부터 얻은 데이터를 정밀하게 정합하기 위해 GICP 알고리즘과 보간 기법이 사용되었으며, 이를 통해 수중 구조물의 3D 모델을 정확하게 재구성할 수 있었다.</p>
<p>이와 같은 사례는 수중 포인트 클라우드 데이터의 정밀 보정이 해양 탐사 및 검사에 얼마나 중요한 역할을 하는지를 보여준다. 수중에서 발생하는 다양한 오류와 노이즈를 보정함으로써, 보다 정밀하고 실용적인 데이터를 확보할 수 있다.</p>
<h3 id="14">14. 수중 포인트 클라우드 데이터의 품질 평가 지표</h3>
<p>수중 포인트 클라우드 데이터를 처리하고 분석할 때, 데이터의 품질을 평가하는 지표는 매우 중요하다. 이러한 지표들은 데이터의 정확도, 정밀도, 일관성, 해상도 등을 정량적으로 평가하는 데 사용되며, 특히 수중 환경에서는 센서 노이즈, 환경 변동성, 그리고 정합 오류 등의 요소가 데이터를 손상시킬 수 있으므로, 품질 평가 지표는 데이터의 신뢰성을 확인하는 중요한 도구이다.</p>
<h4 id="1-precision-accuracy">(1) 정밀도(Precision)와 정확도(Accuracy)</h4>
<p>정밀도와 정확도는 포인트 클라우드 데이터의 품질을 평가하는 가장 기본적인 지표 중 하나이다. 이 두 개념은 서로 밀접하게 연관되어 있으나, 각각의 의미는 다르다.</p>
<ul>
<li>
<p><strong>정밀도(Precision)</strong>: 데이터 내 포인트 간의 일관성을 평가한다. 즉, 측정된 데이터가 얼마나 일관되게 모여 있는지를 나타낸다. 수중 환경에서 동일한 물체를 여러 번 스캔했을 때, 측정된 포인트들이 얼마나 가까이 위치하는지를 평가하는 지표로 사용된다.</p>
</li>
<li>
<p><strong>정확도(Accuracy)</strong>: 측정된 데이터가 실제 값과 얼마나 가까운지를 나타낸다. 실제 물체의 형상이나 크기와 비교하여 포인트 클라우드가 얼마나 잘 일치하는지를 평가하며, 정밀도가 높아도 정확도가 낮을 수 있다는 점을 고려해야 한다.</p>
</li>
</ul>
<p>정확도를 평가하기 위해서는 참조 데이터(ground truth)와 측정된 데이터를 비교하여 오차를 계산하는 방법이 일반적이다. 두 포인트 집합 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span> 사이의 평균 제곱 오차(RMSE: Root Mean Square Error)는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{RMSE} = \sqrt{\frac{1}{N} \sum_{i=1}^{N} \left( \mathbf{p}_i - \mathbf{q}_i \right)^2}
</div>
<script type="math/tex; mode=display">
\text{RMSE} = \sqrt{\frac{1}{N} \sum_{i=1}^{N} \left( \mathbf{p}_i - \mathbf{q}_i \right)^2}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span>는 각각 참조 데이터와 측정된 데이터의 대응점이다.</p>
<h4 id="2-resolution">(2) 해상도(Resolution)</h4>
<p>해상도는 포인트 클라우드 데이터의 세밀함을 나타내는 중요한 지표이다. 해상도가 높을수록 포인트 간의 간격이 좁아져 더 많은 세부 정보를 포함할 수 있다. 수중 포인트 클라우드에서는 센서의 분해능, 탐지 거리, 환경적 제약에 따라 해상도가 달라지며, 해상도가 높아질수록 노이즈에 민감해질 수 있다는 점도 고려해야 한다.</p>
<p>포인트 클라우드 데이터의 해상도는 포인트 사이의 평균 거리로 측정할 수 있으며, 이는 다음과 같은 식으로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Resolution} = \frac{1}{N} \sum_{i=1}^{N} \min_{j \neq i} \|\mathbf{p}_i - \mathbf{p}_j\|
</div>
<script type="math/tex; mode=display">
\text{Resolution} = \frac{1}{N} \sum_{i=1}^{N} \min_{j \neq i} \|\mathbf{p}_i - \mathbf{p}_j\|
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 포인트 클라우드 내의 각 포인트이며, <span class="arithmatex"><span class="MathJax_Preview">\|\mathbf{p}_i - \mathbf{p}_j\|</span><script type="math/tex">\|\mathbf{p}_i - \mathbf{p}_j\|</script></span>는 포인트 간의 유클리드 거리이다. 이 식은 각 포인트에 대해 가장 가까운 이웃 포인트와의 거리를 측정하여 데이터의 해상도를 평가한다.</p>
<h4 id="3-noise-ratio">(3) 노이즈 비율(Noise Ratio)</h4>
<p>수중 환경에서 노이즈는 매우 중요한 문제로 대두된다. 특히 음파 기반 센서나 광학 센서는 수중 환경의 변동성(예: 부유물, 수중 생물)으로 인해 불필요한 노이즈가 발생할 수 있다. 노이즈 비율은 데이터의 전체 포인트 중에서 이상치(outliers)로 간주되는 포인트의 비율을 의미한다.</p>
<p>노이즈를 평가하기 위한 방법 중 하나는 <strong>이상치 탐지(Outlier Detection)</strong> 기법을 사용하여, 통계적 분석을 통해 노이즈 포인트를 검출하는 것이다. 통계적 방법으로는 각 포인트의 평균 이웃 거리와 전체 데이터의 평균 거리를 비교하여, 특정 임계값을 초과하는 포인트들을 노이즈로 분류한다. 이를 수식으로 표현하면, 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 평균 이웃 거리 <span class="arithmatex"><span class="MathJax_Preview">d_i</span><script type="math/tex">d_i</script></span>는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d_i = \frac{1}{k} \sum_{j=1}^{k} \|\mathbf{p}_i - \mathbf{p}_j\|
</div>
<script type="math/tex; mode=display">
d_i = \frac{1}{k} \sum_{j=1}^{k} \|\mathbf{p}_i - \mathbf{p}_j\|
</script>
</div>
<p>이때, <span class="arithmatex"><span class="MathJax_Preview">d_i</span><script type="math/tex">d_i</script></span>가 데이터 전체의 평균 거리 <span class="arithmatex"><span class="MathJax_Preview">\bar{d}</span><script type="math/tex">\bar{d}</script></span>에 비해 특정 임계값 <span class="arithmatex"><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>를 초과하면, 해당 포인트는 노이즈로 간주된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{if } d_i &gt; \bar{d} + \sigma, \text{ then } \mathbf{p}_i \text{ is classified as noise.}
</div>
<script type="math/tex; mode=display">
\text{if } d_i > \bar{d} + \sigma, \text{ then } \mathbf{p}_i \text{ is classified as noise.}
</script>
</div>
<p>노이즈 비율은 이러한 노이즈 포인트들의 개수를 전체 포인트 수로 나누어 계산된다.</p>
<h4 id="4-density">(4) 데이터 밀도(Density)</h4>
<p>포인트 클라우드 데이터의 밀도는 주어진 공간 내에서 얼마나 많은 포인트가 존재하는지를 나타내는 지표이다. 수중 환경에서는 데이터 밀도가 수집된 센서의 특성, 스캔 범위, 그리고 데이터 처리 방법에 따라 달라진다. 밀도는 데이터의 품질을 평가하는 중요한 지표로 사용되며, 밀도가 높을수록 세밀한 구조를 더 잘 표현할 수 있지만 처리 비용이 증가할 수 있다.</p>
<p>포인트 클라우드 데이터의 밀도는 특정 구역 내의 포인트 수를 기준으로 계산되며, 이를 수식으로 표현하면 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Density} = \frac{N}{V}
</div>
<script type="math/tex; mode=display">
\text{Density} = \frac{N}{V}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 주어진 구역 내의 포인트 수, <span class="arithmatex"><span class="MathJax_Preview">V</span><script type="math/tex">V</script></span>는 구역의 부피(volume)이다. 밀도는 특정 관심 영역에서 포인트가 얼마나 집중되어 있는지를 평가할 때 유용하다.</p>
<h4 id="5-completeness">(5) 데이터 완전성(Completeness)</h4>
<p>데이터 완전성은 포인트 클라우드가 실제 환경을 얼마나 완벽하게 반영하고 있는지를 나타낸다. 수중 환경에서 포인트 클라우드는 음파나 광학 신호의 감쇠, 환경적 방해물, 또는 센서의 탐지 각도 제한으로 인해 불완전한 데이터가 발생할 수 있다. 데이터 완전성은 이러한 누락된 정보를 평가하는 지표이다.</p>
<p>데이터 완전성은 주어진 참조 데이터와 비교하여, 포인트 클라우드가 얼마나 많은 공간을 커버하고 있는지를 평가할 수 있다. 이를 수식적으로 표현하면, 참조 데이터와 측정된 데이터 간의 일치 비율을 통해 완전성을 측정할 수 있으며, 이 비율은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Completeness} = \frac{\text{Matched Points}}{\text{Total Reference Points}}
</div>
<script type="math/tex; mode=display">
\text{Completeness} = \frac{\text{Matched Points}}{\text{Total Reference Points}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\text{Matched Points}</span><script type="math/tex">\text{Matched Points}</script></span>는 참조 데이터와 일치하는 포인트 클라우드의 포인트 수를 의미한다. 이 지표는 수중 탐사에서 특정 지형이나 구조물을 얼마나 잘 재현했는지를 평가하는 데 사용된다.</p>
<h4 id="6-reproducibility">(6) 재현성(Reproducibility)</h4>
<p>재현성은 동일한 환경에서 여러 번 데이터를 수집할 때, 얼마나 일관된 결과를 얻을 수 있는지를 평가하는 지표이다. 수중 환경에서는 환경 변화, 센서의 성능, 로봇이나 장비의 움직임으로 인해 매번 수집되는 데이터가 달라질 수 있기 때문에, 재현성은 데이터 품질을 평가하는 중요한 기준이 된다.</p>
<p>재현성을 평가하기 위해서는 동일한 대상에 대해 여러 번 수집한 포인트 클라우드를 비교하여, 각 수집된 데이터 간의 차이를 정량화한다. 이를 수식으로 표현하면, 두 번의 수집에서 얻은 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span> 간의 평균 거리 차이는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Reproducibility} = \frac{1}{N} \sum_{i=1}^{N} \|\mathbf{p}_i - \mathbf{q}_i\|
</div>
<script type="math/tex; mode=display">
\text{Reproducibility} = \frac{1}{N} \sum_{i=1}^{N} \|\mathbf{p}_i - \mathbf{q}_i\|
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span>는 각각 두 번의 수집에서 얻은 대응점이다. 이 값이 작을수록 데이터의 재현성이 높다고 평가할 수 있다.</p>
<h3 id="15">15. 수중 포인트 클라우드 데이터의 실시간 처리 및 최적화</h3>
<p>수중 환경에서 포인트 클라우드 데이터를 실시간으로 처리하는 것은 해양 탐사, 수중 구조물 검사, 그리고 로봇 제어와 같은 응용 분야에서 매우 중요하다. 실시간 처리는 센서에서 수집된 데이터를 빠르게 분석하고 결과를 도출하여 즉각적인 의사결정을 내리는 데 필수적이다. 그러나 수중에서는 데이터의 대역폭 제한, 신호 감쇠, 그리고 복잡한 환경 조건 등으로 인해 실시간 처리에 여러 가지 어려움이 따른다. 이를 극복하기 위한 다양한 최적화 기법과 알고리즘이 존재한다.</p>
<h4 id="1_7">(1) 스트리밍 데이터 처리</h4>
<p>수중에서의 포인트 클라우드 데이터는 주로 스트리밍 방식으로 실시간 전송되며, 이러한 스트리밍 데이터의 처리는 일반적인 배치 처리와 달리 즉각적인 분석을 요구한다. 스트리밍 데이터는 지속적으로 입력되기 때문에, 각 데이터를 실시간으로 처리하고, 필요한 경우 데이터의 일부만을 저장하거나 전송하는 최적화가 필요하다.</p>
<p>스트리밍 환경에서 자주 사용되는 기법 중 하나는 <strong>슬라이딩 윈도우(Sliding Window)</strong> 기법이다. 이 방법은 연속적으로 들어오는 데이터 중에서 일정 구간(window)만을 선택하여 처리하는 방식으로, 메모리 사용을 줄이고, 실시간 분석의 효율성을 높인다.</p>
<p>슬라이딩 윈도우 기법을 수식적으로 표현하면, 주어진 포인트 클라우드 데이터 스트림 <span class="arithmatex"><span class="MathJax_Preview">D = \{d_1, d_2, \dots, d_n\}</span><script type="math/tex">D = \{d_1, d_2, \dots, d_n\}</script></span>에서 크기 <span class="arithmatex"><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>의 윈도우를 적용하여 현재 구간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서 처리할 데이터를 선택한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
W_t = \{d_{t-w+1}, d_{t-w+2}, \dots, d_t\}
</div>
<script type="math/tex; mode=display">
W_t = \{d_{t-w+1}, d_{t-w+2}, \dots, d_t\}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">W_t</span><script type="math/tex">W_t</script></span>는 현재 윈도우에 포함된 데이터 구간을 나타내며, 이 구간 내의 데이터만 실시간으로 처리된다. 윈도우의 크기 <span class="arithmatex"><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>는 데이터 처리 성능과 실시간성을 고려하여 적절하게 설정된다.</p>
<h4 id="2-gpu">(2) 병렬 처리 및 GPU 가속</h4>
<p>포인트 클라우드 데이터는 매우 큰 양의 데이터를 포함하고 있기 때문에, 실시간 처리를 위해서는 병렬 처리와 GPU 가속이 필수적이다. 병렬 처리는 포인트 클라우드 데이터를 동시에 여러 프로세스에서 처리하여 처리 시간을 단축시키는 방식으로, GPU는 수천 개의 코어를 활용하여 다수의 연산을 동시에 수행할 수 있다.</p>
<p>특히, 포인트 클라우드의 필터링, 정합, 클러스터링과 같은 연산은 다수의 포인트에 대해 병렬로 적용할 수 있기 때문에, GPU 가속을 활용하면 실시간 성능을 크게 향상시킬 수 있다. GPU에서 포인트 클라우드의 필터링 연산은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i^{\text{filtered}} = \text{GPU}_{\text{kernel}}(\mathbf{p}_i)
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i^{\text{filtered}} = \text{GPU}_{\text{kernel}}(\mathbf{p}_i)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\text{GPU}_{\text{kernel}}</span><script type="math/tex">\text{GPU}_{\text{kernel}}</script></span>은 GPU에서 병렬로 실행되는 커널 함수로, 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해 독립적으로 처리된다. 이 방식은 수백만 개의 포인트를 포함하는 대규모 포인트 클라우드 데이터를 빠르게 처리할 수 있도록 한다.</p>
<h4 id="3_6">(3) 데이터 압축을 통한 전송 최적화</h4>
<p>수중에서는 네트워크 대역폭이 매우 제한적이기 때문에, 포인트 클라우드 데이터를 실시간으로 전송하기 위해서는 데이터 압축이 필수적이다. 압축은 데이터를 보다 작은 크기로 변환하여 전송 시간을 단축하고, 대역폭을 절약하는 역할을 한다. 압축 기법은 손실 압축(Lossy Compression)과 무손실 압축(Lossless Compression)으로 나눌 수 있다.</p>
<ul>
<li>
<p><strong>손실 압축</strong>: 데이터를 축소하기 위해 일부 정보를 제거하는 방식으로, 압축률이 높지만 데이터의 정밀도가 감소할 수 있다. 포인트 클라우드에서 불필요한 세부 정보를 제거하여 데이터 크기를 줄이는 방식이다. 예를 들어, 포인트의 좌표를 근사화하여 저장하는 기법이 사용될 수 있다.</p>
</li>
<li>
<p><strong>무손실 압축</strong>: 데이터를 손실 없이 압축하여 전송하는 방식으로, 압축률은 낮지만 데이터의 정밀도를 유지한다. 무손실 압축에서는 주로 중복된 데이터를 제거하거나, 데이터의 구조를 활용하여 압축을 수행한다. 대표적인 방법으로 <strong>Octree 압축</strong>이 있으며, 포인트 클라우드를 3D 공간에서 계층적으로 분할하여 압축한다.</p>
</li>
</ul>
<p>Octree 압축에서 공간은 계층적으로 8개의 하위 공간으로 나누어지며, 각 하위 공간 내의 포인트를 저장한다. 이를 수식으로 표현하면, 주어진 3D 공간 <span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>를 <span class="arithmatex"><span class="MathJax_Preview">l</span><script type="math/tex">l</script></span> 레벨까지 Octree로 분할할 때, 각 레벨의 공간 <span class="arithmatex"><span class="MathJax_Preview">S_l</span><script type="math/tex">S_l</script></span>은 다음과 같이 나누어진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S_l = \bigcup_{i=1}^{8^l} S_{l,i}
</div>
<script type="math/tex; mode=display">
S_l = \bigcup_{i=1}^{8^l} S_{l,i}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">S_{l,i}</span><script type="math/tex">S_{l,i}</script></span>는 레벨 <span class="arithmatex"><span class="MathJax_Preview">l</span><script type="math/tex">l</script></span>에서의 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>번째 하위 공간을 나타낸다. 이 방식으로 포인트 클라우드를 압축하고, 각 하위 공간의 포인트 수에 따라 효율적인 데이터 전송을 가능하게 한다.</p>
<h4 id="4_4">(4) 실시간 노이즈 필터링</h4>
<p>실시간으로 수집되는 포인트 클라우드 데이터는 다양한 노이즈를 포함하고 있기 때문에, 데이터를 신속하게 처리하기 위해서는 실시간 노이즈 필터링이 필수적이다. 실시간 필터링 알고리즘은 수집된 데이터를 즉시 분석하고, 불필요한 노이즈나 이상치를 제거하는 방식으로 동작한다.</p>
<p>대표적인 실시간 필터링 기법 중 하나는 <strong>Voxel Grid 필터</strong>이다. 이 방법은 포인트 클라우드를 작은 격자(Voxel)로 나누고, 각 격자 내에서 하나의 대표 포인트만을 남기는 방식으로, 데이터 크기를 줄이고 노이즈를 제거한다.</p>
<p>Voxel Grid 필터는 주어진 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>에서 격자의 크기를 <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>로 설정하여, 각 격자 내에서 포인트의 평균값을 계산한다. 수식적으로는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_{\text{avg}} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
\mathbf{p}_{\text{avg}} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 격자 내의 포인트 수, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 격자 내의 포인트들이다. 이 과정을 통해 데이터의 크기를 줄이면서도 중요한 정보를 유지할 수 있다.</p>
<h4 id="5_3">(5) 적응적 샘플링 기법</h4>
<p>적응적 샘플링은 포인트 클라우드의 밀도와 복잡성에 따라 샘플링 비율을 동적으로 조정하는 기법이다. 수중 환경에서 실시간 처리를 위해서는 중요도가 높은 영역에서는 더 많은 포인트를 유지하고, 중요도가 낮은 영역에서는 포인트 수를 줄이는 방식으로 데이터의 처리 효율성을 극대화할 수 있다.</p>
<p>적응적 샘플링은 포인트 클라우드의 각 영역에 대해 복잡도를 분석하고, 복잡도가 높은 영역에서는 더 높은 샘플링 비율을 적용한다. 이를 수식적으로 표현하면, 포인트의 복잡도 <span class="arithmatex"><span class="MathJax_Preview">C(\mathbf{p})</span><script type="math/tex">C(\mathbf{p})</script></span>에 따라 샘플링 비율 <span class="arithmatex"><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>는 다음과 같은 함수로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
s = f(C(\mathbf{p}))
</div>
<script type="math/tex; mode=display">
s = f(C(\mathbf{p}))
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>는 복잡도에 따라 샘플링 비율을 결정하는 함수이다. 복잡도가 높은 영역에서는 샘플링 비율이 증가하며, 단순한 영역에서는 감소한다. 이 방식은 실시간으로 대규모 데이터를 처리하는 데 매우 유용하다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2902/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2902/" class="btn btn-xs btn-link">
        소나와 라이다를 통한 데이터 수집
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_28/2805/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_28/2805/" class="btn btn-xs btn-link">
        항공 촬영을 통한 지형 분석 사례
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>