<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introduction_to_pointcloud_processing_with_pcl_library/chapter_20/2002/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>이동 로봇의 포인트 클라우드 활용 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "1. \ud658\uacbd \uc778\uc2dd\uacfc \ub9e4\ud551", url: "#_top", children: [
          ]},
          {title: "2. \uacbd\ub85c \uacc4\ud68d", url: "#2", children: [
          ]},
          {title: "3. \uc7a5\uc560\ubb3c \ud68c\ud53c", url: "#3", children: [
          ]},
          {title: "4. \uc9c0\ud615 \ubd84\uc11d \ubc0f \uc790\uc728 \uc774\ub3d9", url: "#4", children: [
          ]},
          {title: "5. \ub85c\ubd07\uc758 \uc704\uce58 \ucd94\uc815 \ubc0f \ucd94\uc801", url: "#5", children: [
          ]},
          {title: "6. \uc774\ub3d9 \ub85c\ubd07\uc5d0\uc11c\uc758 \uc7a5\uc560\ubb3c \uc9c0\ub3c4 \uc0dd\uc131", url: "#6", children: [
              {title: "1. \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uae30\ubc18\uc758 \uc7a5\uc560\ubb3c \ud0d0\uc9c0", url: "#1_1" },
              {title: "2. \uc7a5\uc560\ubb3c \uc9c0\ub3c4 \uc0dd\uc131", url: "#2_1" },
              {title: "3. \uc7a5\uc560\ubb3c \uc9c0\ub3c4 \uc5c5\ub370\uc774\ud2b8", url: "#3_1" },
              {title: "4. \uc2e4\uc2dc\uac04 \uacbd\ub85c \uc218\uc815", url: "#4_1" },
          ]},
          {title: "7. \uc774\ub3d9 \ub85c\ubd07\uc5d0\uc11c\uc758 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc640 SLAM", url: "#7-slam", children: [
              {title: "1. \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc SLAM \uac1c\uc694", url: "#1-slam" },
              {title: "2. SLAM \uacfc\uc815", url: "#2-slam" },
              {title: "3. SLAM \uc54c\uace0\ub9ac\uc998\uc758 \uc885\ub958", url: "#3-slam" },
              {title: "4. \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc SLAM\uc758 \ub3c4\uc804 \uacfc\uc81c", url: "#4-slam" },
          ]},
          {title: "8. \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\ub97c \uc774\uc6a9\ud55c \ub85c\ubd07\uc758 \ud658\uacbd \uc774\ud574", url: "#8", children: [
              {title: "1. 3D \uacf5\uac04 \ubd84\ud560 \ubc0f \ud45c\ud604", url: "#1-3d" },
              {title: "2. \ud3c9\uba74 \ubc0f \ubb3c\uccb4 \uac80\ucd9c", url: "#2_2" },
              {title: "3. \uc9c0\ud615 \ubd84\uc11d \ubc0f \uc8fc\ud589 \uac00\ub2a5\uc131 \ud3c9\uac00", url: "#3_2" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2003/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2003/" class="btn btn-xs btn-link">
        매니퓰레이터의 환경 인식
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2001/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2001/" class="btn btn-xs btn-link">
        로봇과 PCL의 연동
      </a>
    </div>
    
  </div>

    

    <p>이동 로봇에서 포인트 클라우드는 환경 인식, 경로 계획, 및 장애물 회피 등 다양한 목적으로 사용된다. 로봇이 센서를 통해 수집한 포인트 클라우드 데이터를 처리하여 주위 환경의 3D 정보를 얻고 이를 실시간으로 분석함으로써 자율적으로 이동할 수 있다. 특히, 포인트 클라우드 데이터는 라이다(LiDAR), 스테레오 카메라, 혹은 RGB-D 카메라 등의 센서를 통해 획득되며, 로봇이 주행하는 환경에 대한 정확한 공간 정보를 제공한다.</p>
<h3 id="1">1. 환경 인식과 매핑</h3>
<p>이동 로봇은 환경을 인식하고 이를 매핑하는 것이 필수적이다. SLAM (Simultaneous Localization and Mapping)은 이동 로봇에서 포인트 클라우드를 활용한 대표적인 기술이다. SLAM 알고리즘은 로봇이 이동하면서 자신의 위치를 추정하고 주변 환경을 지도화하는 작업을 동시에 수행한다. 이를 위해, 로봇은 다음과 같은 절차를 따른다.</p>
<ol>
<li><strong>포인트 클라우드 수집</strong>: 로봇의 센서가 주위 환경에서 얻은 포인트 클라우드를 실시간으로 수집한다. 이러한 포인트 클라우드는 로봇의 움직임에 따라 연속적으로 업데이트된다.</li>
<li><strong>피처 추출 및 매칭</strong>: 로봇이 다른 위치에서 수집한 포인트 클라우드를 비교하고 공통된 특징을 매칭하여 현재 위치를 추정한다. 일반적으로, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i \in \mathbb{R}^3</span><script type="math/tex">\mathbf{p}_i \in \mathbb{R}^3</script></span>로 표현되는 포인트는 각 좌표에서 공간적 피처를 나타낸다.</li>
<li><strong>지도 갱신</strong>: 새로운 포인트 클라우드를 기존의 지도로 통합하여 환경 지도를 업데이트한다. 이때, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_{k} \in \mathbb{R}^{4 \times 4}</span><script type="math/tex">\mathbf{T}_{k} \in \mathbb{R}^{4 \times 4}</script></span>로 표현되는 변환 행렬을 사용하여 현재 프레임의 포인트 클라우드를 전역 좌표계로 변환한다.</li>
</ol>
<h3 id="2">2. 경로 계획</h3>
<p>로봇이 목표 지점에 도달하기 위해서는 경로 계획이 필요하다. 포인트 클라우드를 활용한 경로 계획은 로봇 주변의 장애물과 지형을 기반으로 최적의 경로를 찾는 데 사용된다. 경로 계획의 주요 단계는 다음과 같다.</p>
<ol>
<li><strong>장애물 검출</strong>: 포인트 클라우드를 이용해 로봇 주위의 장애물을 식별한다. 이는 로봇의 위치를 기준으로 특정 거리 내에 위치한 포인트들을 필터링하여 가능하다. 예를 들어, 로봇의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r} = (x_r, y_r, z_r)</span><script type="math/tex">\mathbf{r} = (x_r, y_r, z_r)</script></span>에서 반경 <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> 이내에 위치한 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>를 탐지하여 장애물로 간주한다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{p}_i - \mathbf{r}\| \leq r
</div>
<script type="math/tex; mode=display">
\|\mathbf{p}_i - \mathbf{r}\| \leq r
</script>
</div>
<ol>
<li><strong>비용 지도 생성</strong>: 포인트 클라우드를 사용하여 로봇이 이동할 수 있는 공간을 비용으로 나타낸다. 이동 경로의 각 지점에 비용을 할당하고, 이때 포인트가 밀집된 지역은 비용이 높게 설정된다. 비용은 일반적으로 다음과 같은 함수로 표현될 수 있다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
C(\mathbf{p}_i) = \frac{1}{1 + \|\mathbf{p}_i - \mathbf{r}\|}
</div>
<script type="math/tex; mode=display">
C(\mathbf{p}_i) = \frac{1}{1 + \|\mathbf{p}_i - \mathbf{r}\|}
</script>
</div>
<ol>
<li><strong>경로 탐색</strong>: 다익스트라(Dijkstra) 또는 A* 알고리즘을 통해 비용 지도를 기반으로 최단 경로를 찾는다. 이러한 경로는 로봇이 충돌 없이 목표 지점에 도달할 수 있도록 계산된다.</li>
</ol>
<h3 id="3">3. 장애물 회피</h3>
<p>이동 로봇이 실시간으로 환경을 탐색하면서 안전하게 이동하기 위해서는 장애물 회피가 중요한 요소다. 포인트 클라우드를 이용한 장애물 회피는 로봇이 주변 장애물을 탐지하고 회피하는 경로를 실시간으로 계산하는 과정을 포함한다. 이 과정에서 고려해야 할 주요 요소는 다음과 같다.</p>
<ol>
<li><strong>동적 장애물 탐지</strong>: 이동 중에 로봇 주변에 새롭게 나타나는 장애물을 실시간으로 탐지해야 한다. 동적 장애물의 경우, 로봇이 계속해서 포인트 클라우드를 업데이트하여 장애물의 위치 변화를 추적한다. 각 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서 로봇의 현재 위치를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}(t)</span><script type="math/tex">\mathbf{r}(t)</script></span>, 장애물의 위치를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{o}(t)</span><script type="math/tex">\mathbf{o}(t)</script></span>로 표현할 수 있다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{r}(t) \quad \text{and} \quad \mathbf{o}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{r}(t) \quad \text{and} \quad \mathbf{o}(t)
</script>
</div>
<p>로봇은 두 객체 간의 거리를 실시간으로 계산하여 충돌 가능성을 평가한다. 이를 위해서는 다음과 같은 거리 함수가 사용될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{r}(t), \mathbf{o}(t)) = \|\mathbf{r}(t) - \mathbf{o}(t)\|
</div>
<script type="math/tex; mode=display">
d(\mathbf{r}(t), \mathbf{o}(t)) = \|\mathbf{r}(t) - \mathbf{o}(t)\|
</script>
</div>
<ol>
<li>
<p><strong>실시간 경로 수정</strong>: 동적 장애물이 감지될 경우, 로봇은 즉시 경로를 수정해야 한다. 기존 경로에서 새로운 장애물의 위치를 반영하여 로봇이 안전하게 이동할 수 있는 새로운 경로를 계획한다. 예를 들어, 경로 상에 있는 포인트가 장애물로 탐지되면, 해당 포인트에 높은 비용을 부여하여 경로를 변경한다. 수정된 경로는 다시 비용 지도에서 계산된다.</p>
</li>
<li>
<p><strong>안전 거리 유지</strong>: 로봇은 장애물과의 안전 거리를 유지해야 한다. 안전 거리는 로봇의 크기와 속도, 장애물의 크기와 움직임 등을 고려하여 설정되며, 이를 통해 로봇은 충돌을 피할 수 있다. 안전 거리는 다음과 같은 불평등으로 정의할 수 있다.</p>
</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
d(\mathbf{r}(t), \mathbf{o}(t)) &gt; d_{\text{safe}}
</div>
<script type="math/tex; mode=display">
d(\mathbf{r}(t), \mathbf{o}(t)) > d_{\text{safe}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{safe}}</span><script type="math/tex">d_{\text{safe}}</script></span>는 미리 설정된 안전 거리다.</p>
<h3 id="4">4. 지형 분석 및 자율 이동</h3>
<p>이동 로봇이 다양한 지형을 탐색할 때, 포인트 클라우드를 통해 지형을 분석하여 이동 가능한 경로를 결정할 수 있다. 이를 위해 로봇은 지형의 기울기, 평면성, 혹은 장애물의 높이 등을 분석하여 이동 경로를 결정한다.</p>
<ol>
<li><strong>기울기 분석</strong>: 포인트 클라우드를 이용하여 지형의 기울기를 계산하고, 로봇이 오르거나 내릴 수 있는 경로를 찾는다. 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i = (x_i, y_i, z_i)</span><script type="math/tex">\mathbf{p}_i = (x_i, y_i, z_i)</script></span>의 기울기는 그 이웃 포인트들과의 고도 차이를 이용해 계산된다. 예를 들어, 두 포인트 간의 기울기는 다음과 같이 계산될 수 있다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\theta = \arctan\left(\frac{z_j - z_i}{\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2}}\right)
</div>
<script type="math/tex; mode=display">
\theta = \arctan\left(\frac{z_j - z_i}{\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2}}\right)
</script>
</div>
<ol>
<li><strong>평면성 분석</strong>: 로봇이 평탄한 지형을 탐지하여 안정적인 경로를 찾기 위해, 포인트 클라우드를 사용하여 로컬 영역의 평면성을 분석한다. 이를 위해, 포인트 클라우드에서 특정 영역의 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>를 계산하고, 각 법선 벡터들 간의 차이를 비교하여 평면성을 평가한다. 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_i</span><script type="math/tex">\mathbf{n}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_j</span><script type="math/tex">\mathbf{n}_j</script></span> 사이의 각도 차이는 다음과 같이 계산된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\phi = \arccos\left(\frac{\mathbf{n}_i \cdot \mathbf{n}_j}{\|\mathbf{n}_i\| \|\mathbf{n}_j\|}\right)
</div>
<script type="math/tex; mode=display">
\phi = \arccos\left(\frac{\mathbf{n}_i \cdot \mathbf{n}_j}{\|\mathbf{n}_i\| \|\mathbf{n}_j\|}\right)
</script>
</div>
<p><span class="arithmatex"><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>가 작을수록 해당 영역은 평탄하다고 판단된다.</p>
<ol>
<li><strong>높이 필터링</strong>: 특정 높이 이상의 장애물을 필터링하여 이동 경로를 결정할 수 있다. 로봇의 높이 한계를 <span class="arithmatex"><span class="MathJax_Preview">h_{\text{max}}</span><script type="math/tex">h_{\text{max}}</script></span>라고 설정하고, 포인트 클라우드에서 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span> 좌표가 <span class="arithmatex"><span class="MathJax_Preview">h_{\text{max}}</span><script type="math/tex">h_{\text{max}}</script></span> 이상인 포인트를 제거한다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\{ \mathbf{p}_i \mid z_i &gt; h_{\text{max}} \}
</div>
<script type="math/tex; mode=display">
\{ \mathbf{p}_i \mid z_i > h_{\text{max}} \}
</script>
</div>
<p>이러한 방식으로, 로봇은 자신이 통과할 수 없는 높이의 장애물을 효과적으로 필터링한다.</p>
<h3 id="5">5. 로봇의 위치 추정 및 추적</h3>
<p>이동 로봇이 포인트 클라우드를 사용하여 자율적으로 이동하기 위해서는 자신의 위치를 정확하게 추정하고 추적하는 기능이 필요하다. 이를 위해 로봇은 외부 환경과의 관계를 기반으로 위치를 계산하며, 이를 정확하게 수행하기 위해 다양한 알고리즘과 수학적 기법이 사용된다.</p>
<ol>
<li>
<p><strong>ICP (Iterative Closest Point) 알고리즘</strong>: 포인트 클라우드를 기반으로 로봇의 위치를 추정하는 대표적인 알고리즘 중 하나는 ICP 알고리즘이다. 이 알고리즘은 두 포인트 클라우드 세트 간의 최적의 변환을 찾는 과정으로, 로봇이 연속적인 시간에 걸쳐 위치를 추적하는 데 유용하다. ICP는 다음과 같은 절차를 따른다.</p>
</li>
<li>
<p><strong>초기 값 설정</strong>: 두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_1</span><script type="math/tex">\mathbf{P}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_2</span><script type="math/tex">\mathbf{P}_2</script></span>를 정의하고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_1</span><script type="math/tex">\mathbf{P}_1</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_2</span><script type="math/tex">\mathbf{P}_2</script></span>로의 초기 변환 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_0</span><script type="math/tex">\mathbf{T}_0</script></span>를 설정한다.</p>
</li>
<li><strong>최근접 점 계산</strong>: <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_1</span><script type="math/tex">\mathbf{P}_1</script></span>의 각 포인트에 대해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_2</span><script type="math/tex">\mathbf{P}_2</script></span>에서 가장 가까운 점을 찾는다. 이때, 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1 \in \mathbf{P}_1</span><script type="math/tex">\mathbf{p}_1 \in \mathbf{P}_1</script></span>에 대해 최근접 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2 \in \mathbf{P}_2</span><script type="math/tex">\mathbf{p}_2 \in \mathbf{P}_2</script></span>는 다음과 같이 계산된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{p}_2 = \arg\min_{\mathbf{q} \in \mathbf{P}_2} \|\mathbf{p}_1 - \mathbf{q}\|
</div>
<script type="math/tex; mode=display">
   \mathbf{p}_2 = \arg\min_{\mathbf{q} \in \mathbf{P}_2} \|\mathbf{p}_1 - \mathbf{q}\|
</script>
</div>
<ul>
<li><strong>변환 행렬 계산</strong>: 두 포인트 클라우드 간의 회전 및 평행 이동을 포함하는 최적의 변환 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span>를 계산한다. 변환 행렬은 다음과 같이 나타낼 수 있다.</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{T} = \begin{pmatrix} \mathbf{R} &amp; \mathbf{t} \\ \mathbf{0} &amp; 1 \end{pmatrix}
</div>
<script type="math/tex; mode=display">
   \mathbf{T} = \begin{pmatrix} \mathbf{R} & \mathbf{t} \\ \mathbf{0} & 1 \end{pmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 회전 행렬이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>는 평행 이동 벡터다. 이를 통해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_1</span><script type="math/tex">\mathbf{P}_1</script></span>을 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_2</span><script type="math/tex">\mathbf{P}_2</script></span>에 맞추는 최적의 변환을 구한다.</p>
<ul>
<li><strong>변환 적용 및 반복</strong>: 계산된 변환 행렬을 사용하여 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_1</span><script type="math/tex">\mathbf{P}_1</script></span>에 적용하고, 두 포인트 클라우드 간의 거리가 최소화될 때까지 반복한다.</li>
</ul>
<p>ICP 알고리즘은 특히 로봇이 움직이는 동안 실시간으로 위치를 추정하는 데 유용하다. 각 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서 로봇의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}(t)</span><script type="math/tex">\mathbf{r}(t)</script></span>는 ICP 알고리즘을 통해 다음과 같이 갱신될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{r}(t+1) = \mathbf{T}(t) \mathbf{r}(t)
</div>
<script type="math/tex; mode=display">
   \mathbf{r}(t+1) = \mathbf{T}(t) \mathbf{r}(t)
</script>
</div>
<ol>
<li>
<p><strong>EKF (Extended Kalman Filter)</strong>: 이동 로봇에서 위치 추정을 보다 정확하게 하기 위해 확장 칼만 필터(EKF)를 사용할 수 있다. EKF는 비선형 시스템에서 상태 추정을 수행하는 필터링 기법으로, 포인트 클라우드를 이용한 위치 추정에도 적용될 수 있다.</p>
</li>
<li>
<p><strong>상태 모델</strong>: 로봇의 상태는 위치와 속도를 포함한 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t) = \begin{pmatrix} \mathbf{r}(t) &amp; \mathbf{v}(t) \end{pmatrix}^\top</span><script type="math/tex">\mathbf{x}(t) = \begin{pmatrix} \mathbf{r}(t) & \mathbf{v}(t) \end{pmatrix}^\top</script></span>로 표현된다. 여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}(t)</span><script type="math/tex">\mathbf{r}(t)</script></span>는 위치, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}(t)</span><script type="math/tex">\mathbf{v}(t)</script></span>는 속도를 나타낸다.</p>
</li>
<li>
<p><strong>예측 단계</strong>: 로봇의 상태는 시간에 따라 예측된다. 예측된 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{\text{pred}}(t+1)</span><script type="math/tex">\mathbf{x}_{\text{pred}}(t+1)</script></span>는 다음과 같이 계산될 수 있다.</p>
</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{x}_{\text{pred}}(t+1) = \mathbf{F}(t) \mathbf{x}(t) + \mathbf{w}(t)
</div>
<script type="math/tex; mode=display">
   \mathbf{x}_{\text{pred}}(t+1) = \mathbf{F}(t) \mathbf{x}(t) + \mathbf{w}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}(t)</span><script type="math/tex">\mathbf{F}(t)</script></span>는 상태 전이 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{w}(t)</span><script type="math/tex">\mathbf{w}(t)</script></span>는 잡음 항이다.</p>
<ul>
<li><strong>관측 업데이트</strong>: 포인트 클라우드를 통해 관측된 정보 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}(t)</span><script type="math/tex">\mathbf{z}(t)</script></span>를 바탕으로 상태를 업데이트한다. 업데이트된 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t+1)</span><script type="math/tex">\mathbf{x}(t+1)</script></span>는 다음과 같다.</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{x}(t+1) = \mathbf{x}_{\text{pred}}(t+1) + \mathbf{K}(t+1) \left(\mathbf{z}(t+1) - \mathbf{H}(t) \mathbf{x}_{\text{pred}}(t+1)\right)
</div>
<script type="math/tex; mode=display">
   \mathbf{x}(t+1) = \mathbf{x}_{\text{pred}}(t+1) + \mathbf{K}(t+1) \left(\mathbf{z}(t+1) - \mathbf{H}(t) \mathbf{x}_{\text{pred}}(t+1)\right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}(t+1)</span><script type="math/tex">\mathbf{K}(t+1)</script></span>는 칼만 이득, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}(t)</span><script type="math/tex">\mathbf{H}(t)</script></span>는 관측 모델을 나타낸다.</p>
<p>EKF는 이동 로봇이 불확실한 환경에서 자신이 추정한 위치와 실제 관측치를 결합하여 보다 정확한 위치를 제공하는 데 유용하다.</p>
<h3 id="6">6. 이동 로봇에서의 장애물 지도 생성</h3>
<p>이동 로봇이 자율적으로 주행하는 과정에서 가장 중요한 요소 중 하나는 장애물 지도를 생성하는 것이다. 포인트 클라우드를 이용한 장애물 지도는 로봇이 주행 가능한 경로와 주행 불가능한 지역을 구분하는 데 필수적이다. 이 지도는 실시간으로 업데이트되어 로봇이 환경에 적응할 수 있게 한다.</p>
<h4 id="1_1">1. 포인트 클라우드 기반의 장애물 탐지</h4>
<p>로봇이 수집한 포인트 클라우드에서 장애물을 탐지하는 방법은 주로 각 포인트의 높이와 밀집도를 이용한다. 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P} = \{\mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n\}</span><script type="math/tex">\mathbf{P} = \{\mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n\}</script></span>에서 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 3차원 좌표 <span class="arithmatex"><span class="MathJax_Preview">(x_i, y_i, z_i)</span><script type="math/tex">(x_i, y_i, z_i)</script></span>로 표현된다. 장애물 탐지는 주로 다음과 같은 방법으로 수행된다.</p>
<ol>
<li><strong>높이 기반 탐지</strong>: 로봇이 주행할 수 없는 높이에 있는 포인트를 필터링하여 장애물로 간주한다. 로봇의 높이 한계 <span class="arithmatex"><span class="MathJax_Preview">h_{\text{max}}</span><script type="math/tex">h_{\text{max}}</script></span>에 따라 다음과 같은 조건을 만족하는 포인트는 장애물로 인식된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
z_i &gt; h_{\text{max}}
</div>
<script type="math/tex; mode=display">
z_i > h_{\text{max}}
</script>
</div>
<ol>
<li><strong>밀도 기반 탐지</strong>: 포인트 클라우드의 특정 영역에서 포인트가 밀집되어 있으면, 해당 영역을 장애물로 간주한다. 이를 위해 일정한 반경 <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> 내에서 포인트의 개수를 계산하여 밀도가 높을수록 장애물일 가능성이 크다고 판단한다. 반경 <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> 내에 포인트 개수를 세는 함수는 다음과 같이 표현될 수 있다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
N(\mathbf{p}_i, r) = \left| \left\{ \mathbf{p}_j \in \mathbf{P} \mid \|\mathbf{p}_j - \mathbf{p}_i\| \leq r \right\} \right|
</div>
<script type="math/tex; mode=display">
N(\mathbf{p}_i, r) = \left| \left\{ \mathbf{p}_j \in \mathbf{P} \mid \|\mathbf{p}_j - \mathbf{p}_i\| \leq r \right\} \right|
</script>
</div>
<h4 id="2_1">2. 장애물 지도 생성</h4>
<p>장애물 지도를 생성하기 위해서는 로봇이 수집한 포인트 클라우드를 기반으로 각 지역의 장애물 여부를 판단하고, 이를 2D 또는 3D 지도 형식으로 표현해야 한다. 이를 위한 주요 방법론은 다음과 같다.</p>
<ol>
<li><strong>그리드 기반 표현</strong>: 포인트 클라우드를 2차원 또는 3차원 그리드로 변환하여 각 그리드 셀에 포인트가 존재하는지 여부를 확인한다. 2D 그리드 맵에서 각 셀 <span class="arithmatex"><span class="MathJax_Preview">G_{i,j}</span><script type="math/tex">G_{i,j}</script></span>는 해당 영역에 포인트가 있는지 여부를 바탕으로 이진 값(0 또는 1)을 가지며, 포인트가 존재하는 셀은 장애물로 표시된다. </li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
G_{i,j} = \begin{cases} 
1 &amp; \text{if } \exists \mathbf{p}_k \in \mathbf{P} \text{ such that } (x_k, y_k) \in \text{cell}(i,j) \\
0 &amp; \text{otherwise}
\end{cases}
</div>
<script type="math/tex; mode=display">
G_{i,j} = \begin{cases} 
1 & \text{if } \exists \mathbf{p}_k \in \mathbf{P} \text{ such that } (x_k, y_k) \in \text{cell}(i,j) \\
0 & \text{otherwise}
\end{cases}
</script>
</div>
<ol>
<li><strong>Octree 기반 표현</strong>: 포인트 클라우드의 3차원 정보를 보다 효율적으로 처리하기 위해 Octree 구조를 이용하여 공간을 분할할 수 있다. Octree는 3차원 공간을 재귀적으로 분할하여 장애물 정보를 저장하며, 특히 대규모 환경에서 효과적인 데이터 압축 및 처리가 가능하다. Octree 노드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}_i</span><script type="math/tex">\mathbf{O}_i</script></span>는 공간을 재귀적으로 분할하며, 각 노드의 크기는 분할 단계에 따라 줄어든다.</li>
</ol>
<h4 id="3_1">3. 장애물 지도 업데이트</h4>
<p>로봇이 이동하는 동안 환경이 동적으로 변할 수 있으므로, 장애물 지도는 실시간으로 업데이트되어야 한다. 이를 위해 로봇은 이동하면서 수집한 새로운 포인트 클라우드를 기존의 지도에 통합하며, 필요시 새로운 장애물을 추가하거나 사라진 장애물을 제거한다. 장애물 지도 업데이트 과정은 다음과 같이 이루어진다.</p>
<ol>
<li>
<p><strong>새로운 포인트 통합</strong>: 새로운 프레임에서 수집된 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{new}}</span><script type="math/tex">\mathbf{P}_{\text{new}}</script></span>를 기존의 지도에 추가한다. 이를 위해 새로운 포인트들이 기존 그리드나 Octree에 적절히 삽입된다.</p>
</li>
<li>
<p><strong>기존 장애물 제거</strong>: 로봇의 움직임에 따라 장애물이 사라졌을 수 있기 때문에, 일정 시간 동안 로봇의 센서에 의해 탐지되지 않은 포인트들은 장애물에서 제거된다. 이를 위해 포인트가 마지막으로 탐지된 시간을 기록하고, 일정 시간 <span class="arithmatex"><span class="MathJax_Preview">T_{\text{timeout}}</span><script type="math/tex">T_{\text{timeout}}</script></span> 이상 경과한 포인트들은 장애물에서 제외된다.</p>
</li>
</ol>
<h4 id="4_1">4. 실시간 경로 수정</h4>
<p>장애물 지도가 실시간으로 업데이트되면, 로봇은 이를 기반으로 경로를 동적으로 수정해야 한다. 경로 수정은 앞서 언급된 경로 계획 알고리즘을 기반으로 하며, 새로운 장애물이 경로 상에 등장하면 경로를 우회하도록 변경된다.</p>
<h3 id="7-slam">7. 이동 로봇에서의 포인트 클라우드와 SLAM</h3>
<p>포인트 클라우드를 활용한 SLAM(동시 위치추정 및 지도작성) 기술은 이동 로봇의 핵심 요소 중 하나이다. 로봇이 자율적으로 환경을 탐지하고 그 환경에서 자신의 위치를 지속적으로 추정하는 SLAM은 포인트 클라우드를 통해 이루어질 수 있다. 특히, 포인트 클라우드는 환경의 고유한 3D 특성을 반영하기 때문에 SLAM 알고리즘이 보다 정확하고 안정적으로 작동할 수 있다.</p>
<h4 id="1-slam">1. 포인트 클라우드 SLAM 개요</h4>
<p>SLAM 문제는 로봇이 이동하면서 다음 두 가지 문제를 동시에 해결하는 것을 의미한다.
- <strong>위치추정</strong>: 로봇이 현재 환경에서 자신의 위치를 정확하게 추정하는 것.
- <strong>지도작성</strong>: 로봇이 주변 환경의 지도를 지속적으로 업데이트하고 작성하는 것.</p>
<p>포인트 클라우드 SLAM에서, 로봇은 라이다(LiDAR) 또는 RGB-D 카메라와 같은 센서로부터 얻은 3차원 포인트 클라우드를 활용하여 다음과 같은 방식으로 SLAM을 수행한다.</p>
<h4 id="2-slam">2. SLAM 과정</h4>
<p>포인트 클라우드를 이용한 SLAM의 기본적인 과정을 단계별로 설명할 수 있다.</p>
<ol>
<li><strong>포인트 클라우드 획득</strong>: 로봇이 센서를 통해 실시간으로 환경에 대한 포인트 클라우드를 수집한다. 이때 수집된 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_t</span><script type="math/tex">\mathbf{P}_t</script></span>는 로봇이 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 시간에서 수집한 포인트 데이터로 정의된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_t = \{\mathbf{p}_1^t, \mathbf{p}_2^t, \dots, \mathbf{p}_n^t\}, \quad \mathbf{p}_i^t \in \mathbb{R}^3
</div>
<script type="math/tex; mode=display">
\mathbf{P}_t = \{\mathbf{p}_1^t, \mathbf{p}_2^t, \dots, \mathbf{p}_n^t\}, \quad \mathbf{p}_i^t \in \mathbb{R}^3
</script>
</div>
<ol>
<li><strong>로봇 위치 추정</strong>: 로봇이 각 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서 자신의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}(t)</span><script type="math/tex">\mathbf{r}(t)</script></span>를 추정한다. 이 위치는 앞서 수집된 포인트 클라우드와 현재 획득한 포인트 클라우드 사이의 변환을 기반으로 계산된다. 위치 추정은 ICP(Iterative Closest Point) 또는 NDT(Normal Distributions Transform)와 같은 방법을 통해 이루어지며, 두 포인트 클라우드 간의 최적 변환 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_t</span><script type="math/tex">\mathbf{T}_t</script></span>를 계산하여 위치를 추정한다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{r}(t+1) = \mathbf{T}_t \mathbf{r}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{r}(t+1) = \mathbf{T}_t \mathbf{r}(t)
</script>
</div>
<ol>
<li><strong>지도 갱신</strong>: 로봇의 위치가 추정된 후, 새로운 포인트 클라우드를 기존의 환경 지도에 통합하여 갱신한다. 기존에 구축된 지도 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}_t</span><script type="math/tex">\mathbf{M}_t</script></span>는 새로운 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_t</span><script type="math/tex">\mathbf{P}_t</script></span>와 결합되어 업데이트된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{M}_{t+1} = \mathbf{M}_t \cup \mathbf{T}_t \mathbf{P}_t
</div>
<script type="math/tex; mode=display">
\mathbf{M}_{t+1} = \mathbf{M}_t \cup \mathbf{T}_t \mathbf{P}_t
</script>
</div>
<ol>
<li><strong>루프 클로징</strong>: 로봇이 이동하다가 이전에 방문한 위치에 도달할 경우, SLAM 알고리즘은 루프 클로징(Loop Closing)을 수행하여 지도를 최적화한다. 이 과정에서 로봇의 위치 추정과 기존 지도 간의 불일치를 최소화하는 최적화 과정이 필요하며, 보통 그래프 기반 SLAM에서 이 문제가 해결된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{T}_1, \dots, \mathbf{T}_N} \sum_{i,j} \|\mathbf{T}_i \mathbf{P}_i - \mathbf{T}_j \mathbf{P}_j\|^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{T}_1, \dots, \mathbf{T}_N} \sum_{i,j} \|\mathbf{T}_i \mathbf{P}_i - \mathbf{T}_j \mathbf{P}_j\|^2
</script>
</div>
<h4 id="3-slam">3. SLAM 알고리즘의 종류</h4>
<p>포인트 클라우드를 이용한 SLAM에서 자주 사용되는 주요 알고리즘으로는 다음과 같은 것들이 있다.</p>
<ol>
<li>
<p><strong>ICP 기반 SLAM</strong>: 두 포인트 클라우드 사이의 최적의 변환을 찾는 ICP 알고리즘을 기반으로 SLAM을 수행한다. 이 방식은 매우 직관적이지만, 많은 양의 계산이 필요하므로 실시간 성능에 제한이 있을 수 있다.</p>
</li>
<li>
<p><strong>NDT 기반 SLAM</strong>: 포인트 클라우드를 일정한 분포로 변환한 후, 이 분포들 간의 변환을 최적화하는 방법이다. NDT는 보다 빠른 수렴 속도를 보이며, 특히 포인트 클라우드가 많은 경우 효율적이다.</p>
</li>
<li>
<p><strong>Graph-based SLAM</strong>: SLAM 문제를 그래프로 표현하여 각 위치에서의 변환을 그래프 노드로 나타내고, 노드 간의 관계를 엣지로 표현하여 최적화를 수행하는 방식이다. 루프 클로징 문제를 효과적으로 해결할 수 있는 장점이 있다.</p>
</li>
</ol>
<h4 id="4-slam">4. 포인트 클라우드 SLAM의 도전 과제</h4>
<ol>
<li>
<p><strong>데이터 불확실성</strong>: 센서에서 수집된 포인트 클라우드는 노이즈가 포함되어 있어, 정확한 위치 추정 및 지도 작성에 어려움이 있다. 이를 극복하기 위해 필터링 기법이 필요하다.</p>
</li>
<li>
<p><strong>계산 성능</strong>: SLAM 알고리즘은 대량의 포인트 클라우드를 처리해야 하기 때문에 실시간 계산 성능이 중요하다. 이를 위해 병렬 처리나 GPU 가속 등이 고려될 수 있다.</p>
</li>
<li>
<p><strong>드리프트 보정</strong>: SLAM에서 로봇의 위치 추정은 시간이 지남에 따라 누적 오차(드리프트)가 발생할 수 있다. 이러한 문제를 해결하기 위해서는 정기적인 루프 클로징이나 외부 참조 시스템을 사용하는 보정 방법이 필요하다.</p>
</li>
</ol>
<h3 id="8">8. 포인트 클라우드를 이용한 로봇의 환경 이해</h3>
<p>이동 로봇이 포인트 클라우드를 사용하여 환경을 이해하고 상호작용하는 과정은 로봇의 자율성과 인식 능력을 결정짓는 중요한 요소다. 포인트 클라우드는 로봇이 주변의 복잡한 3D 환경을 탐지하고, 이를 바탕으로 다양한 의사 결정을 수행하는 데 필수적인 데이터를 제공한다. 여기서는 로봇이 포인트 클라우드를 이용하여 환경을 이해하는 주요 방법에 대해 다룬다.</p>
<h4 id="1-3d">1. 3D 공간 분할 및 표현</h4>
<p>로봇이 포인트 클라우드를 처리하는 첫 단계는 수집된 포인트 클라우드를 구조화하여 3D 공간을 이해하는 것이다. 이를 위해 자주 사용되는 두 가지 방법이 있다.</p>
<ol>
<li><strong>Octree 기반 공간 분할</strong>: Octree는 3차원 공간을 재귀적으로 8개의 하위 공간으로 분할하여 포인트 클라우드를 효율적으로 저장하고 검색하는 자료구조다. 로봇은 Octree를 사용하여 주변 환경을 빠르게 검색할 수 있으며, 포인트 클라우드가 대규모일 때도 적은 메모리로 관리할 수 있다. 각 노드는 하위 공간을 나타내며, 노드의 크기는 분할 단계에 따라 감소한다.</li>
</ol>
<p>Octree에서 노드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}_i</span><script type="math/tex">\mathbf{O}_i</script></span>는 공간의 특정 부분을 포함하며, 이 노드가 포함하는 포인트의 좌표 범위는 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{O}_i = \{(x, y, z) \mid x_{\text{min}} \leq x \leq x_{\text{max}}, y_{\text{min}} \leq y \leq y_{\text{max}}, z_{\text{min}} \leq z \leq z_{\text{max}}\}
</div>
<script type="math/tex; mode=display">
\mathbf{O}_i = \{(x, y, z) \mid x_{\text{min}} \leq x \leq x_{\text{max}}, y_{\text{min}} \leq y \leq y_{\text{max}}, z_{\text{min}} \leq z \leq z_{\text{max}}\}
</script>
</div>
<ol>
<li><strong>Voxel 그리드 필터</strong>: 포인트 클라우드를 일정한 크기의 격자로 나누어, 각 격자(Voxel)에 포함된 포인트를 하나의 포인트로 대체하는 방법이다. 이를 통해 데이터의 양을 줄이고, 연산 속도를 높일 수 있다. 각 Voxel은 3차원 공간의 일정한 크기를 가지며, 이 안에 포함된 포인트들의 중심점을 대리 포인트로 사용한다.</li>
</ol>
<p>Voxel 그리드 필터는 다음과 같이 정의된다. 각 Voxel <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}_i</span><script type="math/tex">\mathbf{V}_i</script></span>는 격자의 한 칸을 의미하며, 이 안에 포함된 포인트들은 중심점으로 대체된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{V}_i = \frac{1}{N_i} \sum_{j=1}^{N_i} \mathbf{p}_j, \quad \mathbf{p}_j \in \text{Voxel}_i
</div>
<script type="math/tex; mode=display">
\mathbf{V}_i = \frac{1}{N_i} \sum_{j=1}^{N_i} \mathbf{p}_j, \quad \mathbf{p}_j \in \text{Voxel}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N_i</span><script type="math/tex">N_i</script></span>는 Voxel <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}_i</span><script type="math/tex">\mathbf{V}_i</script></span> 안에 포함된 포인트의 개수다.</p>
<h4 id="2_2">2. 평면 및 물체 검출</h4>
<p>로봇이 환경을 이해하기 위해서는 단순히 포인트 클라우드를 수집하는 것뿐만 아니라, 해당 데이터를 통해 의미 있는 구조를 검출하는 것이 중요하다. 이를 위해 평면 및 물체를 검출하는 방법들이 주로 사용된다.</p>
<ol>
<li>
<p><strong>RANSAC을 이용한 평면 검출</strong>: RANSAC(Random Sample Consensus)은 포인트 클라우드에서 평면과 같은 구조를 검출하는 데 널리 사용되는 알고리즘이다. 로봇이 주행하는 동안 바닥이나 벽과 같은 평면을 인식하는 데 유용하다. RANSAC은 다음과 같은 절차로 이루어진다.</p>
</li>
<li>
<p><strong>샘플링</strong>: 포인트 클라우드에서 무작위로 일부 포인트를 샘플링한다.</p>
</li>
<li><strong>모델 생성</strong>: 샘플링된 포인트들을 사용하여 평면 모델을 생성한다. 평면은 일반적으로 다음과 같은 식으로 표현된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   ax + by + cz + d = 0
</div>
<script type="math/tex; mode=display">
   ax + by + cz + d = 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>, <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>, <span class="arithmatex"><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span>, <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>는 평면 방정식의 계수다.</p>
<ul>
<li>
<p><strong>모델 평가</strong>: 나머지 포인트들에 대해 해당 모델이 얼마나 잘 맞는지 평가하여 모델을 개선한다. 모델에 잘 맞는 포인트들은 인라이어(inlier)로 간주되며, 해당 모델이 가장 많은 인라이어를 가지는 경우 최종 모델로 선택된다.</p>
</li>
<li>
<p><strong>Euclidean 클러스터링을 이용한 물체 검출</strong>: 로봇이 포인트 클라우드를 통해 주변의 개별 물체를 탐지하기 위해서는 포인트 클라우드 클러스터링 기법을 사용할 수 있다. Euclidean 클러스터링은 포인트 간의 거리 정보를 기반으로, 인접한 포인트들을 하나의 클러스터로 묶는다.</p>
</li>
</ul>
<p>Euclidean 클러스터링은 다음과 같은 단계로 이루어진다.</p>
<ul>
<li><strong>포인트 간 거리 계산</strong>: 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 다른 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span> 사이의 유클리드 거리를 계산한다.</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
   d(\mathbf{p}_i, \mathbf{p}_j) = \|\mathbf{p}_i - \mathbf{p}_j\|
</div>
<script type="math/tex; mode=display">
   d(\mathbf{p}_i, \mathbf{p}_j) = \|\mathbf{p}_i - \mathbf{p}_j\|
</script>
</div>
<ul>
<li><strong>클러스터 생성</strong>: 주어진 임계값 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span> 이하의 거리를 가지는 포인트들을 하나의 클러스터로 묶는다. 이를 반복하여 모든 포인트를 하나 이상의 클러스터로 분류한다.</li>
</ul>
<p>물체 검출은 이 클러스터링 결과를 바탕으로 각 클러스터를 개별 물체로 인식하며, 클러스터의 크기와 모양 정보를 통해 특정 객체의 특징을 추출할 수 있다.</p>
<h4 id="3_2">3. 지형 분석 및 주행 가능성 평가</h4>
<p>이동 로봇이 포인트 클라우드를 기반으로 지형을 분석하고 그 지형을 통과할 수 있는지를 평가하는 것도 매우 중요한 작업이다. 로봇이 고르지 않은 지형에서 이동해야 하는 경우, 주행 가능성 평가를 통해 안정적인 경로를 계획할 수 있다.</p>
<ol>
<li><strong>기울기 분석</strong>: 로봇은 포인트 클라우드를 통해 각 지형의 기울기를 계산하여, 기울기가 일정 이상인 곳은 주행이 어렵다고 판단한다. 기울기는 평면의 법선 벡터와 지면의 법선 벡터 사이의 각도로 계산된다.</li>
</ol>
<p>두 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_1</span><script type="math/tex">\mathbf{n}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_2</span><script type="math/tex">\mathbf{n}_2</script></span> 사이의 기울기 각도 <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>는 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
   \theta = \arccos\left(\frac{\mathbf{n}_1 \cdot \mathbf{n}_2}{\|\mathbf{n}_1\| \|\mathbf{n}_2\|}\right)
</div>
<script type="math/tex; mode=display">
   \theta = \arccos\left(\frac{\mathbf{n}_1 \cdot \mathbf{n}_2}{\|\mathbf{n}_1\| \|\mathbf{n}_2\|}\right)
</script>
</div>
<ol>
<li><strong>울퉁불퉁한 지형 탐지</strong>: 포인트 클라우드에서 고르지 않은 지형을 탐지하기 위해 포인트 간의 높이 차이를 계산하여, 해당 지형이 로봇이 통과할 수 있는지 여부를 결정한다. 이 과정에서는 각 포인트의 높이 차이 <span class="arithmatex"><span class="MathJax_Preview">\Delta z</span><script type="math/tex">\Delta z</script></span>를 기준으로 울퉁불퉁한 지형을 탐지한다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\Delta z = |z_i - z_j|, \quad \mathbf{p}_i, \mathbf{p}_j \in \mathbf{P}
</div>
<script type="math/tex; mode=display">
\Delta z = |z_i - z_j|, \quad \mathbf{p}_i, \mathbf{p}_j \in \mathbf{P}
</script>
</div>
<p>이러한 기법들을 사용하여 이동 로봇은 주행 가능성을 평가하고, 실시간으로 주행 가능한 경로를 계산하여 안전한 자율 주행을 가능하게 한다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2003/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2003/" class="btn btn-xs btn-link">
        매니퓰레이터의 환경 인식
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2001/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2001/" class="btn btn-xs btn-link">
        로봇과 PCL의 연동
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>