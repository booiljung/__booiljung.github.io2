<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introduction_to_pointcloud_processing_with_pcl_library/chapter_09/0901/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>PCL에서의 포인트 클라우드 등록 개요 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \ub4f1\ub85d\uc758 \uc218\ud559\uc801 \uc815\uc758", url: "#_top", children: [
          ]},
          {title: "\ubcc0\ud658\uc758 \ubaa9\uc801 \ubc0f \uc81c\uc57d", url: "#_2", children: [
          ]},
          {title: "ICP \uc54c\uace0\ub9ac\uc998\uc758 \uac1c\uc694", url: "#icp", children: [
          ]},
          {title: "\ub300\uc751\uc810 \ucc3e\uae30", url: "#_3", children: [
          ]},
          {title: "\ubcc0\ud658 \ucd94\uc815", url: "#_4", children: [
              {title: "\uc911\uc2ec \uc88c\ud45c\ub85c \uc774\ub3d9", url: "#_5" },
              {title: "\ucd5c\uc801\uc758 \ud68c\uc804 \ud589\ub82c \\mathbf{R}\\mathbf{R} \uacc4\uc0b0", url: "#mathbfrmathbfr" },
              {title: "\ud3c9\ud589 \uc774\ub3d9 \ubca1\ud130 \\mathbf{t}\\mathbf{t} \uacc4\uc0b0", url: "#mathbftmathbft" },
          ]},
          {title: "\uc624\ucc28 \uacc4\uc0b0", url: "#_6", children: [
          ]},
          {title: "ICP\uc758 \uc218\ub834 \uc870\uac74", url: "#icp_1", children: [
          ]},
          {title: "PCL\uc5d0\uc11c\uc758 ICP \uad6c\ud604", url: "#pcl-icp", children: [
          ]},
          {title: "\ub9e4\uac1c\ubcc0\uc218 \uc124\uba85", url: "#_7", children: [
          ]},
          {title: "\uc774\uc0c1\uc810 \ucc98\ub9ac", url: "#_8", children: [
          ]},
          {title: "\ub300\uaddc\ubaa8 \ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\uc758 \ub4f1\ub85d", url: "#_9", children: [
          ]},
          {title: "\ub2e4\uc591\ud55c \ub4f1\ub85d \uc54c\uace0\ub9ac\uc998", url: "#_10", children: [
              {title: "Generalized ICP (GICP)", url: "#generalized-icp-gicp" },
              {title: "NDT (Normal Distributions Transform)", url: "#ndt-normal-distributions-transform" },
              {title: "Feature-based Registration", url: "#feature-based-registration" },
          ]},
          {title: "\ub300\uaddc\ubaa8 \ub370\uc774\ud130\uc758 \ubcd1\ub82c \ucc98\ub9ac \ubc0f \ucd5c\uc801\ud654", url: "#_11", children: [
          ]},
          {title: "\ub4f1\ub85d \uc131\ub2a5 \ucd5c\uc801\ud654 \uc804\ub7b5", url: "#_12", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0902/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0902/" class="btn btn-xs btn-link">
        ICP와 NDT 등록 알고리즘
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_08/0805/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_08/0805/" class="btn btn-xs btn-link">
        좌표계 변환 사례 연구
      </a>
    </div>
    
  </div>

    

    <p>포인트 클라우드 등록(Point Cloud Registration)은 두 개 이상의 서로 다른 좌표계에 존재하는 포인트 클라우드를 동일한 좌표계로 맞추는 작업을 말한다. 주로 여러 개의 3D 스캔 데이터가 있을 때, 각각의 포인트 클라우드를 정렬하여 하나의 통합된 모델을 얻기 위해 사용된다. PCL(Point Cloud Library)에서는 다양한 알고리즘과 도구들이 이러한 포인트 클라우드 등록을 수행할 수 있게 제공되고 있다.</p>
<h3 id="_1">포인트 클라우드 등록의 수학적 정의</h3>
<p>포인트 클라우드 등록은 일반적으로 두 개의 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span> 와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span> 사이의 변환을 찾는 문제로 정의할 수 있다. 여기서 각 포인트 클라우드는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P} = \{ \mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n \} \quad \mathbf{Q} = \{ \mathbf{q}_1, \mathbf{q}_2, \dots, \mathbf{q}_m \}
</div>
<script type="math/tex; mode=display">
\mathbf{P} = \{ \mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n \} \quad \mathbf{Q} = \{ \mathbf{q}_1, \mathbf{q}_2, \dots, \mathbf{q}_m \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_j</span><script type="math/tex">\mathbf{q}_j</script></span>는 각각 3D 공간의 점을 나타내는 벡터이다. 이때 등록은 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span> 사이의 변환 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>를 찾는 문제로 정의되며, 변환 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 회전 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 평행 이동 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>로 구성된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T(\mathbf{p}_i) = \mathbf{R} \mathbf{p}_i + \mathbf{t}
</div>
<script type="math/tex; mode=display">
T(\mathbf{p}_i) = \mathbf{R} \mathbf{p}_i + \mathbf{t}
</script>
</div>
<p>따라서, 포인트 클라우드 등록의 목적은 최적의 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 평행 이동 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>를 찾아, 두 포인트 클라우드 사이의 대응점을 최소 오차로 맞추는 것이다.</p>
<h3 id="_2">변환의 목적 및 제약</h3>
<p>변환 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>를 통해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>를 동일한 좌표계로 맞추는 데 있어, 목표는 각 대응점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span> 사이의 거리 차이를 최소화하는 것이다. 이 문제는 일반적으로 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \left\| \mathbf{q}_i - \left( \mathbf{R} \mathbf{p}_i + \mathbf{t} \right) \right\|^2
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{R}, \mathbf{t}} \sum_{i=1}^{N} \left\| \mathbf{q}_i - \left( \mathbf{R} \mathbf{p}_i + \mathbf{t} \right) \right\|^2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\left\| \cdot \right\|</span><script type="math/tex">\left\| \cdot \right\|</script></span>는 유클리드 거리이며, 대응점은 두 포인트 클라우드에서 가장 유사한 점들로 정의된다. 이 최적화 문제를 해결하기 위해 PCL에서는 Iterative Closest Point(ICP) 알고리즘을 포함한 여러 등록 알고리즘이 제공된다.</p>
<h3 id="icp">ICP 알고리즘의 개요</h3>
<p>ICP(Iterative Closest Point) 알고리즘은 포인트 클라우드 등록을 위해 가장 널리 사용되는 방법 중 하나다. 이 알고리즘은 반복적으로 두 포인트 클라우드 간의 대응점을 찾고, 그 대응점들 사이의 변환을 추정하여 포인트 클라우드가 정렬될 때까지 이를 반복한다.</p>
<p>ICP 알고리즘은 다음과 같은 단계로 구성된다:</p>
<ol>
<li><strong>대응점 찾기:</strong> 두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>에서 가장 가까운 점들을 각각 대응시킨다.</li>
<li><strong>변환 추정:</strong> 대응점들 간의 변환 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> (즉, 회전 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 평행 이동 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>)를 추정한다.</li>
<li><strong>포인트 클라우드 변환:</strong> 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>에 추정된 변환 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>를 적용하여 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>에 더 가까운 위치로 이동시킨다.</li>
<li><strong>오차 계산:</strong> 두 포인트 클라우드 간의 오차를 계산하고, 오차가 충분히 작아지거나 반복 횟수가 일정 수에 도달할 때까지 1~3단계를 반복한다.</li>
</ol>
<p>이러한 절차는 변환된 포인트 클라우드가 목표 포인트 클라우드에 근접하도록 만든다. </p>
<h3 id="_3">대응점 찾기</h3>
<p>ICP의 핵심 단계 중 하나는 대응점을 찾는 것이다. 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i \in \mathbf{P}</span><script type="math/tex">\mathbf{p}_i \in \mathbf{P}</script></span>에 대해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>에서 가장 가까운 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_j \in \mathbf{Q}</span><script type="math/tex">\mathbf{q}_j \in \mathbf{Q}</script></span>를 찾는 방식이다. 이 대응점 찾기는 포인트 간의 유클리드 거리를 최소화하는 문제로 귀결된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
j = \arg \min_j \left\| \mathbf{p}_i - \mathbf{q}_j \right\|
</div>
<script type="math/tex; mode=display">
j = \arg \min_j \left\| \mathbf{p}_i - \mathbf{q}_j \right\|
</script>
</div>
<p>이 과정은 전통적으로 브루트 포스 방식으로 진행되었으나, 이는 시간이 오래 걸리므로 효율적인 알고리즘, 예를 들어 KD-트리(KD-tree)를 이용한 근사화 기법이 사용된다.</p>
<h3 id="_4">변환 추정</h3>
<p>대응점이 결정되면, 다음 단계는 두 포인트 클라우드 사이의 변환 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>를 추정하는 것이다. 이는 대응점 사이의 유클리드 거리를 최소화하는 회전 및 평행 이동을 찾는 과정이다. 변환 추정은 다음과 같은 절차로 이루어진다:</p>
<h4 id="_5">중심 좌표로 이동</h4>
<p>먼저 두 포인트 클라우드의 중심을 원점으로 이동시켜서 회전만 고려할 수 있게 한다. 이를 위해 각각의 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>의 중심점을 계산한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\bar{p}} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i \quad \mathbf{\bar{q}} = \frac{1}{M} \sum_{j=1}^{M} \mathbf{q}_j
</div>
<script type="math/tex; mode=display">
\mathbf{\bar{p}} = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i \quad \mathbf{\bar{q}} = \frac{1}{M} \sum_{j=1}^{M} \mathbf{q}_j
</script>
</div>
<p>그 후, 각 포인트를 해당 중심점으로부터의 상대 좌표로 변환한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_i' = \mathbf{p}_i - \mathbf{\bar{p}} \quad \mathbf{q}_j' = \mathbf{q}_j - \mathbf{\bar{q}}
</div>
<script type="math/tex; mode=display">
\mathbf{p}_i' = \mathbf{p}_i - \mathbf{\bar{p}} \quad \mathbf{q}_j' = \mathbf{q}_j - \mathbf{\bar{q}}
</script>
</div>
<p>이 과정을 통해 각 포인트 클라우드는 원점 중심으로 정렬된다.</p>
<h4 id="mathbfrmathbfr">최적의 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span> 계산</h4>
<p>변환 문제는 이제 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i'</span><script type="math/tex">\mathbf{p}_i'</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_j'</span><script type="math/tex">\mathbf{q}_j'</script></span> 사이에서 최적의 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>을 찾는 문제로 단순화된다. 이를 위해 SVD(특이값 분해, Singular Value Decomposition) 방법이 자주 사용된다.</p>
<p>먼저 두 포인트 클라우드의 상관행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}</span><script type="math/tex">\mathbf{H}</script></span>를 정의한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{H} = \sum_{i=1}^{N} \mathbf{p}_i' \mathbf{q}_i'^T
</div>
<script type="math/tex; mode=display">
\mathbf{H} = \sum_{i=1}^{N} \mathbf{p}_i' \mathbf{q}_i'^T
</script>
</div>
<p>그 다음, 상관행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}</span><script type="math/tex">\mathbf{H}</script></span>에 대해 SVD를 수행하여 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{S}</span><script type="math/tex">\mathbf{S}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}^T</span><script type="math/tex">\mathbf{V}^T</script></span>를 구한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{H} = \mathbf{U} \mathbf{S} \mathbf{V}^T
</div>
<script type="math/tex; mode=display">
\mathbf{H} = \mathbf{U} \mathbf{S} \mathbf{V}^T
</script>
</div>
<p>최적의 회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{R} = \mathbf{V} \mathbf{U}^T
</div>
<script type="math/tex; mode=display">
\mathbf{R} = \mathbf{V} \mathbf{U}^T
</script>
</div>
<p>이렇게 계산된 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 두 포인트 클라우드를 가장 잘 일치시키는 회전 행렬이다.</p>
<h4 id="mathbftmathbft">평행 이동 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span> 계산</h4>
<p>회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>을 구한 후, 평행 이동 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>는 간단히 두 포인트 클라우드의 중심점의 차이를 이용하여 계산할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{t} = \mathbf{\bar{q}} - \mathbf{R} \mathbf{\bar{p}}
</div>
<script type="math/tex; mode=display">
\mathbf{t} = \mathbf{\bar{q}} - \mathbf{R} \mathbf{\bar{p}}
</script>
</div>
<p>따라서 최종 변환은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T(\mathbf{p}_i) = \mathbf{R} \mathbf{p}_i + \mathbf{t}
</div>
<script type="math/tex; mode=display">
T(\mathbf{p}_i) = \mathbf{R} \mathbf{p}_i + \mathbf{t}
</script>
</div>
<p>이 변환을 통해 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>는 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>와 가장 잘 맞는 형태로 변환된다.</p>
<h3 id="_6">오차 계산</h3>
<p>변환을 적용한 후, 두 포인트 클라우드 간의 오차를 계산하여 등록이 얼마나 잘 이루어졌는지 평가한다. 일반적으로 사용되는 오차 함수는 대응점 사이의 평균 제곱 오차(MSE, Mean Squared Error)이다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{MSE} = \frac{1}{N} \sum_{i=1}^{N} \left\| \mathbf{q}_i - \left( \mathbf{R} \mathbf{p}_i + \mathbf{t} \right) \right\|^2
</div>
<script type="math/tex; mode=display">
\text{MSE} = \frac{1}{N} \sum_{i=1}^{N} \left\| \mathbf{q}_i - \left( \mathbf{R} \mathbf{p}_i + \mathbf{t} \right) \right\|^2
</script>
</div>
<p>이 오차가 일정 기준 이하로 내려가거나, 반복 횟수가 한계에 도달하면 알고리즘은 종료된다.</p>
<h3 id="icp_1">ICP의 수렴 조건</h3>
<p>ICP 알고리즘은 일반적으로 빠르게 수렴하지만, 다음과 같은 조건에서 성능이 저하될 수 있다:</p>
<ol>
<li><strong>초기 정렬 상태:</strong> 두 포인트 클라우드가 충분히 가까운 위치에 있어야 한다. 초기 위치가 너무 멀리 떨어져 있으면 국소 최적해에 빠질 수 있다.</li>
<li><strong>잡음 및 이상점(outlier):</strong> 포인트 클라우드에 잡음이나 이상점이 포함되면, 대응점 찾기 과정에서 잘못된 대응이 이루어질 수 있다. 이를 방지하기 위해 이상점 제거 알고리즘을 사용할 수 있다.</li>
<li><strong>포인트 밀도:</strong> 두 포인트 클라우드의 밀도가 비슷해야 한다. 그렇지 않으면 대응점 찾기에서 부정확한 결과가 나올 수 있다.</li>
</ol>
<h3 id="pcl-icp">PCL에서의 ICP 구현</h3>
<p>PCL(Point Cloud Library)은 ICP 알고리즘을 쉽게 사용할 수 있는 도구들을 제공한다. PCL에서의 ICP 구현은 매우 간단하며, 주로 다음과 같은 기본 절차를 따른다:</p>
<ol>
<li><strong>포인트 클라우드 데이터 로드:</strong> 두 개의 포인트 클라우드를 로드한다. 여기서 하나는 이동할 대상 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>, 다른 하나는 기준 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>로 사용된다.</li>
<li><strong>ICP 객체 생성 및 설정:</strong> PCL에서 제공하는 ICP 객체를 생성하고, 최대 반복 횟수, 허용 오차 등 다양한 매개변수를 설정한다.</li>
<li><strong>등록 수행:</strong> ICP 객체를 통해 등록을 수행하고, 최적의 변환 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{t}</span><script type="math/tex">\mathbf{t}</script></span>를 계산한다.</li>
<li><strong>변환 적용:</strong> 계산된 변환을 원본 포인트 클라우드에 적용하여 두 포인트 클라우드를 정렬한다.</li>
<li><strong>오차 확인:</strong> 등록 후 두 포인트 클라우드 간의 오차를 확인하여 결과를 평가한다.</li>
</ol>
<p>PCL에서의 ICP 구현에 대한 기본적인 코드는 다음과 같다:</p>
<pre><code class="language-cpp">#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/registration/icp.h&gt;

int main() {
  // 포인트 클라우드 객체 생성 및 로드
  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_in(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_out(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
  pcl::io::loadPCDFile(&quot;input.pcd&quot;, *cloud_in);  // 입력 포인트 클라우드
  pcl::io::loadPCDFile(&quot;target.pcd&quot;, *cloud_out); // 타겟 포인트 클라우드

  // ICP 객체 생성
  pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp;
  icp.setInputSource(cloud_in);  // 이동할 포인트 클라우드
  icp.setInputTarget(cloud_out); // 기준 포인트 클라우드

  // ICP 설정
  icp.setMaximumIterations(50);       // 최대 반복 횟수
  icp.setMaxCorrespondenceDistance(0.05); // 대응점 최대 거리
  icp.setTransformationEpsilon(1e-8); // 변환 허용 오차

  // 등록 수행
  pcl::PointCloud&lt;pcl::PointXYZ&gt; final;
  icp.align(final);

  // 변환 성공 여부 확인
  if (icp.hasConverged()) {
    std::cout &lt;&lt; &quot;ICP converged. Score: &quot; &lt;&lt; icp.getFitnessScore() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Final transformation:\n&quot; &lt;&lt; icp.getFinalTransformation() &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; &quot;ICP did not converge.&quot; &lt;&lt; std::endl;
  }

  return 0;
}
</code></pre>
<h3 id="_7">매개변수 설명</h3>
<p>ICP 알고리즘은 몇 가지 중요한 매개변수를 설정하여 성능을 조정할 수 있다. PCL에서는 다음과 같은 매개변수들이 자주 사용된다:</p>
<ul>
<li>
<p><strong>최대 반복 횟수 (Maximum Iterations):</strong> ICP 알고리즘이 종료되기 전까지 최대 몇 번의 반복을 수행할지 설정한다. 기본적으로 50번으로 설정되며, 이 값이 클수록 정밀도가 증가하지만 계산 시간이 길어진다.</p>
</li>
<li>
<p><strong>최대 대응점 거리 (Max Correspondence Distance):</strong> 두 포인트 클라우드에서 대응점을 찾을 때 사용할 최대 거리를 설정한다. 너무 큰 값을 설정하면 잘못된 대응점이 선택될 가능성이 증가하고, 너무 작은 값을 설정하면 대응점이 충분히 선택되지 않을 수 있다.</p>
</li>
<li>
<p><strong>변환 허용 오차 (Transformation Epsilon):</strong> ICP 알고리즘이 수렴할 때까지 허용할 최소 변환값을 설정한다. 이 값이 작을수록 변환이 더 세밀하게 이루어지지만, 수렴 속도가 느려질 수 있다.</p>
</li>
</ul>
<h3 id="_8">이상점 처리</h3>
<p>포인트 클라우드에는 잡음이나 이상점(outliers)이 포함될 수 있으며, 이는 ICP 알고리즘의 정확도를 저하시킬 수 있다. PCL에서는 이상점을 제거하거나 무시할 수 있는 여러 기법을 제공한다. 예를 들어, 필터를 적용하여 일정 거리 이상 떨어진 포인트를 제거하거나, 추정된 대응점에서 일정 오차 이상인 점들을 제거하는 방법이 있다.</p>
<p>다음은 PCL에서 이상점을 처리하는 예시이다:</p>
<pre><code class="language-cpp">#include &lt;pcl/filters/statistical_outlier_removal.h&gt;

pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor;
sor.setInputCloud(cloud_in);
sor.setMeanK(50);               // 근처 포인트 클라우드의 평균 개수
sor.setStddevMulThresh(1.0);     // 표준 편차 임계값
sor.filter(*filtered_cloud);
</code></pre>
<p>이 코드는 평균 거리에서 벗어난 이상점을 제거하여 보다 정확한 ICP 결과를 얻을 수 있게 한다.</p>
<h3 id="_9">대규모 포인트 클라우드의 등록</h3>
<p>대규모 포인트 클라우드를 등록하는 경우, 메모리와 계산 시간 문제를 고려해야 한다. 이를 해결하기 위한 대표적인 기법으로는 다음과 같은 방법들이 있다:</p>
<ol>
<li><strong>다운샘플링 (Downsampling):</strong> 포인트 클라우드의 해상도를 낮추어 계산 비용을 줄인다. PCL에서는 Voxel Grid Filter를 사용하여 다운샘플링을 수행할 수 있다.</li>
</ol>
<p>```cpp
   #include <pcl/filters/voxel_grid.h></p>
<p>pcl::VoxelGrid<pcl::PointXYZ> sor;
   sor.setInputCloud(cloud_in);
   sor.setLeafSize(0.01f, 0.01f, 0.01f);  // 그리드의 크기 설정
   sor.filter(*filtered_cloud);
   ```</p>
<ol>
<li>
<p><strong>부분 등록 (Partial Registration):</strong> 전체 포인트 클라우드 대신 중요한 부분만을 선택하여 등록을 수행한다. 예를 들어, 객체의 윤곽선이나 특이점을 추출하여 그 부분에만 등록을 수행할 수 있다.</p>
</li>
<li>
<p><strong>병렬 처리:</strong> PCL은 병렬 처리를 지원하여 대규모 데이터에 대한 처리를 가속화할 수 있다. OpenMP 등의 병렬 처리 라이브러리를 이용해 포인트 클라우드의 처리 성능을 향상시킬 수 있다.</p>
</li>
</ol>
<h3 id="_10">다양한 등록 알고리즘</h3>
<p>PCL은 ICP 알고리즘뿐만 아니라 다양한 포인트 클라우드 등록 알고리즘을 지원한다. 각각의 알고리즘은 특정한 상황에서 더 나은 성능을 발휘하도록 설계되었으며, 다양한 데이터 셋에 적용할 수 있다. 몇 가지 대표적인 등록 알고리즘은 다음과 같다.</p>
<h4 id="generalized-icp-gicp">Generalized ICP (GICP)</h4>
<p>일반화된 ICP(Generalized ICP)는 전통적인 ICP 알고리즘의 확장판으로, 포인트 클라우드의 로컬 기하학 정보를 더 많이 고려하여 보다 정확한 등록을 수행한다. GICP는 포인트 클라우드에서 점의 밀도 및 표면의 기울기와 같은 정보를 사용하여 대응점을 더 정밀하게 계산한다.</p>
<p>PCL에서는 <code>GeneralizedIterativeClosestPoint</code> 클래스를 통해 GICP를 사용할 수 있다. 다음은 GICP를 사용하는 기본적인 예시 코드이다.</p>
<pre><code class="language-cpp">#include &lt;pcl/registration/gicp.h&gt;

pcl::GeneralizedIterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; gicp;
gicp.setInputSource(cloud_in);  // 이동할 포인트 클라우드
gicp.setInputTarget(cloud_out); // 기준 포인트 클라우드

pcl::PointCloud&lt;pcl::PointXYZ&gt; final;
gicp.align(final);

if (gicp.hasConverged()) {
  std::cout &lt;&lt; &quot;GICP converged. Score: &quot; &lt;&lt; gicp.getFitnessScore() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Final transformation:\n&quot; &lt;&lt; gicp.getFinalTransformation() &lt;&lt; std::endl;
} else {
  std::cout &lt;&lt; &quot;GICP did not converge.&quot; &lt;&lt; std::endl;
}
</code></pre>
<p>GICP는 특히 복잡한 표면이 포함된 데이터셋이나 포인트 클라우드가 잘 맞지 않는 경우에 ICP보다 더 나은 성능을 발휘할 수 있다.</p>
<h4 id="ndt-normal-distributions-transform">NDT (Normal Distributions Transform)</h4>
<p>NDT(Normal Distributions Transform)는 포인트 클라우드를 3D 그리드로 나누고 각 그리드 셀 내에서 포인트들의 확률 분포를 모델링하는 방식으로 등록을 수행하는 알고리즘이다. NDT는 특히 환경 매핑과 같이 잡음이 많고 대규모 데이터셋에서 안정적인 성능을 발휘한다.</p>
<p>NDT는 포인트 클라우드의 기하학적 분포를 확률적으로 모델링함으로써 포인트 클라우드가 특정 패턴을 가진 경우에 매우 강력하다. PCL에서는 <code>NormalDistributionsTransform</code> 클래스를 통해 NDT 알고리즘을 사용할 수 있다.</p>
<p>다음은 NDT를 사용하는 기본적인 예시이다.</p>
<pre><code class="language-cpp">#include &lt;pcl/registration/ndt.h&gt;

pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
ndt.setInputSource(cloud_in);   // 이동할 포인트 클라우드
ndt.setInputTarget(cloud_out);  // 기준 포인트 클라우드

// NDT 설정
ndt.setResolution(1.0);  // 해상도 설정
ndt.setStepSize(0.1);    // 최적화 스텝 사이즈 설정
ndt.setMaximumIterations(35);  // 최대 반복 횟수 설정

pcl::PointCloud&lt;pcl::PointXYZ&gt; final;
ndt.align(final);

if (ndt.hasConverged()) {
  std::cout &lt;&lt; &quot;NDT converged. Score: &quot; &lt;&lt; ndt.getFitnessScore() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Final transformation:\n&quot; &lt;&lt; ndt.getFinalTransformation() &lt;&lt; std::endl;
} else {
  std::cout &lt;&lt; &quot;NDT did not converge.&quot; &lt;&lt; std::endl;
}
</code></pre>
<p>NDT는 대규모 실내/외 환경 매핑 등에서 사용되며, 초기 등록 상태가 불확실한 경우에도 상대적으로 안정적인 결과를 제공한다.</p>
<h4 id="feature-based-registration">Feature-based Registration</h4>
<p>특징 기반 등록은 포인트 클라우드의 전역적인 형상을 분석하여 각 포인트에 대해 특징을 추출하고, 이 특징들 간의 대응을 통해 등록을 수행하는 방식이다. 이는 ICP나 GICP와 같은 방식이 전체 포인트 클라우드를 사용하는 것과 달리, 중요한 포인트(특징점)만을 사용하므로 더 빠른 계산이 가능하다.</p>
<p>특징 기반 등록에서 일반적으로 사용되는 특징들은 다음과 같다:</p>
<ul>
<li><strong>FPFH (Fast Point Feature Histograms):</strong> 포인트 클라우드의 국소 영역에 대한 기하학적 구조를 요약하는 히스토그램 기반 특징.</li>
<li><strong>SHOT (Signature of Histograms of Orientations):</strong> 포인트 클라우드의 국소 기하학적 구조와 법선 정보를 결합하여 표현한 특징.</li>
</ul>
<p>특징 기반 등록 과정은 다음과 같은 단계로 이루어진다:</p>
<ol>
<li><strong>특징점 추출:</strong> 포인트 클라우드에서 관심 있는 영역의 특징점을 추출한다.</li>
<li><strong>특징 매칭:</strong> 추출된 특징점들 간의 매칭을 수행하여 대응점을 찾는다.</li>
<li><strong>변환 추정:</strong> 대응점들 간의 변환을 추정하여 포인트 클라우드를 등록한다.</li>
</ol>
<p>PCL에서는 이러한 특징 기반 등록을 위한 여러 도구들을 제공하고 있으며, 특징 추출, 매칭, 등록까지의 전 과정을 구현할 수 있다.</p>
<h3 id="_11">대규모 데이터의 병렬 처리 및 최적화</h3>
<p>대규모 포인트 클라우드 데이터를 처리할 때는 계산 성능과 메모리 관리가 매우 중요하다. PCL은 OpenMP, CUDA 등의 병렬 처리 프레임워크와 통합하여 포인트 클라우드 데이터 처리 속도를 최적화할 수 있다. 특히 고성능 GPU를 활용한 병렬 처리를 통해 실시간 포인트 클라우드 등록 작업을 수행할 수 있다.</p>
<ul>
<li>
<p><strong>OpenMP:</strong> PCL의 여러 함수는 OpenMP를 사용하여 다중 스레드에서 병렬 처리가 가능하다. 예를 들어, KD-tree를 이용한 대응점 찾기에서 여러 스레드를 사용해 검색 시간을 줄일 수 있다.</p>
</li>
<li>
<p><strong>CUDA:</strong> CUDA 기반의 GPU 병렬 처리를 활용하면 수백만 개 이상의 포인트 클라우드를 빠르게 처리할 수 있다. PCL은 CUDA 통합을 지원하여 ICP와 같은 알고리즘을 병렬 처리할 수 있다.</p>
</li>
</ul>
<h3 id="_12">등록 성능 최적화 전략</h3>
<p>포인트 클라우드 등록 작업의 성능을 최적화하는 방법은 여러 가지가 있으며, 주요 전략은 다음과 같다:</p>
<ol>
<li><strong>프레임워크 선택:</strong> CUDA, OpenMP 등을 사용하여 병렬 처리 성능을 극대화한다.</li>
<li><strong>데이터 전처리:</strong> 잡음 제거 및 다운샘플링을 통해 데이터의 크기를 줄이고, 처리 속도를 높인다.</li>
<li><strong>매개변수 튜닝:</strong> ICP, NDT, GICP 등 등록 알고리즘의 매개변수를 데이터셋에 맞게 최적화하여 성능을 개선한다.</li>
<li><strong>부분 등록:</strong> 전체 포인트 클라우드 대신 중요한 부분만을 선택하여 등록 작업을 수행함으로써 계산 비용을 줄인다.</li>
</ol>
<p>이러한 방법들은 특히 실시간 3D 스캔이나 대규모 환경 매핑 작업에서 필수적이다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0902/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0902/" class="btn btn-xs btn-link">
        ICP와 NDT 등록 알고리즘
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_08/0805/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_08/0805/" class="btn btn-xs btn-link">
        좌표계 변환 사례 연구
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>