<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/pointcloud/introduction_to_pointcloud_processing_with_pcl_library/chapter_30/3005/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>PCL을 활용한 프로젝트 사례 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc790\uc728 \uc8fc\ud589 \ucc28\ub7c9\uc744 \uc704\ud55c \uc7a5\uc560\ubb3c \uac10\uc9c0 \ud504\ub85c\uc81d\ud2b8", url: "#_top", children: [
          ]},
          {title: "\uc0b0\uc5c5 \uc790\ub3d9\ud654\ub97c \uc704\ud55c \ud488\uc9c8 \uac80\uc0ac \uc2dc\uc2a4\ud15c", url: "#_2", children: [
          ]},
          {title: "\uc99d\uac15 \ud604\uc2e4(AR)\uacfc \uac00\uc0c1 \ud604\uc2e4(VR)\uc5d0\uc11c\uc758 3D \ud658\uacbd \uc7ac\uad6c\uc131", url: "#ar-vr-3d", children: [
              {title: "\uc2e4\uc2dc\uac04 3D \ub370\uc774\ud130 \uc218\uc9d1 \ubc0f \ud544\ud130\ub9c1", url: "#3d" },
              {title: "3D \ud658\uacbd \uc7ac\uad6c\uc131", url: "#3d_1" },
          ]},
          {title: "\uc758\ub8cc \uc601\uc0c1 \ucc98\ub9ac\uc5d0\uc11c\uc758 3D \uc7ac\uad6c\uc131", url: "#3d_2", children: [
              {title: "\ub370\uc774\ud130 \uc804\ucc98\ub9ac \ubc0f \ud544\ud130\ub9c1", url: "#_3" },
              {title: "3D \uc7ac\uad6c\uc131 \ubc0f \ubaa8\ub378\ub9c1", url: "#3d_3" },
              {title: "3D \ubaa8\ub378\uc758 \uc815\ud569\uacfc \ubd84\uc11d", url: "#3d_4" },
          ]},
          {title: "\uc790\uc728 \uc8fc\ud589\ucc28\uc5d0\uc11c\uc758 \uc2e4\uc2dc\uac04 \uacbd\ub85c \uacc4\ud68d", url: "#_4", children: [
              {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc\ub97c \uc774\uc6a9\ud55c \ud658\uacbd \uc778\uc2dd", url: "#_5" },
              {title: "\uacbd\ub85c \uacc4\ud68d \uc54c\uace0\ub9ac\uc998", url: "#_6" },
              {title: "\uc2e4\uc2dc\uac04 \uacbd\ub85c \uc7ac\uacc4\ud68d", url: "#_7" },
          ]},
          {title: "\ub85c\ubd07 \ub9e4\ub2c8\ud4f0\ub808\uc774\ud130\ub97c \uc704\ud55c \ud658\uacbd \uc778\uc2dd \ubc0f \uacbd\ub85c \uacc4\ud68d", url: "#_8", children: [
              {title: "\ub9e4\ub2c8\ud4f0\ub808\uc774\ud130\uc758 \ud658\uacbd \uc778\uc2dd", url: "#_9" },
              {title: "\uacbd\ub85c \uacc4\ud68d", url: "#_10" },
              {title: "\ub9e4\ub2c8\ud4f0\ub808\uc774\ud130\uc758 \uc801\uc6a9 \uc0ac\ub840", url: "#_11" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../../gnss/01_preface_ko/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../../gnss/01_preface_ko/" class="btn btn-xs btn-link">
        소개
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../3004/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../3004/" class="btn btn-xs btn-link">
        오픈소스 커뮤니티와의 협업 방법
      </a>
    </div>
    
  </div>

    

    <p>PCL(Point Cloud Library)은 다양한 포인트 클라우드 처리 프로젝트에 활용되며, 그 적용 범위는 산업 자동화부터 로봇 공학, 자율 주행차, AR/VR, 의료 영상 처리에 이르기까지 매우 광범위하다. 이 주제에서는 PCL을 기반으로 한 실제 프로젝트 사례들을 통해, PCL의 유연성과 강력한 기능을 분석하고, 각 프로젝트에서 구현된 맞춤형 모듈과 알고리즘에 대해 논의할 것이다.</p>
<h3 id="_1">자율 주행 차량을 위한 장애물 감지 프로젝트</h3>
<p>PCL은 자율 주행 차량의 장애물 감지와 회피 시스템 개발에 널리 사용되고 있다. 이 시스템은 라이다(LiDAR) 또는 스테레오 카메라로 수집된 포인트 클라우드를 실시간으로 처리하여 주변 환경을 분석한다. 여기에서 중요한 단계는 포인트 클라우드 데이터의 전처리, 군집화, 그리고 장애물의 식별이다.</p>
<p>장애물 감지 알고리즘은 다음과 같은 단계로 진행된다:</p>
<ol>
<li>
<p><strong>전처리</strong>: 라이다 센서로부터 얻은 포인트 클라우드 데이터에는 노이즈가 포함되어 있을 수 있다. 이를 필터링하여 불필요한 데이터를 제거하는 것이 필수적이다. 여기에는 바닥 평면 제거, 이상치 탐지 등이 포함된다. 바닥 평면 제거는 RANSAC 알고리즘을 활용하여 포인트 클라우드에서 평면을 탐지하고 제거하는 방식으로 이루어진다. </p>
</li>
<li>
<p><strong>클러스터링</strong>: 장애물 식별을 위해서는 포인트 클라우드에서 독립적인 객체를 분리해야 한다. 이를 위해 PCL의 <strong>Euclidean Cluster Extraction</strong> 알고리즘이 주로 사용된다. 이 알고리즘은 인접한 포인트들 간의 거리를 기준으로 군집을 형성하고, 이 군집을 하나의 객체로 인식한다. 객체 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}_i</span><script type="math/tex">\mathbf{O}_i</script></span>는 다음과 같이 정의된다:</p>
</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{O}_i = \left\{ \mathbf{p}_j \in \mathbb{R}^3 \ | \ \|\mathbf{p}_j - \mathbf{p}_k\| &lt; \epsilon \right\}, \quad \forall \mathbf{p}_k \in \mathbf{O}_i
</div>
<script type="math/tex; mode=display">
   \mathbf{O}_i = \left\{ \mathbf{p}_j \in \mathbb{R}^3 \ | \ \|\mathbf{p}_j - \mathbf{p}_k\| < \epsilon \right\}, \quad \forall \mathbf{p}_k \in \mathbf{O}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span>는 포인트 클라우드의 한 점을 의미하고, <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>은 두 점 사이의 거리 기준이다.</p>
<ol>
<li><strong>장애물 크기 계산</strong>: 클러스터링이 완료된 후 각 객체의 크기를 계산해야 한다. 각 객체는 포인트들의 집합으로 이루어져 있으며, 이를 바탕으로 객체의 최소 경계 상자를 계산한다. 객체 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}_i</span><script type="math/tex">\mathbf{O}_i</script></span>의 크기는 경계 상자의 직경으로 표현될 수 있다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   D(\mathbf{O}_i) = \max_{\mathbf{p}_j, \mathbf{p}_k \in \mathbf{O}_i} \|\mathbf{p}_j - \mathbf{p}_k\|
</div>
<script type="math/tex; mode=display">
   D(\mathbf{O}_i) = \max_{\mathbf{p}_j, \mathbf{p}_k \in \mathbf{O}_i} \|\mathbf{p}_j - \mathbf{p}_k\|
</script>
</div>
<p>이 값은 객체의 물리적 크기를 대략적으로 측정하는 데 사용된다.</p>
<h3 id="_2">산업 자동화를 위한 품질 검사 시스템</h3>
<p>PCL을 이용하여 개발된 또 다른 프로젝트 사례는 제조 공정에서의 품질 검사 시스템이다. 이 시스템은 3D 스캐너로 수집한 포인트 클라우드 데이터를 분석하여 제품의 결함을 감지한다. 일반적으로 다음과 같은 단계를 거친다:</p>
<ol>
<li><strong>포인트 클라우드 정합</strong>: 여러 각도에서 스캔된 데이터는 서로 다른 좌표계에 존재하므로, 이를 동일한 좌표계로 정합하는 과정이 필요하다. PCL에서는 <strong>Iterative Closest Point (ICP)</strong> 알고리즘을 사용하여 두 포인트 클라우드 간의 정합을 수행한다. ICP 알고리즘은 다음과 같이 작동한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{T}_{k+1} = \arg\min_{\mathbf{T}} \sum_{i=1}^{N} \|\mathbf{T} \mathbf{p}_i - \mathbf{q}_i\|^2
</div>
<script type="math/tex; mode=display">
   \mathbf{T}_{k+1} = \arg\min_{\mathbf{T}} \sum_{i=1}^{N} \|\mathbf{T} \mathbf{p}_i - \mathbf{q}_i\|^2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span>는 변환 행렬이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 기준 포인트 클라우드의 점, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_i</span><script type="math/tex">\mathbf{q}_i</script></span>는 이동 포인트 클라우드의 대응점이다.</p>
<ol>
<li><strong>결함 탐지</strong>: 정합이 완료된 후, 예상된 3D 모델과 실제 스캔된 데이터 간의 차이를 분석하여 결함을 감지할 수 있다. 이 과정에서 각 포인트의 오차를 계산하는데, 오차는 두 점 사이의 거리에 기반하여 다음과 같이 정의된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   e_i = \|\mathbf{p}_i - \mathbf{q}_i\|
</div>
<script type="math/tex; mode=display">
   e_i = \|\mathbf{p}_i - \mathbf{q}_i\|
</script>
</div>
<p>이 값이 설정된 임계값을 초과하면 결함이 있다고 판단한다.</p>
<h3 id="ar-vr-3d">증강 현실(AR)과 가상 현실(VR)에서의 3D 환경 재구성</h3>
<p>PCL을 활용한 또 다른 프로젝트 사례는 증강 현실(AR)과 가상 현실(VR) 시스템에서의 3D 환경 재구성이다. 이러한 시스템은 현실 세계의 3D 데이터를 실시간으로 수집하고 이를 기반으로 가상 공간에서 시각화하거나 상호작용을 제공한다. PCL은 이 과정에서 실시간 포인트 클라우드 처리 및 매칭에 중요한 역할을 한다.</p>
<h4 id="3d">실시간 3D 데이터 수집 및 필터링</h4>
<p>AR/VR 환경에서 사용되는 포인트 클라우드는 라이다(LiDAR), RGB-D 카메라, 또는 스테레오 비전을 통해 실시간으로 수집된다. 이 과정에서 수집된 데이터는 노이즈가 포함될 수 있으며, 이를 실시간으로 필터링하고 정리하는 것이 필요하다. 다음과 같은 주요 필터링 기법들이 사용된다:</p>
<ol>
<li><strong>Voxel Grid 필터</strong>: 포인트 클라우드의 밀도를 줄이면서도 중요한 형상을 보존하기 위해, <strong>Voxel Grid 필터</strong>가 자주 사용된다. 이 필터는 포인트 클라우드 데이터를 3D 그리드 상에서 작은 셀로 나누고, 각 셀 내에서 대표 포인트를 하나 선택한다. 이는 데이터를 간결하게 만들고 실시간 처리 성능을 향상시키는 데 도움을 준다. 각 셀의 대표 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_v</span><script type="math/tex">\mathbf{p}_v</script></span>는 셀 내 모든 포인트들의 평균으로 계산된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{p}_v = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</div>
<script type="math/tex; mode=display">
   \mathbf{p}_v = \frac{1}{N} \sum_{i=1}^{N} \mathbf{p}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 셀 내의 포인트, <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 셀 내 포인트의 개수이다.</p>
<ol>
<li><strong>Statistical Outlier Removal 필터</strong>: 노이즈를 제거하기 위해 <strong>Statistical Outlier Removal (SOR)</strong> 필터가 사용된다. 이 필터는 각 포인트의 근처에 있는 다른 포인트들과의 거리를 분석하여, 평균 거리에서 크게 벗어나는 포인트를 제거한다. 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해 근처 포인트들과의 평균 거리 <span class="arithmatex"><span class="MathJax_Preview">\mu_i</span><script type="math/tex">\mu_i</script></span>가 주어졌을 때, 다음과 같은 조건을 만족하는 포인트는 이상치로 간주된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mu_i &gt; \mu_{\text{global}} + k \cdot \sigma_{\text{global}}
</div>
<script type="math/tex; mode=display">
   \mu_i > \mu_{\text{global}} + k \cdot \sigma_{\text{global}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mu_{\text{global}}</span><script type="math/tex">\mu_{\text{global}}</script></span>은 전체 포인트 클라우드의 평균 거리, <span class="arithmatex"><span class="MathJax_Preview">\sigma_{\text{global}}</span><script type="math/tex">\sigma_{\text{global}}</script></span>은 표준 편차, <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>는 임계값 계수이다.</p>
<h4 id="3d_1">3D 환경 재구성</h4>
<p>필터링된 포인트 클라우드는 다양한 방법으로 재구성된다. 재구성의 목적은 현실 세계를 가상 환경에서 정확하게 표현하거나, 사용자와의 상호작용을 가능하게 하는 것이다. 재구성은 다음과 같은 방식으로 이루어진다:</p>
<ol>
<li><strong>포인트 클라우드 기반의 표면 생성</strong>: 포인트 클라우드로부터 직접적으로 표면을 생성하기 위해 <strong>Marching Cubes 알고리즘</strong>이 사용된다. 이 알고리즘은 3D 스칼라 필드에서 등치선을 추출하여, 포인트 클라우드 데이터에 기반한 메시를 생성한다. 이를 통해 포인트 클라우드의 점들이 하나의 연속된 표면으로 변환된다. 메시 생성 후, 각 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대한 면적 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_i</span><script type="math/tex">\mathbf{A}_i</script></span>는 다음과 같이 정의될 수 있다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{A}_i = \sum_{j=1}^{M} \mathbf{A}_{ij}, \quad \mathbf{A}_{ij} = \frac{1}{2} \|\mathbf{p}_i \times \mathbf{p}_j\|
</div>
<script type="math/tex; mode=display">
   \mathbf{A}_i = \sum_{j=1}^{M} \mathbf{A}_{ij}, \quad \mathbf{A}_{ij} = \frac{1}{2} \|\mathbf{p}_i \times \mathbf{p}_j\|
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>은 해당 점에 연결된 삼각형의 수이다.</p>
<ol>
<li><strong>다중 뷰 포인트 클라우드 정합</strong>: 여러 센서 또는 여러 각도에서 수집된 포인트 클라우드 데이터를 정합하여 하나의 통합된 3D 모델을 생성한다. 여기에는 <strong>Generalized-ICP (G-ICP)</strong> 알고리즘이 사용되며, 이 알고리즘은 각 포인트의 위치뿐만 아니라 그 주변의 기하학적 특성도 반영하여 정합 성능을 향상시킨다. G-ICP는 다음의 최적화 문제로 정의된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{T} = \arg\min_{\mathbf{T}} \sum_{i=1}^{N} \mathbf{R}_i^T \mathbf{C}_i^{-1} \mathbf{R}_i
</div>
<script type="math/tex; mode=display">
   \mathbf{T} = \arg\min_{\mathbf{T}} \sum_{i=1}^{N} \mathbf{R}_i^T \mathbf{C}_i^{-1} \mathbf{R}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_i</span><script type="math/tex">\mathbf{R}_i</script></span>는 포인트 간의 잔여 벡터, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}_i</span><script type="math/tex">\mathbf{C}_i</script></span>는 공분산 행렬이다.</p>
<ol>
<li><strong>메시의 후처리 및 스무딩</strong>: 생성된 메시는 종종 거친 표면을 가지게 되는데, 이를 부드럽게 하기 위해 <strong>Laplacian Smoothing</strong> 또는 <strong>Bilateral Filtering</strong>과 같은 기법이 사용된다. 이러한 스무딩 기법은 메시의 구조를 보존하면서 노이즈를 감소시키는 역할을 한다. Laplacian Smoothing은 각 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해 이웃한 점들의 평균으로 점의 위치를 업데이트하는 방식으로 작동한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{p}_i' = \frac{1}{N} \sum_{j \in \text{neigh}(\mathbf{p}_i)} \mathbf{p}_j
</div>
<script type="math/tex; mode=display">
   \mathbf{p}_i' = \frac{1}{N} \sum_{j \in \text{neigh}(\mathbf{p}_i)} \mathbf{p}_j
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\text{neigh}(\mathbf{p}_i)</span><script type="math/tex">\text{neigh}(\mathbf{p}_i)</script></span>는 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 이웃 점들의 집합이다.</p>
<h3 id="3d_2">의료 영상 처리에서의 3D 재구성</h3>
<p>PCL을 활용한 또 다른 중요한 프로젝트 사례는 의료 영상 처리 분야에서의 3D 재구성이다. 의료 이미징 기술은 CT(Computed Tomography), MRI(Magnetic Resonance Imaging)와 같은 기술을 통해 인체 내부의 3D 구조를 스캔하고, 이 데이터를 이용해 다양한 진단 및 치료 계획을 수립할 수 있다. 이 과정에서 PCL을 이용해 환자의 3D 모델을 생성하고 분석할 수 있다.</p>
<h4 id="_3">데이터 전처리 및 필터링</h4>
<p>의료 영상 데이터는 대개 노이즈와 아티팩트가 포함되어 있기 때문에, 이를 정리하고 재구성하기 위한 전처리 과정이 필요하다. 이 과정에서는 주로 다음과 같은 필터링 기법이 사용된다:</p>
<ol>
<li><strong>Gaussian 필터</strong>: 의료 이미지의 노이즈를 제거하기 위해 Gaussian 필터가 자주 사용된다. Gaussian 필터는 각 포인트의 주변 값을 Gaussian 함수로 가중하여 평활화하는 방식이다. 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 새로운 값 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i'</span><script type="math/tex">\mathbf{p}_i'</script></span>는 다음과 같이 계산된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{p}_i' = \frac{1}{W} \sum_{j=1}^{N} \mathbf{p}_j e^{-\frac{\|\mathbf{p}_i - \mathbf{p}_j\|^2}{2\sigma^2}}
</div>
<script type="math/tex; mode=display">
   \mathbf{p}_i' = \frac{1}{W} \sum_{j=1}^{N} \mathbf{p}_j e^{-\frac{\|\mathbf{p}_i - \mathbf{p}_j\|^2}{2\sigma^2}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>는 Gaussian 필터의 표준 편차이고, <span class="arithmatex"><span class="MathJax_Preview">W</span><script type="math/tex">W</script></span>는 정규화 상수이다.</p>
<ol>
<li><strong>Bilateral 필터</strong>: 이 필터는 Gaussian 필터와 유사하지만, 공간적 거리뿐만 아니라 포인트의 값 차이도 고려하여 필터링한다. 따라서 경계선이 뚜렷한 구조를 보존하면서 노이즈를 제거할 수 있다. Bilateral 필터는 다음과 같이 정의된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{p}_i' = \frac{1}{W} \sum_{j=1}^{N} \mathbf{p}_j e^{-\frac{\|\mathbf{p}_i - \mathbf{p}_j\|^2}{2\sigma_s^2}} e^{-\frac{|I(\mathbf{p}_i) - I(\mathbf{p}_j)|^2}{2\sigma_r^2}}
</div>
<script type="math/tex; mode=display">
   \mathbf{p}_i' = \frac{1}{W} \sum_{j=1}^{N} \mathbf{p}_j e^{-\frac{\|\mathbf{p}_i - \mathbf{p}_j\|^2}{2\sigma_s^2}} e^{-\frac{|I(\mathbf{p}_i) - I(\mathbf{p}_j)|^2}{2\sigma_r^2}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">I(\mathbf{p}_i)</span><script type="math/tex">I(\mathbf{p}_i)</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 값, <span class="arithmatex"><span class="MathJax_Preview">\sigma_s</span><script type="math/tex">\sigma_s</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\sigma_r</span><script type="math/tex">\sigma_r</script></span>는 각각 공간적 거리와 값 차이에 대한 가중치이다.</p>
<h4 id="3d_3">3D 재구성 및 모델링</h4>
<p>의료 영상 데이터를 3D 모델로 변환하기 위해 포인트 클라우드를 이용한 재구성 기법이 많이 활용된다. 특히 PCL은 다양한 의료 영상 처리 프로젝트에서 3D 재구성의 핵심 역할을 하고 있다. 3D 재구성의 주요 과정은 다음과 같다:</p>
<ol>
<li>
<p><strong>Segmentation(분할)</strong>: 영상 데이터에서 관심 있는 부분만을 추출하기 위해 분할 과정이 필요하다. 의료 영상의 경우, 장기나 특정 조직의 경계를 찾아내는 것이 매우 중요하다. PCL에서는 <strong>Region Growing Segmentation</strong> 또는 <strong>Conditional Euclidean Clustering</strong> 기법을 이용하여 포인트 클라우드를 분할할 수 있다. 예를 들어, 조건부 유클리드 클러스터링은 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>에 대해 인접 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span>와의 거리 <span class="arithmatex"><span class="MathJax_Preview">\|\mathbf{p}_i - \mathbf{p}_j\|</span><script type="math/tex">\|\mathbf{p}_i - \mathbf{p}_j\|</script></span>를 측정하고, 특정 조건을 만족하는 포인트들끼리 클러스터링한다.</p>
</li>
<li>
<p><strong>포인트 클라우드에서의 메시 생성</strong>: 포인트 클라우드로부터 메시를 생성하여 3D 모델을 구성하는 과정은 <strong>Delaunay Triangulation</strong>이나 <strong>Poisson Surface Reconstruction</strong>과 같은 기법을 통해 이루어진다. PCL은 이러한 재구성 과정을 자동화하고 효율적으로 처리할 수 있는 기능을 제공한다. 메시 생성 과정에서 각 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>는 다음과 같이 삼각형으로 연결된다:</p>
</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{T}_i = \{\mathbf{p}_i, \mathbf{p}_j, \mathbf{p}_k\}, \quad \mathbf{p}_i, \mathbf{p}_j, \mathbf{p}_k \in \mathbb{R}^3
</div>
<script type="math/tex; mode=display">
   \mathbf{T}_i = \{\mathbf{p}_i, \mathbf{p}_j, \mathbf{p}_k\}, \quad \mathbf{p}_i, \mathbf{p}_j, \mathbf{p}_k \in \mathbb{R}^3
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_i</span><script type="math/tex">\mathbf{T}_i</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>를 포함하는 삼각형이다.</p>
<ol>
<li><strong>볼륨 렌더링</strong>: 포인트 클라우드를 이용한 3D 모델은 볼륨 렌더링을 통해 시각화된다. 이 과정에서 각 포인트에 대한 색상 및 투명도가 할당되며, 이를 통해 내부 구조를 시각적으로 탐색할 수 있다. 특히, 의료 영상에서 특정 조직이나 장기의 경계선을 명확하게 보기 위해 볼륨 렌더링이 효과적으로 사용된다.</li>
</ol>
<h4 id="3d_4">3D 모델의 정합과 분석</h4>
<p>의료 영상에서 수집한 다중 뷰 포인트 클라우드를 정합하여 하나의 통합된 모델을 생성하는 과정은 매우 중요하다. 이를 위해 PCL의 <strong>Generalized Iterative Closest Point (GICP)</strong> 알고리즘이 사용된다. 이 알고리즘은 포인트 간의 위치와 기하학적 특성을 동시에 고려하여 정합 성능을 최적화한다. 두 포인트 클라우드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_1</span><script type="math/tex">\mathbf{P}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_2</span><script type="math/tex">\mathbf{P}_2</script></span> 간의 최적 정합은 다음과 같은 최소화 문제로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{T}^* = \arg\min_{\mathbf{T}} \sum_{i=1}^{N} \left\| \mathbf{T} \mathbf{p}_i^{(1)} - \mathbf{p}_i^{(2)} \right\|^2
</div>
<script type="math/tex; mode=display">
   \mathbf{T}^* = \arg\min_{\mathbf{T}} \sum_{i=1}^{N} \left\| \mathbf{T} \mathbf{p}_i^{(1)} - \mathbf{p}_i^{(2)} \right\|^2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span>는 변환 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i^{(1)}</span><script type="math/tex">\mathbf{p}_i^{(1)}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i^{(2)}</span><script type="math/tex">\mathbf{p}_i^{(2)}</script></span>는 두 포인트 클라우드에서 대응하는 점들이다.</p>
<h3 id="_4">자율 주행차에서의 실시간 경로 계획</h3>
<p>PCL을 활용한 자율 주행차 프로젝트에서 중요한 역할을 하는 것은 실시간 경로 계획이다. 경로 계획 시스템은 자율 주행차가 실시간으로 주변 환경을 인식하고, 장애물을 피하면서 목적지까지 안전하게 이동할 수 있도록 한다. 이 시스템에서는 라이다(LiDAR) 센서 또는 스테레오 카메라를 통해 수집된 포인트 클라우드 데이터를 기반으로 차량 주변의 3D 환경을 분석하고, 경로를 계획하는 과정이 이루어진다.</p>
<h4 id="_5">포인트 클라우드를 이용한 환경 인식</h4>
<p>자율 주행 차량이 실시간으로 주변 환경을 인식하기 위해서는 포인트 클라우드를 통해 얻은 데이터를 처리해야 한다. 이 과정은 보통 다음의 단계로 진행된다:</p>
<ol>
<li><strong>장애물 탐지</strong>: 라이다로부터 수집된 포인트 클라우드 데이터에서 장애물을 탐지하는 것은 자율 주행 차량의 안전에 중요한 요소이다. 장애물 탐지는 <strong>Euclidean Cluster Extraction</strong> 알고리즘을 사용하여, 포인트 클라우드를 여러 개의 클러스터로 분할하는 것으로 시작된다. 클러스터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}_i</span><script type="math/tex">\mathbf{C}_i</script></span>는 다음과 같이 정의된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{C}_i = \left\{ \mathbf{p}_j \in \mathbb{R}^3 \ | \ \|\mathbf{p}_j - \mathbf{p}_k\| &lt; \epsilon \right\}, \quad \forall \mathbf{p}_k \in \mathbf{C}_i
</div>
<script type="math/tex; mode=display">
   \mathbf{C}_i = \left\{ \mathbf{p}_j \in \mathbb{R}^3 \ | \ \|\mathbf{p}_j - \mathbf{p}_k\| < \epsilon \right\}, \quad \forall \mathbf{p}_k \in \mathbf{C}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>은 포인트들 사이의 거리 임계값으로, 서로 가까운 포인트들을 하나의 클러스터로 묶는 데 사용된다.</p>
<ol>
<li><strong>장애물의 경계 상자 계산</strong>: 클러스터링이 완료된 후, 각 클러스터에 대해 최소 경계 상자(Axis-Aligned Bounding Box, AABB)를 계산하여 장애물의 크기와 위치를 결정한다. 경계 상자는 포인트 클라우드 내에서 각 클러스터의 최솟값과 최댓값을 기준으로 정의된다. 클러스터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}_i</span><script type="math/tex">\mathbf{C}_i</script></span>의 AABB는 다음과 같이 표현될 수 있다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{AABB}_i = \left[ \min(\mathbf{p}_j), \max(\mathbf{p}_j) \right], \quad \mathbf{p}_j \in \mathbf{C}_i
</div>
<script type="math/tex; mode=display">
   \mathbf{AABB}_i = \left[ \min(\mathbf{p}_j), \max(\mathbf{p}_j) \right], \quad \mathbf{p}_j \in \mathbf{C}_i
</script>
</div>
<ol>
<li><strong>주행 가능 영역 탐지</strong>: 장애물을 피하면서 차량이 이동할 수 있는 경로를 찾기 위해, 포인트 클라우드 데이터에서 주행 가능 영역을 탐지한다. 이를 위해 <strong>Ground Plane Estimation</strong> 기법을 사용하여, 차량이 주행할 수 있는 평평한 바닥 영역을 추정한다. 바닥 평면은 RANSAC(Random Sample Consensus) 알고리즘을 통해 추정할 수 있으며, 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>가 바닥 평면에 속하는지 여부는 다음의 평면 방정식으로 결정된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   a x_i + b y_i + c z_i + d = 0
</div>
<script type="math/tex; mode=display">
   a x_i + b y_i + c z_i + d = 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>, <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>, <span class="arithmatex"><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span>, <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>는 평면의 계수들이며, <span class="arithmatex"><span class="MathJax_Preview">x_i</span><script type="math/tex">x_i</script></span>, <span class="arithmatex"><span class="MathJax_Preview">y_i</span><script type="math/tex">y_i</script></span>, <span class="arithmatex"><span class="MathJax_Preview">z_i</span><script type="math/tex">z_i</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 좌표이다.</p>
<h4 id="_6">경로 계획 알고리즘</h4>
<p>포인트 클라우드를 기반으로 장애물과 주행 가능 영역을 파악한 후에는, 차량이 목적지까지 안전하게 이동할 수 있는 경로를 계획하는 것이 중요하다. 이 과정에서 <strong>A* 알고리즘</strong>과 같은 경로 탐색 알고리즘이 자주 사용된다.</p>
<ol>
<li><strong>A* 알고리즘</strong>: A* 알고리즘은 그래프 탐색 기반 경로 계획 알고리즘으로, 시작 지점에서 목적지까지의 최적 경로를 찾는다. 이 알고리즘은 휴리스틱 함수를 사용하여 각 경로의 비용을 계산하고, 가장 비용이 적은 경로를 선택한다. 각 경로 <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>의 총 비용 <span class="arithmatex"><span class="MathJax_Preview">f(P)</span><script type="math/tex">f(P)</script></span>는 다음과 같이 정의된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   f(P) = g(P) + h(P)
</div>
<script type="math/tex; mode=display">
   f(P) = g(P) + h(P)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">g(P)</span><script type="math/tex">g(P)</script></span>는 시작 지점에서 해당 경로까지의 실제 비용, <span class="arithmatex"><span class="MathJax_Preview">h(P)</span><script type="math/tex">h(P)</script></span>는 해당 경로에서 목적지까지의 예상 비용(휴리스틱 값)이다.</p>
<ol>
<li><strong>RRT (Rapidly-exploring Random Tree)</strong>: RRT 알고리즘은 자율 주행 차량의 실시간 경로 계획에 자주 사용되는 또 다른 방법이다. 이 알고리즘은 무작위로 탐색 공간을 확장하면서 빠르게 경로를 탐색하며, 특히 복잡한 환경에서 효과적이다. RRT 알고리즘은 다음과 같은 방식으로 작동한다:</li>
<li>시작 지점에서 출발하여 무작위로 선택된 방향으로 나아간다.</li>
<li>장애물이 없는 방향으로 이동하면서 탐색 트리를 확장한다.</li>
<li>목적지에 도달할 때까지 탐색을 반복한다.</li>
</ol>
<p>RRT 알고리즘의 탐색 과정에서 각 탐색 노드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_i</span><script type="math/tex">\mathbf{n}_i</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 위치와 탐색 방향 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_i</span><script type="math/tex">\mathbf{d}_i</script></span>에 따라 확장되며, 트리는 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{T} = \{ \mathbf{n}_i \ | \mathbf{n}_i = (\mathbf{p}_i, \mathbf{d}_i) \}
</div>
<script type="math/tex; mode=display">
   \mathbf{T} = \{ \mathbf{n}_i \ | \mathbf{n}_i = (\mathbf{p}_i, \mathbf{d}_i) \}
</script>
</div>
<h4 id="_7">실시간 경로 재계획</h4>
<p>주행 도중, 예상하지 못한 장애물이나 도로 상황의 변화가 발생할 수 있기 때문에, 실시간 경로 재계획이 필수적이다. 이를 위해 PCL을 기반으로 한 실시간 포인트 클라우드 처리를 통해 차량이 끊임없이 주변 환경을 분석하고 새로운 경로를 계획한다.</p>
<ol>
<li>
<p><strong>Dynamic Replanning</strong>: 장애물이 갑작스럽게 나타나거나 도로 상황이 변경될 경우, 경로를 즉시 재계획해야 한다. 이를 위해 차량은 주기적으로 라이다 데이터를 수집하고, 최신 포인트 클라우드를 분석하여 새로운 경로를 탐색한다. A* 또는 RRT 알고리즘을 반복 실행하여, 최적의 경로를 실시간으로 계산한다.</p>
</li>
<li>
<p><strong>Collision Avoidance</strong>: 차량의 경로 상에 장애물이 나타날 경우, 충돌을 피하기 위해 경로를 수정하거나 정지할 수 있어야 한다. 이를 위해 포인트 클라우드에서 탐지된 장애물의 위치와 크기를 실시간으로 추적하고, 충돌이 예상되는 경우 경로를 수정하여 회피 경로를 계획한다.</p>
</li>
</ol>
<h3 id="_8">로봇 매니퓰레이터를 위한 환경 인식 및 경로 계획</h3>
<p>PCL은 로봇 매니퓰레이터(manipulator)가 환경을 인식하고 복잡한 작업을 수행하는 데 중요한 도구로 사용된다. 로봇 매니퓰레이터는 다양한 환경에서 물체를 집거나 조작할 수 있으며, 이를 위해서는 포인트 클라우드를 활용한 정확한 환경 인식과 경로 계획이 필요하다. 이 프로젝트 사례에서는 로봇이 주변 환경을 인식하고, 효율적인 경로를 계획하는 방법을 다룬다.</p>
<h4 id="_9">매니퓰레이터의 환경 인식</h4>
<p>로봇 매니퓰레이터가 작업을 수행하기 위해서는 작업 환경에 대한 정확한 3D 데이터를 인식하는 것이 중요하다. 이를 위해 포인트 클라우드 데이터가 사용되며, PCL의 다양한 기능을 통해 환경을 분석한다.</p>
<ol>
<li><strong>객체 탐지 및 분할</strong>: 로봇이 조작할 물체를 탐지하기 위해서는 포인트 클라우드에서 객체를 분할하는 작업이 필요하다. PCL에서는 <strong>Euclidean Cluster Extraction</strong> 알고리즘을 사용하여 인접한 포인트를 군집화하고 객체를 분리할 수 있다. 객체 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}_i</span><script type="math/tex">\mathbf{O}_i</script></span>는 다음과 같이 정의된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{O}_i = \left\{ \mathbf{p}_j \in \mathbb{R}^3 \ | \ \|\mathbf{p}_j - \mathbf{p}_k\| &lt; \epsilon \right\}, \quad \forall \mathbf{p}_k \in \mathbf{O}_i
</div>
<script type="math/tex; mode=display">
   \mathbf{O}_i = \left\{ \mathbf{p}_j \in \mathbb{R}^3 \ | \ \|\mathbf{p}_j - \mathbf{p}_k\| < \epsilon \right\}, \quad \forall \mathbf{p}_k \in \mathbf{O}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>은 군집을 형성하는 포인트 간의 최대 거리이다.</p>
<ol>
<li><strong>표면 추정</strong>: 로봇이 물체를 정확하게 잡기 위해서는 물체 표면의 기하학적 정보를 추정해야 한다. PCL에서는 <strong>Normal Estimation</strong> 알고리즘을 통해 각 포인트의 표면 법선 벡터를 계산한다. 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_i</span><script type="math/tex">\mathbf{n}_i</script></span>는 주어진 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 주변 포인트들과의 관계를 기반으로 계산되며, 다음과 같이 표현된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{n}_i = \frac{\mathbf{p}_i \times \mathbf{p}_j}{\|\mathbf{p}_i \times \mathbf{p}_j\|}
</div>
<script type="math/tex; mode=display">
   \mathbf{n}_i = \frac{\mathbf{p}_i \times \mathbf{p}_j}{\|\mathbf{p}_i \times \mathbf{p}_j\|}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span>는 포인트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>의 이웃 포인트들이다.</p>
<ol>
<li><strong>그리핑 지점 탐색</strong>: 매니퓰레이터가 물체를 안정적으로 잡기 위해서는 그리핑 지점(Grasp Point)을 찾아야 한다. 이를 위해 물체의 표면 법선과 포인트 간의 기하학적 관계를 분석하여 그리핑에 적합한 지점을 선택할 수 있다. 그리핑 지점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{g}_i</span><script type="math/tex">\mathbf{g}_i</script></span>는 물체의 표면에서 접촉이 가능한 영역을 나타내며, 다음과 같은 조건을 만족해야 한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{n}_i \cdot \mathbf{f}_\text{grip} &gt; 0
</div>
<script type="math/tex; mode=display">
   \mathbf{n}_i \cdot \mathbf{f}_\text{grip} > 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_i</span><script type="math/tex">\mathbf{n}_i</script></span>는 표면의 법선 벡터, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}_\text{grip}</span><script type="math/tex">\mathbf{f}_\text{grip}</script></span>는 그리핑 시의 힘 벡터이다.</p>
<h4 id="_10">경로 계획</h4>
<p>로봇 매니퓰레이터가 물체를 안전하게 잡고, 원하는 위치로 이동하기 위해서는 적절한 경로를 계획하는 과정이 필요하다. 경로 계획 알고리즘은 매니퓰레이터가 장애물에 부딪치지 않고 작업을 수행할 수 있도록 경로를 계산한다.</p>
<ol>
<li><strong>Inverse Kinematics (역운동학)</strong>: 매니퓰레이터의 경로 계획에서 중요한 부분은 목표 위치에 도달하기 위한 조인트 각도를 계산하는 것이다. 이를 위해 역운동학(Inverse Kinematics, IK)이 사용되며, 이는 매니퓰레이터의 각 조인트가 특정 위치에 도달하기 위한 각도 값을 계산하는 과정이다. 로봇의 말단 포즈 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_{end}</span><script type="math/tex">\mathbf{T}_{end}</script></span>는 다음과 같은 변환 행렬로 표현된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{T}_{end} = \mathbf{T}_1 \mathbf{T}_2 \cdots \mathbf{T}_n
</div>
<script type="math/tex; mode=display">
   \mathbf{T}_{end} = \mathbf{T}_1 \mathbf{T}_2 \cdots \mathbf{T}_n
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_i</span><script type="math/tex">\mathbf{T}_i</script></span>는 각 조인트의 변환 행렬이다.</p>
<ol>
<li><strong>RRT (Rapidly-exploring Random Tree)</strong>: 로봇 매니퓰레이터의 복잡한 환경에서 경로를 탐색하기 위해, <strong>RRT</strong> 알고리즘이 사용될 수 있다. 이 알고리즘은 로봇의 작업 공간에서 무작위로 샘플링하여 빠르게 경로를 탐색한다. RRT는 작업 공간에서 새로운 노드를 확장하고, 노드 간 연결을 통해 최적 경로를 찾는다. 경로 탐색 과정에서, 각 노드 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}_i</span><script type="math/tex">\mathbf{n}_i</script></span>는 매니퓰레이터의 특정 위치를 나타내며, 노드 간 연결은 다음과 같은 거리 함수로 결정된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   d(\mathbf{n}_i, \mathbf{n}_j) = \|\mathbf{n}_i - \mathbf{n}_j\|
</div>
<script type="math/tex; mode=display">
   d(\mathbf{n}_i, \mathbf{n}_j) = \|\mathbf{n}_i - \mathbf{n}_j\|
</script>
</div>
<ol>
<li><strong>Collision Detection</strong>: 경로 계획 과정에서 중요한 요소는 로봇이 이동하는 동안 장애물과 충돌하지 않도록 경로를 생성하는 것이다. 이를 위해 실시간 충돌 감지 시스템이 필요하며, 포인트 클라우드를 활용한 충돌 감지 알고리즘이 사용된다. 충돌 여부는 로봇의 각 조인트 위치와 장애물 사이의 거리로 판단된다. 두 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_i</span><script type="math/tex">\mathbf{p}_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_j</span><script type="math/tex">\mathbf{p}_j</script></span> 간의 거리가 최소 안전 거리 <span class="arithmatex"><span class="MathJax_Preview">d_\text{safe}</span><script type="math/tex">d_\text{safe}</script></span>보다 작으면 충돌로 간주한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   d(\mathbf{p}_i, \mathbf{p}_j) &lt; d_\text{safe}
</div>
<script type="math/tex; mode=display">
   d(\mathbf{p}_i, \mathbf{p}_j) < d_\text{safe}
</script>
</div>
<ol>
<li><strong>실시간 경로 수정</strong>: 작업 중 환경이 변하거나 예상치 못한 장애물이 발생할 경우, 매니퓰레이터는 경로를 즉시 수정해야 한다. 이를 위해 실시간 포인트 클라우드 처리를 통해 환경 변화를 감지하고, 새로운 경로를 계산한다. A* 또는 RRT 알고리즘을 반복적으로 실행하여 새로운 경로를 탐색하며, 매니퓰레이터는 즉시 경로를 수정하여 작업을 지속할 수 있다.</li>
</ol>
<h4 id="_11">매니퓰레이터의 적용 사례</h4>
<p>로봇 매니퓰레이터는 제조 공정, 물류 자동화, 수술 로봇 등 다양한 분야에서 활용되고 있다. PCL을 기반으로 한 실시간 환경 인식과 경로 계획은 이러한 응용 사례에서 필수적인 요소로 자리 잡고 있으며, 특히 복잡한 환경에서의 정밀 작업을 수행하는 데 중요한 역할을 한다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../../../gnss/01_preface_ko/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../../../gnss/01_preface_ko/" class="btn btn-xs btn-link">
        소개
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../3004/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../3004/" class="btn btn-xs btn-link">
        오픈소스 커뮤니티와의 협업 방법
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>