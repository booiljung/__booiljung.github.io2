<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/sensor_data_processing/__pointcloud/introduction_to_pointcloud/chapter_02/0203/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>PCL 설치 및 환경 설정 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "PCL \uc124\uce58", url: "#_top", children: [
              {title: "Ubuntu\uc5d0\uc11c PCL \uc124\uce58", url: "#ubuntu-pcl" },
              {title: "Windows\uc5d0\uc11c PCL \uc124\uce58", url: "#windows-pcl" },
          ]},
          {title: "PCL \ud658\uacbd \uc124\uc815", url: "#pcl_1", children: [
              {title: "CMake \ud504\ub85c\uc81d\ud2b8 \uc124\uc815", url: "#cmake" },
              {title: "\ud658\uacbd \ubcc0\uc218 \uc124\uc815", url: "#_1" },
              {title: "PCL \ud14c\uc2a4\ud2b8 \ud504\ub85c\uadf8\ub7a8", url: "#pcl_2" },
          ]},
          {title: "PCL \uc124\uce58 \uc2dc \uc720\uc758\uc0ac\ud56d", url: "#pcl_3", children: [
              {title: "Ubuntu\uc5d0\uc11c\uc758 \uc758\uc874\uc131 \ubb38\uc81c \ud574\uacb0", url: "#ubuntu" },
              {title: "Windows\uc5d0\uc11c\uc758 Visual Studio\uc640 CMake \uc124\uc815", url: "#windows-visual-studio-cmake" },
          ]},
          {title: "C++\uc5d0\uc11c PCL \uc0ac\uc6a9 \uc608\uc81c", url: "#c-pcl", children: [
              {title: "\ud3ec\uc778\ud2b8\ud074\ub77c\uc6b0\ub4dc \ud30c\uc77c \ubd88\ub7ec\uc624\uae30", url: "#_2" },
              {title: "\ud3ec\uc778\ud2b8\ud074\ub77c\uc6b0\ub4dc \ubcc0\ud658", url: "#_3" },
          ]},
          {title: "PCL\uc5d0\uc11c\uc758 \ud544\ud130\ub9c1", url: "#pcl_4", children: [
              {title: "Voxel Grid \ud544\ud130", url: "#voxel-grid" },
              {title: "PassThrough \ud544\ud130", url: "#passthrough" },
              {title: "Statistical Outlier Removal (SOR) \ud544\ud130", url: "#statistical-outlier-removal-sor" },
          ]},
          {title: "Radius Outlier Removal \ud544\ud130", url: "#radius-outlier-removal", children: [
          ]},
          {title: "PCL\uc5d0\uc11c\uc758 \ud658\uacbd \uc124\uc815 \ubc0f \ube4c\ub4dc", url: "#pcl_5", children: [
              {title: "CMake\ub97c \uc0ac\uc6a9\ud55c \ube4c\ub4dc \uc124\uc815", url: "#cmake_1" },
              {title: "PCL\uacfc OpenCV \uc5f0\ub3d9", url: "#pcl-opencv" },
          ]},
          {title: "PCL \ub370\uc774\ud130 \ucc98\ub9ac \uc694\uc57d", url: "#pcl_6", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <p>PCL(Point Cloud Library)은 3D 포인트클라우드 데이터 처리에 강력한 기능을 제공하는 오픈 소스 라이브러리이다. 포인트클라우드 데이터의 필터링, 변환, 정렬, 시각화 등을 지원하며, C++을 기반으로 개발되었다. PCL을 활용하기 위해서는 먼저 설치 및 환경 설정이 필요하다.</p>
<h3 id="pcl">PCL 설치</h3>
<p>PCL을 설치하는 방법은 사용하는 운영체제에 따라 달라질 수 있다. 이 예제에서는 Ubuntu 리눅스와 Windows 환경에서의 설치 방법을 설명하겠다.</p>
<h4 id="ubuntu-pcl">Ubuntu에서 PCL 설치</h4>
<p>Ubuntu에서는 PCL을 apt 패키지 관리자를 통해 쉽게 설치할 수 있다. 아래 명령어를 사용하면 필요한 모든 의존성을 포함하여 PCL이 설치된다.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install libpcl-dev
</code></pre>
<p>이 명령어는 PCL 라이브러리와 관련된 헤더 파일, 컴파일러, 의존성 패키지를 모두 설치한다. 설치 후 PCL을 사용한 C++ 프로젝트를 구성할 수 있다.</p>
<h4 id="windows-pcl">Windows에서 PCL 설치</h4>
<p>Windows 환경에서는 PCL을 설치하기 위해 Visual Studio와 함께 사용할 수 있다. 공식 PCL 웹사이트에서 제공하는 윈도우용 설치 파일을 다운로드하여 설치할 수 있다. 그러나, 윈도우에서 PCL을 사용하기 위해서는 CMake를 사용하여 빌드하는 과정이 필요하다. 이를 위한 단계는 아래와 같다.</p>
<ol>
<li><strong>CMake 설치</strong>: <a href="https://cmake.org/download/">CMake</a>를 다운로드하고 설치한다.</li>
<li><strong>PCL 소스 코드 다운로드</strong>: <a href="https://github.com/PointCloudLibrary/pcl">PCL GitHub 저장소</a>에서 최신 소스 코드를 다운로드한다.</li>
<li><strong>빌드 환경 설정</strong>: Visual Studio와 CMake를 연동하여 PCL을 빌드한다.</li>
</ol>
<p>CMake를 통해 PCL을 빌드하기 위한 CMake 명령어 예시는 다음과 같다:</p>
<pre><code class="language-bash">mkdir build
cd build
cmake -G &quot;Visual Studio 16 2019&quot; -A x64 ..
cmake --build .
</code></pre>
<p>이 과정에서 Visual Studio 프로젝트 파일이 생성되며, 이를 통해 PCL 라이브러리를 컴파일하고 사용할 수 있게 된다.</p>
<h3 id="pcl_1">PCL 환경 설정</h3>
<p>PCL을 설치한 후, 프로젝트에서 PCL을 사용하기 위해 몇 가지 설정이 필요하다. 이 과정에서는 CMake를 통해 프로젝트 환경을 설정하는 방법을 설명하겠다.</p>
<h4 id="cmake">CMake 프로젝트 설정</h4>
<p>PCL을 사용하는 C++ 프로젝트를 설정할 때는 <code>CMakeLists.txt</code> 파일에 PCL 관련 설정을 추가해야 한다. 아래는 기본적인 <code>CMakeLists.txt</code>의 예시이다.</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.0 FATAL_ERROR)

project(pcl_example)

find_package(PCL 1.2 REQUIRED)

include_directories(${PCL_INCLUDE_DIRS})
link_directories(${PCL_LIBRARY_DIRS})
add_definitions(${PCL_DEFINITIONS})

add_executable(example example.cpp)
target_link_libraries(example ${PCL_LIBRARIES})
</code></pre>
<p>이 설정 파일은 PCL 라이브러리를 찾고, 프로젝트에서 사용할 수 있도록 연결한다. <code>find_package(PCL 1.2 REQUIRED)</code>는 최소 PCL 버전 1.2 이상이 필요하다는 것을 의미한다. <code>include_directories</code>와 <code>link_directories</code>는 PCL의 헤더 파일과 라이브러리를 프로젝트에서 사용할 수 있도록 설정하는 부분이다.</p>
<h4 id="_1">환경 변수 설정</h4>
<p>만약 프로젝트에서 PCL을 사용할 때 환경 변수가 올바르게 설정되지 않으면, 라이브러리나 헤더 파일을 찾을 수 없다는 에러가 발생할 수 있다. 이를 방지하기 위해, PCL이 설치된 경로를 환경 변수로 등록해야 한다.</p>
<p>Ubuntu에서는 <code>.bashrc</code> 파일을 수정하여 PCL 경로를 추가할 수 있다.</p>
<pre><code class="language-bash">export PCL_DIR=/usr/lib/x86_64-linux-gnu/cmake/pcl
</code></pre>
<p>Windows에서는 <code>시스템 환경 변수</code> 설정에서 PCL 경로를 추가할 수 있다.</p>
<h4 id="pcl_2">PCL 테스트 프로그램</h4>
<p>설치 및 환경 설정이 완료된 후, PCL이 제대로 작동하는지 테스트하기 위해 간단한 프로그램을 작성할 수 있다. 다음은 포인트클라우드 데이터를 생성하고 이를 시각화하는 간단한 예제이다.</p>
<pre><code class="language-cpp">#include &lt;pcl/visualization/cloud_viewer.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;

int main() {
    // 포인트클라우드 객체 생성
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

    // 예시 데이터를 포인트클라우드에 추가
    cloud-&gt;width = 100;
    cloud-&gt;height = 1;
    cloud-&gt;points.resize(cloud-&gt;width * cloud-&gt;height);

    for (auto&amp; point : cloud-&gt;points) {
        point.x = 1024 * rand() / (RAND_MAX + 1.0f);
        point.y = 1024 * rand() / (RAND_MAX + 1.0f);
        point.z = 1024 * rand() / (RAND_MAX + 1.0f);
    }

    // 포인트클라우드 시각화
    pcl::visualization::CloudViewer viewer(&quot;Cloud Viewer&quot;);
    viewer.showCloud(cloud);

    // 프로그램 종료
    while (!viewer.wasStopped()) {}

    return 0;
}
</code></pre>
<p>이 예제에서는 <code>pcl::PointCloud</code> 객체를 생성하고 임의의 포인트 데이터를 추가한 후, 이를 <code>pcl::visualization::CloudViewer</code>로 시각화한다.</p>
<h3 id="pcl_3">PCL 설치 시 유의사항</h3>
<p>PCL 설치 시 몇 가지 주의해야 할 사항이 있다. 특히 PCL은 다양한 의존성 라이브러리에 기반하고 있어, 설치 과정에서 의존성 충돌이나 미설치 문제가 발생할 수 있다. 이러한 문제를 방지하고 해결하는 방법을 아래에 설명한다.</p>
<h4 id="ubuntu">Ubuntu에서의 의존성 문제 해결</h4>
<p>PCL은 여러 서드파티 라이브러리에 의존한다. 예를 들어, OpenNI, Eigen, FLANN, VTK 등의 라이브러리들이 필요할 수 있다. 이들 의존성이 제대로 설치되지 않으면 PCL 빌드 과정에서 에러가 발생할 수 있다. 이를 해결하기 위해서는 PCL 설치 전에 필요한 의존성 라이브러리를 설치해야 한다.</p>
<pre><code class="language-bash">sudo apt install libvtk7-dev libeigen3-dev libflann-dev
sudo apt install libopenni-dev libopenni2-dev
</code></pre>
<p>이러한 라이브러리들이 설치되어 있으면 PCL을 빌드할 때 발생하는 의존성 문제를 해결할 수 있다.</p>
<h4 id="windows-visual-studio-cmake">Windows에서의 Visual Studio와 CMake 설정</h4>
<p>Windows 환경에서는 Visual Studio와 CMake의 버전 호환성에 주의해야 한다. Visual Studio의 버전이 너무 낮거나 CMake 버전이 맞지 않으면 빌드 과정에서 오류가 발생할 수 있다. PCL 공식 문서에서는 Visual Studio 2017 이상의 버전과 최신 CMake 버전을 사용하는 것을 권장한다.</p>
<p>CMake 빌드 시에는 빌드 타입을 설정하는 옵션도 필요하다. 예를 들어, 디버그 모드로 빌드하고 싶다면 CMake 옵션에서 <code>-DCMAKE_BUILD_TYPE=Debug</code>를 설정할 수 있다. 반면 릴리즈 모드에서는 <code>Release</code>로 설정한다.</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release ..
</code></pre>
<p>또한, Windows에서 빌드 시에는 PCL의 경로가 시스템 경로에 정확히 설정되어야 하며, 환경 변수 <code>PCL_DIR</code>이 PCL이 설치된 경로를 가리키고 있어야 한다.</p>
<h3 id="c-pcl">C++에서 PCL 사용 예제</h3>
<p>위에서 설명한 환경 설정이 완료되었다면, 이제 PCL을 사용한 실제 프로젝트를 작성할 수 있다. PCL은 포인트클라우드 데이터를 처리하고 변환하는 데 매우 유용한 다양한 함수들을 제공한다. 예를 들어, 포인트클라우드 데이터를 파일에서 불러오고 이를 변환하는 과정을 다룬 예제를 살펴보자.</p>
<h4 id="_2">포인트클라우드 파일 불러오기</h4>
<p>PCL은 여러 파일 형식에서 포인트클라우드를 불러올 수 있는 기능을 제공한다. 가장 일반적인 형식으로는 PCD(Point Cloud Data) 파일이 있다. 다음은 PCD 파일을 불러와서 시각화하는 간단한 코드이다.</p>
<pre><code class="language-cpp">#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/visualization/cloud_viewer.h&gt;

int main(int argc, char** argv) {
    // 포인트클라우드 객체 생성
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

    // PCD 파일에서 포인트클라우드 데이터를 읽어오기
    if (pcl::io::loadPCDFile&lt;pcl::PointXYZ&gt;(&quot;test_pcd.pcd&quot;, *cloud) == -1) {
        PCL_ERROR(&quot;Couldn't read the file \n&quot;);
        return (-1);
    }

    // 포인트클라우드 시각화
    pcl::visualization::CloudViewer viewer(&quot;PCD Viewer&quot;);
    viewer.showCloud(cloud);

    // 프로그램 종료
    while (!viewer.wasStopped()) {}

    return 0;
}
</code></pre>
<p>이 코드는 <code>test_pcd.pcd</code> 파일에서 포인트클라우드 데이터를 불러와 이를 <code>CloudViewer</code>를 통해 시각화한다. <code>pcl::io::loadPCDFile</code> 함수를 사용하여 PCD 파일을 읽어들이고, 그 데이터를 <code>pcl::PointCloud</code> 객체에 저장한다.</p>
<h4 id="_3">포인트클라우드 변환</h4>
<p>PCL에서 포인트클라우드 데이터를 변환할 때는 주로 변환 행렬을 사용한다. 변환 행렬은 포인트클라우드의 위치와 방향을 이동, 회전시키는 데 사용되며, 4x4 행렬로 표현된다. 이 행렬을 이용하여 포인트클라우드 전체를 변환할 수 있다.</p>
<p>포인트클라우드 변환을 위한 코드는 아래와 같다.</p>
<pre><code class="language-cpp">#include &lt;pcl/common/transforms.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/visualization/cloud_viewer.h&gt;
#include &lt;Eigen/Dense&gt;

int main() {
    // 포인트클라우드 객체 생성 및 PCD 파일 읽기
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::io::loadPCDFile(&quot;test_pcd.pcd&quot;, *cloud);

    // 변환 행렬 생성 (이동: 0.1, 0.2, 0.3)
    Eigen::Matrix4f transform = Eigen::Matrix4f::Identity();
    transform(0, 3) = 0.1;  // X 축 이동
    transform(1, 3) = 0.2;  // Y 축 이동
    transform(2, 3) = 0.3;  // Z 축 이동

    // 포인트클라우드 변환
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr transformed_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::transformPointCloud(*cloud, *transformed_cloud, transform);

    // 변환된 포인트클라우드 시각화
    pcl::visualization::CloudViewer viewer(&quot;Transformed Cloud Viewer&quot;);
    viewer.showCloud(transformed_cloud);

    // 프로그램 종료
    while (!viewer.wasStopped()) {}

    return 0;
}
</code></pre>
<p>이 코드에서는 4x4 변환 행렬을 정의한 후, <code>pcl::transformPointCloud</code> 함수를 사용하여 포인트클라우드 데이터를 변환한다. 여기서 정의된 변환은 포인트클라우드를 X, Y, Z 축 방향으로 각각 0.1, 0.2, 0.3 단위로 이동시킨다.</p>
<h3 id="pcl_4">PCL에서의 필터링</h3>
<p>포인트클라우드 데이터는 매우 큰 데이터를 다루는 경우가 많으며, 데이터의 노이즈가 많을 수 있다. 이를 해결하기 위해 PCL은 다양한 필터링 기법을 제공한다. 필터링은 포인트클라우드의 품질을 향상시키거나 특정 데이터만을 남기는 데 유용하다. 이번에는 PCL에서 제공하는 몇 가지 대표적인 필터링 기법을 다루겠다.</p>
<h4 id="voxel-grid">Voxel Grid 필터</h4>
<p>Voxel Grid 필터는 포인트클라우드 데이터를 다운샘플링하는데 사용된다. 이 필터는 포인트클라우드를 격자 구조로 분할하고, 각 격자 내에서 대표 포인트를 계산하여 새로운 포인트클라우드를 생성한다. 이 과정을 통해 데이터 크기를 줄이고 계산 시간을 단축할 수 있다.</p>
<pre><code class="language-cpp">#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;
#include &lt;pcl/visualization/cloud_viewer.h&gt;

int main(int argc, char** argv) {
    // 원본 포인트클라우드 객체 생성
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::io::loadPCDFile(&quot;test_pcd.pcd&quot;, *cloud);

    // Voxel Grid 필터 적용
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor;
    sor.setInputCloud(cloud);
    sor.setLeafSize(0.01f, 0.01f, 0.01f);  // 리프 크기를 1cm로 설정
    sor.filter(*cloud_filtered);

    // 필터링된 포인트클라우드 시각화
    pcl::visualization::CloudViewer viewer(&quot;Filtered Cloud Viewer&quot;);
    viewer.showCloud(cloud_filtered);

    // 프로그램 종료
    while (!viewer.wasStopped()) {}

    return 0;
}
</code></pre>
<p>위의 코드에서는 <code>pcl::VoxelGrid</code> 클래스를 사용하여 포인트클라우드를 다운샘플링하고, 결과를 시각화한다. <code>setLeafSize</code> 함수에서 각 격자의 크기를 설정할 수 있으며, 여기서는 1cm의 크기로 격자를 설정하여 데이터를 샘플링한다.</p>
<h4 id="passthrough">PassThrough 필터</h4>
<p>PassThrough 필터는 포인트클라우드에서 특정 범위의 포인트만을 남기고 나머지는 제거하는 필터이다. 이 필터는 주로 관심 영역만 남기고 주변의 불필요한 데이터를 제거하는 데 유용하다.</p>
<pre><code class="language-cpp">#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/filters/passthrough.h&gt;
#include &lt;pcl/visualization/cloud_viewer.h&gt;

int main() {
    // 원본 포인트클라우드 객체 생성
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::io::loadPCDFile(&quot;test_pcd.pcd&quot;, *cloud);

    // PassThrough 필터 적용 (z 축 기준 0.0 ~ 1.0 사이의 포인트만 남김)
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::PassThrough&lt;pcl::PointXYZ&gt; pass;
    pass.setInputCloud(cloud);
    pass.setFilterFieldName(&quot;z&quot;);
    pass.setFilterLimits(0.0, 1.0);  // z 축의 값이 0.0 ~ 1.0 사이인 포인트만 남김
    pass.filter(*cloud_filtered);

    // 필터링된 포인트클라우드 시각화
    pcl::visualization::CloudViewer viewer(&quot;PassThrough Filter Viewer&quot;);
    viewer.showCloud(cloud_filtered);

    // 프로그램 종료
    while (!viewer.wasStopped()) {}

    return 0;
}
</code></pre>
<p>이 예제에서는 <code>pcl::PassThrough</code> 필터를 사용하여 z 축 값이 0.0과 1.0 사이에 있는 포인트만 남기고 나머지는 제거한다. <code>setFilterFieldName</code> 함수에서 필터링할 축을 지정할 수 있으며, <code>setFilterLimits</code>에서 필터링할 값의 범위를 지정한다.</p>
<h4 id="statistical-outlier-removal-sor">Statistical Outlier Removal (SOR) 필터</h4>
<p>통계적 외부값 제거(Statistical Outlier Removal, SOR) 필터는 포인트클라우드에서 통계적으로 이상치(outlier)를 제거하는 필터이다. 이 필터는 각 포인트에 대해 주변 포인트와의 거리를 분석하여, 평균 거리에서 크게 벗어나는 포인트를 이상치로 간주하고 제거한다.</p>
<pre><code class="language-cpp">#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/filters/statistical_outlier_removal.h&gt;
#include &lt;pcl/visualization/cloud_viewer.h&gt;

int main() {
    // 원본 포인트클라우드 객체 생성
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::io::loadPCDFile(&quot;test_pcd.pcd&quot;, *cloud);

    // Statistical Outlier Removal 필터 적용
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor;
    sor.setInputCloud(cloud);
    sor.setMeanK(50);  // 각 포인트 주변 50개의 이웃 포인트를 참조
    sor.setStddevMulThresh(1.0);  // 평균에서 1 표준편차 이상 벗어난 포인트를 이상치로 간주
    sor.filter(*cloud_filtered);

    // 필터링된 포인트클라우드 시각화
    pcl::visualization::CloudViewer viewer(&quot;Statistical Outlier Removal Filter Viewer&quot;);
    viewer.showCloud(cloud_filtered);

    // 프로그램 종료
    while (!viewer.wasStopped()) {}

    return 0;
}
</code></pre>
<p>위 코드에서는 <code>pcl::StatisticalOutlierRemoval</code> 필터를 사용하여 포인트클라우드에서 통계적으로 이상치를 제거한다. <code>setMeanK</code> 함수는 각 포인트의 주변에서 참조할 이웃 포인트의 개수를 설정하며, <code>setStddevMulThresh</code> 함수는 표준편차를 기준으로 이상치를 정의하는 임계값을 설정한다.</p>
<h3 id="radius-outlier-removal">Radius Outlier Removal 필터</h3>
<p>Radius Outlier Removal 필터는 각 포인트의 주변에 존재하는 포인트 수를 기반으로 이상치를 제거하는 필터이다. 특정 반경 내에 존재하는 포인트 수가 설정한 임계값보다 적으면, 해당 포인트는 이상치로 간주되어 제거된다. 이는 특히 밀도가 낮은 부분의 노이즈를 제거하는 데 유용하다.</p>
<pre><code class="language-cpp">#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/filters/radius_outlier_removal.h&gt;
#include &lt;pcl/visualization/cloud_viewer.h&gt;

int main() {
    // 원본 포인트클라우드 객체 생성
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::io::loadPCDFile(&quot;test_pcd.pcd&quot;, *cloud);

    // Radius Outlier Removal 필터 적용
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem;
    outrem.setInputCloud(cloud);
    outrem.setRadiusSearch(0.8);  // 반경 0.8 내에 이웃 포인트 탐색
    outrem.setMinNeighborsInRadius(2);  // 반경 내에 최소 2개의 이웃 포인트가 존재해야 이상치로 간주하지 않음
    outrem.filter(*cloud_filtered);

    // 필터링된 포인트클라우드 시각화
    pcl::visualization::CloudViewer viewer(&quot;Radius Outlier Removal Filter Viewer&quot;);
    viewer.showCloud(cloud_filtered);

    // 프로그램 종료
    while (!viewer.wasStopped()) {}

    return 0;
}
</code></pre>
<p>위 코드는 <code>pcl::RadiusOutlierRemoval</code> 필터를 사용하여 반경 내의 포인트 개수를 기준으로 이상치를 제거한다. <code>setRadiusSearch</code> 함수는 검색할 반경을 설정하며, <code>setMinNeighborsInRadius</code> 함수는 반경 내에 존재해야 하는 최소 이웃 포인트 수를 설정한다.</p>
<h3 id="pcl_5">PCL에서의 환경 설정 및 빌드</h3>
<p>PCL을 설치한 후, 라이브러리를 사용하기 위해서는 프로젝트의 빌드 환경을 적절히 구성해야 한다. Ubuntu에서 PCL 설치는 apt 패키지 관리자를 통해 쉽게 설치할 수 있지만, Windows에서는 Visual Studio와 CMake를 사용한 설정이 필요하다. 이 설정 과정에서 발생할 수 있는 문제들을 해결하기 위한 몇 가지 팁을 제공한다.</p>
<h4 id="cmake_1">CMake를 사용한 빌드 설정</h4>
<p>CMake를 사용하여 PCL 프로젝트를 빌드할 때, 프로젝트 파일인 <code>CMakeLists.txt</code>에 PCL의 경로를 명확히 지정해야 한다. 앞서 언급한 CMake 설정 외에도, PCL이 설치된 경로를 <code>PCL_DIR</code> 환경 변수로 설정할 수 있다.</p>
<pre><code class="language-bash">export PCL_DIR=/usr/lib/x86_64-linux-gnu/cmake/pcl
</code></pre>
<p>Windows 환경에서는 시스템 속성에서 PCL 경로를 추가할 수 있으며, Visual Studio에서 CMake를 통해 PCL 프로젝트를 빌드할 수 있다. </p>
<h4 id="pcl-opencv">PCL과 OpenCV 연동</h4>
<p>포인트클라우드와 영상 데이터를 함께 처리할 때는 PCL과 OpenCV를 함께 사용할 수 있다. PCL은 3D 데이터를 처리하는 데 탁월한 기능을 제공하고, OpenCV는 2D 영상 데이터를 처리하는 데 강력한 라이브러리이다. 두 라이브러리를 함께 사용하면 2D-3D 데이터 융합을 통해 다양한 응용 프로그램을 구현할 수 있다.</p>
<p>PCL과 OpenCV를 함께 사용하기 위해서는 프로젝트에 OpenCV를 추가적으로 설치하고, <code>CMakeLists.txt</code> 파일에 OpenCV 설정을 추가해야 한다.</p>
<pre><code class="language-cmake">find_package(OpenCV REQUIRED)
include_directories(${OpenCV_INCLUDE_DIRS})
target_link_libraries(example ${OpenCV_LIBS}${PCL_LIBRARIES})
</code></pre>
<p>이 설정은 PCL과 OpenCV의 라이브러리와 헤더 파일을 프로젝트에 연결하여 두 라이브러리를 함께 사용할 수 있도록 한다.</p>
<h3 id="pcl_6">PCL 데이터 처리 요약</h3>
<p>지금까지 PCL 설치 및 환경 설정, 그리고 기본적인 포인트클라우드 데이터 처리 방법에 대해 다루었다. PCL은 다양한 필터링 기법과 변환 방법을 제공하여 대용량의 3D 포인트클라우드 데이터를 효과적으로 처리할 수 있다. 또한, PCL은 시각화 도구를 통해 처리된 데이터를 쉽게 확인할 수 있으며, 다른 라이브러리와 연동하여 더 복잡한 응용 프로그램을 구현할 수 있다.</p>
<p>PCL의 설치 및 환경 설정이 완료되면, 포인트클라우드를 사용한 다양한 응용 프로그램을 개발할 수 있으며, 이러한 응용 프로그램에서 PCL의 필터링, 변환, 등록(Registration)과 같은 기능을 활용할 수 있다.</p>

  <br>
    

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>