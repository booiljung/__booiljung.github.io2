<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/sensor_data_processing/__pointcloud/introduction_to_pointcloud/chapter_02/02/" rel="canonical"/>
<link href="../../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>PCL(Point Cloud Library) 소개 - 실험 도서관</title>
<link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "PCL\uc758 \uc5ed\uc0ac\uc640 \ubc30\uacbd", url: "#_top", children: [
          ]},
          {title: "\uc8fc\uc694 \uad6c\uc131 \uc694\uc18c", url: "#_1", children: [
          ]},
          {title: "PCL \uc124\uce58 \ubc0f \ud658\uacbd \uc124\uc815", url: "#pcl_1", children: [
              {title: "PCL \uc124\uce58 (Ubuntu)", url: "#pcl-ubuntu" },
          ]},
          {title: "PCL \uc608\uc81c: \ud3ec\uc778\ud2b8\ud074\ub77c\uc6b0\ub4dc \uc0dd\uc131 \ubc0f \uc2dc\uac01\ud654", url: "#pcl_2", children: [
              {title: "\ucf54\ub4dc \uc608\uc81c", url: "#_2" },
              {title: "PCL\uc758 \uc7a5\uc810", url: "#pcl_3" },
          ]},
          {title: "PCL\uc758 \uae30\ubcf8 \ub370\uc774\ud130 \uad6c\uc870", url: "#pcl_4", children: [
              {title: "pcl::PointCloud\uc758 \uae30\ubcf8 \uad6c\uc870", url: "#pclpointcloud" },
              {title: "pcl::PointCloud\uc758 \uae30\ubcf8 \uc0ac\uc6a9\ubc95", url: "#pclpointcloud_1" },
          ]},
          {title: "PCL\uc5d0\uc11c \uc9c0\uc6d0\ud558\ub294 \ud3ec\uc778\ud2b8 \ud0c0\uc785", url: "#pcl_5", children: [
          ]},
          {title: "\ud3ec\uc778\ud2b8\ud074\ub77c\uc6b0\ub4dc\uc758 \ud6a8\uc728\uc801 \uad00\ub9ac", url: "#_3", children: [
              {title: "Voxel Grid \ud544\ud130 \uc801\uc6a9 \uc608\uc81c", url: "#voxel-grid" },
          ]},
          {title: "PCL\uc758 \ud655\uc7a5\uc131\uacfc \ubaa8\ub4c8\ud654", url: "#pcl_6", children: [
              {title: "PCL \ubaa8\ub4c8 \uac04\uc758 \uc0c1\ud638\uc791\uc6a9", url: "#pcl_7" },
          ]},
          {title: "PCL\uc5d0\uc11c\uc758 \uc131\ub2a5 \ucd5c\uc801\ud654", url: "#pcl_8", children: [
              {title: "\ubcd1\ub82c \ucc98\ub9ac", url: "#_4" },
              {title: "GPU \uac00\uc18d", url: "#gpu" },
          ]},
          {title: "PCL\uc758 \ud65c\uc6a9 \ubd84\uc57c", url: "#pcl_9", children: [
          ]},
        ];

    </script>
<script src="../../../../../js/base.js"></script>
<script src="../../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<p>PCL(Point Cloud Library)는 3D 포인트클라우드 데이터를 처리하고 분석하는 데 특화된 오픈 소스 라이브러리이다. 다양한 3D 센서에서 생성된 데이터를 효율적으로 처리할 수 있도록 광범위한 기능을 제공한다. PCL의 주요 목적은 로봇 비전, 자율 주행, 3D 스캐닝, AR/VR 등의 다양한 응용 분야에서 포인트클라우드 데이터의 처리를 간소화하고, 성능을 최적화하는 것이다. 다음은 PCL의 주요 특징과 기능에 대한 개요이다.</p>
<h3 id="pcl">PCL의 역사와 배경</h3>
<p>PCL은 2010년 Open Perception에서 처음 개발되었으며, 이후 여러 연구자들과 기업들이 협력하여 성장하였다. 주로 3D 컴퓨터 비전과 로봇 공학 연구를 위해 개발되었으며, 특히 실시간 3D 데이터 처리와 관련된 응용에서 널리 사용되고 있다. PCL은 아래와 같은 다양한 데이터 처리 기능을 제공한다:</p>
<ul>
<li>필터링</li>
<li>세그먼테이션</li>
<li>특징 추출</li>
<li>정렬 및 매칭</li>
<li>표면 재구성</li>
</ul>
<h3 id="_1">주요 구성 요소</h3>
<p>PCL은 모듈화된 구조로 이루어져 있으며, 각 모듈은 특정한 기능을 수행한다. 주요 모듈은 다음과 같다:</p>
<ul>
<li><strong>PCL Filters</strong>: 포인트클라우드를 필터링하여 불필요한 데이터를 제거하거나 데이터를 리샘플링하는 모듈이다.</li>
<li><strong>PCL Segmentation</strong>: 포인트클라우드 데이터를 분할하여 서로 다른 객체를 구분하는 기능을 제공한다.</li>
<li><strong>PCL Features</strong>: 특징점을 추출하고 그에 대한 기술자를 계산하여, 물체 인식 또는 매칭에 사용된다.</li>
<li><strong>PCL Registration</strong>: 포인트클라우드를 정합(Registration)하여 여러 개의 포인트클라우드를 하나로 병합하는 기능을 수행한다.</li>
<li><strong>PCL Surface</strong>: 포인트클라우드 데이터에서 표면을 재구성하여 매쉬 모델을 생성한다.</li>
<li><strong>PCL Visualization</strong>: 포인트클라우드를 시각화하는 모듈로, 3D 데이터를 쉽게 확인할 수 있는 도구를 제공한다.</li>
</ul>
<h3 id="pcl_1">PCL 설치 및 환경 설정</h3>
<p>PCL을 설치하고 사용하기 위해서는 몇 가지 기본적인 환경 설정이 필요하다. PCL은 다양한 운영체제에서 사용할 수 있으며, 일반적으로 C++ 기반으로 구현된다. 아래는 Ubuntu에서 PCL을 설치하는 방법이다.</p>
<h4 id="pcl-ubuntu">PCL 설치 (Ubuntu)</h4>
<p>PCL은 패키지 관리자를 통해 손쉽게 설치할 수 있다. 다음 명령을 사용하여 PCL을 설치할 수 있다:</p>
<pre><code class="language-bash">sudo apt-get install libpcl-dev
</code></pre>
<p>설치가 완료되면, C++ 프로젝트에서 PCL을 사용할 준비가 완료된다. 이제 PCL을 사용하는 간단한 예제를 살펴보자.</p>
<h3 id="pcl_2">PCL 예제: 포인트클라우드 생성 및 시각화</h3>
<p>다음은 PCL을 사용하여 포인트클라우드를 생성하고 이를 시각화하는 간단한 예제이다. 이 예제에서는 기본적인 포인트클라우드 데이터를 생성하고, 이를 시각화 도구로 출력한다.</p>
<h4 id="_2">코드 예제</h4>
<pre><code class="language-cpp">#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/visualization/cloud_viewer.h&gt;

int main()
{
    // 포인트클라우드 객체 생성
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

    // 포인트클라우드에 점 추가
    cloud-&gt;width = 5;
    cloud-&gt;height = 1;
    cloud-&gt;is_dense = false;
    cloud-&gt;points.resize(cloud-&gt;width * cloud-&gt;height);

    for (auto&amp; point : cloud-&gt;points)
    {
        point.x = 1024 * rand() / (RAND_MAX + 1.0f);
        point.y = 1024 * rand() / (RAND_MAX + 1.0f);
        point.z = 1024 * rand() / (RAND_MAX + 1.0f);
    }

    // 포인트클라우드 시각화
    pcl::visualization::CloudViewer viewer("Simple Cloud Viewer");
    viewer.showCloud(cloud);

    // 사용자가 창을 닫을 때까지 대기
    while (!viewer.wasStopped())
    {
    }

    return 0;
}
</code></pre>
<p>위 코드는 <code>pcl::PointCloud</code> 객체를 생성하고, 포인트들의 좌표값을 임의로 설정한 후, 시각화 도구를 사용하여 포인트클라우드를 화면에 출력하는 과정이다.</p>
<p>이 예제에서 중요한 점은 다음과 같다:
1. <strong>pcl::PointCloud</strong>: PCL에서 포인트클라우드를 나타내는 객체이다. 이 객체는 포인트들의 배열을 포함하며, 각 포인트는 3D 좌표로 나타난다.
2. <strong>pcl::visualization::CloudViewer</strong>: 포인트클라우드를 화면에 출력하기 위한 시각화 도구이다.</p>
<h4 id="pcl_3">PCL의 장점</h4>
<p>PCL은 수많은 기능을 제공하며, 다양한 3D 데이터 처리를 위한 최적의 도구이다. 실시간 처리 성능을 위한 최적화된 알고리즘과 함께, 다양한 형태의 포인트클라우드 데이터를 처리할 수 있다. 또한, 다른 라이브러리나 툴과의 호환성도 뛰어나며, 로봇 공학, 자율 주행, AR/VR 등 다양한 분야에서 폭넓게 사용된다.</p>
<h3 id="pcl_4">PCL의 기본 데이터 구조</h3>
<p>PCL에서 포인트클라우드를 처리하기 위해서는 적절한 데이터 구조를 이해하는 것이 중요하다. PCL은 포인트클라우드를 저장하고 처리하기 위한 다양한 데이터 구조를 제공하며, 그 중 가장 기본적인 구조는 <code>pcl::PointCloud</code>이다. 이 데이터 구조는 3D 좌표계 상의 점들로 이루어진 배열을 나타낸다.</p>
<h4 id="pclpointcloud"><code>pcl::PointCloud</code>의 기본 구조</h4>
<p><code>pcl::PointCloud</code>는 기본적으로 다음과 같은 데이터 필드를 포함한다:</p>
<ul>
<li><strong>width</strong>: 포인트클라우드의 가로 길이. 포인트의 수를 나타내는 데 사용될 수 있다.</li>
<li><strong>height</strong>: 포인트클라우드의 세로 길이. 포인트가 2D 배열 형식으로 배치될 경우 유용하다.</li>
<li><strong>points</strong>: 실제 포인트 데이터를 저장하는 배열. 각 포인트는 좌표 정보와 추가 속성을 가질 수 있다.</li>
<li><strong>is_dense</strong>: 포인트 데이터가 밀집(dense)되어 있는지 여부를 나타낸다. <code>true</code>이면 데이터가 빈틈없이 채워져 있음을 의미하며, <code>false</code>이면 데이터 중 일부가 누락되었을 가능성이 있음을 의미한다.</li>
</ul>
<p><code>pcl::PointCloud</code>는 다양한 유형의 포인트 데이터를 처리할 수 있으며, 가장 일반적인 유형은 <code>pcl::PointXYZ</code>이다. 이 데이터 구조는 각 포인트의 (x, y, z) 좌표를 저장한다.</p>
<h4 id="pclpointcloud_1"><code>pcl::PointCloud</code>의 기본 사용법</h4>
<pre><code class="language-cpp">pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud;
cloud.width = 100;
cloud.height = 1;  // 단일 포인트 배열을 나타냄
cloud.is_dense = false;
cloud.points.resize(cloud.width * cloud.height);

for (std::size_t i = 0; i &lt; cloud.points.size(); ++i)
{
    cloud.points[i].x = 1024 * rand() / (RAND_MAX + 1.0f);
    cloud.points[i].y = 1024 * rand() / (RAND_MAX + 1.0f);
    cloud.points[i].z = 1024 * rand() / (RAND_MAX + 1.0f);
}
</code></pre>
<p>위 예제에서 <code>cloud</code>는 100개의 포인트를 포함하는 단일 배열 형태의 포인트클라우드를 생성한다. 각 포인트는 임의의 (x, y, z) 좌표를 가지며, <code>cloud.points[i]</code>를 통해 각 포인트에 접근할 수 있다.</p>
<h3 id="pcl_5">PCL에서 지원하는 포인트 타입</h3>
<p>PCL은 다양한 포인트 타입을 지원한다. 포인트 타입은 각 점이 가지는 데이터의 종류를 정의하며, 이를 통해 각 점이 어떤 속성들을 가지는지 명시할 수 있다. PCL에서 자주 사용되는 몇 가지 포인트 타입은 다음과 같다:</p>
<ul>
<li><strong>pcl::PointXYZ</strong>: (x, y, z) 좌표 정보만을 가지는 기본적인 포인트 타입.</li>
<li><strong>pcl::PointXYZRGB</strong>: (x, y, z) 좌표와 더불어 각 점의 RGB 색상 값을 저장할 수 있는 타입.</li>
<li><strong>pcl::PointNormal</strong>: (x, y, z) 좌표와 법선(normal) 벡터 정보를 저장할 수 있는 타입.</li>
<li><strong>pcl::PointXYZI</strong>: (x, y, z) 좌표와 더불어 intensity(세기) 값을 저장할 수 있는 타입.</li>
</ul>
<p>다음은 포인트 타입별로 데이터 구조를 활용하는 예제이다:</p>
<pre><code class="language-cpp">pcl::PointCloud&lt;pcl::PointXYZRGB&gt; cloud;
cloud.width = 100;
cloud.height = 1;
cloud.is_dense = false;
cloud.points.resize(cloud.width * cloud.height);

for (std::size_t i = 0; i &lt; cloud.points.size(); ++i)
{
    cloud.points[i].x = 1024 * rand() / (RAND_MAX + 1.0f);
    cloud.points[i].y = 1024 * rand() / (RAND_MAX + 1.0f);
    cloud.points[i].z = 1024 * rand() / (RAND_MAX + 1.0f);
    cloud.points[i].r = 255;  // 빨간색 채널 값
    cloud.points[i].g = 0;    // 녹색 채널 값
    cloud.points[i].b = 0;    // 파란색 채널 값
}
</code></pre>
<p>이 코드는 <code>pcl::PointXYZRGB</code> 타입의 포인트클라우드를 생성하며, 각 포인트에 RGB 색상 정보를 추가한다. 이와 같이 PCL은 포인트 데이터의 타입을 확장하여 좌표 정보 외에도 다양한 속성을 저장할 수 있도록 한다.</p>
<h3 id="_3">포인트클라우드의 효율적 관리</h3>
<p>포인트클라우드 데이터는 매우 많은 양의 데이터를 포함할 수 있다. 이 때문에 포인트클라우드를 효율적으로 관리하는 것이 중요하다. PCL에서는 이를 위해 다양한 기능을 제공하며, 대표적인 예가 <strong>Voxel Grid 필터</strong>이다. Voxel Grid 필터는 포인트클라우드를 작은 3D 격자로 나누어, 격자 내의 대표 포인트만을 남기는 방식으로 데이터 양을 줄이다.</p>
<h4 id="voxel-grid">Voxel Grid 필터 적용 예제</h4>
<pre><code class="language-cpp">#include &lt;pcl/filters/voxel_grid.h&gt;

pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

// Voxel Grid 필터 객체 생성
pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor;
sor.setInputCloud(cloud);
sor.setLeafSize(0.01f, 0.01f, 0.01f);  // 격자 크기 설정
sor.filter(*cloud_filtered);
</code></pre>
<p>위 코드는 <code>VoxelGrid</code> 필터를 사용하여 포인트클라우드의 해상도를 줄이는 예제이다. <code>setLeafSize</code> 함수를 통해 각 격자의 크기를 설정할 수 있으며, 이 값을 줄이면 더 많은 포인트가 제거된다. 이를 통해 포인트클라우드 데이터를 효율적으로 관리하고 처리 시간을 단축할 수 있다.</p>
<h3 id="pcl_6">PCL의 확장성과 모듈화</h3>
<p>PCL은 매우 모듈화된 구조를 가지고 있어 사용자가 필요로 하는 기능만을 선택적으로 사용할 수 있도록 설계되었다. 이 확장성 덕분에 PCL은 다양한 응용 분야에서 적합하게 사용될 수 있으며, 사용자는 필요에 따라 라이브러리를 쉽게 확장하거나 커스터마이징할 수 있다. 이를 위해 PCL은 다음과 같은 구성 요소를 모듈로 나누어 제공한다:</p>
<ul>
<li>
<p><strong>PCL Filters</strong>: 포인트클라우드를 필터링하여 데이터의 크기를 줄이거나 노이즈를 제거하는 기능을 제공한다. 이 모듈에서는 Voxel Grid 필터 외에도 PassThrough 필터, Statistical Outlier Removal 필터 등 다양한 필터를 사용할 수 있다.</p>
</li>
<li>
<p><strong>PCL Segmentation</strong>: 포인트클라우드 데이터를 세그먼트로 나누어 각 객체를 구분하는 기능을 제공한다. 이는 포인트클라우드 기반의 객체 인식, 맵핑, 로봇 비전 등에서 중요한 역할을 한다.</p>
</li>
<li>
<p><strong>PCL Features</strong>: 포인트클라우드의 특징점을 추출하고 그에 대한 기술자를 계산하는 기능을 제공한다. 이러한 특징점은 물체 인식이나 매칭에 사용된다.</p>
</li>
<li>
<p><strong>PCL Registration</strong>: 여러 포인트클라우드 데이터를 하나로 정합(Registration)하는 기능을 제공한다. 이 모듈을 사용하면 서로 다른 시점에서 촬영한 포인트클라우드 데이터를 하나의 통합된 데이터로 병합할 수 있다.</p>
</li>
<li>
<p><strong>PCL Surface</strong>: 포인트클라우드 데이터에서 표면을 재구성하고, 이를 기반으로 3D 모델을 생성하는 기능을 제공한다. 이 모듈을 통해 포인트클라우드 데이터를 매쉬(mesh) 형태로 변환할 수 있다.</p>
</li>
</ul>
<h4 id="pcl_7">PCL 모듈 간의 상호작용</h4>
<p>PCL의 모듈들은 서로 독립적으로 작동할 수 있지만, 필요에 따라 상호작용하도록 설계되어 있다. 예를 들어, 필터 모듈을 사용하여 포인트클라우드의 노이즈를 제거한 후, 세그먼테이션 모듈을 사용하여 데이터를 분리할 수 있다. 이후, 특징 추출 모듈을 사용하여 각 세그먼트의 특징점을 추출하고, 등록 모듈을 통해 여러 포인트클라우드를 정합할 수 있다.</p>
<p>이러한 모듈 간의 상호작용은 다음과 같이 그림으로 나타낼 수 있다:</p>
<div class="mermaid">graph TD;
    A[필터링] --&gt; B[세그먼테이션];
    B --&gt; C[특징 추출];
    C --&gt; D[등록];
    D --&gt; E[표면 재구성];
</div>
<p>위의 다이어그램은 포인트클라우드 데이터가 필터링되어 노이즈가 제거된 후, 세그먼테이션 과정을 거쳐 각 객체가 분리되고, 그 후 특징 추출 및 등록 과정을 통해 포인트클라우드가 병합되는 과정을 보여준다.</p>
<h3 id="pcl_8">PCL에서의 성능 최적화</h3>
<p>포인트클라우드 데이터는 매우 큰 양의 데이터를 포함하기 때문에 처리 성능이 중요한 문제이다. PCL은 이를 해결하기 위해 다양한 성능 최적화 기법을 제공하며, 이를 통해 실시간 처리 성능을 보장할 수 있다.</p>
<h4 id="_4">병렬 처리</h4>
<p>PCL은 포인트클라우드 데이터를 병렬로 처리할 수 있는 기능을 제공한다. 예를 들어, 큰 데이터 세트를 처리할 때, PCL은 OpenMP와 같은 병렬 처리 라이브러리를 사용하여 데이터를 여러 스레드로 나누어 처리한다. 이를 통해 처리 시간을 크게 줄일 수 있다.</p>
<h4 id="gpu">GPU 가속</h4>
<p>PCL은 GPU를 활용한 가속 처리도 지원한다. 특히, <code>pcl::gpu</code> 모듈은 CUDA를 사용하여 포인트클라우드 데이터를 병렬로 처리할 수 있도록 설계되었다. 이를 통해 복잡한 계산을 빠르게 처리하고, 실시간 응용에 적합한 성능을 제공한다. 예를 들어, 실시간 3D 스캐닝 또는 자율 주행과 같은 애플리케이션에서 이러한 GPU 가속 기능은 필수적이다.</p>
<p>다음은 GPU 기반의 Voxel Grid 필터 적용 예시이다:</p>
<pre><code class="language-cpp">#include &lt;pcl/gpu/filters/voxel_grid.h&gt;

pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
pcl::gpu::VoxelGrid voxel_grid;
pcl::gpu::PointCloud pcl_cloud;

// 포인트클라우드를 GPU 포맷으로 변환
pcl_cloud.upload(*cloud);

// Voxel Grid 필터 적용
voxel_grid.setInputCloud(pcl_cloud);
voxel_grid.setLeafSize(0.01f, 0.01f, 0.01f);
pcl::gpu::PointCloud cloud_filtered;
voxel_grid.filter(cloud_filtered);
</code></pre>
<p>위 코드는 <code>pcl::gpu::VoxelGrid</code> 클래스를 사용하여 GPU에서 포인트클라우드를 필터링하는 과정을 보여준다. 이를 통해 CPU보다 훨씬 빠르게 데이터를 처리할 수 있다.</p>
<h3 id="pcl_9">PCL의 활용 분야</h3>
<p>PCL은 다양한 산업 분야에서 포인트클라우드 데이터를 처리하는 데 사용된다. 대표적인 응용 분야는 다음과 같다:</p>
<ul>
<li><strong>로봇 비전</strong>: 로봇이 환경을 인식하고, 객체를 탐지하며, 경로를 계획할 수 있도록 돕는다.</li>
<li><strong>자율 주행</strong>: 자율 주행 차량은 라이다(LiDAR) 센서를 사용하여 3D 포인트클라우드를 생성하고, 이를 바탕으로 주변 환경을 인식하여 경로를 계획한다.</li>
<li><strong>증강 현실(AR) 및 가상 현실(VR)</strong>: 3D 스캔 데이터를 활용하여 AR/VR 애플리케이션에서 현실 세계의 물체를 인식하고 상호작용하는 데 사용된다.</li>
<li><strong>건축 및 토목 공학</strong>: 건축물의 3D 스캔 데이터를 분석하여 구조물을 모델링하고, 시뮬레이션할 수 있다.</li>
</ul>
<p>PCL은 이와 같은 다양한 응용에서 사용되며, 그 유연성과 성능 덕분에 매우 인기 있는 라이브러리이다.</p>
<br/>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>