<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/programming/cplusplus/cplusplus_boost_asio_programming/chapter_05/0504/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>핸들러 전달 및 매개변수 처리 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ud578\ub4e4\ub7ec \uc804\ub2ec\uc758 \uae30\ubcf8 \uc6d0\ub9ac", url: "#_top", children: [
          ]},
          {title: "\ub9e4\uac1c\ubcc0\uc218 \ucc98\ub9ac\uc758 \uc720\uc5f0\uc131", url: "#_2", children: [
          ]},
          {title: "\ub9e4\uac1c\ubcc0\uc218 \uc804\ub2ec \uc21c\uc11c\uc640 \uaddc\uce59", url: "#_3", children: [
          ]},
          {title: "\ub9e4\uac1c\ubcc0\uc218 \uc804\ub2ec\uacfc \ubcf5\uc0ac", url: "#_4", children: [
          ]},
          {title: "\ud578\ub4e4\ub7ec\uc758 \uc218\uba85 \uad00\ub9ac", url: "#_5", children: [
          ]},
          {title: "\uba40\ud2f0\uc2a4\ub808\ub4dc \ud658\uacbd\uc5d0\uc11c\uc758 \ud578\ub4e4\ub7ec \uc804\ub2ec", url: "#_6", children: [
          ]},
          {title: "\ud578\ub4e4\ub7ec\uc5d0\uc11c\uc758 \uc5d0\ub7ec \ucc98\ub9ac", url: "#_7", children: [
          ]},
          {title: "\ub2e4\uc218\uc758 \ub9e4\uac1c\ubcc0\uc218 \ucc98\ub9ac", url: "#_8", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 \ud578\ub4e4\ub7ec\uc758 \ub9e4\uac1c\ubcc0\uc218\ub85c \ub78c\ub2e4 \ud568\uc218 \uc0ac\uc6a9", url: "#_9", children: [
          ]},
          {title: "\uacf5\uc720 \uc0c1\ud0dc\ub97c \ud65c\uc6a9\ud55c \ud578\ub4e4\ub7ec \ub9e4\uac1c\ubcc0\uc218 \uad00\ub9ac", url: "#_10", children: [
          ]},
          {title: "\ud578\ub4e4\ub7ec\uc758 \uc7ac\uc0ac\uc6a9\uacfc \ub9e4\uac1c\ubcc0\uc218 \uc804\ub2ec", url: "#_11", children: [
          ]},
          {title: "\ud578\ub4e4\ub7ec\uc640 \ud568\uc218 \uac1d\uccb4", url: "#_12", children: [
          ]},
          {title: "\ud578\ub4e4\ub7ec\uc5d0\uc11c\uc758 \ube44\ub3d9\uae30 \ud750\ub984 \uc81c\uc5b4", url: "#_13", children: [
          ]},
          {title: "\ud578\ub4e4\ub7ec \uc804\ub2ec\uc744 \ud1b5\ud55c \ube44\ub3d9\uae30 \uc791\uc5c5 \uad6c\uc131", url: "#_14", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0505/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0505/" class="btn btn-xs btn-link">
        다중 핸들러 관리와 구조화
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0503/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0503/" class="btn btn-xs btn-link">
        람다 함수를 이용한 비동기 작업 처리
      </a>
    </div>
    
  </div>

    

    <p>Boost.Asio에서 비동기 작업을 수행할 때, 핸들러를 효과적으로 전달하고 매개변수를 처리하는 방식은 중요한 역할을 한다. 핸들러는 작업 완료 시 호출되는 콜백 함수로, 작업 결과와 추가 정보를 매개변수로 받을 수 있다. Boost.Bind와 Boost.Function을 활용하여 이러한 핸들러의 매개변수를 자유롭게 처리할 수 있으며, 다양한 방식으로 핸들러를 전달할 수 있다.</p>
<h3 id="_1">핸들러 전달의 기본 원리</h3>
<p>비동기 작업에서 핸들러는 일반적으로 다음과 같은 형식으로 전달된다:</p>
<pre><code class="language-cpp">io_service.post(boost::bind(&amp;핸들러함수, this, 매개변수들));
</code></pre>
<p>여기서 <code>boost::bind</code>는 함수의 매개변수를 미리 설정하거나, 나중에 전달될 값을 바인딩하는 역할을 한다. <code>io_service.post</code>는 작업을 큐에 넣고, 적절한 시점에서 핸들러를 호출하게 된다. 이때 핸들러가 호출될 때, 매개변수들이 적절하게 전달되어야 한다.</p>
<p>예를 들어, 다음과 같은 비동기 작업이 있을 수 있다:</p>
<pre><code class="language-cpp">void async_task_handler(const boost::system::error_code&amp; error, int result) {
    if (!error) {
        std::cout &lt;&lt; &quot;작업 결과: &quot; &lt;&lt; result &lt;&lt; std::endl;
    }
}

io_service.post(boost::bind(&amp;async_task_handler, _1, 42));
</code></pre>
<p>이 코드에서 <code>boost::bind</code>는 <code>async_task_handler</code> 함수와 <code>42</code>라는 매개변수를 연결한다. 작업이 완료되면 <code>async_task_handler</code>는 에러 코드와 함께 42라는 값을 매개변수로 받게 된다.</p>
<h3 id="_2">매개변수 처리의 유연성</h3>
<p>Boost.Bind를 이용하면 핸들러 함수에 전달되는 매개변수의 유연성을 극대화할 수 있다. <code>boost::bind</code>는 특정 매개변수를 미리 지정하거나, 자리 표시자인 <code>_1, _2</code> 등을 사용하여 나중에 전달될 값을 설정할 수 있다.</p>
<pre><code class="language-cpp">io_service.post(boost::bind(&amp;async_task_handler, _1, some_value));
</code></pre>
<p>위의 예에서는 첫 번째 매개변수는 나중에 전달될 값으로, 두 번째 매개변수는 <code>some_value</code>로 미리 바인딩된다. 이와 같이 다양한 매개변수 조합을 사용할 수 있다는 점이 Boost.Bind의 장점이다.</p>
<p>핸들러가 받는 매개변수는 비동기 작업에 따라 달라질 수 있으며, 비동기 소켓 작업의 경우 보통 <code>boost::system::error_code</code>와 같은 에러 코드가 첫 번째 매개변수로 전달된다.</p>
<h3 id="_3">매개변수 전달 순서와 규칙</h3>
<p>Boost.Bind와 Boost.Function은 매개변수 전달 순서를 매우 엄격하게 처리한다. 사용자가 지정한 매개변수가 호출될 때 정확한 순서로 전달되어야 한다. 예를 들어, 다음과 같은 핸들러가 있다고 가정해보자:</p>
<pre><code class="language-cpp">void handler(const boost::system::error_code&amp; error, int value1, double value2) {
    // 에러 코드 처리
    // value1, value2 처리
}
</code></pre>
<p>이 핸들러를 비동기 작업에 연결할 때, <code>boost::bind</code>를 사용하여 매개변수를 적절히 바인딩해야 한다. 예를 들어:</p>
<pre><code class="language-cpp">io_service.post(boost::bind(&amp;handler, _1, 100, 3.14));
</code></pre>
<p>여기서 <code>_1</code>은 나중에 전달될 값(예: 에러 코드)이며, <code>100</code>과 <code>3.14</code>는 미리 바인딩된 값이다. 이처럼 매개변수는 핸들러의 정의에 맞게 정확한 순서로 전달되어야 하며, 매개변수의 갯수나 타입이 핸들러의 정의와 다르면 컴파일 타임 에러가 발생할 수 있다.</p>
<p>또한, 매개변수를 바인딩할 때 기본 자료형 외에도 사용자 정의 자료형이나 객체를 전달할 수도 있다. 이 경우, 객체의 복사 또는 참조를 통해 매개변수가 전달될 수 있으며, 상황에 따라 성능 및 메모리 관리 측면에서 주의가 필요하다.</p>
<h3 id="_4">매개변수 전달과 복사</h3>
<p>핸들러에 객체나 데이터를 전달할 때, 매개변수의 복사 또는 참조 여부는 성능에 중요한 영향을 미칠 수 있다. 특히 대용량 데이터를 처리하는 비동기 작업에서는 복사로 인한 오버헤드가 발생할 수 있으므로, 참조 또는 스마트 포인터를 활용하는 것이 효율적일 수 있다.</p>
<pre><code class="language-cpp">io_service.post(boost::bind(&amp;handler, _1, boost::ref(some_object)));
</code></pre>
<p>위의 코드에서 <code>boost::ref</code>를 사용하면 <code>some_object</code>가 참조로 전달되어 불필요한 복사를 방지할 수 있다. 이는 복사가 비싼 객체를 전달할 때 매우 유용한 기법이다.</p>
<h3 id="_5">핸들러의 수명 관리</h3>
<p>비동기 작업에서 핸들러가 전달된 후, 핸들러가 호출되기 전까지의 수명을 적절히 관리하는 것은 매우 중요하다. 핸들러가 참조하는 객체가 유효하지 않으면 비동기 작업이 완료되었을 때 프로그램이 예기치 않게 동작하거나 충돌할 수 있다.</p>
<p>이 문제를 해결하기 위해 스마트 포인터, 특히 <code>std::shared_ptr</code>나 <code>boost::shared_ptr</code>을 자주 사용한다. 이를 통해 핸들러와 비동기 작업 간의 객체 수명을 안전하게 관리할 수 있다. 예를 들어, 다음과 같은 상황을 고려할 수 있다:</p>
<pre><code class="language-cpp">class AsyncTask {
public:
    void start() {
        io_service.post(boost::bind(&amp;AsyncTask::handler, shared_from_this()));
    }

    void handler() {
        // 작업 완료 처리
    }
};
</code></pre>
<p>여기서 <code>shared_from_this()</code>는 <code>AsyncTask</code> 객체에 대한 <code>shared_ptr</code>을 반환하며, 이를 통해 핸들러가 객체를 안전하게 참조할 수 있게 한다. 이 방식을 통해 핸들러가 호출될 때까지 객체의 수명을 유지할 수 있으며, 작업이 완료되면 자동으로 메모리가 해제된다.</p>
<p>이와 같은 방식은 특히 클래스 멤버 함수가 핸들러로 사용될 때 유용하다. 멤버 함수가 핸들러로 전달되면, 해당 클래스의 인스턴스가 핸들러가 호출되기 전에 소멸되지 않도록 보장해야 한다.</p>
<h3 id="_6">멀티스레드 환경에서의 핸들러 전달</h3>
<p>비동기 핸들러를 멀티스레드 환경에서 안전하게 전달하고 실행하는 것은 복잡한 작업이 될 수 있다. Boost.Asio는 멀티스레드 환경에서의 비동기 작업을 지원하며, 이를 위해 핸들러 전달 시 동기화 메커니즘을 사용하는 것이 중요하다.</p>
<p>일반적으로, 핸들러가 여러 스레드에서 동시에 실행되는 것을 방지하기 위해 <code>strand</code>를 사용한다. <code>strand</code>는 특정 핸들러가 여러 스레드에서 동시에 실행되지 않도록 보장하는 동기화 도구이다. 이를 통해 핸들러가 안전하게 실행되도록 관리할 수 있다.</p>
<pre><code class="language-cpp">boost::asio::strand strand(io_service);

io_service.post(strand.wrap(boost::bind(&amp;handler, shared_from_this())));
</code></pre>
<p>위 코드에서는 <code>strand.wrap</code>을 사용하여 핸들러를 감싸고, 이를 통해 핸들러가 멀티스레드 환경에서도 안전하게 실행될 수 있도록 보장한다. <code>strand</code>를 사용하면, 핸들러가 실행되는 동안 동일한 <code>strand</code>에 의해 관리되는 다른 핸들러는 동시 실행되지 않도록 한다.</p>
<h3 id="_7">핸들러에서의 에러 처리</h3>
<p>비동기 작업에서는 핸들러가 호출될 때 에러가 발생할 수 있으며, 이를 적절하게 처리해야 한다. 보통 비동기 작업의 첫 번째 매개변수는 <code>boost::system::error_code</code>를 통해 에러 정보를 전달받는다.</p>
<p>핸들러에서 에러를 처리하는 방법은 다음과 같다:</p>
<pre><code class="language-cpp">void handler(const boost::system::error_code&amp; error) {
    if (!error) {
        // 작업 성공
    } else {
        std::cerr &lt;&lt; &quot;에러 발생: &quot; &lt;&lt; error.message() &lt;&lt; std::endl;
    }
}
</code></pre>
<p>여기서 <code>error</code> 매개변수를 통해 비동기 작업의 성공 또는 실패 여부를 판단할 수 있다. 에러가 발생하지 않았을 때는 <code>error</code> 객체가 비어 있으며, 에러가 발생하면 그에 따른 에러 메시지나 코드를 사용할 수 있다.</p>
<p>에러 처리의 중요성은 비동기 작업이 진행되는 동안 문제가 발생할 가능성이 있기 때문에 매우 크다. 에러가 제대로 처리되지 않으면 프로그램의 동작이 예측 불가능해질 수 있다.</p>
<h3 id="_8">다수의 매개변수 처리</h3>
<p>Boost.Bind를 사용하면 다수의 매개변수를 핸들러에 전달하는 것이 가능하다. 핸들러에 여러 개의 매개변수를 전달할 경우, 각 매개변수를 <code>boost::bind</code>에서 적절히 설정해야 한다. 예를 들어, 다음과 같은 다중 매개변수를 처리하는 핸들러가 있을 수 있다:</p>
<pre><code class="language-cpp">void handler(const boost::system::error_code&amp; error, int value1, double value2, const std::string&amp; message) {
    if (!error) {
        std::cout &lt;&lt; &quot;값1: &quot; &lt;&lt; value1 &lt;&lt; &quot;, 값2: &quot; &lt;&lt; value2 &lt;&lt; &quot;, 메시지: &quot; &lt;&lt; message &lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; &quot;에러 발생: &quot; &lt;&lt; error.message() &lt;&lt; std::endl;
    }
}

io_service.post(boost::bind(&amp;handler, _1, 42, 3.14, &quot;Hello World&quot;));
</code></pre>
<p>이 예제에서 <code>handler</code>는 4개의 매개변수를 받으며, 첫 번째는 비동기 작업의 결과인 <code>error_code</code>, 나머지는 각각 정수, 실수, 문자열로 이루어진다. <code>boost::bind</code>를 사용하여 각 매개변수를 적절히 바인딩하고, 작업이 완료되면 핸들러가 호출될 때 이 매개변수들이 전달된다.</p>
<p>매개변수가 많아질수록 핸들러의 관리와 처리 복잡성이 증가하므로, 매개변수 전달 방식을 체계적으로 설계하는 것이 중요하다.</p>
<h3 id="_9">비동기 핸들러의 매개변수로 람다 함수 사용</h3>
<p>Boost.Bind와 함께 Boost.Function을 사용하는 경우, 람다 함수를 통해 더 간결하게 비동기 핸들러의 매개변수를 처리할 수 있다. 특히 C++11 이후부터는 람다 함수가 자주 사용되며, 람다 표현식을 사용하면 코드의 가독성과 유연성이 향상된다. 람다 함수는 즉석에서 정의할 수 있는 익명 함수로, 함수 객체처럼 동작하면서 추가적인 매개변수 전달을 유연하게 처리할 수 있다.</p>
<p>다음은 람다 함수를 사용하여 핸들러에서 매개변수를 처리하는 예제이다:</p>
<pre><code class="language-cpp">io_service.post([=](const boost::system::error_code&amp; error, int value1, double value2) {
    if (!error) {
        std::cout &lt;&lt; &quot;값1: &quot; &lt;&lt; value1 &lt;&lt; &quot;, 값2: &quot; &lt;&lt; value2 &lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; &quot;에러 발생: &quot; &lt;&lt; error.message() &lt;&lt; std::endl;
    }
});
</code></pre>
<p>위 코드에서는 람다 표현식을 통해 핸들러를 정의하고, <code>value1</code>과 <code>value2</code>를 핸들러 내부에서 사용할 수 있도록 한다. 람다 함수는 <code>[=]</code>를 사용하여 외부에서 정의된 모든 변수를 캡처하여 사용할 수 있다. 이와 같은 방식으로 핸들러 내부에서 추가적인 변수를 처리할 수 있다.</p>
<p>람다 함수는 특히 복잡한 함수 객체를 정의하는 것을 피하면서, 간단한 핸들러 동작을 구현할 때 매우 유용하다. 이를 통해 코드를 더 간결하고 직관적으로 만들 수 있으며, 더 복잡한 매개변수 처리 로직도 깔끔하게 표현할 수 있다.</p>
<h3 id="_10">공유 상태를 활용한 핸들러 매개변수 관리</h3>
<p>비동기 작업에서 공유 상태를 관리하는 것도 중요한 문제이다. 비동기 작업 간에 공유되는 데이터는 서로 간섭하지 않도록 안전하게 관리되어야 한다. 이를 위해 <code>std::shared_ptr</code>과 같은 스마트 포인터를 사용하여 공유 상태를 관리할 수 있다.</p>
<p>핸들러가 호출될 때, 스마트 포인터를 사용하여 공유 상태를 전달하고, 이 상태가 작업이 완료될 때까지 유지되도록 할 수 있다. 예를 들어, 다음과 같이 공유 상태를 사용하는 비동기 핸들러를 작성할 수 있다:</p>
<pre><code class="language-cpp">struct SharedState {
    int value1;
    double value2;
};

std::shared_ptr&lt;SharedState&gt; state = std::make_shared&lt;SharedState&gt;();

io_service.post([state](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;공유 상태 값1: &quot; &lt;&lt; state-&gt;value1 &lt;&lt; &quot;, 값2: &quot; &lt;&lt; state-&gt;value2 &lt;&lt; std::endl;
    }
});
</code></pre>
<p>이 코드에서 <code>SharedState</code>라는 구조체가 공유 상태를 나타내며, <code>std::shared_ptr</code>로 관리된다. 이 상태는 여러 비동기 작업 간에 안전하게 공유되며, 작업이 완료될 때까지 상태가 유지된다. 핸들러 내부에서는 공유 상태의 값을 참조할 수 있으며, 작업이 끝난 후에는 자동으로 메모리가 해제된다.</p>
<p>이 방법은 복잡한 비동기 작업에서 여러 핸들러가 동일한 상태를 공유해야 할 때 매우 유용하다. 특히 다수의 비동기 작업이 서로 협력해야 하거나, 순차적으로 실행되어야 할 경우 공유 상태를 안전하게 관리하는 것이 필수적이다.</p>
<h3 id="_11">핸들러의 재사용과 매개변수 전달</h3>
<p>Boost.Bind와 Boost.Function을 사용하면 핸들러를 재사용하면서 매개변수를 다르게 전달할 수 있다. 즉, 동일한 핸들러 함수에 대해 여러 다른 매개변수 조합을 사용할 수 있다. 이를 통해 핸들러의 재사용성과 유연성을 극대화할 수 있다.</p>
<p>예를 들어, 다음과 같은 핸들러가 있다고 가정해 보자:</p>
<pre><code class="language-cpp">void reusable_handler(const boost::system::error_code&amp; error, int id, const std::string&amp; message) {
    if (!error) {
        std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; id &lt;&lt; &quot;, 메시지: &quot; &lt;&lt; message &lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; &quot;에러 발생: &quot; &lt;&lt; error.message() &lt;&lt; std::endl;
    }
}
</code></pre>
<p>이 핸들러는 <code>id</code>와 <code>message</code>라는 매개변수를 받아 특정 작업을 수행한다. Boost.Bind를 사용하여 이 핸들러에 다양한 매개변수를 전달할 수 있다:</p>
<pre><code class="language-cpp">io_service.post(boost::bind(&amp;reusable_handler, _1, 101, &quot;첫 번째 메시지&quot;));
io_service.post(boost::bind(&amp;reusable_handler, _1, 202, &quot;두 번째 메시지&quot;));
</code></pre>
<p>위 코드에서 <code>reusable_handler</code>는 동일한 함수지만, 매개변수로 각각 다른 <code>id</code>와 <code>message</code>를 전달받아 서로 다른 작업을 처리한다. 이렇게 핸들러를 재사용하면서 각기 다른 매개변수를 바인딩하는 방식은 비동기 작업에서 매우 유연하게 적용될 수 있다.</p>
<p>이러한 재사용 방식은 핸들러 로직을 반복적으로 작성할 필요 없이, 매개변수만 다르게 설정하여 다양한 비동기 작업을 처리할 수 있게 해준다. 이를 통해 코드의 중복을 줄이고 유지보수성을 향상시킬 수 있다.</p>
<h3 id="_12">핸들러와 함수 객체</h3>
<p>Boost.Bind와 Boost.Function을 사용하는 또 다른 방법은 사용자 정의 함수 객체를 핸들러로 사용하는 것이다. 함수 객체는 함수처럼 호출할 수 있는 객체로, 클래스의 연산자 <code>operator()</code>를 오버로드하여 구현된다. 이를 통해 핸들러에 필요한 상태나 데이터를 클래스 내부에서 관리할 수 있다.</p>
<p>함수 객체를 핸들러로 사용하는 예는 다음과 같다:</p>
<pre><code class="language-cpp">class TaskHandler {
public:
    void operator()(const boost::system::error_code&amp; error, int value) {
        if (!error) {
            std::cout &lt;&lt; &quot;값: &quot; &lt;&lt; value &lt;&lt; std::endl;
        } else {
            std::cerr &lt;&lt; &quot;에러 발생: &quot; &lt;&lt; error.message() &lt;&lt; std::endl;
        }
    }
};

TaskHandler handler;
io_service.post(boost::bind(handler, _1, 42));
</code></pre>
<p>이 예제에서 <code>TaskHandler</code>는 함수 객체로, 연산자 <code>operator()</code>를 오버로드하여 핸들러로서 동작할 수 있도록 만들었다. 비동기 작업이 완료되면 <code>TaskHandler</code> 객체가 호출되고, 결과 값을 처리하게 된다.</p>
<p>함수 객체는 상태를 저장할 수 있는 장점이 있다. 예를 들어, 함수 객체 내부에 추가적인 멤버 변수를 두어 핸들러가 호출될 때마다 상태를 유지하거나 갱신할 수 있다. 이는 복잡한 비동기 작업에서 핸들러의 상태 관리가 필요할 때 매우 유용하게 사용할 수 있다.</p>
<pre><code class="language-cpp">class StatefulHandler {
private:
    int call_count;

public:
    StatefulHandler() : call_count(0) {}

    void operator()(const boost::system::error_code&amp; error, int value) {
        if (!error) {
            call_count++;
            std::cout &lt;&lt; &quot;호출 횟수: &quot; &lt;&lt; call_count &lt;&lt; &quot;, 값: &quot; &lt;&lt; value &lt;&lt; std::endl;
        } else {
            std::cerr &lt;&lt; &quot;에러 발생: &quot; &lt;&lt; error.message() &lt;&lt; std::endl;
        }
    }
};
</code></pre>
<p>이 함수 객체는 <code>call_count</code>라는 멤버 변수를 통해 핸들러가 호출된 횟수를 기록하고 있다. 핸들러가 여러 번 호출되더라도 상태가 유지되며, 상태에 따라 다른 동작을 수행할 수 있다.</p>
<p>함수 객체를 핸들러로 사용하는 것은 매우 유연하며, 비동기 작업의 복잡성이 증가할수록 이 방법을 통해 코드의 재사용성을 높이고 상태 관리 문제를 해결할 수 있다.</p>
<h3 id="_13">핸들러에서의 비동기 흐름 제어</h3>
<p>비동기 작업이 연속적으로 실행되거나, 특정 조건에서 다음 작업이 이어서 수행되어야 하는 경우, 핸들러 내부에서 비동기 흐름 제어를 할 수 있다. 예를 들어, 핸들러가 호출된 후 다음 비동기 작업을 큐에 넣어 실행할 수 있다.</p>
<p>다음 예제는 핸들러에서 다른 비동기 작업을 다시 시작하는 구조를 보여준다:</p>
<pre><code class="language-cpp">void handler1(const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;첫 번째 작업 완료&quot; &lt;&lt; std::endl;
        io_service.post(boost::bind(&amp;handler2, _1));
    }
}

void handler2(const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;두 번째 작업 완료&quot; &lt;&lt; std::endl;
    }
}

io_service.post(boost::bind(&amp;handler1, _1));
</code></pre>
<p>여기서 첫 번째 핸들러인 <code>handler1</code>이 호출된 후, 두 번째 작업을 큐에 넣어 <code>handler2</code>가 실행되도록 한다. 이렇게 비동기 작업의 흐름을 제어하여 작업 간의 연속성을 보장할 수 있다.</p>
<p>또한, 여러 조건에 따라 비동기 작업의 흐름을 다르게 제어할 수도 있다. 예를 들어, 첫 번째 작업의 결과에 따라 두 번째 작업이 실행될지 말지를 결정할 수 있다:</p>
<pre><code class="language-cpp">void handler(const boost::system::error_code&amp; error, int value) {
    if (!error) {
        if (value &gt; 0) {
            io_service.post(boost::bind(&amp;next_handler, _1));
        } else {
            std::cout &lt;&lt; &quot;조건이 맞지 않아 다음 작업을 실행하지 않음&quot; &lt;&lt; std::endl;
        }
    }
}
</code></pre>
<p>이처럼 핸들러 내부에서 비동기 흐름을 동적으로 제어함으로써 복잡한 비동기 작업을 보다 유연하게 처리할 수 있다. 이러한 비동기 흐름 제어는 비동기 프로그래밍의 중요한 개념으로, 작업의 순서를 유연하게 관리할 수 있게 한다.</p>
<h3 id="_14">핸들러 전달을 통한 비동기 작업 구성</h3>
<p>비동기 프로그래밍에서 핸들러 전달과 매개변수 처리의 복잡성이 증가할 때, 코드를 모듈화하고 체계적으로 구성하는 것이 중요하다. 특히, 여러 개의 비동기 작업이 연속적으로 실행되거나, 핸들러 간의 협력이 필요한 경우 이러한 구조가 필요하다.</p>
<p>다음은 비동기 작업을 모듈화하여 핸들러를 전달하는 방법의 예이다:</p>
<pre><code class="language-cpp">class Task {
public:
    void start() {
        io_service.post(boost::bind(&amp;Task::step1, this, _1));
    }

    void step1(const boost::system::error_code&amp; error) {
        if (!error) {
            std::cout &lt;&lt; &quot;1단계 완료&quot; &lt;&lt; std::endl;
            io_service.post(boost::bind(&amp;Task::step2, this, _1));
        }
    }

    void step2(const boost::system::error_code&amp; error) {
        if (!error) {
            std::cout &lt;&lt; &quot;2단계 완료&quot; &lt;&lt; std::endl;
        }
    }
};
</code></pre>
<p>이 구조에서 <code>Task</code> 클래스는 여러 단계의 비동기 작업을 정의하고, 각 단계를 핸들러로 처리한다. 각 단계가 완료되면 다음 단계를 큐에 넣어 비동기 작업이 순차적으로 실행되도록 한다. 이러한 방식은 비동기 작업이 체계적으로 구성되고, 관리가 용이해진다.</p>
<p>비동기 작업이 많아질수록 핸들러의 모듈화와 전달 방식이 중요해진다. 코드를 깔끔하게 유지하면서도 비동기 흐름을 유연하게 관리할 수 있는 구조를 설계하는 것이 핵심이다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0505/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0505/" class="btn btn-xs btn-link">
        다중 핸들러 관리와 구조화
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0503/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0503/" class="btn btn-xs btn-link">
        람다 함수를 이용한 비동기 작업 처리
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>