<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/programming/cplusplus/cplusplus_boost_asio_programming/chapter_02/0206/" rel="canonical"/>
<link href="../../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>타이머를 이용한 비동기 작업 관리 - 실험 도서관</title>
<link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uae30\ubcf8\uc801\uc778 \ud0c0\uc774\uba38 \uc124\uc815", url: "#_top", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 \ud0c0\uc774\uba38\uc758 \ub3d9\uc791 \uc6d0\ub9ac", url: "#_2", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uc218\ud559\uc801 \ubaa8\ub378\ub9c1", url: "#_3", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \ucde8\uc18c \ubc0f \uc7ac\uc124\uc815", url: "#_4", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uc8fc\uae30\uc801 \uc2e4\ud589", url: "#_5", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \ube44\ub3d9\uae30 I/O\uc758 \uacb0\ud569", url: "#io", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \uc774\ubca4\ud2b8 \ud050", url: "#_6", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uc624\ub958 \ucc98\ub9ac", url: "#_7", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uace0\uae09 \uc751\uc6a9", url: "#_8", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \ub3d9\uae30\ud654", url: "#_9", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uc131\ub2a5 \uace0\ub824\uc0ac\ud56d", url: "#_10", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \uc2dc\uac04 \uae30\ubc18 \uc81c\ud55c", url: "#_11", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uc815\ubc00\ub3c4\uc640 \uc2dc\uc2a4\ud15c \ud074\ub85d", url: "#_12", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \uc2a4\ub808\ub4dc \uac04 \uc0c1\ud638\uc791\uc6a9", url: "#_13", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \ube44\ub3d9\uae30 \uc791\uc5c5\uc758 \uc870\ud569", url: "#_14", children: [
              {title: "\ud0c0\uc774\uba38\uc640 \uc0c1\ud0dc \uc804\uc774", url: "#_15" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \ud65c\uc6a9 \uc0ac\ub840", url: "#_16", children: [
          ]},
          {title: "\ud0c0\uc774\uba38 \uad00\ub828 \ucf54\ub4dc \ucd5c\uc801\ud654", url: "#_17", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \uc2dc\uc2a4\ud15c \uc790\uc6d0 \uad00\ub9ac", url: "#_18", children: [
          ]},
        ];

    </script>
<script src="../../../../../js/base.js"></script>
<script src="../../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0207/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0207/">
        비동기 입출력 스트림 관리
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0205/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0205/">
        비동기 작업 오류 처리
      </a>
</div>
</div>
<p>Boost.Asio에서는 타이머를 이용해 비동기 작업을 관리할 수 있는 강력한 기능을 제공한다. 타이머는 시간 기반 이벤트를 생성하여, 일정 시간이 지난 후 또는 특정 시간에 작업이 실행되도록 설계된다. 이를 통해 주기적인 작업, 지연 실행, 시간 제한 설정 등이 가능하며, 비동기 환경에서 타이머는 매우 중요한 역할을 한다.</p>
<h3 id="_1">기본적인 타이머 설정</h3>
<p>Boost.Asio에서는 <code>steady_timer</code>, <code>deadline_timer</code>, 그리고 <code>system_timer</code>라는 세 가지 주요 타이머 클래스를 제공한다. 이들은 각각의 시간 측정 기준과 사용 목적에 따라 다르게 동작한다.</p>
<ul>
<li><code>steady_timer</code>: 모노토닉 클록을 사용하며, 클록이 중단 없이 일정하게 증가하기 때문에 시스템 시간이 변경되더라도 영향을 받지 않는다.</li>
<li><code>system_timer</code>: 시스템 시간을 기준으로 하며, 시스템 시간이 변경되면 타이머의 만료 시간도 영향을 받는다.</li>
<li><code>deadline_timer</code>: 고정된 시간을 기준으로 설정하며, 일정 시간이 지나면 타이머가 만료된다.</li>
</ul>
<p>타이머는 다음과 같은 방식으로 설정할 수 있다.</p>
<pre><code class="language-cpp">boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(5));
</code></pre>
<p>위 코드는 5초 후에 만료되는 <code>steady_timer</code>를 설정한다. 이 타이머는 5초가 지나면 비동기 작업을 트리거할 수 있다.</p>
<h3 id="_2">비동기 타이머의 동작 원리</h3>
<p>비동기 타이머는 특정 시간이 지났을 때 핸들러를 호출하는 방식으로 동작한다. 타이머는 다음과 같이 <code>async_wait</code> 메서드를 사용하여 비동기 작업을 처리한다.</p>
<pre><code class="language-cpp">timer.async_wait([](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Timer expired!" &lt;&lt; std::endl;
    }
});
</code></pre>
<p>핸들러는 비동기 작업이 완료되었을 때 호출되며, 여기서 <code>error_code</code>는 타이머가 정상적으로 완료되었는지 또는 오류가 발생했는지를 나타낸다. 타이머가 만료되었을 때 <code>error_code</code>는 정상적인 완료를 의미하는 값인 <code>boost::system::errc::success</code>가 된다.</p>
<p>타이머의 동작 흐름은 이벤트 루프와 연관되어 있다. Boost.Asio의 <code>io_context</code>는 비동기 작업을 관리하는 핵심 객체로, 타이머가 만료되면 <code>io_context</code>에 등록된 핸들러가 실행된다.</p>
<h3 id="_3">타이머의 수학적 모델링</h3>
<p>비동기 타이머의 동작을 수학적으로 표현하면, 타이머의 동작은 다음과 같이 시간 함수 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에 의존하는 비동기 이벤트로 정의할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T(t) = 
\begin{cases} 
0 &amp; \text{if } t &lt; t_0 \\
1 &amp; \text{if } t \geq t_0
\end{cases}
</div>
<script type="math/tex; mode=display">
T(t) = 
\begin{cases} 
0 & \text{if } t < t_0 \\
1 & \text{if } t \geq t_0
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t_0</span><script type="math/tex">t_0</script></span>는 타이머가 설정된 만료 시간을 의미하며, <span class="arithmatex"><span class="MathJax_Preview">T(t)</span><script type="math/tex">T(t)</script></span>는 타이머가 만료된 후 발생하는 이벤트를 나타낸다. <span class="arithmatex"><span class="MathJax_Preview">T(t) = 1</span><script type="math/tex">T(t) = 1</script></span>인 경우, 타이머가 만료되어 핸들러가 호출된 상태를 의미한다.</p>
<p>이러한 타이머의 동작은 비동기 이벤트 루프 내에서 핸들러를 스케줄링하는 방식으로 관리되며, 시간 <span class="arithmatex"><span class="MathJax_Preview">t_0</span><script type="math/tex">t_0</script></span>에 해당하는 순간에 핸들러가 실행되도록 스케줄된다.</p>
<h3 id="_4">타이머의 취소 및 재설정</h3>
<p>타이머는 비동기적으로 동작하기 때문에, 타이머가 만료되기 전에 이를 취소하거나 재설정할 수 있다. 타이머의 취소는 <code>cancel</code> 메서드를 통해 가능한다.</p>
<pre><code class="language-cpp">timer.cancel();
</code></pre>
<p>위 코드는 타이머를 취소하여 더 이상 만료 이벤트가 발생하지 않도록 한다. 취소된 타이머의 핸들러는 호출되지 않는다. 또한, 이미 실행 중인 타이머를 재설정하는 경우는 다음과 같이 할 수 있다.</p>
<pre><code class="language-cpp">timer.expires_after(boost::asio::chrono::seconds(10));
</code></pre>
<p>위 코드는 타이머의 만료 시간을 10초로 재설정한다. 이때 기존의 타이머 이벤트는 무효화되며 새로운 만료 시간이 설정된다.</p>
<h3 id="_5">타이머의 주기적 실행</h3>
<p>비동기 프로그래밍에서 타이머를 주기적으로 실행하는 것은 매우 일반적인 시나리오이다. 이를 구현하기 위해서는 타이머가 만료될 때마다 타이머를 다시 설정하고, 다음 주기 동안 기다리는 패턴을 사용할 수 있다. 예를 들어, 1초마다 주기적으로 실행되는 타이머는 다음과 같이 구현할 수 있다.</p>
<pre><code class="language-cpp">void start_timer(boost::asio::steady_timer&amp; timer) {
    timer.async_wait([&amp;timer](const boost::system::error_code&amp; ec) {
        if (!ec) {
            std::cout &lt;&lt; "Timer triggered!" &lt;&lt; std::endl;
            // 타이머를 다시 시작하여 주기적으로 실행
            timer.expires_after(boost::asio::chrono::seconds(1));
            start_timer(timer);
        }
    });
}
</code></pre>
<p>이 코드에서 타이머가 만료될 때마다 <code>expires_after</code>를 호출하여 타이머의 만료 시간을 다시 설정하고, <code>start_timer</code> 함수가 재귀적으로 호출된다. 이 방식은 비동기 타이머를 무한히 주기적으로 실행할 수 있도록 만든다.</p>
<p>이 방식의 수학적 표현은 주기 <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>에 대해 주기적으로 타이머가 동작하는 함수로 정의할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T(t) = 
\begin{cases} 
1 &amp; \text{if } t = t_0 + nP \quad (n = 0, 1, 2, \dots) \\
0 &amp; \text{otherwise}
\end{cases}
</div>
<script type="math/tex; mode=display">
T(t) = 
\begin{cases} 
1 & \text{if } t = t_0 + nP \quad (n = 0, 1, 2, \dots) \\
0 & \text{otherwise}
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t_0</span><script type="math/tex">t_0</script></span>는 타이머의 초기 설정 시간, <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>는 주기, 그리고 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>은 주기의 횟수를 의미한다. 이 모델에 따르면, 타이머는 <span class="arithmatex"><span class="MathJax_Preview">t = t_0 + nP</span><script type="math/tex">t = t_0 + nP</script></span>일 때마다 비동기 핸들러를 호출하게 된다.</p>
<h3 id="io">타이머와 비동기 I/O의 결합</h3>
<p>타이머는 비동기 I/O 작업과 결합하여 복잡한 작업을 제어하는 데에도 사용할 수 있다. 예를 들어, 특정 I/O 작업에 시간 제한을 설정하려는 경우, 타이머와 비동기 I/O 작업을 동시에 실행하고, 타이머가 먼저 만료되면 I/O 작업을 취소하는 방식으로 사용할 수 있다.</p>
<pre><code class="language-cpp">boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(5));
boost::asio::ip::tcp::socket socket(io_context);

timer.async_wait([&amp;socket](const boost::system::error_code&amp; ec) {
    if (!ec) {
        // 타이머가 만료되었으므로 소켓 작업을 취소
        socket.cancel();
    }
});

socket.async_connect(endpoint, [](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Connected!" &lt;&lt; std::endl;
    }
});
</code></pre>
<p>위 코드에서 소켓 연결을 시도하면서 동시에 5초짜리 타이머를 설정한다. 만약 소켓이 5초 이내에 연결되지 않으면 타이머 핸들러가 호출되어 소켓 작업을 취소한다. 이렇게 타이머를 비동기 I/O 작업과 결합함으로써, 제한된 시간 내에 작업을 완료하거나 중단하는 로직을 구현할 수 있다.</p>
<h3 id="_6">타이머와 이벤트 큐</h3>
<p>비동기 타이머는 Boost.Asio의 이벤트 큐와 밀접하게 연관되어 동작한다. 타이머가 설정되면 <code>io_context</code>에 해당 타이머 이벤트가 등록되며, 타이머가 만료되면 이벤트 큐에 핸들러가 추가된다. 이벤트 큐는 비동기 작업의 순서를 관리하며, 큐에 등록된 작업들이 차례로 실행된다.</p>
<p>이를 시각적으로 다이어그램을 이용해 설명하면 다음과 같다.</p>
<div class="mermaid">graph LR
    A[타이머 설정] --&gt; B[타이머 이벤트 등록]
    B --&gt; C{타이머 만료}
    C --&gt;|만료됨| D[핸들러 실행]
    C --&gt;|만료 안됨| B
</div>
<p>이 다이어그램에서 타이머는 설정되면 이벤트 큐에 등록되며, 시간이 지나면 만료 이벤트가 발생하고, 핸들러가 실행된다. 타이머가 만료되지 않았을 경우, 다시 큐에 남아 다음 이벤트를 대기하게 된다.</p>
<h3 id="_7">타이머의 오류 처리</h3>
<p>비동기 타이머에서도 오류 처리는 중요한 부분이다. 예를 들어, 시스템 클록이 변경되거나 타이머가 비정상적으로 취소될 경우, 타이머의 핸들러는 오류 코드를 통해 이러한 상황을 처리할 수 있다. 타이머의 오류 처리는 <code>boost::system::error_code</code>를 통해 이루어진다.</p>
<pre><code class="language-cpp">timer.async_wait([](const boost::system::error_code&amp; ec) {
    if (ec) {
        std::cerr &lt;&lt; "Timer error: " &lt;&lt; ec.message() &lt;&lt; std::endl;
    }
});
</code></pre>
<p>오류 코드는 타이머의 동작이 예상치 못한 상황에서 어떻게 처리될지를 결정하며, 비동기 작업에서는 항상 이러한 오류를 대비한 처리가 필요하다.</p>
<h3 id="_8">타이머의 고급 응용</h3>
<p>복잡한 비동기 시스템에서는 여러 타이머를 사용하여 다양한 작업을 관리하는 경우가 있다. 예를 들어, 여러 개의 타이머를 동시에 실행하여 각각 다른 작업을 비동기적으로 처리할 수 있다. 이를 통해 다양한 시간 기반 작업을 동시다발적으로 처리할 수 있으며, 비동기 타이머는 이러한 시스템에서 핵심적인 역할을 한다.</p>
<h3 id="_9">타이머와 동기화</h3>
<p>멀티스레드 환경에서 타이머를 사용할 때는 동기화 문제를 주의 깊게 다루어야 한다. 비동기 타이머는 기본적으로 하나의 스레드에서 관리되지만, 여러 스레드에서 동일한 타이머를 접근하거나 사용하는 경우에는 동기화 문제가 발생할 수 있다. 이를 해결하기 위해 Boost.Asio의 <code>strand</code>를 활용할 수 있다. <code>strand</code>는 핸들러의 실행 순서를 보장하여, 여러 스레드에서 동일한 핸들러가 동시에 실행되지 않도록 보호해준다.</p>
<pre><code class="language-cpp">boost::asio::strand&lt;boost::asio::io_context::executor_type&gt; strand(io_context.get_executor());
boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(1));

timer.async_wait(boost::asio::bind_executor(strand, [](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Timer triggered in strand!" &lt;&lt; std::endl;
    }
}));
</code></pre>
<p>위 코드에서는 <code>strand</code>를 사용하여 타이머 핸들러가 여러 스레드에서 동시에 실행되지 않도록 보장한다. 이 방식은 멀티스레드 환경에서 타이머와 비동기 작업을 안전하게 관리하는 데 유용하다.</p>
<h3 id="_10">타이머의 성능 고려사항</h3>
<p>비동기 프로그래밍에서 타이머를 많이 사용하는 경우, 성능이 중요한 고려사항이 될 수 있다. 특히 많은 타이머가 동시에 사용되거나 매우 짧은 주기로 반복되는 경우, 타이머 관리와 이벤트 큐 처리에서 성능 저하가 발생할 수 있다. 이러한 성능 문제를 완화하기 위해 Boost.Asio는 타이머의 효율적인 처리를 위한 다양한 최적화 기법을 제공한다.</p>
<ul>
<li><strong>타이머 풀링</strong>: 다수의 타이머를 관리할 때, 각각의 타이머를 독립적으로 생성하기보다는 타이머 풀(pool)을 사용하여 타이머 객체를 재사용하는 방식이 유리할 수 있다.</li>
<li><strong>짧은 주기의 타이머</strong>: 짧은 시간 간격으로 반복되는 타이머의 경우, 주기적인 작업을 최적화하여 타이머의 재설정을 최소화하거나, 타이머가 아닌 다른 시간 측정 방법을 고려할 수 있다.</li>
</ul>
<p>성능에 대한 수학적 모델링은 타이머의 이벤트 발생 빈도를 기반으로 표현할 수 있다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>개의 타이머가 주기적으로 실행되고 각각의 타이머가 주기 <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>로 실행된다면, 총 이벤트 발생 빈도는 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
F_{\text{total}} = \frac{N}{P}
</div>
<script type="math/tex; mode=display">
F_{\text{total}} = \frac{N}{P}
</script>
</div>
<p>이때, 이벤트 큐가 처리할 수 있는 최대 빈도 <span class="arithmatex"><span class="MathJax_Preview">F_{\text{max}}</span><script type="math/tex">F_{\text{max}}</script></span>를 초과하면 성능 저하가 발생할 수 있다. 따라서 <span class="arithmatex"><span class="MathJax_Preview">F_{\text{total}} \leq F_{\text{max}}</span><script type="math/tex">F_{\text{total}} \leq F_{\text{max}}</script></span>를 유지하도록 타이머의 주기를 설정하거나 타이머의 개수를 조정해야 한다.</p>
<h3 id="_11">타이머와 시간 기반 제한</h3>
<p>비동기 작업에서 타이머를 사용하여 작업에 시간 제한을 두는 것은 매우 유용한 패턴이다. 예를 들어, 특정 작업이 주어진 시간 내에 완료되지 않으면 그 작업을 취소하거나, 다른 대체 작업을 수행할 수 있다. 이러한 패턴은 네트워크 통신, 파일 입출력 등에서 자주 사용된다.</p>
<pre><code class="language-cpp">boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(5));
boost::asio::ip::tcp::socket socket(io_context);

timer.async_wait([&amp;socket](const boost::system::error_code&amp; ec) {
    if (!ec) {
        // 시간 초과 시 소켓 작업을 취소
        socket.close();
        std::cout &lt;&lt; "Operation timed out" &lt;&lt; std::endl;
    }
});

socket.async_connect(endpoint, [](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Connected!" &lt;&lt; std::endl;
    }
});
</code></pre>
<p>이 코드는 소켓 연결 작업에 5초의 시간 제한을 두고, 제한 시간이 초과되면 연결을 취소하는 로직이다. 이러한 시간 기반 제한은 비동기 프로그래밍에서 중요한 기능 중 하나이다.</p>
<h3 id="_12">타이머의 정밀도와 시스템 클록</h3>
<p>타이머의 정밀도는 사용하는 클록에 따라 달라진다. <code>steady_timer</code>는 모노토닉 클록을 기반으로 하여, 높은 정밀도를 유지하면서 일정한 시간 간격으로 타이머를 실행할 수 있다. 반면, <code>system_timer</code>는 시스템 시간을 사용하므로, 시스템 시간이 변경될 경우 타이머의 정밀도가 떨어질 수 있다. 따라서, 시스템의 특성과 요구 사항에 따라 적절한 타이머 유형을 선택하는 것이 중요하다.</p>
<p>정밀도를 수학적으로 표현하면, 타이머의 실제 실행 시간이 설정된 시간과의 차이를 나타내는 오차 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>를 고려할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\Delta t = |t_{\text{실제}} - t_{\text{설정}}|
</div>
<script type="math/tex; mode=display">
\Delta t = |t_{\text{실제}} - t_{\text{설정}}|
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t_{\text{실제}}</span><script type="math/tex">t_{\text{실제}}</script></span>는 타이머가 실제로 실행된 시간, <span class="arithmatex"><span class="MathJax_Preview">t_{\text{설정}}</span><script type="math/tex">t_{\text{설정}}</script></span>은 설정된 만료 시간을 의미한다. 일반적으로 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 타이머가 사용하는 클록의 정밀도에 따라 달라지며, 모노토닉 클록은 일반적으로 시스템 클록보다 정밀도가 높다.</p>
<h3 id="_13">타이머와 스레드 간 상호작용</h3>
<p>타이머는 비동기 작업이므로, 스레드와 결합하여 동작할 수 있다. 특히, 멀티스레드 환경에서 타이머를 사용하면 각각의 스레드에서 독립적으로 타이머를 관리하거나, 타이머의 결과를 다른 스레드에서 처리할 수 있다. 이를 위해 <code>strand</code>를 사용하여 핸들러의 실행을 동기화하거나, 스레드 간의 작업을 조정하는 방식이 필요하다.</p>
<p>멀티스레드 환경에서 타이머가 스레드 간 어떻게 상호작용하는지를 설명하는 다이어그램은 다음과 같다.</p>
<div class="mermaid">graph TD
    A[스레드 1] --&gt;|타이머 시작| B[타이머 핸들러 실행]
    B --&gt;|타이머 만료| C[스레드 2에서 결과 처리]
    C --&gt;|다음 타이머 설정| A
</div>
<p>이 구조에서는 스레드 1에서 타이머를 설정하고, 타이머가 만료되면 핸들러가 실행되어 스레드 2에서 결과를 처리하는 방식으로 동작한다. 이러한 구조를 통해 스레드 간의 상호작용을 타이머와 결합하여 효율적으로 처리할 수 있다.</p>
<h3 id="_14">타이머와 비동기 작업의 조합</h3>
<p>타이머는 비동기 작업과 결합하여 다양한 응용 사례에 활용된다. 예를 들어, 네트워크 프로토콜에서 일정 시간 동안 응답이 없을 경우 타임아웃을 설정하여 연결을 종료하거나 재시도하는 등의 작업에 타이머를 사용할 수 있다. 또한, 데이터베이스와 같은 I/O가 많은 작업에서도 시간 제한을 두어 리소스를 효율적으로 관리할 수 있다.</p>
<p>특히, 타이머는 복잡한 비동기 상태 관리에서 중요한 역할을 한다. 비동기 작업에서 타이머는 상태 전환을 트리거하는 이벤트로 사용될 수 있다. 예를 들어, 상태 기반의 비동기 작업을 진행하는 도중 특정 상태에서 일정 시간이 지나면 다음 상태로 자동으로 넘어가는 시스템을 구현할 수 있다.</p>
<h4 id="_15">타이머와 상태 전이</h4>
<p>상태 기반의 비동기 작업에서 타이머를 이용하여 자동으로 상태를 전이시키는 것은 매우 유용한 패턴이다. 다음은 상태 머신과 타이머를 결합한 비동기 상태 전이 예시이다.</p>
<pre><code class="language-cpp">enum class State { IDLE, WORKING, WAITING, DONE };
State current_state = State::IDLE;

boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(3));

void handle_timer(const boost::system::error_code&amp; ec) {
    if (!ec) {
        switch (current_state) {
            case State::IDLE:
                std::cout &lt;&lt; "Transition to WORKING state" &lt;&lt; std::endl;
                current_state = State::WORKING;
                timer.expires_after(boost::asio::chrono::seconds(5));
                timer.async_wait(handle_timer);
                break;
            case State::WORKING:
                std::cout &lt;&lt; "Transition to WAITING state" &lt;&lt; std::endl;
                current_state = State::WAITING;
                timer.expires_after(boost::asio::chrono::seconds(2));
                timer.async_wait(handle_timer);
                break;
            case State::WAITING:
                std::cout &lt;&lt; "Transition to DONE state" &lt;&lt; std::endl;
                current_state = State::DONE;
                break;
            default:
                break;
        }
    }
}
</code></pre>
<p>위 코드에서 타이머는 상태 전이의 트리거로 사용된다. 처음 <code>IDLE</code> 상태에서 <code>WORKING</code> 상태로 전이되고, 일정 시간이 지나면 <code>WAITING</code> 상태로 넘어간다. 마지막으로 <code>DONE</code> 상태로 전이되면서 타이머는 더 이상 동작하지 않는다. 이렇게 타이머를 활용한 상태 머신은 비동기 작업에서 매우 유용하며, 복잡한 상태 전이를 간단하게 구현할 수 있다.</p>
<p>수학적으로 상태 전이를 모델링하면, 상태 <span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>는 시간에 따른 함수 <span class="arithmatex"><span class="MathJax_Preview">f(t)</span><script type="math/tex">f(t)</script></span>로 나타낼 수 있으며, 타이머가 작동함에 따라 상태가 전이된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S(t) = 
\begin{cases}
\text{IDLE} &amp; 0 \leq t &lt; t_1 \\
\text{WORKING} &amp; t_1 \leq t &lt; t_2 \\
\text{WAITING} &amp; t_2 \leq t &lt; t_3 \\
\text{DONE} &amp; t \geq t_3
\end{cases}
</div>
<script type="math/tex; mode=display">
S(t) = 
\begin{cases}
\text{IDLE} & 0 \leq t < t_1 \\
\text{WORKING} & t_1 \leq t < t_2 \\
\text{WAITING} & t_2 \leq t < t_3 \\
\text{DONE} & t \geq t_3
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t_1, t_2, t_3</span><script type="math/tex">t_1, t_2, t_3</script></span>는 각각 타이머에 의해 트리거되는 상태 전이 시점을 나타낸다.</p>
<h3 id="_16">타이머의 활용 사례</h3>
<p>타이머는 다양한 시스템에서 시간 기반의 작업을 처리하기 위한 필수 도구로 사용된다. 여기 몇 가지 타이머의 활용 사례를 소개한다.</p>
<ol>
<li><strong>네트워크 연결 관리</strong>: 비동기 네트워크 프로그래밍에서 일정 시간 내에 연결이 이루어지지 않으면 타이머를 이용해 타임아웃을 발생시키고 연결을 종료하는 방식으로 자원을 효율적으로 관리한다.</li>
<li><strong>주기적인 작업 스케줄링</strong>: 시스템 모니터링이나 주기적인 로그 파일 업데이트와 같이, 일정 시간 간격으로 반복되어야 하는 작업을 타이머를 이용하여 자동으로 실행할 수 있다.</li>
<li><strong>시간 제한을 둔 리소스 접근</strong>: 데이터베이스나 파일 I/O와 같은 작업에서 타이머를 사용해 리소스 접근에 시간 제한을 두어, 특정 작업이 제한 시간 내에 완료되지 않으면 작업을 취소하고 시스템의 과부하를 방지할 수 있다.</li>
<li><strong>UI 애플리케이션의 비동기 작업</strong>: 사용자 인터페이스(UI) 애플리케이션에서 타이머를 이용해 비동기적으로 UI 업데이트를 처리하거나, 일정 시간 후에 자동으로 작업을 수행하는 기능을 구현할 수 있다.</li>
</ol>
<h3 id="_17">타이머 관련 코드 최적화</h3>
<p>비동기 타이머의 구현에서는 최적화가 중요한 요소 중 하나이다. 특히, 짧은 간격으로 주기적인 작업을 수행하거나 다수의 타이머를 동시에 관리해야 하는 경우, 불필요한 성능 저하를 방지하기 위한 최적화 전략이 필요하다. 몇 가지 최적화 기법은 다음과 같다.</p>
<ul>
<li><strong>타이머의 재사용</strong>: 동일한 타이머 객체를 여러 번 재설정하여 사용하는 방식으로, 매번 새로운 타이머 객체를 생성하는 오버헤드를 줄일 수 있다.</li>
<li><strong>타이머 큐의 효율적 관리</strong>: 많은 수의 타이머를 관리해야 하는 경우, 타이머 큐를 효율적으로 관리하여 각 타이머의 만료 시간을 기준으로 큐를 정렬하고, 가장 빠른 타이머만 처리하는 방식으로 성능을 향상시킬 수 있다.</li>
</ul>
<p>타이머 큐의 효율적인 관리 방식을 수학적으로 모델링하면, 각 타이머의 만료 시간을 <span class="arithmatex"><span class="MathJax_Preview">t_i</span><script type="math/tex">t_i</script></span>라 할 때, 모든 타이머에 대해 최소 만료 시간을 찾는 작업은 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
t_{\text{min}} = \min(t_1, t_2, \dots, t_n)
</div>
<script type="math/tex; mode=display">
t_{\text{min}} = \min(t_1, t_2, \dots, t_n)
</script>
</div>
<p>이때 <span class="arithmatex"><span class="MathJax_Preview">t_{\text{min}}</span><script type="math/tex">t_{\text{min}}</script></span>에 해당하는 타이머가 먼저 처리되며, 나머지 타이머는 계속 큐에 남아 대기하게 된다. 이를 통해 비동기 타이머의 처리 순서를 효율적으로 관리할 수 있다.</p>
<h3 id="_18">타이머와 시스템 자원 관리</h3>
<p>비동기 타이머는 시스템 자원을 효율적으로 관리하는 데에도 중요한 역할을 한다. 비동기 타이머는 주기적으로 자원을 모니터링하거나, 일정 시간이 지나면 자원을 해제하는 작업을 자동으로 처리할 수 있다. 예를 들어, 네트워크 소켓의 유휴 상태를 감지하고, 일정 시간 동안 유휴 상태가 지속되면 타이머를 통해 소켓을 닫는 방식으로 리소스를 절약할 수 있다.</p>
<p>또한, 타이머를 사용하여 시스템의 메모리, CPU 사용량을 모니터링하고, 특정 임계값을 초과할 경우 경고를 발생시키거나 자원을 자동으로 해제하는 등의 작업을 구현할 수 있다. 이러한 타이머 기반의 자원 관리 시스템은 특히 대규모 분산 시스템에서 자원 사용의 효율성을 극대화하는 데 중요한 역할을 한다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0207/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0207/">
        비동기 입출력 스트림 관리
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0205/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0205/">
        비동기 작업 오류 처리
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>