<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/programming/cplusplus/cplusplus_boost_asio_programming/chapter_02/0203/" rel="canonical"/>
<link href="../../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>콜백 함수와 핸들러 - 소프트웨어 융합</title>
<link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ucf5c\ubc31 \ud568\uc218\uc758 \uc77c\ubc18\uc801\uc778 \uad6c\uc870", url: "#_top", children: [
          ]},
          {title: "\ud578\ub4e4\ub7ec\uc758 \uc5ed\ud560\uacfc \uad6c\uc870", url: "#_2", children: [
          ]},
          {title: "\ucf5c\ubc31 \ud568\uc218\uc758 \uc7a5\ub2e8\uc810", url: "#_3", children: [
          ]},
          {title: "\ud578\ub4e4\ub7ec \ubc14\uc778\ub529", url: "#_4", children: [
          ]},
          {title: "C++11 Lambda\ub97c \ud65c\uc6a9\ud55c \ucf5c\ubc31 \ud568\uc218 \uc815\uc758", url: "#c11-lambda", children: [
          ]},
          {title: "\ucf5c\ubc31 \ud568\uc218\uc640 \uc0c1\ud0dc \uad00\ub9ac", url: "#_5", children: [
              {title: "\uc0c1\ud0dc\ub97c \uc774\uc6a9\ud55c \ucf5c\ubc31 \ud568\uc218 \uc608\uc81c", url: "#_6" },
          ]},
          {title: "\ud578\ub4e4\ub7ec \ub514\uc2a4\ud328\uce6d", url: "#_7", children: [
              {title: "dispatch\uc640 post\uc758 \ucc28\uc774", url: "#dispatch-post" },
          ]},
          {title: "\ud578\ub4e4\ub7ec \ub3d9\uae30\ud654: Strand\uc758 \ud65c\uc6a9", url: "#strand", children: [
              {title: "Strand \uc0ac\uc6a9 \uc608\uc81c", url: "#strand_1" },
          ]},
          {title: "\ud578\ub4e4\ub7ec \ub3d9\uae30\ud654: Strand\uc758 \ub0b4\ubd80 \ub3d9\uc791", url: "#strand_2", children: [
          ]},
          {title: "Strand\uc758 \uc608\uc2dc: \uba40\ud2f0\uc2a4\ub808\ub4dc \ud658\uacbd\uc5d0\uc11c\uc758 \ub3d9\uc791", url: "#strand_3", children: [
          ]},
          {title: "\ud578\ub4e4\ub7ec\uc640 \uc608\uc678 \ucc98\ub9ac", url: "#_8", children: [
              {title: "\uc608\uc678 \ucc98\ub9ac\uac00 \ud3ec\ud568\ub41c \ud578\ub4e4\ub7ec \uc608\uc2dc", url: "#_9" },
          ]},
          {title: "\ube44\ub3d9\uae30 \uc791\uc5c5\uc758 \uc2e4\ud589 \ud750\ub984", url: "#_10", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 \ucf5c\ubc31 \ud568\uc218 \uccb4\uc774\ub2dd", url: "#_11", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 \ucf5c\ubc31 \ud568\uc218 \uccb4\uc774\ub2dd\uc758 \uc608\uc2dc", url: "#_12", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 \ucf5c\ubc31 \ud568\uc218 \uccb4\uc774\ub2dd\uacfc \uc624\ub958 \ucc98\ub9ac", url: "#_13", children: [
          ]},
          {title: "\ucf5c\ubc31 \ud568\uc218\uc758 \uc218\uba85 \uad00\ub9ac", url: "#_14", children: [
              {title: "shared_ptr\uc744 \uc0ac\uc6a9\ud55c \uc548\uc804\ud55c \ucf5c\ubc31 \ud568\uc218 \uc608\uc2dc", url: "#shared_ptr" },
          ]},
          {title: "\ud578\ub4e4\ub7ec\uc758 \uc131\ub2a5 \ucd5c\uc801\ud654", url: "#_15", children: [
          ]},
        ];

    </script>
<script src="../../../../../js/base.js"></script>
<script src="../../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0204/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0204/">
        비동기 작업의 스케줄링
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0202/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0202/">
        비동기 작업 실행 흐름
      </a>
</div>
</div>
<p>비동기 프로그래밍에서 콜백 함수와 핸들러는 매우 중요한 개념이다. 기본적으로 비동기 작업의 완료 시점을 명시적으로 관리하기 위해 콜백 함수(callback function)와 핸들러(handler)가 사용된다. 이 개념들은 일반적으로 비동기 작업이 완료될 때 호출되어 작업 결과를 처리하거나 후속 작업을 수행하는 역할을 한다.</p>
<p>콜백 함수는 프로그램의 특정 시점에 호출되도록 미리 등록된 함수다. 비동기 작업을 실행할 때, 그 작업이 완료되면 미리 지정된 콜백 함수가 호출된다. 콜백 함수는 비동기 작업이 완료된 후 발생할 동작을 정의하며, 이 함수의 호출은 작업의 성공 또는 실패 여부와 관계없이 이루어진다. 핸들러는 이러한 콜백 함수의 한 형태로, Boost.Asio에서는 핸들러라는 용어를 콜백 함수와 동의어로 사용한다.</p>
<h3 id="_1">콜백 함수의 일반적인 구조</h3>
<p>콜백 함수는 특정 비동기 작업이 완료된 시점에서 호출되는 함수로서, 대개 다음과 같은 형태로 정의된다:</p>
<pre><code class="language-cpp">void my_callback(const boost::system::error_code&amp; ec) {
    if (!ec) {
        // 성공적인 작업 완료 시 처리할 로직
    } else {
        // 오류 처리 로직
    }
}
</code></pre>
<p>여기서 <code>boost::system::error_code</code>는 작업의 성공 여부를 나타내는 매개변수로, 오류가 발생했을 때 오류 코드를 담고 있다. 이 매개변수는 콜백 함수에서 성공 여부를 검사하여 적절한 로직을 실행하는데 사용된다.</p>
<h3 id="_2">핸들러의 역할과 구조</h3>
<p>핸들러는 비동기 작업의 결과를 처리하는 책임을 지는 콜백 함수로 볼 수 있다. 비동기 작업이 성공적으로 완료되었는지 여부에 따라 작업의 후속 처리를 수행하거나, 오류가 발생한 경우 오류 처리 작업을 수행한다. Boost.Asio에서 핸들러는 비동기 작업과 밀접하게 연관되어 있으며, 작업의 결과를 핸들링할 때 주로 사용된다.</p>
<p>핸들러의 구조는 대체로 콜백 함수와 유사하며, Boost.Asio에서는 비동기 작업의 완료 시점에 호출되는 콜백 함수로서 작동한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(\mathbf{x}) = 
\begin{cases} 
\text{작업 성공 시 처리할 로직} &amp; \text{if } ec = 0 \\
\text{오류 처리 로직} &amp; \text{if } ec \neq 0
\end{cases}
</div>
<script type="math/tex; mode=display">
f(\mathbf{x}) = 
\begin{cases} 
\text{작업 성공 시 처리할 로직} & \text{if } ec = 0 \\
\text{오류 처리 로직} & \text{if } ec \neq 0
\end{cases}
</script>
</div>
<h3 id="_3">콜백 함수의 장단점</h3>
<p>비동기 프로그래밍에서 콜백 함수의 주요 장점은 비동기 작업의 흐름을 간결하게 관리할 수 있다는 점이다. 콜백 함수는 작업이 완료된 즉시 호출되므로, 별도의 작업 완료 확인 로직을 작성할 필요가 없다. 하지만, 콜백 함수를 과도하게 사용하게 되면 코드의 복잡도가 증가하고, 가독성이 떨어지는 문제점이 있다. 이는 흔히 "콜백 지옥(callback hell)"이라고 불리며, 콜백 함수가 중첩되거나 체이닝되면서 코드가 읽기 어려워지는 상황을 초래할 수 있다.</p>
<p>콜백 함수와 핸들러는 비동기 프로그래밍에서 중요한 개념이며, Boost.Asio의 비동기 작업 모델에서 이 둘을 이해하는 것은 필수적이다. Boost.Asio에서는 비동기 작업을 수행한 후, 완료 시점에 콜백 함수 또는 핸들러를 호출함으로써 후속 작업을 관리한다.</p>
<h3 id="_4">핸들러 바인딩</h3>
<p>콜백 함수 또는 핸들러는 다양한 방식으로 바인딩할 수 있다. Boost.Asio에서는 <code>boost::bind</code> 또는 C++11 이후부터 제공되는 <code>std::bind</code>를 사용하여 핸들러를 바인딩할 수 있다. 이를 통해 콜백 함수에 추가적인 매개변수를 전달하거나, 클래스의 멤버 함수를 콜백 함수로 등록할 수 있다.</p>
<pre><code class="language-cpp">boost::asio::io_service io_service;
boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5));

timer.async_wait(boost::bind(&amp;my_callback, _1));
</code></pre>
<p>위의 예제에서는 타이머의 비동기 대기 작업이 완료되었을 때, <code>my_callback</code> 함수가 호출된다. 이때, <code>boost::bind</code>를 통해 핸들러에 오류 코드를 전달하는 방식으로 바인딩한다.</p>
<h3 id="c11-lambda">C++11 Lambda를 활용한 콜백 함수 정의</h3>
<p>C++11 이후로는 <code>std::bind</code> 대신 Lambda를 사용하여 보다 간결한 방식으로 콜백 함수를 정의할 수 있다. Lambda는 짧은 코드 블록을 하나의 함수처럼 취급할 수 있어, 콜백 함수 작성 시 매우 유용하다.</p>
<pre><code class="language-cpp">timer.async_wait([](const boost::system::error_code&amp; ec) {
    if (!ec) {
        // 타이머 완료 처리 로직
    } else {
        // 오류 처리
    }
});
</code></pre>
<p>Lambda를 사용하면 코드의 간결성이 향상되며, 콜백 함수의 인라인 정의가 가능해져 코드 가독성이 증가한다.</p>
<h3 id="_5">콜백 함수와 상태 관리</h3>
<p>비동기 작업을 수행할 때, 단순히 작업의 완료 여부만 처리하는 경우도 있지만, 복잡한 비동기 작업 흐름을 처리할 때는 상태를 관리해야 할 필요가 생긴다. 이때 콜백 함수는 여러 상태를 적절히 관리하면서 비동기 작업의 흐름을 제어할 수 있다.</p>
<p>콜백 함수 내에서 상태를 관리하기 위해 전역 변수를 사용하거나, 특정 객체의 멤버 변수를 이용하는 방법이 있다. 하지만 이러한 방식은 코드의 복잡성을 증가시키고, 특히 다중 스레드 환경에서 동시성 문제를 일으킬 수 있다. 이러한 문제를 방지하기 위해, 콜백 함수 내에서 상태를 관리할 수 있는 구조체나 클래스를 정의하는 방식이 주로 사용된다.</p>
<h4 id="_6">상태를 이용한 콜백 함수 예제</h4>
<p>아래 예제는 간단한 상태 관리 콜백 함수의 구조를 보여준다.</p>
<pre><code class="language-cpp">struct async_task {
    int state;
    void operator()(const boost::system::error_code&amp; ec) {
        if (!ec) {
            if (state == 0) {
                // 첫 번째 비동기 작업 성공
                state = 1;
                // 두 번째 비동기 작업 시작
            } else if (state == 1) {
                // 두 번째 비동기 작업 성공
                // 이후의 작업 처리
            }
        } else {
            // 오류 처리
        }
    }
};
</code></pre>
<p>여기서 <code>async_task</code>는 작업의 상태를 관리하는 구조체로, <code>state</code> 변수를 통해 각 작업이 어느 단계에 있는지 확인하고 적절한 로직을 수행할 수 있다. 이와 같은 방식으로 콜백 함수는 단순한 작업 흐름뿐만 아니라, 복잡한 상태 기반의 비동기 작업도 처리할 수 있다.</p>
<h3 id="_7">핸들러 디스패칭</h3>
<p>Boost.Asio에서는 비동기 작업이 완료되었을 때 핸들러를 호출하는 방식으로 콜백 함수가 실행되지만, 핸들러의 실행 시점과 스레드 모델에 따라 그 디스패칭(dispatching) 방식이 달라질 수 있다.</p>
<p>핸들러 디스패칭의 주요 메커니즘으로는 <code>dispatch</code>, <code>post</code>, 그리고 <code>defer</code>가 있다.</p>
<ul>
<li><strong>dispatch</strong>: 핸들러를 즉시 실행한다. 현재 실행 중인 스레드가 비동기 작업을 처리할 수 있는 상황이면, 해당 핸들러는 바로 실행된다. 그렇지 않은 경우에는 핸들러가 대기열에 들어간다.</li>
<li><strong>post</strong>: 핸들러를 나중에 실행되도록 대기열에 넣는다. 이는 즉각적인 실행을 보장하지 않으며, 작업 스케줄링을 통해 이후에 실행된다.</li>
<li><strong>defer</strong>: <code>post</code>와 유사하게 핸들러를 대기열에 넣지만, 특히 현재 스레드가 비동기 작업을 처리할 수 있는 경우라면 해당 핸들러의 실행을 지연시키는 특징을 가진다.</li>
</ul>
<p>이 세 가지 메커니즘을 이해하면 핸들러의 실행 타이밍을 제어하는 데 큰 도움이 된다.</p>
<h4 id="dispatch-post">dispatch와 post의 차이</h4>
<p><code>dispatch</code>와 <code>post</code>의 차이를 명확히 이해하기 위해 다음과 같은 코드를 살펴보자.</p>
<pre><code class="language-cpp">boost::asio::io_service io_service;
boost::asio::strand strand(io_service);

strand.dispatch([] {
    std::cout &lt;&lt; "즉시 실행" &lt;&lt; std::endl;
});

strand.post([] {
    std::cout &lt;&lt; "나중에 실행" &lt;&lt; std::endl;
});

io_service.run();
</code></pre>
<p>위 코드에서 <code>dispatch</code>는 가능한 즉시 핸들러를 실행하려고 시도하지만, <code>post</code>는 나중에 실행되도록 예약한다. 이를 통해 비동기 작업의 실행 흐름을 세밀하게 조정할 수 있다.</p>
<h3 id="strand">핸들러 동기화: Strand의 활용</h3>
<p>비동기 작업이 여러 스레드에서 동시에 처리될 때는 동기화 문제를 고려해야 한다. Boost.Asio에서는 이러한 동기화 문제를 해결하기 위해 <code>strand</code>라는 개념을 제공한다. <code>strand</code>는 동일한 비동기 작업 그룹 내에서 핸들러가 서로 충돌 없이 실행되도록 보장하는 동기화 메커니즘이다.</p>
<p>Strand를 사용하면 다중 스레드 환경에서도 서로 충돌하지 않고 안전하게 핸들러를 실행할 수 있다. 이는 특히 동일한 자원에 여러 개의 핸들러가 접근해야 하는 상황에서 유용하다.</p>
<h4 id="strand_1">Strand 사용 예제</h4>
<pre><code class="language-cpp">boost::asio::io_service io_service;
boost::asio::strand strand(io_service);

strand.post([] {
    std::cout &lt;&lt; "첫 번째 작업" &lt;&lt; std::endl;
});

strand.post([] {
    std::cout &lt;&lt; "두 번째 작업" &lt;&lt; std::endl;
});

io_service.run();
</code></pre>
<p>위 예제에서 두 개의 작업은 <code>strand</code>를 통해 순차적으로 실행된다. <code>strand</code>는 두 작업이 동일한 스레드에서 실행됨을 보장하고, 따라서 자원 충돌 문제를 피할 수 있다.</p>
<h3 id="strand_2">핸들러 동기화: Strand의 내부 동작</h3>
<p>Strand는 비동기 작업을 안전하게 동기화할 수 있는 메커니즘이지만, 그 내부 동작은 비교적 간단하다. Strand는 자신을 통해 제출된 모든 작업이 순차적으로 실행되도록 관리한다. 이를 통해 각 작업이 서로 간섭 없이 안전하게 처리될 수 있다. 다중 스레드 환경에서 <code>strand.post()</code>로 제출된 작업들은 비록 여러 스레드에서 실행될 수 있지만, strand가 동일한 자원에 대한 동시 접근을 방지하므로 각 작업이 완료될 때까지 다른 작업은 실행되지 않는다.</p>
<h3 id="strand_3">Strand의 예시: 멀티스레드 환경에서의 동작</h3>
<p>멀티스레드 환경에서 비동기 작업을 처리할 때, 각 스레드가 서로 독립적으로 동작하는 경우 자원 충돌이 발생할 수 있다. 이를 방지하기 위해 Boost.Asio에서는 <code>strand</code>를 사용하여 스레드 간 안전성을 보장한다.</p>
<p>아래 예제는 멀티스레드 환경에서 <code>strand</code>를 사용하는 방식을 보여준다.</p>
<pre><code class="language-cpp">boost::asio::io_service io_service;
boost::asio::strand strand(io_service);

std::thread thread1([&amp;]() {
    strand.post([] {
        std::cout &lt;&lt; "스레드 1에서 실행" &lt;&lt; std::endl;
    });
    io_service.run();
});

std::thread thread2([&amp;]() {
    strand.post([] {
        std::cout &lt;&lt; "스레드 2에서 실행" &lt;&lt; std::endl;
    });
    io_service.run();
});

thread1.join();
thread2.join();
</code></pre>
<p>위 코드는 두 개의 스레드가 동일한 strand를 사용하여 작업을 제출하는 예시다. <code>strand.post()</code>를 사용하여 각 스레드에서 작업을 제출하면, strand는 두 스레드 간의 작업 충돌을 방지하고, 작업이 순차적으로 실행되도록 한다.</p>
<h3 id="_8">핸들러와 예외 처리</h3>
<p>비동기 작업에서 예외 처리 역시 매우 중요하다. 비동기 작업 중에 예외가 발생하면 콜백 함수가 적절하게 호출되지 않거나, 비정상적인 상태에서 작업이 중단될 수 있다. 이러한 문제를 방지하기 위해서는 콜백 함수나 핸들러 내부에서 발생할 수 있는 예외를 적절히 처리해야 한다.</p>
<p>Boost.Asio는 기본적으로 예외가 핸들러 내부에서 발생할 경우, 예외를 처리하지 않고 전파시킨다. 따라서 핸들러 내부에서는 항상 예외가 발생할 가능성을 고려하여 try-catch 구문을 사용하는 것이 권장된다.</p>
<h4 id="_9">예외 처리가 포함된 핸들러 예시</h4>
<pre><code class="language-cpp">void my_handler(const boost::system::error_code&amp; ec) {
    try {
        if (!ec) {
            // 비동기 작업 성공 시 처리 로직
        } else {
            // 오류 발생 시 처리 로직
        }
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "예외 발생: " &lt;&lt; e.what() &lt;&lt; std::endl;
        // 예외 처리 로직
    }
}
</code></pre>
<p>위의 예시에서는 핸들러 내부에서 예외가 발생할 수 있는 상황을 대비하여 <code>try-catch</code> 블록을 사용한다. 이렇게 하면 예외가 발생하더라도 프로그램이 중단되지 않고 적절하게 처리된다.</p>
<h3 id="_10">비동기 작업의 실행 흐름</h3>
<p>비동기 작업의 실행 흐름은 비동기 작업이 시작되고, 중간에 작업이 완료되면 콜백 함수 또는 핸들러가 호출되는 방식으로 진행된다. Boost.Asio에서 비동기 작업의 실행 흐름을 이해하기 위해서는 다음과 같은 과정을 명확히 인식할 필요가 있다.</p>
<ol>
<li>
<p><strong>비동기 작업 요청</strong>: 사용자가 비동기 작업을 요청할 때, <code>async_</code>로 시작하는 함수가 호출된다. 이 함수는 비동기 작업을 시작하고, 작업이 완료되면 호출될 콜백 함수 또는 핸들러를 등록한다.</p>
</li>
<li>
<p><strong>작업 완료 후 핸들러 호출</strong>: 작업이 완료되면 Boost.Asio의 I/O 서비스는 해당 작업과 관련된 핸들러를 호출하여 결과를 처리한다.</p>
</li>
<li>
<p><strong>핸들러 실행</strong>: 핸들러는 작업의 결과에 따라 후속 작업을 수행하거나, 오류가 발생한 경우 이를 처리한다. 핸들러는 비동기 작업의 종료 시점에서 자동으로 호출된다.</p>
</li>
</ol>
<p>이 과정을 더 구체적으로 다이어그램으로 표현하면 다음과 같다:</p>
<div class="mermaid">graph TD;
    A[비동기 작업 요청] --&gt;|작업 대기| B[작업 완료 이벤트 발생];
    B --&gt;|성공 시| C[성공 핸들러 호출];
    B --&gt;|실패 시| D[오류 처리 핸들러 호출];
    C --&gt; E[후속 작업 수행];
    D --&gt; F[오류 로그 기록];
</div>
<h3 id="_11">비동기 콜백 함수 체이닝</h3>
<p>비동기 작업에서 후속 작업을 처리하기 위해서는 콜백 함수나 핸들러를 체이닝하여 다음 작업을 연결하는 방식이 자주 사용된다. 이 방법을 통해 비동기 작업을 순차적으로 처리할 수 있으며, 여러 작업이 독립적으로 이루어져야 할 경우에도 체계적으로 관리할 수 있다.</p>
<p>콜백 함수 체이닝의 기본 원리는 하나의 작업이 완료된 후, 그 결과를 바탕으로 다음 작업을 비동기적으로 호출하는 것이다. 이를 통해 작업 간의 의존성을 해결하고, 각 작업이 순차적으로 처리될 수 있도록 보장한다.</p>
<h3 id="_12">비동기 콜백 함수 체이닝의 예시</h3>
<p>비동기 작업을 체이닝하는 방법은 매우 유용하다. 여러 비동기 작업을 순차적으로 수행해야 할 경우, 각 작업이 완료된 후 다음 작업을 연결하는 방식을 통해 작업의 흐름을 관리할 수 있다.</p>
<p>다음은 콜백 함수 체이닝의 간단한 예시다.</p>
<pre><code class="language-cpp">boost::asio::io_service io_service;
boost::asio::deadline_timer timer1(io_service, boost::posix_time::seconds(1));
boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(2));

timer1.async_wait([](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "첫 번째 타이머 완료" &lt;&lt; std::endl;
    }
});

timer1.async_wait([&amp;timer2](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "두 번째 타이머 시작" &lt;&lt; std::endl;
        timer2.async_wait([](const boost::system::error_code&amp; ec2) {
            if (!ec2) {
                std::cout &lt;&lt; "두 번째 타이머 완료" &lt;&lt; std::endl;
            }
        });
    }
});

io_service.run();
</code></pre>
<p>이 예제에서는 두 개의 타이머를 설정하여 첫 번째 타이머가 완료되면 두 번째 타이머가 시작되고, 두 번째 타이머가 완료되면 다시 후속 처리를 수행하는 방식으로 체이닝이 이루어진다. 이 방식은 여러 비동기 작업이 순차적으로 진행되도록 하는 데 매우 유용하다.</p>
<h3 id="_13">비동기 콜백 함수 체이닝과 오류 처리</h3>
<p>비동기 작업을 체이닝할 때는 오류 처리 또한 매우 중요한 부분이다. 체이닝된 작업 중 하나라도 오류가 발생하면 후속 작업은 중단되거나, 오류를 처리하는 로직을 따로 구성해야 한다. 이를 위해 각 콜백 함수 또는 핸들러 내부에서 오류 검사를 하고, 오류 발생 시 적절한 조치를 취하도록 설계해야 한다.</p>
<pre><code class="language-cpp">boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(1));

timer.async_wait([](const boost::system::error_code&amp; ec) {
    if (!ec) {
        // 성공적인 비동기 작업
        std::cout &lt;&lt; "첫 번째 작업 완료" &lt;&lt; std::endl;
    } else {
        // 오류 발생 시 처리
        std::cerr &lt;&lt; "첫 번째 작업에서 오류 발생: " &lt;&lt; ec.message() &lt;&lt; std::endl;
        return;
    }

    // 두 번째 작업 시작
    boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(2));
    timer2.async_wait([](const boost::system::error_code&amp; ec2) {
        if (!ec2) {
            std::cout &lt;&lt; "두 번째 작업 완료" &lt;&lt; std::endl;
        } else {
            std::cerr &lt;&lt; "두 번째 작업에서 오류 발생: " &lt;&lt; ec2.message() &lt;&lt; std::endl;
        }
    });
});
</code></pre>
<p>위의 코드는 각 비동기 작업이 체이닝된 상태에서 오류 발생 시 적절하게 중단하거나 후속 작업을 처리할 수 있도록 하는 예시다. 첫 번째 작업에서 오류가 발생하면 두 번째 작업은 시작되지 않고, 오류 메시지를 출력한다.</p>
<h3 id="_14">콜백 함수의 수명 관리</h3>
<p>비동기 작업의 수행 중 객체나 리소스가 파괴되거나 해제되는 경우, 핸들러나 콜백 함수가 호출될 때 접근할 수 없는 자원을 참조할 위험이 있다. 이를 방지하기 위해, 비동기 작업 중 객체의 수명을 적절히 관리하는 것이 매우 중요하다.</p>
<p>Boost.Asio에서는 이러한 문제를 해결하기 위해 <code>shared_ptr</code>을 활용하는 방식을 제공한다. 이를 통해 비동기 작업 중 참조되고 있는 객체가 안전하게 유지될 수 있도록 보장할 수 있다.</p>
<h4 id="shared_ptr">shared_ptr을 사용한 안전한 콜백 함수 예시</h4>
<pre><code class="language-cpp">struct my_task {
    void operator()(const boost::system::error_code&amp; ec) {
        if (!ec) {
            std::cout &lt;&lt; "작업 완료" &lt;&lt; std::endl;
        }
    }
};

void start_async_task(boost::asio::io_service&amp; io_service) {
    auto task = std::make_shared&lt;my_task&gt;();
    boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(1));

    timer.async_wait([task](const boost::system::error_code&amp; ec) {
        (*task)(ec);  // shared_ptr로 안전하게 작업 수행
    });
}

int main() {
    boost::asio::io_service io_service;
    start_async_task(io_service);
    io_service.run();
}
</code></pre>
<p>위 코드에서는 <code>shared_ptr</code>을 사용하여 <code>my_task</code> 객체를 안전하게 관리하고 있다. 비동기 작업이 완료되기 전까지 <code>shared_ptr</code>이 객체의 수명을 관리하므로, 객체가 비동기 작업 중 해제되는 상황을 방지할 수 있다.</p>
<p>이러한 방식은 객체의 수명이 비동기 작업의 완료 시점까지 유지되도록 보장하는 일반적인 패턴이다. Boost.Asio에서 자주 사용되는 수명 관리 기법 중 하나로, 특히 복잡한 비동기 작업 흐름에서 매우 유용하다.</p>
<h3 id="_15">핸들러의 성능 최적화</h3>
<p>비동기 작업에서 핸들러는 중요한 역할을 수행하므로, 그 성능 역시 매우 중요하다. 비동기 작업이 많아지면 핸들러의 호출 빈도도 높아지며, 따라서 핸들러의 성능을 최적화하는 것이 필수적이다. Boost.Asio에서는 핸들러의 호출 오버헤드를 줄이고 성능을 개선하기 위한 몇 가지 최적화 방법을 제공한다.</p>
<ol>
<li><strong>핸들러 인라인화</strong>: 작은 크기의 핸들러는 가능한 인라인으로 처리하여 호출 오버헤드를 줄인다.</li>
<li><strong>핸들러 객체의 메모리 관리</strong>: 핸들러 객체의 동적 할당을 최소화하여 메모리 관리 오버헤드를 줄인다.</li>
<li><strong>핸들러 객체 풀링</strong>: 자주 사용되는 핸들러 객체는 풀링(pooling) 기법을 사용하여 재사용할 수 있다.</li>
</ol>
<p>Boost.Asio는 이러한 최적화를 통해 높은 성능의 비동기 작업 처리를 가능하게 하며, 대규모 비동기 시스템에서도 핸들러의 오버헤드를 최소화할 수 있다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0204/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0204/">
        비동기 작업의 스케줄링
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0202/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0202/">
        비동기 작업 실행 흐름
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>