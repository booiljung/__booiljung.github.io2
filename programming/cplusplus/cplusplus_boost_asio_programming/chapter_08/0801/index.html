<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/programming/cplusplus/cplusplus_boost_asio_programming/chapter_08/0801/" rel="canonical"/>
<link href="../../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>Boost.Asio 타이머 개요 - 실험 도서관</title>
<link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Boost.Asio \ud0c0\uc774\uba38\uc758 \uc885\ub958", url: "#_top", children: [
          ]},
          {title: "\ud0c0\uc774\uba38 \ub3d9\uc791 \uc6d0\ub9ac", url: "#_1", children: [
              {title: "\ud0c0\uc774\uba38 \uc124\uc815 \ubc0f \ub9cc\ub8cc \uc2dc\uac04", url: "#_2" },
          ]},
          {title: "\ube44\ub3d9\uae30 \ud0c0\uc774\uba38 \uc608\uc2dc", url: "#_3", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \ucde8\uc18c \ubc0f \uc7ac\uc124\uc815", url: "#_4", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 \ud0c0\uc774\uba38\uc758 \ub3d9\uc791 \uba54\ucee4\ub2c8\uc998", url: "#_5", children: [
          ]},
          {title: "io_context\uc640 \ud0c0\uc774\uba38\uc758 \uad00\uacc4", url: "#io_context", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \uba40\ud2f0\uc2a4\ub808\ub529", url: "#_6", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \ube44\ub3d9\uae30 \ub300\uae30 \uad00\ub9ac", url: "#_7", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uc8fc\uae30\uc801 \uc2e4\ud589", url: "#_8", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \ub3d9\uc801 \uc7ac\uc124\uc815", url: "#_9", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uc815\ud655\uc131", url: "#_10", children: [
              {title: "\uc9c0\uc5f0 \uc2dc\uac04 \ubaa8\ub378", url: "#_11" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 Boost.System", url: "#boostsystem", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \ucde8\uc18c", url: "#_12", children: [
              {title: "\ud0c0\uc774\uba38 \ucde8\uc18c \uc608\uc2dc", url: "#_13" },
              {title: "cancel_one() \ud568\uc218", url: "#cancel_one" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \uc608\uc678 \ucc98\ub9ac", url: "#_14", children: [
              {title: "\uc608\uc678 \ucc98\ub9ac \uc608\uc2dc", url: "#_15" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \ub9ac\uc18c\uc2a4 \uad00\ub9ac", url: "#_16", children: [
              {title: "\ud0c0\uc774\uba38\uc758 \uc885\ub8cc \ub300\uae30", url: "#_17" },
          ]},
        ];

    </script>
<script src="../../../../../js/base.js"></script>
<script src="../../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0802/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0802/">
        Boost.Asio를 활용한 비동기 타이머
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../../chapter_07/0706/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../../chapter_07/0706/">
        파일 입출력에서의 성능 최적화
      </a>
</div>
</div>
<p>Boost.Asio는 비동기 I/O를 위한 라이브러리로, 네트워크 프로그래밍을 비롯한 다양한 비동기 작업에 활용된다. 그중에서도 타이머는 시간과 관련된 작업을 관리할 때 유용하게 사용된다. Boost.Asio의 타이머는 특정 시간 동안 대기하거나 주기적으로 실행되는 비동기 작업을 쉽게 처리할 수 있는 도구를 제공한다.</p>
<h3 id="boostasio">Boost.Asio 타이머의 종류</h3>
<p>Boost.Asio에서 제공하는 주요 타이머는 크게 두 가지로 나눌 수 있다.</p>
<ol>
<li>
<p><strong><code>steady_timer</code></strong>: 이 타이머는 <strong>고정된 시간 간격</strong>을 측정할 때 사용된다. <code>steady_timer</code>는 시스템 시계와는 독립적으로 일정한 시간 간격을 보장한다. 즉, 시스템 시간의 변경에도 영향을 받지 않는다. 이는 타이머의 <strong>정확한 시간 제어</strong>가 중요한 경우에 유리한다.</p>
</li>
<li>
<p><strong><code>system_timer</code></strong>: 이 타이머는 <strong>시스템의 시간</strong>을 기반으로 동작한다. 주로 시스템 시간을 기준으로 특정 시간에 작업을 예약할 때 사용된다. 하지만 시스템 시간이 변경될 경우, 타이머의 동작에도 영향을 미칠 수 있다.</p>
</li>
</ol>
<h3 id="_1">타이머 동작 원리</h3>
<p>Boost.Asio 타이머는 내부적으로 <strong>비동기 작업 큐</strong>를 통해 동작한다. 타이머가 만료되면, 등록된 <strong>콜백 함수</strong>가 호출되어 특정 작업을 수행한다. 이 과정에서 <code>io_context</code> 객체가 중요한 역할을 한다. <code>io_context</code>는 비동기 작업을 처리하는 메인 루프 역할을 하며, 타이머와 같은 비동기 작업을 관리한다.</p>
<h4 id="_2">타이머 설정 및 만료 시간</h4>
<p>타이머는 기본적으로 다음과 같은 방식으로 설정된다:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">t_{expiry} = t_{current} + t_{duration}</span><script type="math/tex">t_{expiry} = t_{current} + t_{duration}</script></span></p>
<p>여기서:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">t_{expiry}</span><script type="math/tex">t_{expiry}</script></span>: 타이머가 만료되는 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">t_{current}</span><script type="math/tex">t_{current}</script></span>: 현재 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">t_{duration}</span><script type="math/tex">t_{duration}</script></span>: 타이머의 대기 시간 또는 지연 시간</li>
</ul>
<p>이 수식은 타이머가 현재 시간으로부터 일정 시간 후에 만료됨을 나타낸다.</p>
<h3 id="_3">비동기 타이머 예시</h3>
<p>Boost.Asio에서 타이머를 설정하고 사용하는 일반적인 방법은 다음과 같다.</p>
<pre><code class="language-cpp">boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(5));
</code></pre>
<p>위 코드는 5초 후에 만료되는 <code>steady_timer</code>를 설정한다. 설정된 시간이 지나면, 등록된 비동기 콜백 함수가 호출된다. 이를 통해 프로그램은 타이머가 만료될 때까지 다른 작업을 계속 수행할 수 있다.</p>
<p>타이머가 만료되었을 때 호출되는 콜백 함수는 다음과 같이 등록할 수 있다.</p>
<pre><code class="language-cpp">timer.async_wait([](const boost::system::error_code&amp; ec){
    if (!ec) {
        std::cout &lt;&lt; "Timer expired!" &lt;&lt; std::endl;
    }
});
</code></pre>
<p><code>async_wait</code> 함수는 타이머가 만료될 때 호출될 콜백을 등록하는 함수이다. 콜백 함수는 타이머의 상태를 나타내는 <code>error_code</code> 객체를 통해 성공 여부를 확인한다. 타이머가 정상적으로 만료되었다면, <code>error_code</code>는 에러 없이 콜백이 호출된다.</p>
<h3 id="_4">타이머의 취소 및 재설정</h3>
<p>타이머는 필요에 따라 <strong>취소</strong>되거나 <strong>재설정</strong>될 수 있다. 타이머를 취소하려면 <code>cancel()</code> 함수를 사용하며, 타이머의 만료 시간을 변경하려면 <code>expires_at()</code> 또는 <code>expires_after()</code> 함수를 사용한다.</p>
<p>타이머를 취소하는 예시는 다음과 같다:</p>
<pre><code class="language-cpp">timer.cancel();
</code></pre>
<p>타이머를 재설정할 때는 새로운 시간을 설정하고 다시 대기할 수 있다.</p>
<pre><code class="language-cpp">timer.expires_after(boost::asio::chrono::seconds(10));
</code></pre>
<p>이는 타이머를 10초 후에 다시 만료되도록 재설정한다.</p>
<h3 id="_5">비동기 타이머의 동작 메커니즘</h3>
<p>Boost.Asio의 비동기 타이머는 내부적으로 <strong>비동기 이벤트 처리 메커니즘</strong>을 사용하여 타이머가 만료될 때마다 관련된 작업을 호출한다. 이 메커니즘은 일반적으로 다음과 같은 과정으로 동작한다:</p>
<ol>
<li>
<p><strong>타이머 설정</strong>: 타이머가 특정 시간에 만료되도록 설정된다. 이때 타이머는 <code>io_context</code>에 비동기 작업으로 등록된다.</p>
</li>
<li>
<p><strong>비동기 대기</strong>: 타이머가 대기 상태에 들어간다. 이때 다른 비동기 작업이 계속 실행될 수 있으며, 타이머는 비동기 대기 큐에서 자신의 차례를 기다린다.</p>
</li>
<li>
<p><strong>만료 시점 도달</strong>: 타이머가 만료 시점에 도달하면, <code>io_context</code>가 이를 감지하고 등록된 콜백 함수를 실행한다.</p>
</li>
<li>
<p><strong>콜백 함수 실행</strong>: 타이머 만료 시 콜백 함수가 호출된다. 이때 타이머의 만료가 성공적으로 이루어졌는지 여부는 <code>error_code</code>를 통해 전달된다. 에러가 없는 경우 정상적으로 처리된 것이다.</p>
</li>
</ol>
<p>이 과정을 도식화하면 다음과 같이 나타낼 수 있다:</p>
<div class="mermaid">graph TD;
    A[타이머 설정] --&gt; B[비동기 대기]
    B --&gt;|타이머 만료 시점 도달| C[콜백 함수 실행]
    C --&gt; D[타이머 종료]
</div>
<h3 id="io_context"><code>io_context</code>와 타이머의 관계</h3>
<p>Boost.Asio의 핵심은 <strong><code>io_context</code></strong>이다. 모든 비동기 작업은 <code>io_context</code> 객체를 통해 관리되며, 타이머 역시 이 객체를 통해 비동기 작업으로 처리된다. <code>io_context</code>는 비동기 작업을 실행하는 <strong>이벤트 루프</strong>의 역할을 하며, 타이머는 이 이벤트 루프에 등록된 작업 중 하나이다.</p>
<p>다음은 <code>io_context</code>와 타이머가 어떻게 협력하는지 보여주는 예시이다:</p>
<pre><code class="language-cpp">boost::asio::io_context io_context;
boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(5));

timer.async_wait([](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Timer expired!" &lt;&lt; std::endl;
    }
});

io_context.run();
</code></pre>
<p>위 코드에서 <code>io_context.run()</code>은 <code>io_context</code>에 등록된 모든 비동기 작업을 실행한다. 타이머가 5초 후에 만료되면 등록된 콜백 함수가 호출되고, 그 이후에 다른 비동기 작업이 계속 처리된다.</p>
<p><code>io_context</code>는 단순히 타이머를 처리하는 데 그치지 않고, 네트워크 I/O, 파일 I/O, 사용자 입력 등 다양한 비동기 작업을 관리할 수 있다. </p>
<h3 id="_6">타이머와 멀티스레딩</h3>
<p>Boost.Asio는 멀티스레드 환경에서 비동기 타이머를 안전하게 사용할 수 있도록 설계되어 있다. 여러 스레드에서 동시에 <code>io_context</code>를 사용할 수 있으며, 이를 통해 타이머와 같은 비동기 작업도 병렬로 처리될 수 있다. 이를 위해 <code>io_context::run()</code>을 여러 스레드에서 호출하여 비동기 작업을 병렬로 처리하도록 할 수 있다.</p>
<p>멀티스레드 환경에서 타이머를 설정하고 사용하는 예시는 다음과 같다:</p>
<pre><code class="language-cpp">boost::asio::io_context io_context;
boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(5));

// 타이머 작업 등록
timer.async_wait([](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Timer expired in thread!" &lt;&lt; std::endl;
    }
});

// 4개의 스레드로 io_context 실행
std::vector&lt;std::thread&gt; threads;
for (int i = 0; i &lt; 4; ++i) {
    threads.emplace_back([&amp;io_context]() {
        io_context.run();
    });
}

// 스레드 종료 대기
for (auto&amp; thread : threads) {
    thread.join();
}
</code></pre>
<p>위 코드는 4개의 스레드를 생성하여 각각 <code>io_context.run()</code>을 실행하고, 타이머 만료 시 등록된 콜백이 실행된다. 여러 스레드에서 타이머를 처리하므로 비동기 작업을 병렬로 효율적으로 처리할 수 있다.</p>
<h3 id="_7">타이머의 비동기 대기 관리</h3>
<p>비동기 타이머는 여러 개의 타이머를 동시에 관리할 수 있다. Boost.Asio의 비동기 작업 처리 메커니즘 덕분에, 다수의 타이머를 <code>io_context</code> 객체에서 관리하며 각각의 타이머가 독립적으로 대기하고 만료되면 각기 다른 콜백 함수를 호출할 수 있다.</p>
<p>다수의 타이머를 설정하는 예시는 다음과 같다:</p>
<pre><code class="language-cpp">boost::asio::steady_timer timer1(io_context, boost::asio::chrono::seconds(3));
boost::asio::steady_timer timer2(io_context, boost::asio::chrono::seconds(5));

// 각각의 타이머에 비동기 작업 등록
timer1.async_wait([](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Timer 1 expired!" &lt;&lt; std::endl;
    }
});

timer2.async_wait([](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Timer 2 expired!" &lt;&lt; std::endl;
    }
});

io_context.run();
</code></pre>
<p>위 코드에서 3초와 5초 후에 각각 만료되는 두 개의 타이머가 설정되어 있다. <code>io_context.run()</code>이 호출되면 두 타이머는 각자의 만료 시간에 도달했을 때 각각의 콜백 함수가 호출된다.</p>
<p>이처럼 Boost.Asio의 타이머는 단일한 <code>io_context</code>에서 여러 비동기 타이머를 효율적으로 관리할 수 있다.</p>
<h3 id="_8">타이머의 주기적 실행</h3>
<p>Boost.Asio의 타이머는 <strong>주기적으로 실행</strong>되는 비동기 작업을 처리하는 데에도 유용하게 사용할 수 있다. 주기적 타이머는 특정 간격마다 반복적으로 작업을 수행하는 데 적합하며, 이를 통해 주기적인 이벤트나 작업을 관리할 수 있다. 주기적 타이머를 구현하는 방식은, 타이머가 만료될 때마다 타이머를 다시 설정하여 새로운 대기 시간을 주는 것이다.</p>
<p>주기적 타이머의 예시는 다음과 같다:</p>
<pre><code class="language-cpp">void repeat_timer(boost::asio::steady_timer&amp; timer, boost::asio::chrono::seconds interval) {
    timer.expires_after(interval);
    timer.async_wait([&amp;timer, interval](const boost::system::error_code&amp; ec) {
        if (!ec) {
            std::cout &lt;&lt; "Timer triggered!" &lt;&lt; std::endl;
            // 타이머를 다시 설정하여 주기적으로 실행
            repeat_timer(timer, interval);
        }
    });
}

int main() {
    boost::asio::io_context io_context;
    boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(2));

    // 주기적으로 2초마다 타이머 실행
    repeat_timer(timer, boost::asio::chrono::seconds(2));

    io_context.run();
    return 0;
}
</code></pre>
<p>이 코드에서는 <code>repeat_timer()</code> 함수를 통해 타이머가 만료될 때마다 다시 설정되며, 주기적으로 콜백 함수가 호출된다. <code>repeat_timer()</code> 함수는 타이머가 만료될 때마다 새로운 만료 시간을 설정하고, 이를 다시 <code>async_wait()</code>에 등록하여 2초마다 반복적으로 실행되도록 한다.</p>
<h3 id="_9">타이머의 동적 재설정</h3>
<p>Boost.Asio의 타이머는 <strong>동적으로 재설정</strong>할 수도 있다. 예를 들어, 타이머가 만료된 후 새로운 대기 시간을 상황에 맞게 동적으로 변경하고자 할 때 사용할 수 있다. 타이머를 재설정하는 방식은 <code>expires_after()</code> 또는 <code>expires_at()</code>을 호출하여 새로운 만료 시간을 설정한 후, 다시 대기 상태로 전환하는 것이다.</p>
<p>동적 재설정의 예시는 다음과 같다:</p>
<pre><code class="language-cpp">void dynamic_reset(boost::asio::steady_timer&amp; timer, int&amp; counter) {
    int new_duration = 1 + counter;  // 동적 대기 시간 설정
    timer.expires_after(boost::asio::chrono::seconds(new_duration));
    timer.async_wait([&amp;timer, &amp;counter](const boost::system::error_code&amp; ec) {
        if (!ec) {
            std::cout &lt;&lt; "Timer expired after " &lt;&lt; 1 + counter &lt;&lt; " seconds!" &lt;&lt; std::endl;
            ++counter;
            // 다시 타이머를 동적으로 재설정
            dynamic_reset(timer, counter);
        }
    });
}

int main() {
    boost::asio::io_context io_context;
    boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(1));
    int counter = 1;

    // 타이머를 동적으로 재설정하여 실행
    dynamic_reset(timer, counter);

    io_context.run();
    return 0;
}
</code></pre>
<p>위 코드에서는 타이머의 대기 시간을 동적으로 변경하면서 실행한다. 처음에는 1초 후에 타이머가 만료되지만, 이후에는 <code>counter</code> 값에 따라 대기 시간이 매번 증가하여 타이머가 동적으로 동작한다. 이처럼 Boost.Asio의 타이머는 단순히 일정 시간 후에 동작하는 것뿐만 아니라, 조건에 따라 <strong>유연하게 조정</strong>될 수 있다.</p>
<h3 id="_10">타이머의 정확성</h3>
<p>Boost.Asio 타이머의 시간 측정 정확성은 사용하는 타이머의 종류에 따라 다르다.</p>
<ul>
<li>
<p><strong><code>steady_timer</code></strong>: 시스템 시계의 변화에 영향을 받지 않고 고정된 간격을 보장하기 때문에 매우 정확한다. 이 타이머는 실시간 성능이 중요한 경우에 적합하며, 시스템 시간의 변경에도 영향을 받지 않으므로 일관된 동작을 보장한다.</p>
</li>
<li>
<p><strong><code>system_timer</code></strong>: 시스템 시간을 기준으로 동작하므로 시스템 시간이 변경되면 타이머의 동작에도 영향을 받을 수 있다. 예를 들어, 시스템 시간이 수동으로 조정되거나 동기화될 경우, 타이머의 정확성이 떨어질 수 있다.</p>
</li>
</ul>
<p>타이머의 <strong>정확성</strong>을 논할 때 중요한 개념 중 하나는 <strong>지연(Latency)</strong>이다. 이는 타이머가 만료된 시점에서 실제로 콜백 함수가 호출되기까지의 시간 차이를 의미한다. Boost.Asio는 비동기 이벤트 루프에서 다수의 작업을 처리하기 때문에 타이머가 정확히 만료된 시간과 콜백이 실행되는 시간 사이에 약간의 지연이 발생할 수 있다. 이는 일반적으로 매우 짧은 시간이지만, <strong>실시간 성능</strong>이 중요한 시스템에서는 고려되어야 할 요소이다.</p>
<h4 id="_11">지연 시간 모델</h4>
<p>타이머의 지연 시간을 다음과 같이 모델링할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{latency} = T_{callback} - T_{expiry}
</div>
<script type="math/tex; mode=display">
T_{latency} = T_{callback} - T_{expiry}
</script>
</div>
<p>여기서:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">T_{latency}</span><script type="math/tex">T_{latency}</script></span>: 타이머 지연 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">T_{callback}</span><script type="math/tex">T_{callback}</script></span>: 콜백 함수가 실행된 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">T_{expiry}</span><script type="math/tex">T_{expiry}</script></span>: 타이머가 설정한 만료 시간</li>
</ul>
<p>이 지연 시간은 비동기 작업 큐에 대기 중인 다른 작업의 양이나 시스템 리소스 사용량에 따라 달라질 수 있다.</p>
<h3 id="boostsystem">타이머와 Boost.System</h3>
<p>Boost.Asio에서 타이머와 같은 비동기 작업은 Boost.System에서 제공하는 <strong><code>boost::system::error_code</code></strong>를 통해 오류를 관리한다. 비동기 작업이 성공적으로 완료되었는지 여부는 <code>error_code</code>를 통해 확인할 수 있으며, 이 코드는 다음과 같은 상황에서 유용하게 사용된다:</p>
<ol>
<li>타이머가 정상적으로 만료되었을 때: <code>error_code</code>는 빈 상태이며, 이는 작업이 정상적으로 완료되었음을 의미한다.</li>
<li>타이머가 취소되었을 때: 타이머가 만료되기 전에 <code>cancel()</code> 함수로 취소된 경우, <code>error_code</code>는 타이머가 취소되었음을 나타내는 값으로 설정된다.</li>
<li>다른 오류가 발생했을 때: 타이머가 만료되지 못하거나 다른 시스템 오류가 발생한 경우, <code>error_code</code>는 해당 오류 정보를 담고 있다.</li>
</ol>
<h3 id="_12">타이머의 취소</h3>
<p>Boost.Asio의 타이머는 <strong>비동기 대기 중</strong>에 <strong>취소</strong>될 수 있다. 이는 <code>cancel()</code> 함수를 통해 이루어지며, 타이머가 만료되기 전에 대기 상태를 중단하고 콜백 함수의 호출을 방지하거나 적절한 에러 코드를 전달한다.</p>
<h4 id="_13">타이머 취소 예시</h4>
<p>다음 예시는 타이머를 설정한 후 일정 시간 내에 타이머를 취소하는 방법을 보여준다.</p>
<pre><code class="language-cpp">boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(10));

// 10초 후에 만료되는 타이머 설정
timer.async_wait([](const boost::system::error_code&amp; ec) {
    if (ec == boost::asio::error::operation_aborted) {
        std::cout &lt;&lt; "Timer was cancelled!" &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Timer expired!" &lt;&lt; std::endl;
    }
});

// 타이머를 5초 후에 취소
std::this_thread::sleep_for(std::chrono::seconds(5));
timer.cancel();
</code></pre>
<p>위 코드에서는 10초 후에 만료될 타이머가 설정되어 있지만, <code>std::this_thread::sleep_for()</code>를 사용하여 5초 후에 <code>cancel()</code> 함수가 호출되어 타이머가 취소된다. 취소된 타이머의 콜백 함수에서 <code>error_code</code>는 <code>operation_aborted</code> 오류를 나타내며, 이를 통해 타이머가 정상적으로 취소되었음을 확인할 수 있다.</p>
<p>타이머가 취소되면 콜백 함수는 여전히 호출되지만, 타이머가 만료되지 않았다는 것을 에러 코드를 통해 알 수 있다. 이렇게 하면 취소된 타이머에 대해 필요한 후속 처리를 할 수 있다.</p>
<h4 id="cancel_one"><code>cancel_one()</code> 함수</h4>
<p>Boost.Asio의 타이머에는 <code>cancel()</code> 외에도 <strong><code>cancel_one()</code></strong>이라는 함수가 존재한다. <code>cancel()</code>은 타이머에 등록된 모든 비동기 대기를 취소하는 반면, <code>cancel_one()</code>은 <strong>가장 먼저 등록된 하나의 비동기 대기</strong>만을 취소한다.</p>
<p>예를 들어, 동일한 타이머에 여러 개의 비동기 대기 작업이 등록된 경우, <code>cancel_one()</code>을 호출하면 그 중 하나의 대기만 취소되며, 나머지 대기는 계속해서 유효하게 유지된다.</p>
<pre><code class="language-cpp">timer.async_wait(callback1);  // 첫 번째 비동기 대기
timer.async_wait(callback2);  // 두 번째 비동기 대기

timer.cancel_one();  // 첫 번째 대기 작업(callback1)만 취소
</code></pre>
<p>이 코드는 <code>callback1</code>이 취소되고, <code>callback2</code>는 여전히 유효한 상태로 남아 있다. 이렇게 하면 여러 비동기 작업을 순차적으로 처리하거나 선택적으로 취소하는 것이 가능해진다.</p>
<h3 id="_14">타이머와 예외 처리</h3>
<p>Boost.Asio에서 발생하는 비동기 작업 중, 타이머와 같은 작업에서 발생할 수 있는 <strong>예외 처리</strong>는 매우 중요하다. 비동기 작업은 일반적으로 예외를 발생시키지 않으며, 오류는 <strong><code>boost::system::error_code</code></strong>를 통해 처리된다. 따라서, 타이머가 만료되거나 취소될 때 발생하는 모든 오류는 예외로 전달되는 것이 아니라, 콜백 함수로 전달된 <code>error_code</code> 객체를 통해 처리된다.</p>
<p>그러나, 콜백 함수 내부에서 발생한 예외는 적절하게 처리되지 않으면 프로그램의 비정상 종료를 초래할 수 있다. 따라서 콜백 함수 내에서 발생하는 예외를 적절히 처리해야 한다. 이를 위해 <code>try-catch</code> 블록을 사용하여 예외 상황을 명확하게 처리할 수 있다.</p>
<h4 id="_15">예외 처리 예시</h4>
<pre><code class="language-cpp">timer.async_wait([](const boost::system::error_code&amp; ec) {
    try {
        if (!ec) {
            // 정상적으로 타이머가 만료되었을 때의 처리
            std::cout &lt;&lt; "Timer expired!" &lt;&lt; std::endl;
        } else if (ec == boost::asio::error::operation_aborted) {
            // 타이머가 취소되었을 때의 처리
            std::cout &lt;&lt; "Timer was cancelled!" &lt;&lt; std::endl;
        } else {
            throw std::runtime_error("Unexpected timer error");
        }
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception caught: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
});
</code></pre>
<p>위 코드에서는 콜백 함수 내부에서 발생할 수 있는 예외를 <code>try-catch</code> 블록을 통해 처리한다. 타이머가 만료되거나 취소되었을 때는 정상적으로 처리되고, 예기치 못한 오류가 발생한 경우에는 예외를 발생시켜 처리한다. 이 방식은 프로그램이 예외 상황에서도 안전하게 동작하도록 보장한다.</p>
<h3 id="_16">타이머와 리소스 관리</h3>
<p>비동기 타이머를 사용할 때 중요한 점 중 하나는 <strong>리소스 관리</strong>이다. 특히, 비동기 작업이 종료되었을 때 타이머와 관련된 리소스가 적절하게 해제되는지 확인해야 한다. Boost.Asio는 기본적으로 RAII(Resource Acquisition Is Initialization) 원칙을 따르기 때문에, 타이머 객체가 스코프를 벗어나면 타이머와 관련된 리소스는 자동으로 해제된다.</p>
<p>그러나 비동기 작업이 완료되지 않은 상태에서 <code>io_context.run()</code>을 중단하거나, 타이머가 취소되지 않은 상태로 프로그램을 종료할 경우 리소스 누수나 불완전한 상태가 발생할 수 있다. 따라서 타이머가 완전히 종료되거나 취소된 후에 프로그램을 종료하는 것이 중요하다.</p>
<h4 id="_17">타이머의 종료 대기</h4>
<p>타이머와 같은 비동기 작업이 완료될 때까지 프로그램이 안전하게 종료되도록 하는 방법 중 하나는 <code>io_context.run()</code>을 호출하기 전에 적절한 종료 대기를 설정하는 것이다. 예를 들어, 다음 코드는 모든 비동기 작업이 종료될 때까지 대기하는 방법을 보여준다.</p>
<pre><code class="language-cpp">boost::asio::steady_timer timer(io_context, boost::asio::chrono::seconds(5));
std::atomic&lt;bool&gt; timer_done{false};

// 타이머가 완료되면 flag를 설정
timer.async_wait([&amp;timer_done](const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Timer expired!" &lt;&lt; std::endl;
    }
    timer_done = true;
});

std::thread io_thread([&amp;io_context]() {
    io_context.run();
});

// 타이머가 완료될 때까지 대기
while (!timer_done) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
}

io_thread.join();
</code></pre>
<p>위 코드에서 <code>timer_done</code>이라는 플래그를 사용하여 타이머가 종료될 때까지 대기한다. 이 방법은 타이머와 관련된 리소스가 모두 안전하게 해제되도록 보장하며, 프로그램이 종료되기 전에 모든 비동기 작업이 완료되는 것을 보장한다.</p>
<p>이와 같은 방식으로 타이머를 관리하면, 프로그램의 <strong>종료 시점에서 리소스 누수</strong>를 방지할 수 있다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0802/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0802/">
        Boost.Asio를 활용한 비동기 타이머
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../../chapter_07/0706/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../../chapter_07/0706/">
        파일 입출력에서의 성능 최적화
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>