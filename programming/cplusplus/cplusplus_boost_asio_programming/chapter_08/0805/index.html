<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/programming/cplusplus/cplusplus_boost_asio_programming/chapter_08/0805/" rel="canonical"/>
<link href="../../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>타이머와 이벤트 기반 프로그래밍 - 실험 도서관</title>
<link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ube44\ub3d9\uae30 \ud504\ub85c\uadf8\ub798\ubc0d\uc758 \uae30\ubcf8 \uac1c\ub150", url: "#_top", children: [
          ]},
          {title: "Boost.Asio\uc758 \ube44\ub3d9\uae30 \ud0c0\uc774\uba38", url: "#boostasio", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 \ud0c0\uc774\uba38\uc758 \uc218\ud559\uc801 \ubaa8\ub378\ub9c1", url: "#_2", children: [
          ]},
          {title: "\uc774\ubca4\ud2b8 \ub8e8\ud504\uc640 \ud0c0\uc774\uba38\uc758 \uc0c1\ud638\uc791\uc6a9", url: "#_3", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 \ud0c0\uc774\uba38\uc758 \ub3d9\uc2dc\uc131 \uc81c\uc5b4", url: "#_4", children: [
              {title: "\ud0c0\uc774\uba38 \uc791\uc5c5\uc758 \ub3c5\ub9bd\uc131", url: "#_5" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \ub3d9\uae30\ud654 \ubb38\uc81c", url: "#_6", children: [
          ]},
          {title: "\uc2a4\ud2b8\ub79c\ub4dc\ub97c \ud1b5\ud55c \ub3d9\uae30\ud654", url: "#_7", children: [
              {title: "\uc2a4\ud2b8\ub79c\ub4dc\uc640 \ud0c0\uc774\uba38\uc758 \uc0c1\ud638\uc791\uc6a9", url: "#_8" },
          ]},
          {title: "\ube44\ub3d9\uae30 \ud0c0\uc774\uba38\uc640 \ub2e4\uc911 \uc774\ubca4\ud2b8 \ucc98\ub9ac", url: "#_9", children: [
              {title: "\uc774\ubca4\ud2b8 \ud050\uc640 \ud0c0\uc774\uba38\uc758 \uc6b0\uc120\uc21c\uc704 \ucc98\ub9ac", url: "#_10" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \ube44\ub3d9\uae30 \uc5f0\uc0b0\uc758 \uacb0\ud569", url: "#_11", children: [
              {title: "\ud0c0\uc774\uba38\uc640 \ube44\ub3d9\uae30 I/O \uacb0\ud569", url: "#io" },
          ]},
          {title: "\ud0c0\uc784\uc544\uc6c3\uacfc \uc7ac\uc2dc\ub3c4 \ucc98\ub9ac", url: "#_12", children: [
              {title: "\uc7ac\uc2dc\ub3c4 \ud69f\uc218 \uc81c\ud55c", url: "#_13" },
          ]},
          {title: "\ud0c0\uc774\uba38\ub97c \uc0ac\uc6a9\ud55c \uc9c0\uc5f0 \uc5f0\uc0b0", url: "#_14", children: [
          ]},
          {title: "\ud0c0\uc774\uba38\uc640 \ub2e4\uc911 \uc4f0\ub808\ub4dc \ud658\uacbd", url: "#_15", children: [
          ]},
        ];

    </script>
<script src="../../../../../js/base.js"></script>
<script src="../../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0806/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0806/">
        타이머 비동기 작업의 오류 처리
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0804/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0804/">
        동적 타이머 관리 및 조작
      </a>
</div>
</div>
<h3 id="_1">비동기 프로그래밍의 기본 개념</h3>
<p>이벤트 기반 프로그래밍은 시스템이 외부 이벤트에 반응하여 특정 동작을 수행하는 패러다임을 말한다. 이를 비동기 프로그래밍으로 확장하면, 특정 작업이 완료될 때까지 프로그램이 차단(block)되지 않고, 이벤트가 발생할 때 콜백(callback) 함수가 호출된다. 이러한 방식은 프로그램이 높은 응답성을 유지할 수 있게 해주며, 자원을 보다 효율적으로 사용할 수 있게 한다.</p>
<h3 id="boostasio">Boost.Asio의 비동기 타이머</h3>
<p>Boost.Asio는 C++에서 비동기 I/O를 간단하게 구현할 수 있도록 돕는 라이브러리로, 타이머를 사용한 비동기 작업도 지원한다. 여기서 사용되는 기본적인 개념은 "작업(task)"과 "이벤트(event)"의 구분이다. 타이머는 일종의 이벤트 소스이며, 비동기 작업의 실행 지연을 관리하는 데 사용된다.</p>
<p>Boost.Asio에서는 <code>boost::asio::steady_timer</code> 클래스가 타이머를 구현하는 데 사용된다. 이 클래스는 <code>std::chrono</code>를 기반으로 하여 고정된 시간 간격 동안 실행을 지연시킨다. 타이머를 사용하여 비동기 작업을 지연시키는 것은 비동기 이벤트 기반 프로그래밍에서 매우 중요하다.</p>
<p>타이머가 특정 시간에 도달하면 콜백 함수가 호출되어 이후의 작업을 수행하게 된다. 이때, 작업의 순차적인 진행이 아닌 이벤트가 발생할 때만 코드가 실행되는 방식으로 동작한다.</p>
<h3 id="_2">비동기 타이머의 수학적 모델링</h3>
<p>비동기 타이머의 동작은 이벤트 발생 시간과 이를 처리하는 작업의 지연 간격을 모델링하는 수학적 표현으로 나타낼 수 있다. 타이머가 동작하는 방식은 다음과 같다:</p>
<ol>
<li><span class="arithmatex"><span class="MathJax_Preview">t_0</span><script type="math/tex">t_0</script></span>: 타이머 시작 시점.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">t_1 = t_0 + \Delta t</span><script type="math/tex">t_1 = t_0 + \Delta t</script></span>: 타이머가 이벤트를 발생시키는 시점, 여기서 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 지연 시간.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>: 설정된 지연 시간(타임아웃)으로, 단위 시간으로 표현될 수 있으며, 보통 <code>std::chrono::duration</code> 타입으로 설정된다.</li>
</ol>
<p>따라서 타이머의 동작을 수식으로 표현하면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
t_1 = t_0 + \Delta t
</div>
<script type="math/tex; mode=display">
t_1 = t_0 + \Delta t
</script>
</div>
<p>이때, 비동기 작업은 타이머가 이벤트를 발생시키기 전까지는 실행되지 않으며, 이벤트 발생 이후에만 콜백 함수가 호출된다.</p>
<p>이를 상태 천이 모델로 표현할 수 있다. 타이머의 상태 변화는 아래와 같은 상태 다이어그램으로 나타낼 수 있다.</p>
<div class="mermaid">stateDiagram-v2
    [*] --&gt; Idle
    Idle --&gt; Active: 타이머 설정
    Active --&gt; Timeout: 시간 경과
    Timeout --&gt; Callback: 콜백 실행
    Callback --&gt; Idle: 완료
</div>
<p>위 다이어그램에서 타이머가 설정되면 <code>Active</code> 상태로 전이되며, 시간이 경과하면 <code>Timeout</code> 상태로 넘어간다. 이 시점에서 콜백이 실행되고, 다시 <code>Idle</code> 상태로 돌아가며 사이클이 종료된다.</p>
<h3 id="_3">이벤트 루프와 타이머의 상호작용</h3>
<p>이벤트 기반 프로그래밍에서 핵심 개념 중 하나는 <strong>이벤트 루프(event loop)</strong>이다. 이벤트 루프는 프로그램이 대기 상태로 있지 않고, 다양한 이벤트가 발생하면 이를 처리하는 구조를 제공한다. Boost.Asio의 경우 <code>boost::asio::io_context</code>가 이벤트 루프의 역할을 수행한다.</p>
<p>타이머는 이벤트 소스로 작동하며, 이벤트 루프에 등록된다. 이벤트 루프는 타이머가 만료되었을 때 이를 감지하고, 등록된 콜백을 실행하게 된다. 이를 수학적으로 설명하면, 타이머 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>의 상태는 다음과 같이 시간 함수로 표현될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S(t) = 
\begin{cases} 
\text{Active}, &amp; \text{if } t_0 \leq t &lt; t_1 \\
\text{Timeout}, &amp; \text{if } t = t_1
\end{cases}
</div>
<script type="math/tex; mode=display">
S(t) = 
\begin{cases} 
\text{Active}, & \text{if } t_0 \leq t < t_1 \\
\text{Timeout}, & \text{if } t = t_1
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">S(t)</span><script type="math/tex">S(t)</script></span>는 타이머의 상태를 나타내는 함수이며, 시간에 따라 타이머가 활성화되는지(Active) 혹은 타임아웃이 발생했는지(Timeout)를 결정한다.</p>
<p>Boost.Asio에서 이벤트 루프는 타이머 이벤트를 큐(queue)에 추가하고, 이벤트가 발생하면 이를 처리하는 방식으로 동작한다. 이벤트 루프는 다음과 같이 수식으로 표현할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
E(t) = 
\begin{cases} 
0, &amp; \text{if } t &lt; t_1 \\
1, &amp; \text{if } t = t_1
\end{cases}
</div>
<script type="math/tex; mode=display">
E(t) = 
\begin{cases} 
0, & \text{if } t < t_1 \\
1, & \text{if } t = t_1
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">E(t)</span><script type="math/tex">E(t)</script></span>는 이벤트 발생 여부를 나타내는 함수이다. <span class="arithmatex"><span class="MathJax_Preview">E(t) = 1</span><script type="math/tex">E(t) = 1</script></span>이면 이벤트가 발생했으며, 타이머가 만료되어 콜백이 실행될 수 있는 상태임을 의미한다. <span class="arithmatex"><span class="MathJax_Preview">E(t) = 0</span><script type="math/tex">E(t) = 0</script></span>이면 이벤트가 아직 발생하지 않은 상태이다.</p>
<h3 id="_4">비동기 타이머의 동시성 제어</h3>
<p>타이머는 비동기 프로그래밍에서 여러 작업을 동시에 처리할 수 있게 하는 중요한 요소 중 하나이다. 여러 타이머가 동시에 동작할 때 발생하는 동시성 문제는 다음과 같이 해결할 수 있다.</p>
<h4 id="_5">타이머 작업의 독립성</h4>
<p>비동기 타이머 작업은 독립적으로 실행될 수 있다. 각각의 타이머는 자신의 타임아웃 이벤트를 발생시키며, 해당 콜백을 실행한다. 두 개 이상의 타이머가 동시에 설정되어 있어도 이벤트 루프는 각 타이머가 설정된 시간에 맞춰 콜백을 순차적으로 실행한다.</p>
<p>이를 수학적으로 표현하면, 두 타이머 <span class="arithmatex"><span class="MathJax_Preview">t_A</span><script type="math/tex">t_A</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">t_B</span><script type="math/tex">t_B</script></span>가 독립적으로 설정된 경우, 각각의 타이머에 대해 다음과 같은 상태 함수를 정의할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S_A(t) = 
\begin{cases} 
\text{Active}, &amp; \text{if } t_0^A \leq t &lt; t_1^A \\
\text{Timeout}, &amp; \text{if } t = t_1^A
\end{cases}
</div>
<script type="math/tex; mode=display">
S_A(t) = 
\begin{cases} 
\text{Active}, & \text{if } t_0^A \leq t < t_1^A \\
\text{Timeout}, & \text{if } t = t_1^A
\end{cases}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
S_B(t) = 
\begin{cases} 
\text{Active}, &amp; \text{if } t_0^B \leq t &lt; t_1^B \\
\text{Timeout}, &amp; \text{if } t = t_1^B
\end{cases}
</div>
<script type="math/tex; mode=display">
S_B(t) = 
\begin{cases} 
\text{Active}, & \text{if } t_0^B \leq t < t_1^B \\
\text{Timeout}, & \text{if } t = t_1^B
\end{cases}
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">t_0^A</span><script type="math/tex">t_0^A</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">t_0^B</span><script type="math/tex">t_0^B</script></span>는 각각 타이머 A와 타이머 B의 시작 시간이며, <span class="arithmatex"><span class="MathJax_Preview">t_1^A</span><script type="math/tex">t_1^A</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">t_1^B</span><script type="math/tex">t_1^B</script></span>는 각각 타이머 A와 타이머 B의 타임아웃 시간이다.</p>
<h3 id="_6">타이머와 동기화 문제</h3>
<p>타이머의 동작이 비동기적으로 수행되므로, 타이머가 만료되기 전에 이벤트 루프에서 다른 작업이 수행될 가능성이 존재한다. 이러한 상황은 경합 조건(race condition)을 유발할 수 있다. 경합 조건을 방지하려면 타이머와 관련된 작업들을 적절히 동기화해야 한다. Boost.Asio는 이러한 동기화를 위한 메커니즘으로 스트랜드(strand)를 제공한다.</p>
<h3 id="_7">스트랜드를 통한 동기화</h3>
<p>스트랜드(strand)는 Boost.Asio에서 제공하는 동기화 메커니즘으로, 비동기 작업을 순차적으로 처리하여 경합 조건(race condition)을 방지한다. 스트랜드는 여러 비동기 작업이 동시에 접근할 수 있는 공유 자원을 안전하게 보호하며, 각 작업이 특정 순서대로 실행되도록 보장한다.</p>
<p>타이머와 같은 비동기 작업이 여러 개 있을 때, 각 작업이 서로의 실행 순서에 의존하지 않도록 하기 위해서는 스트랜드를 사용하는 것이 일반적인 방법이다. Boost.Asio에서 제공하는 <code>boost::asio::strand</code> 클래스는 이를 쉽게 구현할 수 있도록 돕는다.</p>
<p>스트랜드는 수학적으로 비동기 작업의 동시성 제어를 하는 일종의 <strong>잠금(locking) 메커니즘</strong>으로 볼 수 있다. 작업 <span class="arithmatex"><span class="MathJax_Preview">T_1, T_2, \dots, T_n</span><script type="math/tex">T_1, T_2, \dots, T_n</script></span>이 주어졌을 때, 스트랜드는 각 작업이 차례로 실행되도록 한다. 이를 수식으로 표현하면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_i(t) = 
\begin{cases} 
\text{Running}, &amp; \text{if } T_{i-1}(t) = \text{Complete} \\
\text{Waiting}, &amp; \text{if } T_{i-1}(t) \neq \text{Complete}
\end{cases}
</div>
<script type="math/tex; mode=display">
T_i(t) = 
\begin{cases} 
\text{Running}, & \text{if } T_{i-1}(t) = \text{Complete} \\
\text{Waiting}, & \text{if } T_{i-1}(t) \neq \text{Complete}
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T_i(t)</span><script type="math/tex">T_i(t)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-번째 작업이 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서 어떤 상태인지를 나타내며, 이전 작업 <span class="arithmatex"><span class="MathJax_Preview">T_{i-1}</span><script type="math/tex">T_{i-1}</script></span>가 완료되어야 다음 작업이 실행된다. 따라서, 스트랜드는 작업이 순차적으로 실행됨을 보장하며, 동시 접근으로 인한 데이터 불일치를 방지한다.</p>
<h4 id="_8">스트랜드와 타이머의 상호작용</h4>
<p>타이머 작업을 스트랜드를 사용하여 동기화할 경우, 비동기적으로 실행되는 콜백 함수들이 스트랜드 내에서 순차적으로 처리된다. 두 개의 타이머가 있을 때, 이 타이머들 각각의 콜백 함수가 동일한 스트랜드를 공유한다면, 스트랜드는 타이머가 타임아웃될 때마다 콜백을 차례로 실행하게 된다.</p>
<p>이를 상태 전이 모델로 설명하면 다음과 같다.</p>
<div class="mermaid">stateDiagram-v2
    [*] --&gt; StrandIdle
    StrandIdle --&gt; TimerA: 타이머 A 시작
    TimerA --&gt; CallbackA: 타이머 A 타임아웃
    CallbackA --&gt; TimerB: 타이머 B 시작
    TimerB --&gt; CallbackB: 타이머 B 타임아웃
    CallbackB --&gt; StrandIdle: 스트랜드 유휴 상태
</div>
<p>위 다이어그램은 스트랜드가 두 개의 타이머 작업을 순차적으로 처리하는 과정을 보여준다. 타이머 A의 타임아웃 콜백이 실행되고 나서야 타이머 B의 콜백이 실행되며, 이 모든 작업은 스트랜드를 통해 동기화된다.</p>
<h3 id="_9">비동기 타이머와 다중 이벤트 처리</h3>
<p>비동기 프로그래밍에서 타이머는 하나의 이벤트 처리 방식이지만, 다른 형태의 비동기 이벤트들과 함께 동작할 수도 있다. 예를 들어, I/O 이벤트와 타이머 이벤트를 동시에 처리해야 할 경우가 있을 수 있다.</p>
<p>Boost.Asio의 <code>boost::asio::io_context</code>는 이러한 다중 이벤트 처리를 지원하는 메커니즘을 제공한다. <strong>이벤트 큐(event queue)</strong>는 다양한 비동기 작업들을 대기시키고, 해당 작업의 이벤트가 발생할 때 이를 실행한다. 이벤트 큐는 수학적으로 다음과 같은 형태로 설명할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
Q(t) = \{ E_1(t), E_2(t), \dots, E_n(t) \}
</div>
<script type="math/tex; mode=display">
Q(t) = \{ E_1(t), E_2(t), \dots, E_n(t) \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">E_i(t)</span><script type="math/tex">E_i(t)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-번째 이벤트를 나타내며, 각 이벤트는 해당 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서 큐에 등록될 수 있다. 각 이벤트는 발생 시점에서 큐에서 꺼내져 실행되며, 이벤트가 발생하지 않으면 큐에서 대기 상태로 유지된다.</p>
<p>이벤트 큐는 타이머 이벤트뿐만 아니라 네트워크 I/O 이벤트, 파일 읽기/쓰기 이벤트 등을 모두 처리할 수 있는 범용적인 비동기 처리 메커니즘이다. 이를 Boost.Asio의 io_context가 처리하는 방식은 다음과 같다:</p>
<ol>
<li>타이머가 설정되고, 일정 시간이 지나 타임아웃 이벤트가 발생하면 해당 이벤트는 큐에 등록된다.</li>
<li>I/O 작업이 완료되면 해당 이벤트도 큐에 추가된다.</li>
<li>io_context는 큐에 있는 이벤트를 순차적으로 꺼내서 처리한다.</li>
</ol>
<p>이를 수학적으로 표현하면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Process}(Q(t)) = 
\begin{cases} 
E_i(t), &amp; \text{if } E_i(t) \in Q(t) \\
\text{Idle}, &amp; \text{if } Q(t) = \emptyset
\end{cases}
</div>
<script type="math/tex; mode=display">
\text{Process}(Q(t)) = 
\begin{cases} 
E_i(t), & \text{if } E_i(t) \in Q(t) \\
\text{Idle}, & \text{if } Q(t) = \emptyset
\end{cases}
</script>
</div>
<p>즉, 이벤트 큐가 비어있으면 시스템은 유휴 상태로 남아 있지만, 큐에 이벤트가 있을 때는 해당 이벤트를 처리한다.</p>
<h4 id="_10">이벤트 큐와 타이머의 우선순위 처리</h4>
<p>Boost.Asio에서는 기본적으로 모든 비동기 작업들이 이벤트 큐에 동일한 우선순위로 등록된다. 하지만 특정 상황에서는 타이머와 다른 비동기 작업들 간에 우선순위를 설정할 필요가 있을 수 있다. 예를 들어, 네트워크 I/O 작업이 더 중요한 경우, 타이머의 콜백 실행을 지연시킬 수 있다. 이는 수학적으로 <strong>우선순위 큐(priority queue)</strong>로 표현될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
Q(t) = \{ (E_1(t), p_1), (E_2(t), p_2), \dots, (E_n(t), p_n) \}
</div>
<script type="math/tex; mode=display">
Q(t) = \{ (E_1(t), p_1), (E_2(t), p_2), \dots, (E_n(t), p_n) \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">p_i</span><script type="math/tex">p_i</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-번째 이벤트의 우선순위이며, 우선순위가 높은 이벤트가 먼저 처리된다. 이러한 우선순위 처리는 시스템 자원의 효율적인 분배를 위해 중요하다. Boost.Asio는 기본적으로 우선순위를 제공하지 않지만, 이를 사용자 정의 방식으로 구현할 수 있다.</p>
<h3 id="_11">타이머와 비동기 연산의 결합</h3>
<p>비동기 타이머는 다른 비동기 연산들과 결합하여 더욱 복잡한 흐름을 만들 수 있다. Boost.Asio에서는 타이머와 I/O 작업을 결합하여 다양한 동작을 만들 수 있으며, 타이머를 사용한 비동기 지연 또는 타임아웃 처리가 일반적이다.</p>
<h4 id="io">타이머와 비동기 I/O 결합</h4>
<p>타이머와 비동기 I/O 작업이 결합될 때, 일정 시간이 지나거나 I/O 작업이 완료되면 콜백이 호출된다. 이때 I/O 작업의 완료 여부와 타이머의 타임아웃 여부가 동시에 처리되어야 하므로, 두 개의 비동기 이벤트를 병렬로 대기하는 구조가 필요하다. Boost.Asio에서는 <code>boost::asio::steady_timer</code>와 비동기 I/O 작업을 함께 처리하는 패턴을 제공하며, 이를 <strong>비동기 컴포지션(asynchronous composition)</strong>이라고 한다.</p>
<p>두 개의 비동기 작업이 있을 때, 하나는 타이머를 사용한 지연 작업이고, 다른 하나는 네트워크에서 데이터를 읽는 작업이라고 가정하자. 이 경우 두 작업이 병렬로 진행되며, 둘 중 하나라도 먼저 완료되면 나머지 작업은 취소되거나 무시될 수 있다. 이를 수식으로 설명하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
R(t) = \min(T(t), I(t))
</div>
<script type="math/tex; mode=display">
R(t) = \min(T(t), I(t))
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">R(t)</span><script type="math/tex">R(t)</script></span>는 실제로 완료된 작업을 나타내며, <span class="arithmatex"><span class="MathJax_Preview">T(t)</span><script type="math/tex">T(t)</script></span>는 타이머 작업의 완료 시간, <span class="arithmatex"><span class="MathJax_Preview">I(t)</span><script type="math/tex">I(t)</script></span>는 I/O 작업의 완료 시간을 의미한다. 즉, 두 작업 중 더 빨리 완료된 작업이 시스템에서 처리되는 것이다.</p>
<p>이를 상태 천이 모델로 표현하면 다음과 같다.</p>
<div class="mermaid">stateDiagram-v2
    [*] --&gt; WaitForBoth
    WaitForBoth --&gt; TimerComplete: 타이머 완료
    WaitForBoth --&gt; IOComplete: I/O 작업 완료
    TimerComplete --&gt; Complete: 타이머 완료 후 종료
    IOComplete --&gt; Complete: I/O 완료 후 종료
    Complete --&gt; [*]
</div>
<p>위 다이어그램에서 타이머와 I/O 작업이 모두 비동기적으로 시작되며, 둘 중 하나가 먼저 완료되면 시스템이 그 작업을 처리하고 나머지 작업은 무시된다.</p>
<h3 id="_12">타임아웃과 재시도 처리</h3>
<p>타이머를 사용한 비동기 연산에서 자주 등장하는 패턴 중 하나는 <strong>타임아웃(timeout)</strong>과 <strong>재시도(retry)</strong> 처리이다. 예를 들어, 네트워크 요청이 일정 시간 내에 완료되지 않으면 타임아웃을 발생시키고, 요청을 재시도할 수 있다. 이때 타이머는 실패 시점에 대한 시간적 기준을 제공하며, 요청의 재시도 주기를 조정하는 역할을 한다.</p>
<p>이를 수학적으로 표현하면, 타이머 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>의 상태 변화는 다음과 같다.</p>
<ol>
<li>타이머가 설정된 시간 <span class="arithmatex"><span class="MathJax_Preview">t_0</span><script type="math/tex">t_0</script></span>에서 시작.</li>
<li>타이머가 타임아웃 시점 <span class="arithmatex"><span class="MathJax_Preview">t_1 = t_0 + \Delta t</span><script type="math/tex">t_1 = t_0 + \Delta t</script></span>에서 만료.</li>
<li>네트워크 요청이 완료되지 않으면 타이머를 다시 시작하여 재시도.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
t_{n+1} = t_n + \Delta t
</div>
<script type="math/tex; mode=display">
t_{n+1} = t_n + \Delta t
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t_n</span><script type="math/tex">t_n</script></span>은 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-번째 요청의 시작 시간이며, <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 타이머의 지연 시간(타임아웃 간격)을 나타낸다.</p>
<h4 id="_13">재시도 횟수 제한</h4>
<p>타이머를 사용한 재시도에는 일정 횟수의 제한을 두는 것이 일반적이다. 요청이 여러 번 실패하면 시스템이 재시도를 중단하고 오류를 반환하는 방식이다. 이때 재시도 횟수를 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>으로 제한하면, 재시도 횟수를 수식으로 다음과 같이 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{RetryCount} = 
\begin{cases} 
n, &amp; \text{if } n \leq N \\
\text{Error}, &amp; \text{if } n &gt; N
\end{cases}
</div>
<script type="math/tex; mode=display">
\text{RetryCount} = 
\begin{cases} 
n, & \text{if } n \leq N \\
\text{Error}, & \text{if } n > N
\end{cases}
</script>
</div>
<p>즉, 재시도가 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>번을 초과하면 오류가 발생하고, 시스템은 더 이상 재시도하지 않는다.</p>
<h3 id="_14">타이머를 사용한 지연 연산</h3>
<p>비동기 타이머는 특정 시간 동안 작업을 지연시키는 데 사용될 수 있다. 이러한 지연 연산은 특히 대기 시간이 필요한 비동기 작업에서 유용하다. 타이머를 사용한 지연 연산은 다음과 같이 모델링할 수 있다:</p>
<ol>
<li>타이머 시작 시간 <span class="arithmatex"><span class="MathJax_Preview">t_0</span><script type="math/tex">t_0</script></span>.</li>
<li>타이머가 지연 시간 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span> 후에 완료.</li>
<li>타이머가 완료되면 이후 작업이 수행.</li>
</ol>
<p>이를 수식으로 나타내면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
t_{\text{complete}} = t_0 + \Delta t
</div>
<script type="math/tex; mode=display">
t_{\text{complete}} = t_0 + \Delta t
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 지연 시간을 나타낸다. 지연 연산이 완료되면 이후의 작업이 실행된다.</p>
<p>이와 같은 비동기 타이머의 지연 연산은 단순한 지연뿐 아니라, 네트워크 요청의 재시도, 대기 시간 조정 등 다양한 시나리오에 적용될 수 있다. Boost.Asio에서 타이머의 지연 연산은 <code>async_wait</code> 함수와 같은 비동기 API를 통해 쉽게 구현할 수 있다.</p>
<h3 id="_15">타이머와 다중 쓰레드 환경</h3>
<p>Boost.Asio는 다중 쓰레드 환경에서도 잘 동작하도록 설계되었으며, 타이머 역시 여러 쓰레드에서 사용할 수 있다. 다중 쓰레드에서 타이머를 사용할 때는 쓰레드 간 경합 조건을 방지하기 위해 동기화가 필요하다. 이를 위해 스트랜드가 주로 사용되며, 스트랜드는 동일한 작업을 순차적으로 처리하여 데이터 무결성을 보장한다.</p>
<p>두 개 이상의 쓰레드가 동시에 타이머를 설정하고 처리할 때, 각 타이머 작업이 서로 독립적으로 실행되지만, 공유 자원에 접근할 때는 스트랜드를 통해 동기화가 이루어진다. 이 동작을 수식으로 나타내면, 두 개의 쓰레드 <span class="arithmatex"><span class="MathJax_Preview">T_1, T_2</span><script type="math/tex">T_1, T_2</script></span>가 동일한 타이머 작업을 처리할 때 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S(t) = 
\begin{cases} 
T_1(t), &amp; \text{if } T_1 \text{ is active} \\
T_2(t), &amp; \text{if } T_2 \text{ is active}
\end{cases}
</div>
<script type="math/tex; mode=display">
S(t) = 
\begin{cases} 
T_1(t), & \text{if } T_1 \text{ is active} \\
T_2(t), & \text{if } T_2 \text{ is active}
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">S(t)</span><script type="math/tex">S(t)</script></span>는 타이머의 상태이며, 각 쓰레드가 순차적으로 타이머 작업을 처리함을 나타낸다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0806/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0806/">
        타이머 비동기 작업의 오류 처리
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0804/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0804/">
        동적 타이머 관리 및 조작
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>