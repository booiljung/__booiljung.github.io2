<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/programming/cplusplus/cplusplus_boost_asio_programming/chapter_08/0804/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>동적 타이머 관리 및 조작 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ud0c0\uc774\uba38\uc758 \ub3d9\uc801 \uc0dd\uc131", url: "#_top", children: [
              {title: "\ub3d9\uc801 \ud0c0\uc774\uba38 \uc0dd\uc131 \uc608\uc2dc", url: "#_2" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uc0c1\ud0dc \ubcc0\uacbd \ubc0f \uc7ac\uc124\uc815", url: "#_3", children: [
          ]},
          {title: "\ub2e4\uc911 \ud0c0\uc774\uba38 \uad00\ub9ac", url: "#_4", children: [
          ]},
          {title: "\ud0c0\uc774\uba38 \ucde8\uc18c \ubc0f \uc7ac\uc0ac\uc6a9", url: "#_5", children: [
              {title: "\ud0c0\uc774\uba38\uc758 \uc7ac\uc0ac\uc6a9", url: "#_6" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \ube44\ub3d9\uae30 \uc791\uc5c5 \ucc98\ub9ac \uc2dc \uace0\ub824\uc0ac\ud56d", url: "#_7", children: [
              {title: "\ud0c0\uc774\uba38\uc640 \ub2e4\uc911 \uc2a4\ub808\ub4dc \ud658\uacbd", url: "#_8" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \ub3d9\uc801 \uc870\uc791\uacfc \ucf5c\ubc31 \uad00\ub9ac", url: "#_9", children: [
              {title: "\ucf5c\ubc31 \ud568\uc218\uc758 \ub3d9\uc801 \ubcc0\uacbd", url: "#_10" },
              {title: "\ucf5c\ubc31 \ud568\uc218\uc758 \uc0c1\ud0dc \uad00\ub9ac", url: "#_11" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uc815\ud655\uc131 \ubc0f \uc131\ub2a5 \uace0\ub824", url: "#_12", children: [
              {title: "\ud0c0\uc774\uba38\uc758 \uc815\ud655\uc131\uc744 \ubcf4\uc7a5\ud558\uae30 \uc704\ud55c \uc804\ub7b5", url: "#_13" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \uc0c1\ud0dc \ud655\uc778 \ubc0f \uc608\uc678 \ucc98\ub9ac", url: "#_14", children: [
              {title: "\ud0c0\uc774\uba38\uc758 \uc0c1\ud0dc \ud655\uc778", url: "#_15" },
              {title: "\uc608\uc678 \ucc98\ub9ac", url: "#_16" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \ub3d9\uae30\uc640 \ube44\ub3d9\uae30 \uc0ac\uc6a9 \ube44\uad50", url: "#_17", children: [
              {title: "\ub3d9\uae30 \ud0c0\uc774\uba38", url: "#_18" },
              {title: "\ube44\ub3d9\uae30 \ud0c0\uc774\uba38", url: "#_19" },
              {title: "\ub3d9\uae30\uc640 \ube44\ub3d9\uae30\uc758 \uc7a5\ub2e8\uc810", url: "#_20" },
          ]},
          {title: "\ud0c0\uc774\uba38\uc758 \ub300\uae30 \uc911\ub2e8 \ubc0f \uc7ac\uc2dc\uc791", url: "#_21", children: [
              {title: "\ud0c0\uc774\uba38 \ub300\uae30 \uc911\ub2e8", url: "#_22" },
              {title: "\ud0c0\uc774\uba38 \uc7ac\uc2dc\uc791", url: "#_23" },
          ]},
          {title: "\ud0c0\uc774\uba38\ub97c \ud65c\uc6a9\ud55c \ube44\ub3d9\uae30 \ubc18\ubcf5 \uc791\uc5c5", url: "#_24", children: [
              {title: "\ubc18\ubcf5 \ud0c0\uc774\uba38 \uad6c\ud604 \uc608\uc2dc", url: "#_25" },
          ]},
          {title: "\ub2e4\uc911 \ud0c0\uc774\uba38\ub97c \ud1b5\ud55c \ubcf5\ud569 \uc791\uc5c5 \uc2a4\ucf00\uc904\ub9c1", url: "#_26", children: [
              {title: "\ub2e4\uc911 \ud0c0\uc774\uba38 \uad00\ub9ac \uc608\uc2dc", url: "#_27" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0805/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0805/" class="btn btn-xs btn-link">
        타이머와 이벤트 기반 프로그래밍
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0803/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0803/" class="btn btn-xs btn-link">
        Boost.Asio를 활용한 비동기 타이머 고정된 시간 간격의 작업 스케줄링
      </a>
    </div>
    
  </div>

    

    <h3 id="_1">타이머의 동적 생성</h3>
<p>Boost.Asio에서 제공하는 <code>deadline_timer</code> 클래스는 타이머를 관리하는 중요한 도구로, 이를 동적으로 생성하고 조작하는 것은 비동기 프로그래밍에서 필수적인 기술이다. 동적 타이머 관리는 프로그램 실행 중 여러 개의 타이머를 필요에 따라 생성하거나 소멸시키는 과정을 포함한다. </p>
<p>타이머는 특정 시간 이후에 특정 작업을 실행하는 비동기적 처리를 가능하게 하며, 이러한 타이머가 동적으로 생성되는 경우 다양한 상황에 대응할 수 있다. 특히, 다양한 시간 간격으로 다수의 작업을 처리해야 하는 시스템에서는 동적으로 타이머를 생성하고, 조건에 따라 타이머를 변경하거나 중지하는 것이 필요하다.</p>
<p>동적 타이머를 관리할 때 주의해야 할 점은 타이머의 생명 주기 관리이다. 즉, 타이머가 언제 시작하고 언제 종료될지를 결정하고, 만약 필요하지 않다면 타이머를 적절히 소멸시켜 자원을 효율적으로 사용하는 것이다.</p>
<h4 id="_2">동적 타이머 생성 예시</h4>
<p>다음 예시는 동적 타이머를 생성하고, 이후에 해당 타이머를 기반으로 작업을 비동기로 처리하는 간단한 코드이다.</p>
<pre><code class="language-cpp">boost::asio::io_service io_service;
boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5));

timer.async_wait([](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer expired!&quot; &lt;&lt; std::endl;
    }
});

io_service.run();
</code></pre>
<p>위 코드에서 타이머는 동적으로 생성되었으며, 5초 후에 비동기 작업이 실행된다. 동적으로 생성된 타이머는 <code>async_wait</code>을 통해 지정된 시간이 경과한 후에 비동기 콜백을 호출하는 구조로 되어 있다.</p>
<h3 id="_3">타이머의 상태 변경 및 재설정</h3>
<p>동적 타이머는 필요에 따라 설정된 시간을 변경하거나 중간에 재설정할 수 있다. <code>expires_at</code> 또는 <code>expires_from_now</code> 메소드를 사용하여 타이머의 종료 시간을 수정할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
t_{\text{expires}} = t_{\text{now}} + \Delta t
</div>
<script type="math/tex; mode=display">
t_{\text{expires}} = t_{\text{now}} + \Delta t
</script>
</div>
<p>여기서:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">t_{\text{expires}}</span><script type="math/tex">t_{\text{expires}}</script></span>는 타이머의 만료 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">t_{\text{now}}</span><script type="math/tex">t_{\text{now}}</script></span>는 현재 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 추가적으로 기다릴 시간</li>
</ul>
<p>이 수식을 기반으로 타이머의 만료 시간을 설정하는 방식으로 동작한다.</p>
<p>다음은 타이머를 재설정하는 코드 예시이다.</p>
<pre><code class="language-cpp">timer.expires_from_now(boost::posix_time::seconds(10));
</code></pre>
<p>이 코드를 통해 타이머는 10초 후에 만료되도록 재설정된다. 타이머의 상태를 변경하는 경우, 이전에 설정된 대기 시간이 있더라도 이를 무시하고 새롭게 설정된 시간이 반영된다.</p>
<h3 id="_4">다중 타이머 관리</h3>
<p>다수의 타이머를 관리하는 경우, 각 타이머가 독립적으로 동작하며 서로 다른 작업을 처리할 수 있다. 이러한 타이머들을 효율적으로 관리하기 위해서는 각 타이머에 고유한 핸들을 할당하고, 필요할 때마다 적절한 타이머를 참조할 수 있어야 한다. </p>
<p>다음은 여러 타이머를 관리하는 예시이다.</p>
<pre><code class="language-cpp">std::vector&lt;std::shared_ptr&lt;boost::asio::deadline_timer&gt;&gt; timers;
for (int i = 0; i &lt; 5; ++i) {
    auto timer = std::make_shared&lt;boost::asio::deadline_timer&gt;(io_service, boost::posix_time::seconds(i+1));
    timer-&gt;async_wait([i](const boost::system::error_code&amp; error) {
        if (!error) {
            std::cout &lt;&lt; &quot;Timer &quot; &lt;&lt; i &lt;&lt; &quot; expired!&quot; &lt;&lt; std::endl;
        }
    });
    timers.push_back(timer);
}
</code></pre>
<p>위 코드는 5개의 타이머를 동적으로 생성하고, 각 타이머가 순차적으로 만료되도록 한다. 이처럼 벡터 등을 활용하여 다수의 타이머를 관리하면 각각의 타이머를 독립적으로 제어할 수 있다.</p>
<h3 id="_5">타이머 취소 및 재사용</h3>
<p>동적으로 생성된 타이머는 필요에 따라 취소하거나 재사용할 수 있다. 타이머를 취소하는 방법은 <code>cancel</code> 메소드를 사용하는 것이다. 타이머가 취소되면 해당 타이머와 연관된 비동기 작업은 호출되지 않으며, 이미 대기 중이던 작업은 취소 상태로 마무리된다.</p>
<p>타이머의 취소는 다음과 같은 수식으로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
C_{\text{timer}} = 1 \implies \text{타이머 취소}
</div>
<script type="math/tex; mode=display">
C_{\text{timer}} = 1 \implies \text{타이머 취소}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">C_{\text{timer}}</span><script type="math/tex">C_{\text{timer}}</script></span>는 타이머의 취소 상태를 나타내는 플래그이며, 값이 1이면 타이머가 취소된 상태임을 의미한다. 타이머가 취소되면 그와 관련된 비동기 작업은 더 이상 실행되지 않는다.</p>
<p>타이머 취소 예시는 다음과 같다.</p>
<pre><code class="language-cpp">boost::system::error_code ec;
timer.cancel(ec);
if (ec) {
    std::cout &lt;&lt; &quot;Error occurred during timer cancellation: &quot; &lt;&lt; ec.message() &lt;&lt; std::endl;
}
</code></pre>
<p>위 코드에서 <code>cancel</code> 메소드는 타이머를 취소하며, 취소가 정상적으로 처리되지 않으면 에러 코드가 반환된다. 타이머를 취소한 후에도 해당 타이머 객체는 여전히 유효하며, 다시 설정해서 재사용할 수 있다.</p>
<h4 id="_6">타이머의 재사용</h4>
<p>동일한 타이머 객체를 다시 사용하려면 <code>expires_from_now</code>를 통해 새로운 만료 시간을 설정한 후 <code>async_wait</code>을 호출하여 다시 비동기 대기를 설정할 수 있다. 이를 통해 타이머 객체를 재사용하는 비용을 줄일 수 있다.</p>
<pre><code class="language-cpp">timer.expires_from_now(boost::posix_time::seconds(15));
timer.async_wait([](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer expired after reconfiguration!&quot; &lt;&lt; std::endl;
    }
});
</code></pre>
<p>위 코드에서는 타이머를 재설정한 후 다시 비동기 작업을 설정하여 새로운 타이머 만료 시점을 기반으로 작업을 수행하도록 한다.</p>
<h3 id="_7">타이머의 비동기 작업 처리 시 고려사항</h3>
<p>비동기 타이머는 특정 시간 후에 작업을 실행하는 방식이기 때문에, 대기 중인 시간 동안 다른 작업이 자유롭게 실행될 수 있어야 한다. 이를 위해 Boost.Asio는 이벤트 기반 비동기 모델을 제공하며, 모든 비동기 작업은 <code>io_service</code> 또는 <code>io_context</code>에서 관리된다.</p>
<p>이때, 타이머의 비동기 대기가 완료될 때까지의 시간 간격을 수식으로 나타내면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{wait}} = t_{\text{expires}} - t_{\text{now}}
</div>
<script type="math/tex; mode=display">
T_{\text{wait}} = t_{\text{expires}} - t_{\text{now}}
</script>
</div>
<p>여기서:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">T_{\text{wait}}</span><script type="math/tex">T_{\text{wait}}</script></span>는 대기 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">t_{\text{expires}}</span><script type="math/tex">t_{\text{expires}}</script></span>는 타이머의 만료 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">t_{\text{now}}</span><script type="math/tex">t_{\text{now}}</script></span>는 현재 시간</li>
</ul>
<p>비동기 작업이 여러 개 있을 때, 타이머가 만료되기 전에 다른 비동기 작업들이 병렬로 실행되거나 완료될 수 있다. 이는 타이머 만료와 상관없이 시스템이 유연하게 다른 작업들을 처리할 수 있도록 한다.</p>
<h4 id="_8">타이머와 다중 스레드 환경</h4>
<p>동적 타이머를 다중 스레드 환경에서 관리할 때는 주의가 필요하다. 각 스레드가 별도의 타이머를 처리하거나, 동일한 타이머를 여러 스레드에서 접근하는 상황이 발생할 수 있기 때문이다. Boost.Asio는 기본적으로 스레드 안전하지 않기 때문에, 여러 스레드에서 타이머 객체를 공유하려면 적절한 동기화가 필요하다.</p>
<p>예를 들어, 다음과 같이 여러 스레드에서 타이머를 동시에 사용할 수 있다.</p>
<pre><code class="language-cpp">boost::asio::io_service io_service;
boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(10));

std::thread t1([&amp;io_service]() {
    io_service.run();
});

std::thread t2([&amp;io_service]() {
    io_service.run();
});

timer.async_wait([](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer expired in multithreaded context!&quot; &lt;&lt; std::endl;
    }
});

t1.join();
t2.join();
</code></pre>
<p>이 코드에서는 두 개의 스레드가 동일한 <code>io_service</code>를 공유하여 타이머 작업을 처리한다. <code>io_service</code>는 스레드 간에 안전하게 공유되지만, 타이머 자체는 안전하지 않기 때문에 스레드 간에 타이머를 직접적으로 접근할 때는 동기화가 필요하다.</p>
<h3 id="_9">타이머의 동적 조작과 콜백 관리</h3>
<p>동적 타이머 관리에서 중요한 또 하나의 측면은 타이머에 연결된 콜백 함수의 관리이다. 타이머는 비동기적으로 작업을 수행하는 도구이므로, 타이머가 만료되었을 때 실행할 작업을 콜백 함수로 설정해야 한다. 이때 콜백 함수는 타이머의 상태나 특정 조건에 따라 동적으로 변경하거나 조정할 수 있다.</p>
<h4 id="_10">콜백 함수의 동적 변경</h4>
<p>타이머에 연결된 콜백 함수는 비동기 작업이 완료될 때 호출된다. 그러나 타이머가 동적으로 변경되는 경우, 콜백 함수도 이에 따라 동적으로 변경해야 할 수 있다. 예를 들어, 타이머 만료 시점에 따라 다른 작업을 수행하거나, 특정 조건이 충족될 때 다른 콜백을 실행하도록 할 수 있다.</p>
<p>다음은 콜백을 동적으로 변경하는 코드의 예시이다.</p>
<pre><code class="language-cpp">void first_callback(const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;First callback executed!&quot; &lt;&lt; std::endl;
    }
}

void second_callback(const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Second callback executed!&quot; &lt;&lt; std::endl;
    }
}

boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5));
timer.async_wait(first_callback);

// 타이머가 실행되기 전에 콜백을 변경
timer.expires_from_now(boost::posix_time::seconds(10));
timer.async_wait(second_callback);
</code></pre>
<p>위 코드에서 처음에는 <code>first_callback</code>이 설정되어 있었지만, 타이머 만료 시간이 변경되면서 <code>second_callback</code>으로 변경되었다. 타이머는 재설정된 시간에 따라 새로운 콜백 함수를 호출한다.</p>
<h4 id="_11">콜백 함수의 상태 관리</h4>
<p>타이머의 콜백 함수에서 시스템 상태나 타이머의 만료 시간을 동적으로 변경할 수 있다. 예를 들어, 타이머가 반복적으로 실행되도록 하고, 콜백 함수 내부에서 타이머를 다시 시작하도록 할 수 있다.</p>
<p>이를 표현하는 수식은 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{next}} = T_{\text{current}} + \Delta T
</div>
<script type="math/tex; mode=display">
T_{\text{next}} = T_{\text{current}} + \Delta T
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T_{\text{next}}</span><script type="math/tex">T_{\text{next}}</script></span>는 다음 타이머의 만료 시간이고, <span class="arithmatex"><span class="MathJax_Preview">\Delta T</span><script type="math/tex">\Delta T</script></span>는 현재 타이머 만료 후의 추가 대기 시간이다. 이러한 방식으로 타이머는 콜백 내에서 동적으로 재설정되며, 주기적인 작업을 수행할 수 있다.</p>
<pre><code class="language-cpp">void repeat_callback(const boost::system::error_code&amp; error, boost::asio::deadline_timer&amp; timer) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer expired, repeating...&quot; &lt;&lt; std::endl;
        timer.expires_from_now(boost::posix_time::seconds(5));
        timer.async_wait(std::bind(repeat_callback, std::placeholders::_1, std::ref(timer)));
    }
}
</code></pre>
<p>위 코드에서 타이머는 만료될 때마다 5초 후에 다시 설정되며, 반복적으로 작업을 수행하게 된다. 이와 같이 콜백 함수 내부에서 타이머를 동적으로 제어함으로써, 주기적인 작업을 간편하게 처리할 수 있다.</p>
<h3 id="_12">타이머의 정확성 및 성능 고려</h3>
<p>타이머를 비동기적으로 사용하면서 중요한 것은 타이머의 정확성이다. Boost.Asio에서 제공하는 타이머는 높은 정밀도로 시간을 측정하지만, 시스템의 부하 상태나 타이머 재설정 시점에 따라 정확도가 떨어질 수 있다. 특히, 다중 타이머를 관리할 때는 시스템의 자원을 효율적으로 사용하는 것이 성능에 큰 영향을 미친다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
E_{\text{timer}} = T_{\text{actual}} - T_{\text{expected}}
</div>
<script type="math/tex; mode=display">
E_{\text{timer}} = T_{\text{actual}} - T_{\text{expected}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">E_{\text{timer}}</span><script type="math/tex">E_{\text{timer}}</script></span>는 타이머의 오차, <span class="arithmatex"><span class="MathJax_Preview">T_{\text{actual}}</span><script type="math/tex">T_{\text{actual}}</script></span>은 실제 타이머가 만료된 시간, <span class="arithmatex"><span class="MathJax_Preview">T_{\text{expected}}</span><script type="math/tex">T_{\text{expected}}</script></span>는 예상된 만료 시간을 의미한다. 이 오차가 발생하는 주된 이유는 타이머가 이벤트 큐에 추가되고 실행되는 동안의 시스템 상태 때문이다.</p>
<h4 id="_13">타이머의 정확성을 보장하기 위한 전략</h4>
<p>타이머의 정확성을 높이기 위해 사용할 수 있는 몇 가지 전략은 다음과 같다.</p>
<ol>
<li>
<p><strong>높은 우선순위 설정</strong>: 타이머가 만료되었을 때 즉시 콜백이 실행될 수 있도록 타이머의 우선순위를 높이는 것이다. 이를 위해 <code>io_service</code>의 스레드 수를 증가시켜 비동기 작업이 신속히 처리되도록 할 수 있다.</p>
</li>
<li>
<p><strong>타이머 재설정 시점 최적화</strong>: 타이머가 만료되기 직전에 재설정하는 것이 아니라, 적절한 시점에서 타이머를 미리 설정하여 시스템이 타이머 작업을 빠르게 인식하도록 해야 한다.</p>
</li>
<li>
<p><strong>정확한 시간 측정 도구 사용</strong>: Boost.Asio는 <code>steady_timer</code>를 제공하여 시스템 클럭에 의존하지 않고 상대적으로 정확한 시간 기반 타이머를 구현할 수 있다.</p>
</li>
</ol>
<pre><code class="language-cpp">boost::asio::steady_timer steady_timer(io_service, boost::asio::chrono::seconds(5));
steady_timer.async_wait([](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Steady timer expired with high precision!&quot; &lt;&lt; std::endl;
    }
});
</code></pre>
<p><code>steady_timer</code>는 시스템의 시간 변동에 영향을 받지 않고 상대적으로 정확한 시간 측정을 제공하므로, 특정 시간 간격을 정확하게 유지해야 하는 작업에 적합하다.</p>
<h3 id="_14">타이머의 상태 확인 및 예외 처리</h3>
<p>동적 타이머 관리에서 타이머의 상태를 실시간으로 확인하고, 예외가 발생할 경우 이를 처리하는 것은 중요한 부분이다. 타이머가 정상적으로 만료되었는지, 아니면 취소되었는지 등을 정확히 파악해야 하며, 발생할 수 있는 다양한 에러 상황에 적절히 대응해야 한다.</p>
<h4 id="_15">타이머의 상태 확인</h4>
<p>타이머의 상태를 확인하는 방법 중 하나는 비동기 작업에서 전달되는 <code>boost::system::error_code</code> 객체를 이용하는 것이다. 타이머가 성공적으로 만료되었는지, 취소되었는지, 혹은 에러가 발생했는지를 확인할 수 있다.</p>
<p>타이머의 상태는 다음과 같은 수식으로 표현할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S_{\text{timer}} =
\begin{cases} 
0, &amp; \text{정상 만료} \\
1, &amp; \text{취소됨} \\
2, &amp; \text{에러 발생} 
\end{cases}
</div>
<script type="math/tex; mode=display">
S_{\text{timer}} =
\begin{cases} 
0, & \text{정상 만료} \\
1, & \text{취소됨} \\
2, & \text{에러 발생} 
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">S_{\text{timer}}</span><script type="math/tex">S_{\text{timer}}</script></span>는 타이머의 상태를 나타내며, 정상적으로 만료되었을 경우 0, 취소되었을 경우 1, 에러가 발생했을 경우 2로 나타낸다.</p>
<p>예를 들어, 아래 코드에서는 타이머의 상태를 확인하여 처리하는 과정을 보여준다.</p>
<pre><code class="language-cpp">void timer_callback(const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer expired normally!&quot; &lt;&lt; std::endl;
    } else if (error == boost::asio::error::operation_aborted) {
        std::cout &lt;&lt; &quot;Timer was cancelled.&quot; &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;An error occurred: &quot; &lt;&lt; error.message() &lt;&lt; std::endl;
    }
}
</code></pre>
<h4 id="_16">예외 처리</h4>
<p>Boost.Asio에서 타이머를 사용할 때 발생할 수 있는 예외는 주로 시스템 에러에 기인한다. 대표적으로 다음과 같은 상황에서 예외가 발생할 수 있다.</p>
<ol>
<li><strong>타이머 취소</strong>: 타이머가 외부에서 취소된 경우, 이는 <code>boost::asio::error::operation_aborted</code>로 처리된다.</li>
<li><strong>시스템 리소스 부족</strong>: 타이머가 생성되었으나 시스템 리소스가 부족하여 제대로 실행되지 못한 경우, <code>boost::system::system_error</code>가 발생할 수 있다.</li>
</ol>
<p>이러한 예외는 비동기 콜백 함수 내에서 적절히 처리해야 한다.</p>
<pre><code class="language-cpp">try {
    boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5));
    timer.async_wait(timer_callback);
    io_service.run();
} catch (const boost::system::system_error&amp; e) {
    std::cerr &lt;&lt; &quot;System error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
}
</code></pre>
<p>위 코드는 타이머 사용 중 발생할 수 있는 시스템 예외를 처리하는 예시이다. <code>try-catch</code> 블록을 사용하여 예외 발생 시 적절한 대응을 할 수 있다.</p>
<h3 id="_17">타이머의 동기와 비동기 사용 비교</h3>
<p>Boost.Asio에서는 타이머를 동기적으로 사용할 수 있으며, 이 경우 타이머가 만료될 때까지 현재 스레드는 대기 상태가 된다. 비동기적으로 사용할 때와의 차이를 비교해 보자.</p>
<h4 id="_18">동기 타이머</h4>
<p>동기 타이머는 <code>wait()</code> 메소드를 사용하여 타이머가 만료될 때까지 스레드를 블록(block)시킨다. 이는 수식으로 다음과 같이 표현될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{block}} = t_{\text{expires}} - t_{\text{now}}
</div>
<script type="math/tex; mode=display">
T_{\text{block}} = t_{\text{expires}} - t_{\text{now}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T_{\text{block}}</span><script type="math/tex">T_{\text{block}}</script></span>는 블록된 시간이며, 타이머가 만료될 때까지 현재 스레드가 블록된 시간을 의미한다.</p>
<pre><code class="language-cpp">boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5));
timer.wait();
std::cout &lt;&lt; &quot;Timer expired synchronously!&quot; &lt;&lt; std::endl;
</code></pre>
<p>위 코드에서는 타이머가 동기적으로 실행되며, 5초 동안 스레드가 블록된 상태로 유지된다.</p>
<h4 id="_19">비동기 타이머</h4>
<p>비동기 타이머는 <code>async_wait()</code> 메소드를 통해 스레드를 블록시키지 않고, 타이머가 만료되었을 때만 콜백 함수가 호출된다. 이 방식은 비동기적으로 다른 작업을 동시에 처리하는 데 유리하다.</p>
<pre><code class="language-cpp">boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5));
timer.async_wait([](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer expired asynchronously!&quot; &lt;&lt; std::endl;
    }
});
io_service.run();
</code></pre>
<p>위 코드는 비동기 타이머를 사용한 예시이며, 타이머가 만료될 때까지 다른 작업이 자유롭게 실행될 수 있다.</p>
<h4 id="_20">동기와 비동기의 장단점</h4>
<table>
<thead>
<tr>
<th><strong>특징</strong></th>
<th><strong>동기 타이머</strong></th>
<th><strong>비동기 타이머</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>스레드 상태</td>
<td>타이머 만료 시까지 블록됨</td>
<td>블록되지 않음, 다른 작업과 병행 가능</td>
</tr>
<tr>
<td>자원 사용</td>
<td>단일 스레드에서 간단히 사용 가능</td>
<td>다중 작업이 동시에 실행될 때 더 유리</td>
</tr>
<tr>
<td>코드 복잡도</td>
<td>단순</td>
<td>콜백 함수 또는 이벤트 핸들러 관리 필요</td>
</tr>
<tr>
<td>성능</td>
<td>제한된 자원 사용 시 적합</td>
<td>고성능 비동기 시스템에 적합</td>
</tr>
</tbody>
</table>
<p>동기 타이머는 간단한 프로그램에서 적합하지만, 비동기 타이머는 더 복잡하고 높은 성능을 요구하는 상황에 적합하다.</p>
<h3 id="_21">타이머의 대기 중단 및 재시작</h3>
<p>Boost.Asio 타이머는 중간에 대기를 중단하거나 다시 시작할 수 있다. 타이머 대기 중단은 타이머가 특정 시간 전에 취소되는 경우로, 이를 통해 타이머의 대기 시간을 유동적으로 관리할 수 있다. 대기 중단과 재시작은 시스템의 요구 사항에 따라 적절히 조정하여 성능을 최적화하는 데 도움을 줄 수 있다.</p>
<h4 id="_22">타이머 대기 중단</h4>
<p>타이머 대기를 중단하는 가장 간단한 방법은 <code>cancel()</code> 메소드를 사용하는 것이다. <code>cancel()</code>은 타이머의 대기를 중지하고, 타이머에 등록된 비동기 작업을 취소한다. 이렇게 취소된 타이머는 더 이상 대기하지 않으며, 그에 따른 콜백 함수도 호출되지 않는다.</p>
<p>타이머의 대기 중단을 수식으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
C_{\text{wait}} = 1 \implies T_{\text{remaining}} = 0
</div>
<script type="math/tex; mode=display">
C_{\text{wait}} = 1 \implies T_{\text{remaining}} = 0
</script>
</div>
<p>여기서:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">C_{\text{wait}}</span><script type="math/tex">C_{\text{wait}}</script></span>는 타이머의 대기 중단 플래그</li>
<li><span class="arithmatex"><span class="MathJax_Preview">T_{\text{remaining}}</span><script type="math/tex">T_{\text{remaining}}</script></span>은 남은 대기 시간, 대기가 취소되면 0이 된다</li>
</ul>
<p>다음은 타이머 대기 중단의 코드 예시이다.</p>
<pre><code class="language-cpp">boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(10));
timer.async_wait([](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer expired normally.&quot; &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;Timer was cancelled.&quot; &lt;&lt; std::endl;
    }
});

boost::system::error_code ec;
timer.cancel(ec);  // 타이머 대기 중단
io_service.run();
</code></pre>
<p>위 코드에서 타이머는 10초 동안 대기하지만, <code>cancel()</code>이 호출됨으로써 대기 중단 상태가 되고 타이머의 콜백 함수는 더 이상 정상적으로 실행되지 않는다. 콜백 함수 내부에서 에러 코드를 통해 타이머가 취소되었음을 확인할 수 있다.</p>
<h4 id="_23">타이머 재시작</h4>
<p>타이머를 대기 중단한 후 다시 대기 상태로 전환하려면 타이머의 만료 시간을 재설정하고, 비동기 대기를 다시 설정해야 한다. <code>expires_from_now()</code> 또는 <code>expires_at()</code> 메소드를 통해 새로운 만료 시간을 설정한 뒤 <code>async_wait()</code>을 호출하여 타이머를 재시작할 수 있다.</p>
<p>타이머의 재시작을 수식으로 표현하면 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{new}} = t_{\text{now}} + \Delta t
</div>
<script type="math/tex; mode=display">
T_{\text{new}} = t_{\text{now}} + \Delta t
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T_{\text{new}}</span><script type="math/tex">T_{\text{new}}</script></span>는 새로운 타이머의 만료 시간이며, <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 추가적으로 대기할 시간을 의미한다.</p>
<p>다음은 타이머를 취소한 후 다시 재시작하는 코드 예시이다.</p>
<pre><code class="language-cpp">boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(10));
timer.async_wait([](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer expired normally.&quot; &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;Timer was cancelled.&quot; &lt;&lt; std::endl;
    }
});

// 타이머 취소
boost::system::error_code ec;
timer.cancel(ec);

// 타이머 재시작
timer.expires_from_now(boost::posix_time::seconds(5));
timer.async_wait([](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer expired after restart.&quot; &lt;&lt; std::endl;
    }
});

io_service.run();
</code></pre>
<p>위 코드에서는 타이머가 처음에는 10초 동안 설정되었지만, 대기 중단 후 5초로 재설정되어 다시 시작된다. 이는 타이머를 동적으로 관리하여 필요에 따라 대기 시간을 변경하거나 취소할 수 있음을 보여준다.</p>
<h3 id="_24">타이머를 활용한 비동기 반복 작업</h3>
<p>타이머를 사용하여 비동기 반복 작업을 구현하는 것은 매우 일반적인 패턴이다. 타이머가 주기적으로 만료될 때마다 특정 작업을 반복적으로 수행하도록 설정할 수 있으며, 이를 통해 주기적인 작업을 비동기적으로 처리할 수 있다. 이 방법은 주로 서버 애플리케이션에서 상태 점검, 정기적 데이터 수집 등의 작업에 유용하다.</p>
<p>타이머를 활용한 반복 작업은 다음과 같은 수식으로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{next}} = T_{\text{current}} + \Delta t
</div>
<script type="math/tex; mode=display">
T_{\text{next}} = T_{\text{current}} + \Delta t
</script>
</div>
<p>여기서:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">T_{\text{next}}</span><script type="math/tex">T_{\text{next}}</script></span>는 다음 작업이 수행될 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">T_{\text{current}}</span><script type="math/tex">T_{\text{current}}</script></span>는 현재 타이머 만료 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 주기적인 대기 시간</li>
</ul>
<h4 id="_25">반복 타이머 구현 예시</h4>
<p>다음은 비동기 타이머를 사용하여 주기적인 작업을 처리하는 코드이다.</p>
<pre><code class="language-cpp">void periodic_task(boost::asio::deadline_timer&amp; timer, int interval) {
    std::cout &lt;&lt; &quot;Task executed!&quot; &lt;&lt; std::endl;

    // 타이머 재설정 및 다시 대기
    timer.expires_from_now(boost::posix_time::seconds(interval));
    timer.async_wait([&amp;timer, interval](const boost::system::error_code&amp; error) {
        if (!error) {
            periodic_task(timer, interval);
        }
    });
}

boost::asio::io_service io_service;
boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(2));

timer.async_wait([&amp;timer](const boost::system::error_code&amp; error) {
    if (!error) {
        periodic_task(timer, 2);  // 2초마다 작업 반복
    }
});

io_service.run();
</code></pre>
<p>위 코드에서 <code>periodic_task</code> 함수는 2초마다 반복적으로 호출된다. 타이머는 매번 만료될 때마다 새로운 대기 시간을 설정하고, 비동기적으로 대기 작업을 수행한다.</p>
<h3 id="_26">다중 타이머를 통한 복합 작업 스케줄링</h3>
<p>여러 개의 타이머를 동시에 사용하여 복합 작업을 스케줄링할 수도 있다. 이를 통해 서로 다른 주기나 시점에 실행되는 여러 작업을 비동기적으로 처리할 수 있다. 이러한 방식은 비동기 네트워크 서버나 복잡한 타이밍 요구 사항을 갖는 애플리케이션에서 유용하다.</p>
<p>다중 타이머를 활용할 때의 시간 관리 방정식은 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{task}_i} = t_{\text{now}} + \Delta t_i
</div>
<script type="math/tex; mode=display">
T_{\text{task}_i} = t_{\text{now}} + \Delta t_i
</script>
</div>
<p>여기서:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">T_{\text{task}_i}</span><script type="math/tex">T_{\text{task}_i}</script></span>는 i번째 작업의 만료 시간</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\Delta t_i</span><script type="math/tex">\Delta t_i</script></span>는 i번째 타이머의 대기 시간</li>
</ul>
<h4 id="_27">다중 타이머 관리 예시</h4>
<p>다음 코드는 여러 타이머를 동시에 사용하여 복합적인 작업을 처리하는 예시이다.</p>
<pre><code class="language-cpp">boost::asio::io_service io_service;
boost::asio::deadline_timer timer1(io_service, boost::posix_time::seconds(3));
boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(5));

timer1.async_wait([](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer 1 expired after 3 seconds.&quot; &lt;&lt; std::endl;
    }
});

timer2.async_wait([](const boost::system::error_code&amp; error) {
    if (!error) {
        std::cout &lt;&lt; &quot;Timer 2 expired after 5 seconds.&quot; &lt;&lt; std::endl;
    }
});

io_service.run();
</code></pre>
<p>이 코드에서는 두 개의 타이머가 각각 3초와 5초 후에 만료되며, 서로 다른 시점에 콜백 함수가 실행된다. 이처럼 다중 타이머를 사용하면 동시에 다양한 작업을 독립적으로 스케줄링할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0805/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0805/" class="btn btn-xs btn-link">
        타이머와 이벤트 기반 프로그래밍
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0803/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0803/" class="btn btn-xs btn-link">
        Boost.Asio를 활용한 비동기 타이머 고정된 시간 간격의 작업 스케줄링
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>