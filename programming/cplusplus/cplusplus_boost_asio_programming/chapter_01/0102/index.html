<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/programming/cplusplus/cplusplus_boost_asio_programming/chapter_01/0102/" rel="canonical"/>
<link href="../../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>비동기 프로그래밍의 필요성 - 실험 도서관</title>
<link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ub3d9\uae30 \ud504\ub85c\uadf8\ub798\ubc0d\uc758 \ubb38\uc81c\uc810", url: "#_top", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 \ud504\ub85c\uadf8\ub798\ubc0d\uc758 \uac1c\ub150", url: "#_2", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 \ud504\ub85c\uadf8\ub798\ubc0d\uc758 \uc7a5\uc810", url: "#_3", children: [
          ]},
          {title: "\ube44\ub3d9\uae30 I/O \ubaa8\ub378", url: "#io", children: [
          ]},
        ];

    </script>
<script src="../../../../../js/base.js"></script>
<script src="../../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0103/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0103/">
        Boost.Asio의 주요 개념
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0101/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0101/">
        Boost.Asio 라이브러리 소개
      </a>
</div>
</div>
<p>비동기 프로그래밍은 현대 소프트웨어 개발에서 필수적인 개념이다. 특히, 네트워크 통신, 파일 입출력(I/O), 타이머 등 여러 하드웨어와 상호작용하는 작업에서는 동기 방식으로 접근할 때의 문제점이 두드러진다. 동기 방식은 요청한 작업이 완료될 때까지 프로그램이 기다리는 방식을 취하는데, 이는 자원의 낭비를 초래하며 프로그램 성능을 심각하게 저하시킬 수 있다. 이러한 문제를 해결하기 위해 비동기 프로그래밍이 필요하다.</p>
<h2 id="_1">동기 프로그래밍의 문제점</h2>
<p>동기 프로그래밍에서는 프로그램이 특정 작업을 요청하면 그 작업이 끝날 때까지 다른 작업을 수행하지 못한다. 예를 들어, 네트워크 소켓을 통해 데이터를 요청하는 경우, 해당 작업이 완료될 때까지 프로그램의 실행 흐름은 멈춘다. 이때 발생하는 문제점은 다음과 같다.</p>
<ol>
<li>
<p><strong>시간 지연</strong>: 작업을 기다리는 동안 CPU는 다른 작업을 처리하지 못하고, 자원은 비효율적으로 사용된다. 예를 들어, 네트워크 통신의 경우, 대기 시간 동안 네트워크 지연(latency)으로 인해 프로그램의 응답성이 떨어질 수 있다.</p>
</li>
<li>
<p><strong>I/O 병목</strong>: 파일 시스템이나 네트워크 등의 입출력 작업은 일반적으로 매우 느리며, 동기 방식으로 이러한 작업을 수행할 경우 프로그램이 해당 작업이 완료될 때까지 아무런 작업도 하지 못하는 병목 현상이 발생한다.</p>
</li>
</ol>
<p>이를 수식으로 설명할 수 있다. 동기 프로그래밍에서 작업 <span class="arithmatex"><span class="MathJax_Preview">T_1</span><script type="math/tex">T_1</script></span>와 작업 <span class="arithmatex"><span class="MathJax_Preview">T_2</span><script type="math/tex">T_2</script></span>가 순차적으로 실행된다면, 총 작업 시간은 두 작업의 시간이 합산된 형태로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{total}} = T_1 + T_2
</div>
<script type="math/tex; mode=display">
T_{\text{total}} = T_1 + T_2
</script>
</div>
<p>작업이 순차적으로 실행되는 동안 대기 시간이 길어지면 <span class="arithmatex"><span class="MathJax_Preview">T_1</span><script type="math/tex">T_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">T_2</span><script type="math/tex">T_2</script></span>의 값이 커지고, 그로 인해 전체 작업 시간이 증가하게 된다.</p>
<h2 id="_2">비동기 프로그래밍의 개념</h2>
<p>비동기 프로그래밍은 위와 같은 문제를 해결하기 위해 고안된 방법론이다. 비동기 방식에서는 특정 작업이 완료될 때까지 기다리는 대신, 작업을 요청한 후 결과가 나올 때까지 다른 작업을 계속 수행할 수 있다. 이를 통해 CPU의 사용률을 극대화하고, 자원의 효율적인 관리를 도모할 수 있다.</p>
<p>비동기 프로그래밍에서 중요한 개념은 <strong>논블로킹(non-blocking)</strong>과 <strong>콜백(callback)</strong>이다. 논블로킹 방식에서는 I/O 작업이나 연산을 요청하면 즉시 제어가 반환되며, 결과가 준비되면 미리 지정된 콜백 함수가 호출된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{total}} = \max(T_1, T_2)
</div>
<script type="math/tex; mode=display">
T_{\text{total}} = \max(T_1, T_2)
</script>
</div>
<p>이 식에서 보듯이 비동기 방식에서는 두 작업이 병렬로 실행될 수 있어, 각 작업의 완료 시간을 기다리지 않고 최대 작업 시간이 전체 작업 시간으로 설정된다. 이는 프로그램의 응답성을 높이고 자원의 활용을 극대화할 수 있는 중요한 요소이다.</p>
<h2 id="_3">비동기 프로그래밍의 장점</h2>
<p>비동기 프로그래밍의 도입으로 인해 다음과 같은 주요 장점이 있다.</p>
<ol>
<li>
<p><strong>응답성 향상</strong>: 비동기 프로그래밍은 사용자 상호작용에서 중요한 역할을 한다. 예를 들어, GUI 응용 프로그램에서는 사용자의 입력에 즉각적으로 반응하는 것이 중요한데, 동기적인 방식으로 시간이 많이 걸리는 작업을 처리할 경우 UI가 멈추는 현상이 발생할 수 있다. 비동기 프로그래밍을 사용하면 이러한 작업을 백그라운드에서 처리하면서도 UI는 계속해서 반응성을 유지할 수 있다.</p>
</li>
<li>
<p><strong>자원 효율성 증가</strong>: 비동기 프로그래밍은 시스템 자원의 활용도를 극대화할 수 있다. 네트워크 요청, 디스크 입출력 등 대기 시간이 긴 작업을 수행할 때, 비동기 방식은 CPU를 다른 작업에 할당할 수 있어 전체 시스템의 자원 사용률을 높인다. 예를 들어, 여러 네트워크 요청이 동시에 들어올 때 비동기 방식으로 처리하면, 각 요청에 대해 대기할 필요 없이 효율적으로 처리할 수 있다.</p>
</li>
<li>
<p><strong>병렬성 지원</strong>: 비동기 프로그래밍은 자연스럽게 병렬성을 지원한다. 여러 I/O 작업이 비동기적으로 실행되면서 동시에 여러 작업을 수행할 수 있다. 비록 완전한 병렬 처리(즉, 멀티스레딩)와는 다르지만, 비동기 방식은 대기 시간이 많은 작업에서 병렬 처리가 일어나는 것과 같은 효과를 낼 수 있다.</p>
</li>
</ol>
<p>이를 더 명확하게 설명하기 위해 아래의 흐름도를 통해 동기 및 비동기 방식의 차이를 시각적으로 나타낼 수 있다.</p>
<div class="mermaid">graph TD
    A[동기 작업 시작] --&gt; B1[작업 1 요청] --&gt; B2[작업 1 대기] --&gt; B3[작업 1 완료]
    B3 --&gt; C1[작업 2 요청] --&gt; C2[작업 2 대기] --&gt; C3[작업 2 완료]
    C3 --&gt; D[동기 작업 종료]
</div>
<p>위의 동기 작업 흐름도에서 볼 수 있듯이, 각 작업은 순차적으로 실행되며, 이전 작업이 끝나야만 다음 작업이 진행된다.</p>
<p>반면에 비동기 방식에서는 다음과 같은 흐름이 성립한다.</p>
<div class="mermaid">graph TD
    A[비동기 작업 시작] --&gt; B1[작업 1 요청] --&gt; B2[작업 1 대기] --&gt; B3[작업 1 완료]
    A --&gt; C1[작업 2 요청] --&gt; C2[작업 2 대기] --&gt; C3[작업 2 완료]
    B3 --&gt; D[작업 1 결과 처리]
    C3 --&gt; E[작업 2 결과 처리]
</div>
<p>비동기 방식에서는 두 작업이 서로 독립적으로 진행되며, 작업이 완료될 때마다 각각의 결과를 처리할 수 있다. 이를 통해 전체적인 처리 속도를 높일 수 있다.</p>
<h2 id="io">비동기 I/O 모델</h2>
<p>비동기 프로그래밍의 핵심 중 하나는 비동기 I/O 모델이다. 특히 네트워크 프로그래밍에서 비동기 I/O는 필수적이다. 동기 I/O에서 발생하는 문제는 네트워크 속도나 데이터 전송 속도가 불규칙할 때 더욱 두드러진다. 이를 해결하기 위해 비동기 I/O는 요청을 처리하는 동안 다른 작업을 계속할 수 있게 한다.</p>
<p>이를 더 구체적으로 설명하기 위해, 비동기 네트워크 프로그래밍에서는 보통 이벤트 기반 모델을 사용한다. 이 모델은 네트워크 작업이 완료되었을 때 그에 대응하는 이벤트를 발생시키고, 이벤트 핸들러가 그 작업을 처리하는 구조로 되어 있다. 이벤트 기반 모델에서의 전체 프로세스를 수식으로 나타내면 다음과 같다.</p>
<ol>
<li>이벤트 발생: 네트워크 요청에 대한 작업이 <span class="arithmatex"><span class="MathJax_Preview">E_i</span><script type="math/tex">E_i</script></span>와 같이 여러 개의 이벤트로 구성된다고 가정하자.</li>
<li>핸들러 호출: 각각의 이벤트는 특정 핸들러 <span class="arithmatex"><span class="MathJax_Preview">H(E_i)</span><script type="math/tex">H(E_i)</script></span>에 의해 처리된다.</li>
</ol>
<p>따라서 전체 과정은 아래와 같은 식으로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{total}} = \sum_{i=1}^{n} T_{H(E_i)}
</div>
<script type="math/tex; mode=display">
T_{\text{total}} = \sum_{i=1}^{n} T_{H(E_i)}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T_{H(E_i)}</span><script type="math/tex">T_{H(E_i)}</script></span>는 이벤트 <span class="arithmatex"><span class="MathJax_Preview">E_i</span><script type="math/tex">E_i</script></span>를 처리하는 시간이며, 각 이벤트에 대해 별도의 핸들러가 호출되므로 전체 처리가 독립적으로 이루어질 수 있다.</p>
<p>[계속]</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0103/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0103/">
        Boost.Asio의 주요 개념
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0101/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0101/">
        Boost.Asio 라이브러리 소개
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>