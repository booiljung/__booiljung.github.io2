<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/programming/dart/chapter_06/0603/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Map - 소프트웨어 융합</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Map\uc758 \uae30\ubcf8 \uc0ac\uc6a9\ubc95", url: "#_top", children: [
          ]},
          {title: "\ud0a4\uc640 \uac12\uc758 \ud2b9\uc131", url: "#_1", children: [
          ]},
          {title: "Map\uc758 \uc8fc\uc694 \uba54\uc18c\ub4dc", url: "#map_1", children: [
          ]},
          {title: "Map\uc758 \uba54\ubaa8\ub9ac \ud6a8\uc728", url: "#map_2", children: [
          ]},
          {title: "Map\uacfc \ub2e4\ub978 \uceec\ub809\uc158\uacfc\uc758 \ube44\uad50", url: "#map_3", children: [
          ]},
          {title: "\uace0\uae09 Map \uc870\uc791", url: "#map_4", children: [
              {title: "Map \uc548\uc5d0 List \uc800\uc7a5", url: "#map-list" },
              {title: "Map \uc548\uc5d0 Map \uc800\uc7a5", url: "#map-map" },
          ]},
          {title: "Map\uc5d0\uc11c\uc758 \uac12 \uac31\uc2e0", url: "#map_5", children: [
          ]},
          {title: "Map\uc744 \uc774\uc6a9\ud55c \ub370\uc774\ud130 \ud544\ud130\ub9c1", url: "#map_6", children: [
          ]},
          {title: "Map\uc758 \uc131\ub2a5 \ubc0f \uc8fc\uc758\uc0ac\ud56d", url: "#map_7", children: [
              {title: "\ud574\uc2dc \ucda9\ub3cc\uc5d0 \ub300\ud55c \uace0\ub824 \uc0ac\ud56d", url: "#_2" },
          ]},
          {title: "\ud0a4\ub85c \uc0ac\uc6a9 \uac00\ub2a5\ud55c \ub370\uc774\ud130 \ud0c0\uc785", url: "#_3", children: [
              {title: "\uc0ac\uc6a9\uc790 \uc815\uc758 \uac1d\uccb4\ub97c \ud0a4\ub85c \uc0ac\uc6a9\ud560 \ub54c \uc8fc\uc758 \uc0ac\ud56d", url: "#_4" },
              {title: "\ubd88\ubcc0\uc131\uacfc \uc131\ub2a5", url: "#_5" },
          ]},
          {title: "Map\uacfc \ub370\uc774\ud130 \uc815\ub82c", url: "#map_8", children: [
          ]},
          {title: "Map\uc758 \ubcd1\ub82c \ucc98\ub9ac \ubc0f \ud6a8\uc728\uc801\uc778 \ub370\uc774\ud130 \ucc98\ub9ac", url: "#map_9", children: [
              {title: "Future\uc640 Map\uc758 \uc870\ud569", url: "#future-map" },
              {title: "Stream\uacfc Map", url: "#stream-map" },
              {title: "Map\uc758 \ub300\uaddc\ubaa8 \ub370\uc774\ud130 \ucc98\ub9ac", url: "#map_10" },
          ]},
          {title: "Map\uacfc \ub3d9\uae30\ud654 \ubb38\uc81c", url: "#map_11", children: [
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0604/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0604/" class="btn btn-xs btn-link">
        컬렉션 조작
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0602/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0602/" class="btn btn-xs btn-link">
        Set
      </a>
    </div>
    
  </div>

    

    <p>Map은 Dart에서 키와 값의 쌍으로 이루어진 데이터 구조로, 각 키는 고유하며 해당 키를 통해 값을 조회할 수 있다. Map은 다른 프로그래밍 언어에서의 '해시 테이블'이나 '연관 배열'과 유사한 개념이다. Dart에서 Map은 유연하고 효율적인 방식으로 데이터의 매핑 관계를 관리할 수 있도록 설계되었다.</p>
<h3 id="map">Map의 기본 사용법</h3>
<p>Dart에서 Map은 <code>Map&lt;K, V&gt;</code> 형식으로 정의되며, <code>K</code>는 키의 데이터 타입, <code>V</code>는 값의 데이터 타입을 나타낸다. 키와 값의 데이터 타입은 각각 다를 수 있다. Map을 선언하는 방법은 두 가지가 있다: 리터럴 방식과 생성자 방식이다.</p>
<pre><code class="language-dart">// 리터럴 방식
Map&lt;String, int&gt; scores = {
  'Alice': 80,
  'Bob': 90,
  'Charlie': 85
};

// 생성자 방식
Map&lt;String, int&gt; ages = Map();
ages['Alice'] = 25;
ages['Bob'] = 30;
</code></pre>
<p>위 예시에서 볼 수 있듯이, Map은 중괄호 <code>{}</code>를 사용해 키-값 쌍을 정의할 수 있으며, 생성자 방식으로도 선언할 수 있다.</p>
<h3 id="_1">키와 값의 특성</h3>
<p>Map에서 키는 고유해야 하며, 중복된 키를 사용할 수 없다. 만약 동일한 키를 여러 번 삽입하면, 마지막으로 삽입된 값이 해당 키의 값으로 대체된다.</p>
<pre><code class="language-dart">Map&lt;String, String&gt; countries = {
  'KR': 'South Korea',
  'US': 'United States',
  'KR': 'Republic of Korea'
};

// 출력 시 'KR'은 'Republic of Korea'로 대체됨
print(countries['KR']); // 출력: Republic of Korea
</code></pre>
<h3 id="map_1">Map의 주요 메소드</h3>
<p>Dart에서 Map은 다양한 메소드를 제공하여 데이터의 추가, 조회, 삭제 등을 쉽게 할 수 있다.</p>
<ul>
<li><code>containsKey(Object key)</code> : 해당 키가 Map에 존재하는지 확인한다.</li>
<li><code>containsValue(Object value)</code> : 해당 값이 Map에 존재하는지 확인한다.</li>
<li><code>remove(Object key)</code> : 해당 키와 관련된 키-값 쌍을 Map에서 제거한다.</li>
<li><code>forEach(void action(K key, V value))</code> : Map의 각 키-값 쌍에 대해 특정 작업을 수행한다.</li>
<li><code>keys</code> : Map에 저장된 모든 키를 반환한다.</li>
<li><code>values</code> : Map에 저장된 모든 값을 반환한다.</li>
</ul>
<pre><code class="language-dart">Map&lt;String, int&gt; population = {
  'Seoul': 9733509,
  'New York': 8175133,
  'Tokyo': 13929286
};

// containsKey 메소드
if (population.containsKey('Seoul')) {
  print('서울 인구: ${population['Seoul']}');
}

// forEach 메소드
population.forEach((key, value) {
  print('$key:$value');
});
</code></pre>
<h3 id="map_2">Map의 메모리 효율</h3>
<p>Map의 메모리 효율은 키와 값의 수, 그리고 키를 찾기 위한 해시 알고리즘의 복잡도에 따라 달라진다. 일반적으로 해시 테이블의 평균적인 시간 복잡도는 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>이므로, 키를 통한 값 조회가 매우 빠르게 이루어진다. 그러나 키의 수가 많아질수록 해시 충돌이 발생할 가능성도 커지며, 이러한 경우 시간 복잡도는 <span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>에 가까워질 수 있다.</p>
<p>다음 내용에서는 Map의 더 구체적인 사용법과 비슷한 자료구조들과의 비교를 설명할 예정이다.</p>
<h3 id="map_3">Map과 다른 컬렉션과의 비교</h3>
<p>Dart에서 제공하는 다른 주요 컬렉션인 <code>List</code>나 <code>Set</code>과 비교했을 때, <code>Map</code>은 다음과 같은 차별점을 갖는다.</p>
<ul>
<li><strong>List</strong>: <code>List</code>는 인덱스 기반의 순차적 컬렉션으로, 요소들이 순서대로 저장된다. 인덱스가 자동으로 할당되는 <code>List</code>와 달리, <code>Map</code>은 사용자가 명시적으로 키를 지정해야 하며, 키를 통해 값에 접근한다.</li>
</ul>
<p>예를 들어, <code>List</code>는 아래와 같이 인덱스를 사용해 값에 접근한다.</p>
<p><code>dart
  List&lt;String&gt; fruits = ['Apple', 'Banana', 'Cherry'];
  print(fruits[0]); // 출력: Apple</code></p>
<p>반면, <code>Map</code>에서는 키를 사용해 접근한다.</p>
<p><code>dart
  Map&lt;String, String&gt; capitals = {'KR': 'Seoul', 'JP': 'Tokyo'};
  print(capitals['KR']); // 출력: Seoul</code></p>
<ul>
<li><strong>Set</strong>: <code>Set</code>은 고유한 요소만 저장할 수 있는 컬렉션으로, 중복된 값을 허용하지 않는다. <code>Map</code>은 중복된 키를 허용하지 않으며, 각 키에 대해 고유한 값을 매핑한다. 그러나 <code>Map</code>에서는 키와 값의 쌍이 다루어진다는 점에서 단순히 값만 저장하는 <code>Set</code>과는 차별된다.</li>
</ul>
<p><code>dart
  Set&lt;String&gt; uniqueNumbers = {'One', 'Two', 'Three'};
  uniqueNumbers.add('Two'); // 중복 값 추가 시 반영되지 않음
  print(uniqueNumbers); // 출력: {One, Two, Three}</code></p>
<h3 id="map_4">고급 Map 조작</h3>
<p>Dart의 <code>Map</code>은 일반적인 키-값 저장 외에도 복잡한 데이터 구조를 다룰 수 있는 방법을 제공한다. 예를 들어, 값으로 리스트나 또 다른 <code>Map</code>을 저장할 수 있다. 이처럼 중첩된 데이터 구조는 특정 시나리오에서 데이터를 더 효과적으로 구조화하고 관리하는 데 도움이 된다.</p>
<h4 id="map-list">Map 안에 List 저장</h4>
<pre><code class="language-dart">Map&lt;String, List&lt;int&gt;&gt; scores = {
  'Math': [95, 80, 88],
  'Science': [90, 85, 92]
};

print(scores['Math']); // 출력: [95, 80, 88]
</code></pre>
<h4 id="map-map">Map 안에 Map 저장</h4>
<pre><code class="language-dart">Map&lt;String, Map&lt;String, int&gt;&gt; population = {
  'Seoul': {'district1': 1000000, 'district2': 2000000},
  'New York': {'Manhattan': 1600000, 'Brooklyn': 2300000}
};

print(population['Seoul']?['district1']); // 출력: 1000000
</code></pre>
<p>위의 예제처럼 <code>Map</code> 안에 <code>List</code>나 다른 <code>Map</code>을 저장하면 복잡한 데이터를 체계적으로 저장할 수 있다. 특히, 복합 데이터 구조를 다룰 때 유용하다.</p>
<h3 id="map_5">Map에서의 값 갱신</h3>
<p><code>Map</code>에 이미 존재하는 키에 대해 새로운 값을 할당하면 해당 값이 갱신된다. 이는 여러 단계로 이루어진 계산 결과를 순차적으로 <code>Map</code>에 반영하는 데 유용하다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; itemStock = {'Pen': 50, 'Notebook': 100};

// Pen 재고를 추가로 30개 받음
itemStock['Pen'] = itemStock['Pen']! + 30;

print(itemStock['Pen']); // 출력: 80
</code></pre>
<h3 id="map_6">Map을 이용한 데이터 필터링</h3>
<p><code>Map</code>의 <code>where()</code> 메소드를 이용하면 특정 조건을 만족하는 키-값 쌍을 필터링할 수 있다. 이는 대규모 데이터에서 특정 조건에 맞는 데이터를 효율적으로 추출하는 데 유용하다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; ages = {'Alice': 25, 'Bob': 30, 'Charlie': 35};

var filteredAges = ages.entries.where((entry) =&gt; entry.value &gt; 28);

filteredAges.forEach((entry) {
  print('${entry.key}:${entry.value}');
});
// 출력:
// Bob: 30
// Charlie: 35
</code></pre>
<p>다음으로는 <code>Map</code>과 관련된 성능 이슈와 주의할 점에 대해 설명할 예정이다.</p>
<h3 id="map_7">Map의 성능 및 주의사항</h3>
<p>Dart의 <code>Map</code>은 해시 기반으로 작동하므로, 일반적으로 키를 통한 값의 조회, 삽입, 삭제는 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>의 시간 복잡도를 갖는다. 그러나, 해시 충돌이 발생할 수 있으며, 이는 성능에 영향을 미칠 수 있다. 해시 충돌은 서로 다른 키들이 동일한 해시 값을 가질 때 발생하며, 이러한 경우 조회 및 삽입 등의 연산에서 <span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>의 시간 복잡도가 발생할 수 있다.</p>
<h4 id="_2">해시 충돌에 대한 고려 사항</h4>
<p>해시 충돌을 줄이기 위해 Dart는 내부적으로 충돌이 발생하지 않도록 해시 함수의 품질을 관리한다. 하지만 사용자 측에서도 키를 선택할 때 해시 충돌 가능성을 염두에 두는 것이 좋다. 특히 키가 고유한 값인지, 해시 충돌 가능성이 낮은지 고려해야 한다.</p>
<p>예를 들어, 복잡한 데이터 구조를 키로 사용할 때는 해시 함수가 고유한 해시 값을 잘 생성하도록 해야 하며, 그렇지 않으면 충돌 가능성이 커질 수 있다. Dart에서는 <code>int</code>, <code>String</code>과 같은 기본 타입은 충돌 가능성이 낮은 해시 값을 생성하지만, 복잡한 객체를 키로 사용할 경우 해시 충돌의 가능성이 커질 수 있다.</p>
<pre><code class="language-dart">class CustomKey {
  final String id;
  final int number;

  CustomKey(this.id, this.number);

  @override
  bool operator ==(Object other) =&gt;
      identical(this, other) ||
      other is CustomKey &amp;&amp; runtimeType == other.runtimeType &amp;&amp; id == other.id &amp;&amp; number == other.number;

  @override
  int get hashCode =&gt; id.hashCode ^ number.hashCode;
}

void main() {
  Map&lt;CustomKey, String&gt; customMap = {
    CustomKey('A', 1): 'Value1',
    CustomKey('B', 2): 'Value2'
  };

  print(customMap[CustomKey('A', 1)]); // 출력: Value1
}
</code></pre>
<p>위 예제에서 <code>CustomKey</code>는 고유한 해시 값을 생성하기 위해 <code>hashCode</code> 메소드를 재정의하였다. <code>hashCode</code>는 객체의 고유 식별자로 사용되며, 충돌 가능성을 최소화하려면 여러 속성의 해시 코드를 적절히 결합해야 한다.</p>
<h3 id="_3">키로 사용 가능한 데이터 타입</h3>
<p>Dart의 <code>Map</code>에서는 모든 데이터 타입을 키로 사용할 수 있지만, 자주 사용되는 데이터 타입으로는 <code>int</code>, <code>String</code>, 그리고 사용자 정의 객체가 있다. Dart에서 키는 반드시 고유해야 하므로, 같은 객체에 대해 <code>==</code> 연산자가 참을 반환해야 하며, 해당 객체의 <code>hashCode</code> 메소드도 동일한 값을 반환해야 한다. </p>
<h4 id="_4">사용자 정의 객체를 키로 사용할 때 주의 사항</h4>
<p>사용자 정의 객체를 키로 사용할 때는 <code>==</code> 연산자와 <code>hashCode</code>를 반드시 재정의해야 한다. 그렇지 않으면, 서로 다른 두 객체가 동일한 값을 갖고 있더라도 해시 값이 달라질 수 있으며, 그 결과 Map에서의 조회가 올바르게 이루어지지 않을 수 있다.</p>
<h4 id="_5">불변성과 성능</h4>
<p>Dart의 <code>Map</code>은 기본적으로 가변적(mutable)이므로, 삽입, 삭제, 갱신이 자유롭게 가능한다. 그러나 많은 데이터가 변하지 않는 경우, 성능을 높이기 위해 불변(immutable) Map을 사용하는 것이 좋다. 불변 Map은 데이터를 변경할 수 없기 때문에, 메모리 관리 및 성능 면에서 이점이 있을 수 있다.</p>
<p>불변성을 보장하기 위해 Dart에서는 <code>const</code>를 사용하여 불변 Map을 선언할 수 있다.</p>
<pre><code class="language-dart">const Map&lt;String, int&gt; constantMap = {'Alice': 25, 'Bob': 30};

// constantMap['Charlie'] = 35; // 불변 Map이므로 오류 발생
</code></pre>
<p>불변 Map은 프로그램의 특정 상태가 변경되지 않음을 보장해야 할 때 매우 유용하다.</p>
<h3 id="map_8">Map과 데이터 정렬</h3>
<p>기본적으로 <code>Map</code>은 입력된 순서대로 요소를 유지하지 않는다. 즉, 데이터를 삽입한 순서와 상관없이, 키의 순서가 보장되지 않는다. 그러나 Dart에서는 <code>LinkedHashMap</code>을 사용하면 삽입된 순서를 유지할 수 있다.</p>
<pre><code class="language-dart">import 'dart:collection';

Map&lt;String, int&gt; orderedMap = LinkedHashMap();
orderedMap['Alice'] = 25;
orderedMap['Bob'] = 30;
orderedMap['Charlie'] = 35;

print(orderedMap); // 출력: {Alice: 25, Bob: 30, Charlie: 35}
</code></pre>
<p><code>LinkedHashMap</code>은 데이터 삽입 순서를 보장하는 Map 구현체로, 데이터를 삽입한 순서대로 정렬된 상태에서 데이터가 유지된다.</p>
<p>다음으로는 Map의 병렬 처리 및 효율적인 데이터 처리 방법을 설명할 예정이다.</p>
<h3 id="map_9">Map의 병렬 처리 및 효율적인 데이터 처리</h3>
<p>Dart에서는 멀티스레드 병렬 처리 대신 비동기 프로그래밍을 통해 효율적인 데이터 처리가 가능한다. 특히 대규모 데이터를 처리하거나 네트워크 통신 등의 시간이 오래 걸리는 작업에서 Map을 활용할 때, 병렬적으로 작업을 수행하여 프로그램의 성능을 향상시킬 수 있다.</p>
<h4 id="future-map">Future와 Map의 조합</h4>
<p>비동기 연산에서 <code>Future</code>와 <code>Map</code>을 함께 사용하는 경우, 각 키-값 쌍에 대해 독립적으로 비동기 작업을 실행할 수 있다. 이를 통해 여러 작업을 동시에 실행하고, 결과를 효율적으로 수집할 수 있다. Dart의 <code>Future.wait()</code> 메소드를 사용하면 여러 비동기 작업이 완료될 때까지 기다렸다가 그 결과를 한 번에 처리할 수 있다.</p>
<pre><code class="language-dart">Future&lt;Map&lt;String, int&gt;&gt; fetchData() async {
  Map&lt;String, Future&lt;int&gt;&gt; asyncMap = {
    'Alice': Future.delayed(Duration(seconds: 2), () =&gt; 25),
    'Bob': Future.delayed(Duration(seconds: 1), () =&gt; 30),
    'Charlie': Future.delayed(Duration(seconds: 3), () =&gt; 35)
  };

  Map&lt;String, int&gt; result = {};
  for (var entry in asyncMap.entries) {
    result[entry.key] = await entry.value;
  }
  return result;
}

void main() async {
  Map&lt;String, int&gt; data = await fetchData();
  print(data); // 출력: {Alice: 25, Bob: 30, Charlie: 35}
}
</code></pre>
<p>위 예제에서는 각 키에 해당하는 비동기 작업이 독립적으로 실행되며, <code>await</code>를 통해 각 값이 완료된 후 최종적으로 결과를 반환한다. 이런 방식은 비동기 I/O나 네트워크 통신을 동반하는 작업에서 매우 유용하다.</p>
<h4 id="stream-map">Stream과 Map</h4>
<p>Map을 반복 처리할 때 <code>Stream</code>을 활용하면 더욱 효율적인 비동기 처리가 가능한다. <code>Stream</code>은 데이터를 이벤트로 나누어 처리하며, 각 이벤트는 연속적으로 처리될 수 있다. <code>Stream</code>을 사용하여 Map의 데이터를 순차적으로 처리하고, 비동기 작업과 결합하여 실시간 데이터를 처리하는 데 활용할 수 있다.</p>
<pre><code class="language-dart">Stream&lt;Map&lt;String, int&gt;&gt; streamData() async* {
  await Future.delayed(Duration(seconds: 1));
  yield {'Alice': 25};

  await Future.delayed(Duration(seconds: 1));
  yield {'Bob': 30};

  await Future.delayed(Duration(seconds: 1));
  yield {'Charlie': 35};
}

void main() async {
  await for (var data in streamData()) {
    print(data); // 출력: {Alice: 25}, {Bob: 30}, {Charlie: 35}
  }
}
</code></pre>
<p>위 예제에서는 <code>Stream</code>을 통해 Map의 데이터가 이벤트 형태로 전달되며, 각 데이터가 비동기적으로 처리된다. <code>await for</code> 구문을 사용해 Stream에서 전달되는 데이터를 하나씩 처리할 수 있다.</p>
<h4 id="map_10">Map의 대규모 데이터 처리</h4>
<p>대규모 데이터를 다룰 때는 메모리 사용량과 성능 최적화가 중요하다. Dart의 <code>Map</code>은 효율적인 데이터 구조이지만, 데이터 양이 커질수록 메모리 사용량이 증가할 수 있다. 이러한 경우, 다음과 같은 최적화 방법을 고려해볼 수 있다.</p>
<ol>
<li>
<p><strong>Lazy Loading</strong>: 데이터를 한꺼번에 메모리에 로드하는 대신, 필요한 시점에만 로드하여 메모리 사용량을 줄일 수 있다. 이는 Map에서 데이터를 조회할 때 데이터베이스나 파일 시스템으로부터 실시간으로 데이터를 불러오는 방식으로 구현할 수 있다.</p>
</li>
<li>
<p><strong>Chunking</strong>: 대규모 데이터를 한 번에 처리하지 않고, 여러 개의 작은 덩어리로 나누어 순차적으로 처리하는 방식이다. 이를 통해 메모리 사용량을 줄이면서도 성능을 유지할 수 있다.</p>
</li>
<li>
<p><strong>캐싱(Caching)</strong>: 자주 사용하는 데이터를 캐시에 저장하여 성능을 높일 수 있다. 캐싱을 통해 같은 데이터를 반복적으로 조회할 때, 불필요한 연산을 피하고 빠르게 결과를 얻을 수 있다.</p>
</li>
</ol>
<h3 id="map_11">Map과 동기화 문제</h3>
<p>Map은 기본적으로 스레드에 안전하지 않기 때문에, 여러 스레드가 동시에 Map에 접근하여 데이터를 수정할 때 동기화 문제가 발생할 수 있다. Dart에서는 스레드 기반의 동시성 처리가 없지만, <code>Zone</code>이나 <code>Isolate</code>를 통해 병렬적으로 작업을 실행할 수 있다.</p>
<p><strong>Isolate</strong>는 Dart에서 별도의 메모리 공간에서 실행되는 독립적인 작업 단위이다. Isolate 간에는 데이터가 공유되지 않으며, 메시지를 통해 데이터를 전달한다. Map을 여러 Isolate에서 동시 수정하려면, 이 메시지 전달 방식을 사용해야 한다.</p>
<pre><code class="language-dart">import 'dart:isolate';

void isolateFunction(SendPort sendPort) {
  Map&lt;String, int&gt; data = {'Alice': 25, 'Bob': 30};
  sendPort.send(data);
}

void main() async {
  ReceivePort receivePort = ReceivePort();
  await Isolate.spawn(isolateFunction, receivePort.sendPort);

  receivePort.listen((message) {
    print(message); // 출력: {Alice: 25, Bob: 30}
  });
}
</code></pre>
<p>위 예제에서는 <code>Isolate</code>를 통해 Map 데이터를 독립된 공간에서 생성하고, 메시지를 통해 데이터를 전달하는 방식으로 구현된다.</p>
<p>Map의 다양한 고급 활용 방법에 대해서는 여기까지이다. 추가로 설명이 필요하면 말씀해 주세요. </p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0604/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0604/" class="btn btn-xs btn-link">
        컬렉션 조작
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0602/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0602/" class="btn btn-xs btn-link">
        Set
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>