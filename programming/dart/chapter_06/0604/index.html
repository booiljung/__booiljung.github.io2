<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/programming/dart/chapter_06/0604/" rel="canonical"/>
<link href="../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>컬렉션 조작 - 실험 도서관</title>
<link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ub9ac\uc2a4\ud2b8(List) \uc870\uc791", url: "#_top", children: [
              {title: "\uc694\uc18c \ucd94\uac00", url: "#_1" },
              {title: "\uc694\uc18c \uc81c\uac70", url: "#_2" },
          ]},
          {title: "\ub9ac\uc2a4\ud2b8 \ubcd1\ud569 \ubc0f \uc2ac\ub77c\uc774\uc2f1", url: "#_3", children: [
              {title: "\ub9ac\uc2a4\ud2b8 \ubcd1\ud569", url: "#_4" },
              {title: "\ub9ac\uc2a4\ud2b8 \uc2ac\ub77c\uc774\uc2f1", url: "#_5" },
          ]},
          {title: "\ub9ac\uc2a4\ud2b8 \ud544\ud130\ub9c1", url: "#_6", children: [
          ]},
          {title: "\ub9ac\uc2a4\ud2b8 \uc815\ub82c", url: "#_7", children: [
          ]},
          {title: "\ub9ac\uc2a4\ud2b8\uc758 \ubcc0\ud658", url: "#_8", children: [
          ]},
          {title: "\ub9ac\uc2a4\ud2b8\uc758 \ubaa8\ub4e0 \uc694\uc18c\uc5d0 \ud568\uc218 \uc801\uc6a9", url: "#_9", children: [
          ]},
          {title: "\ub9ac\uc2a4\ud2b8\uc758 \ud0d0\uc0c9", url: "#_10", children: [
              {title: "\uccab \ubc88\uc9f8 \uc77c\uce58\ud558\ub294 \uc694\uc18c \ucc3e\uae30", url: "#_11" },
              {title: "\ub9c8\uc9c0\ub9c9 \uc77c\uce58\ud558\ub294 \uc694\uc18c \ucc3e\uae30", url: "#_12" },
              {title: "\ud2b9\uc815 \uc694\uc18c\uc758 \uc778\ub371\uc2a4 \ucc3e\uae30", url: "#_13" },
          ]},
          {title: "\ub9ac\uc2a4\ud2b8\uc758 \uc911\ubcf5 \uc81c\uac70", url: "#_14", children: [
          ]},
          {title: "\ub9ac\uc2a4\ud2b8\uc758 \uae38\uc774\uc640 \ube48 \ub9ac\uc2a4\ud2b8 \ud655\uc778", url: "#_15", children: [
          ]},
          {title: "\ub9ac\uc2a4\ud2b8 \ucd08\uae30\ud654", url: "#_16", children: [
          ]},
          {title: "\ub9ac\uc2a4\ud2b8\uc758 \ubd80\ubd84 \uc5c5\ub370\uc774\ud2b8", url: "#_17", children: [
          ]},
          {title: "\ub9ac\uc2a4\ud2b8\uc758 \ube48 \uc790\ub9ac \uc0bd\uc785", url: "#_18", children: [
          ]},
          {title: "\ub9ac\uc2a4\ud2b8 \ubcd1\ud569 \ubc0f \ubcc0\ud658 \uacfc\uc815\uc758 \ubcf5\uc7a1\ub3c4 \ubd84\uc11d", url: "#_19", children: [
              {title: "\uc2dc\uac04 \ubcf5\uc7a1\ub3c4 \ubd84\uc11d", url: "#_20" },
          ]},
          {title: "\ub9ac\uc2a4\ud2b8\uc758 \uc7ac\uc815\ub82c \ubc0f \ubcf5\uc7a1\ub3c4 \ubd84\uc11d", url: "#_21", children: [
              {title: "\uc2dc\uac04 \ubcf5\uc7a1\ub3c4", url: "#_22" },
          ]},
          {title: "Set \uc870\uc791", url: "#set", children: [
              {title: "\uc694\uc18c \ucd94\uac00 \ubc0f \uc81c\uac70", url: "#_23" },
              {title: "Set \uc5f0\uc0b0", url: "#set_1" },
              {title: "\ud569\uc9d1\ud569", url: "#_24" },
              {title: "\uad50\uc9d1\ud569", url: "#_25" },
              {title: "\ucc28\uc9d1\ud569", url: "#_26" },
              {title: "\uc2dc\uac04 \ubcf5\uc7a1\ub3c4 \ubd84\uc11d", url: "#_27" },
          ]},
          {title: "Map \uc870\uc791", url: "#map", children: [
              {title: "\uc694\uc18c \ucd94\uac00 \ubc0f \uc5c5\ub370\uc774\ud2b8", url: "#_28" },
              {title: "\uc694\uc18c \uc81c\uac70", url: "#_29" },
              {title: "\uc694\uc18c \ud0d0\uc0c9", url: "#_30" },
              {title: "\ud0a4\uc640 \uac12 \ubaa9\ub85d", url: "#_31" },
          ]},
          {title: "Map\uc758 \uace0\uae09 \uc870\uc791", url: "#map_1", children: [
              {title: "\ud0a4 \uc874\uc7ac \uc5ec\ubd80 \ud655\uc778", url: "#_32" },
              {title: "\uac12 \uc874\uc7ac \uc5ec\ubd80 \ud655\uc778", url: "#_33" },
              {title: "Map \ubcd1\ud569", url: "#map_2" },
              {title: "Map\uc758 \uae30\ubcf8\uac12 \uc124\uc815", url: "#map_3" },
              {title: "Map\uc758 \uc21c\ud68c", url: "#map_4" },
          ]},
          {title: "Map \ubcc0\ud658 \ubc0f \ud544\ud130\ub9c1", url: "#map_5", children: [
              {title: "Map \ubcc0\ud658", url: "#map_6" },
              {title: "Map \ud544\ud130\ub9c1", url: "#map_7" },
          ]},
          {title: "Map\uc5d0\uc11c\uc758 \ubcf5\uc7a1\ub3c4 \ubd84\uc11d", url: "#map_8", children: [
              {title: "Map\uc758 \uba54\ubaa8\ub9ac \ud6a8\uc728\uc131", url: "#map_9" },
          ]},
          {title: "Map\uc758 \ud0a4\uc640 \uac12 \ubcc0\ud658", url: "#map_10", children: [
              {title: "\uac12 \ubcc0\ud658", url: "#_34" },
              {title: "\ud0a4 \ubcc0\ud658", url: "#_35" },
          ]},
          {title: "Map\uc758 \uae4a\uc740 \ubcf5\uc0ac\uc640 \uc595\uc740 \ubcf5\uc0ac", url: "#map_11", children: [
              {title: "\uc595\uc740 \ubcf5\uc0ac", url: "#_36" },
              {title: "\uae4a\uc740 \ubcf5\uc0ac", url: "#_37" },
          ]},
          {title: "Map\uc758 \uae30\ubcf8 \uac12 \uc124\uc815", url: "#map_12", children: [
          ]},
          {title: "Map\uc758 \ud0a4 \ub9ac\uc2a4\ud2b8\uc640 \uac12 \ub9ac\uc2a4\ud2b8", url: "#map_13", children: [
          ]},
          {title: "Map\uc758 \uad6c\uc870 \uc2dc\uac01\ud654", url: "#map_14", children: [
          ]},
          {title: "Map\uc758 \ubcd1\ud569\uacfc \ud544\ud130\ub9c1\uc758 \ubcf5\uc7a1\ub3c4 \ubd84\uc11d", url: "#map_15", children: [
          ]},
          {title: "Map\uc758 \uace0\uae09 \uae30\ub2a5\uacfc \ud65c\uc6a9 \uc0ac\ub840", url: "#map_16", children: [
              {title: "JSON\uacfc Map", url: "#json-map" },
          ]},
        ];

    </script>
<script src="../../../../js/base.js"></script>
<script src="../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../../chapter_07/0701/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../../chapter_07/0701/">
        제너릭 클래스
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0603/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0603/">
        Map
      </a>
</div>
</div>
<p>컬렉션 조작은 Dart에서 리스트(List), 셋(Set), 맵(Map)과 같은 컬렉션을 다루는 다양한 기법들을 의미한다. 이 챕터에서는 Dart에서 제공하는 컬렉션을 보다 효과적으로 다루기 위한 다양한 방법을 설명한다.</p>
<h3 id="list">리스트(List) 조작</h3>
<p>리스트는 순서가 있는 컬렉션으로, Dart에서 가장 많이 사용되는 자료형 중 하나다. 리스트에서 데이터를 추가하거나 제거하는 작업은 매우 흔하며, Dart에서는 이를 지원하는 다양한 메소드가 제공된다.</p>
<h4 id="_1">요소 추가</h4>
<p>리스트에 요소를 추가하는 방법으로는 <code>add()</code>와 <code>addAll()</code> 메소드가 있다. <code>add()</code>는 단일 요소를 리스트의 끝에 추가하고, <code>addAll()</code>은 여러 요소를 한 번에 추가할 수 있다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 3];
numbers.add(4);   // 결과: [1, 2, 3, 4]
numbers.addAll([5, 6]); // 결과: [1, 2, 3, 4, 5, 6]
</code></pre>
<h4 id="_2">요소 제거</h4>
<p>리스트에서 특정 요소를 제거할 때는 <code>remove()</code>와 <code>removeAt()</code> 메소드를 사용할 수 있다. <code>remove()</code>는 리스트에서 특정 값을 제거하고, <code>removeAt()</code>은 인덱스를 기반으로 요소를 제거한다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 3, 4];
numbers.remove(3);   // 결과: [1, 2, 4]
numbers.removeAt(0); // 결과: [2, 4]
</code></pre>
<h3 id="_3">리스트 병합 및 슬라이싱</h3>
<h4 id="_4">리스트 병합</h4>
<p>두 개 이상의 리스트를 병합하는 작업은 <code>addAll()</code> 메소드를 사용하거나, Dart에서 제공하는 <code>...</code>(스프레드 연산자)를 활용할 수 있다.</p>
<pre><code class="language-dart">List&lt;int&gt; list1 = [1, 2, 3];
List&lt;int&gt; list2 = [4, 5, 6];
List&lt;int&gt; merged = [...list1, ...list2]; // 결과: [1, 2, 3, 4, 5, 6]
</code></pre>
<h4 id="_5">리스트 슬라이싱</h4>
<p>리스트에서 특정 구간을 추출할 때는 <code>sublist()</code> 메소드를 사용할 수 있다. <code>sublist(startIndex, endIndex)</code> 형태로 사용되며, <code>startIndex</code>부터 <code>endIndex-1</code>까지의 값을 포함하는 서브리스트를 반환한다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 3, 4, 5, 6];
List&lt;int&gt; slice = numbers.sublist(1, 4); // 결과: [2, 3, 4]
</code></pre>
<h3 id="_6">리스트 필터링</h3>
<p>리스트에서 조건에 맞는 요소만 추출할 때는 <code>where()</code> 메소드를 사용한다. 이 메소드는 함수형 프로그래밍의 개념을 따르며, 불리언 값을 반환하는 조건을 기반으로 리스트를 필터링한다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 3, 4, 5, 6];
List&lt;int&gt; evenNumbers = numbers.where((num) =&gt; num % 2 == 0).toList(); // 결과: [2, 4, 6]
</code></pre>
<h3 id="_7">리스트 정렬</h3>
<p>리스트의 요소를 오름차순이나 내림차순으로 정렬하는 방법은 <code>sort()</code> 메소드를 사용한다. 기본적으로 <code>sort()</code> 메소드는 오름차순 정렬을 수행하지만, 커스텀 비교 함수를 제공하여 내림차순으로도 정렬할 수 있다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [5, 1, 4, 2, 3];
numbers.sort(); // 결과: [1, 2, 3, 4, 5]

numbers.sort((a, b) =&gt; b.compareTo(a)); // 내림차순 정렬 결과: [5, 4, 3, 2, 1]
</code></pre>
<h3 id="_8">리스트의 변환</h3>
<p>리스트의 각 요소를 특정 방식으로 변환하는 작업은 <code>map()</code> 메소드를 사용하여 가능하다. 이 메소드는 리스트의 모든 요소에 변환 로직을 적용한 새로운 리스트를 반환한다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 3, 4, 5];
List&lt;int&gt; squaredNumbers = numbers.map((num) =&gt; num * num).toList(); // 결과: [1, 4, 9, 16, 25]
</code></pre>
<h3 id="_9">리스트의 모든 요소에 함수 적용</h3>
<p>리스트의 모든 요소에 대해 함수나 연산을 적용하는 방법으로는 <code>forEach()</code>를 사용할 수 있다. 이는 주로 리스트 내의 각 요소를 순회하며 부수적인 작업을 할 때 사용된다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 3];
numbers.forEach((num) =&gt; print(num)); // 1, 2, 3 출력
</code></pre>
<h3 id="_10">리스트의 탐색</h3>
<p>리스트에서 특정 조건에 맞는 요소를 찾는 방법으로는 <code>firstWhere()</code>, <code>lastWhere()</code>, <code>indexOf()</code> 등이 있다.</p>
<h4 id="_11">첫 번째 일치하는 요소 찾기</h4>
<p><code>firstWhere()</code> 메소드는 리스트에서 주어진 조건을 만족하는 첫 번째 요소를 반환한다. 만약 조건을 만족하는 요소가 없을 경우, 기본값을 설정하거나 예외를 발생시킬 수 있다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 3, 4, 5];
int firstEven = numbers.firstWhere((num) =&gt; num % 2 == 0); // 결과: 2
</code></pre>
<h4 id="_12">마지막 일치하는 요소 찾기</h4>
<p><code>lastWhere()</code> 메소드는 <code>firstWhere()</code>와 동일하지만, 리스트에서 마지막으로 조건을 만족하는 요소를 반환한다.</p>
<pre><code class="language-dart">int lastEven = numbers.lastWhere((num) =&gt; num % 2 == 0); // 결과: 4
</code></pre>
<h4 id="_13">특정 요소의 인덱스 찾기</h4>
<p><code>indexOf()</code> 메소드는 리스트에서 특정 값의 첫 번째 인덱스를 반환한다. 만약 값이 리스트에 없으면 <code>-1</code>을 반환한다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 3, 4, 5];
int index = numbers.indexOf(3); // 결과: 2
</code></pre>
<h3 id="_14">리스트의 중복 제거</h3>
<p>리스트의 중복 요소를 제거하는 방법으로는 <code>toSet()</code> 메소드를 사용할 수 있다. 이 메소드는 리스트를 <code>Set</code>으로 변환하여 중복을 제거한 후, 다시 리스트로 변환한다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 2, 3, 3, 4];
List&lt;int&gt; uniqueNumbers = numbers.toSet().toList(); // 결과: [1, 2, 3, 4]
</code></pre>
<h3 id="_15">리스트의 길이와 빈 리스트 확인</h3>
<p>리스트의 길이를 확인할 때는 <code>length</code> 속성을 사용한다. 또한, 리스트가 비어 있는지 확인할 때는 <code>isEmpty</code> 또는 <code>isNotEmpty</code> 속성을 사용할 수 있다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 3];
int length = numbers.length;  // 결과: 3
bool isEmpty = numbers.isEmpty; // 결과: false
</code></pre>
<h3 id="_16">리스트 초기화</h3>
<p>리스트를 고정된 길이로 초기화하거나 특정 값으로 초기화할 때는 <code>List.filled()</code> 메소드를 사용한다. 이는 리스트를 특정 크기와 값으로 초기화하는 데 유용하다.</p>
<pre><code class="language-dart">List&lt;int&gt; zeros = List.filled(5, 0);  // 결과: [0, 0, 0, 0, 0]
</code></pre>
<h3 id="_17">리스트의 부분 업데이트</h3>
<p>리스트의 특정 구간을 다른 값으로 업데이트하는 방법으로는 <code>setRange()</code> 메소드를 사용할 수 있다. 이 메소드는 리스트의 일부를 지정한 값으로 덮어쓴다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 3, 4, 5];
numbers.setRange(1, 3, [10, 20]); // 결과: [1, 10, 20, 4, 5]
</code></pre>
<h3 id="_18">리스트의 빈 자리 삽입</h3>
<p>리스트에 특정 위치에 요소를 삽입할 때는 <code>insert()</code>와 <code>insertAll()</code> 메소드를 사용할 수 있다. <code>insert()</code>는 단일 요소를 삽입하고, <code>insertAll()</code>은 여러 요소를 삽입한다.</p>
<pre><code class="language-dart">List&lt;int&gt; numbers = [1, 2, 4, 5];
numbers.insert(2, 3); // 결과: [1, 2, 3, 4, 5]

List&lt;int&gt; numbers2 = [1, 2, 5];
numbers2.insertAll(2, [3, 4]); // 결과: [1, 2, 3, 4, 5]
</code></pre>
<h3 id="_19">리스트 병합 및 변환 과정의 복잡도 분석</h3>
<p>리스트를 병합하거나 변환할 때의 복잡도를 수학적으로 분석할 수 있다. 리스트에 요소를 하나씩 추가하는 것은 시간 복잡도가 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>이지만, 리스트를 전체적으로 병합하는 경우에는 복잡도가 <span class="arithmatex"><span class="MathJax_Preview">O(n + m)</span><script type="math/tex">O(n + m)</script></span>이 될 수 있다. 여기서 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>은 첫 번째 리스트의 길이, <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 두 번째 리스트의 길이이다.</p>
<h4 id="_20">시간 복잡도 분석</h4>
<p>리스트 병합에서 시간 복잡도는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{merge}}(n, m) = O(n + m)
</div>
<script type="math/tex; mode=display">
T_{\text{merge}}(n, m) = O(n + m)
</script>
</div>
<p>리스트 슬라이싱과 필터링에서의 복잡도는 리스트의 크기 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>에 비례하여 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{sublist}}(n) = O(n)
</div>
<script type="math/tex; mode=display">
T_{\text{sublist}}(n) = O(n)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{filter}}(n) = O(n)
</div>
<script type="math/tex; mode=display">
T_{\text{filter}}(n) = O(n)
</script>
</div>
<p>이 복잡도는 리스트의 크기와 변환 과정에서 얼마나 많은 계산이 필요한지를 나타낸다.</p>
<h3 id="_21">리스트의 재정렬 및 복잡도 분석</h3>
<p>리스트를 정렬하는 작업은 Dart의 <code>sort()</code> 메소드를 사용하며, 기본적으로 퀵소트(QuickSort) 알고리즘이 적용된다. 이는 최선의 경우 <span class="arithmatex"><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span>의 시간 복잡도를 갖지만, 최악의 경우 <span class="arithmatex"><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span>이 될 수 있다. 하지만 Dart는 최악의 경우에도 <span class="arithmatex"><span class="MathJax_Preview">O(n \log n)</span><script type="math/tex">O(n \log n)</script></span> 성능을 보장하는 알고리즘을 사용한다.</p>
<h4 id="_22">시간 복잡도</h4>
<p>리스트를 오름차순 또는 내림차순으로 정렬하는 경우 시간 복잡도는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
T_{\text{sort}}(n) = O(n \log n)
</div>
<script type="math/tex; mode=display">
T_{\text{sort}}(n) = O(n \log n)
</script>
</div>
<p>이 복잡도는 리스트에 포함된 요소 수에 따라 결정되며, 매우 큰 리스트를 처리할 때 성능 최적화의 중요한 부분이 된다.</p>
<h3 id="set">Set 조작</h3>
<p>Set은 중복을 허용하지 않는 컬렉션이며, Dart에서 리스트와 유사한 방식으로 사용할 수 있지만, 순서가 보장되지 않는다. Set의 주요 특징은 중복 요소를 허용하지 않는다는 점이다.</p>
<h4 id="_23">요소 추가 및 제거</h4>
<p>Set에 요소를 추가하는 것은 리스트와 동일하게 <code>add()</code> 메소드를 사용한다. 하지만, 중복된 값은 허용되지 않는다.</p>
<pre><code class="language-dart">Set&lt;int&gt; numbers = {1, 2, 3};
numbers.add(3);  // 결과: {1, 2, 3}
</code></pre>
<p><code>remove()</code> 메소드는 리스트와 동일하게 특정 요소를 제거한다.</p>
<pre><code class="language-dart">numbers.remove(2);  // 결과: {1, 3}
</code></pre>
<h4 id="set_1">Set 연산</h4>
<p>Set을 활용하면 교집합, 합집합, 차집합 등의 수학적 집합 연산을 간편하게 수행할 수 있다. 이러한 연산은 수학적 표현으로도 설명할 수 있다.</p>
<h4 id="_24">합집합</h4>
<p>두 Set의 합집합은 Dart에서 <code>union()</code> 메소드를 사용하여 구현할 수 있다. 이 연산은 두 Set에 포함된 모든 요소를 반환하며, 중복된 요소는 제거된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
A \cup B = \{x \mid x \in A \text{ 또는 } x \in B\}
</div>
<script type="math/tex; mode=display">
A \cup B = \{x \mid x \in A \text{ 또는 } x \in B\}
</script>
</div>
<pre><code class="language-dart">Set&lt;int&gt; set1 = {1, 2, 3};
Set&lt;int&gt; set2 = {3, 4, 5};
Set&lt;int&gt; unionSet = set1.union(set2);  // 결과: {1, 2, 3, 4, 5}
</code></pre>
<h4 id="_25">교집합</h4>
<p>교집합은 두 Set에서 공통된 요소만 반환하는 연산으로, <code>intersection()</code> 메소드를 사용한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
A \cap B = \{x \mid x \in A \text{ 그리고 } x \in B\}
</div>
<script type="math/tex; mode=display">
A \cap B = \{x \mid x \in A \text{ 그리고 } x \in B\}
</script>
</div>
<pre><code class="language-dart">Set&lt;int&gt; intersectionSet = set1.intersection(set2);  // 결과: {3}
</code></pre>
<h4 id="_26">차집합</h4>
<p>차집합은 첫 번째 Set에서 두 번째 Set에 포함되지 않은 요소만 반환하는 연산이다. Dart에서는 <code>difference()</code> 메소드를 사용한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
A - B = \{x \mid x \in A \text{ 이지만 } x \notin B\}
</div>
<script type="math/tex; mode=display">
A - B = \{x \mid x \in A \text{ 이지만 } x \notin B\}
</script>
</div>
<pre><code class="language-dart">Set&lt;int&gt; differenceSet = set1.difference(set2);  // 결과: {1, 2}
</code></pre>
<h4 id="_27">시간 복잡도 분석</h4>
<p>Set의 주요 연산들의 시간 복잡도는 다음과 같다:</p>
<ul>
<li>합집합: <span class="arithmatex"><span class="MathJax_Preview">O(n + m)</span><script type="math/tex">O(n + m)</script></span></li>
<li>교집합: <span class="arithmatex"><span class="MathJax_Preview">O(\min(n, m))</span><script type="math/tex">O(\min(n, m))</script></span></li>
<li>차집합: <span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span></li>
</ul>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 두 Set의 크기를 나타낸다.</p>
<h3 id="map">Map 조작</h3>
<p>Map은 키와 값의 쌍으로 이루어진 컬렉션이다. Dart에서는 Map을 사용하여 키를 기반으로 값을 빠르게 조회하고, 추가 및 삭제 작업을 수행할 수 있다.</p>
<h4 id="_28">요소 추가 및 업데이트</h4>
<p>Map에 새로운 요소를 추가하거나 기존 요소를 업데이트할 때는 <code>[]</code> 연산자를 사용한다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; scores = {'John': 90, 'Jane': 85};
scores['Alice'] = 95;  // 새로운 요소 추가
scores['John'] = 92;   // 기존 요소 업데이트
</code></pre>
<h4 id="_29">요소 제거</h4>
<p>Map에서 요소를 제거할 때는 <code>remove()</code> 메소드를 사용한다. 키를 기반으로 값을 삭제할 수 있다.</p>
<pre><code class="language-dart">scores.remove('Jane');  // 결과: {'John': 92, 'Alice': 95}
</code></pre>
<h4 id="_30">요소 탐색</h4>
<p>Map에서 특정 키에 대한 값을 조회할 때는 <code>[]</code> 연산자를 사용할 수 있다. 존재하지 않는 키를 조회하면 <code>null</code>을 반환한다.</p>
<pre><code class="language-dart">int? johnScore = scores['John'];  // 결과: 92
</code></pre>
<h4 id="_31">키와 값 목록</h4>
<p>Map의 키와 값만을 따로 추출하여 리스트 형태로 가져오고자 할 때는 <code>keys</code>와 <code>values</code> 속성을 사용할 수 있다.</p>
<pre><code class="language-dart">Iterable&lt;String&gt; names = scores.keys;  // 결과: ('John', 'Alice')
Iterable&lt;int&gt; scoresList = scores.values;  // 결과: (92, 95)
</code></pre>
<h3 id="map_1">Map의 고급 조작</h3>
<p>Map은 키-값 쌍을 기반으로 데이터를 저장하고 조작하는 컬렉션으로, 다양한 방법으로 탐색, 수정, 업데이트가 가능하다. 아래에서는 Dart의 Map에서 제공하는 고급 기능들을 살펴본다.</p>
<h4 id="_32">키 존재 여부 확인</h4>
<p>Map에서 특정 키가 존재하는지 확인하려면 <code>containsKey()</code> 메소드를 사용할 수 있다. 이 메소드는 해당 키가 존재하면 <code>true</code>를 반환하고, 그렇지 않으면 <code>false</code>를 반환한다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; scores = {'John': 92, 'Alice': 95};
bool hasJohn = scores.containsKey('John');  // 결과: true
bool hasBob = scores.containsKey('Bob');    // 결과: false
</code></pre>
<h4 id="_33">값 존재 여부 확인</h4>
<p>특정 값이 Map에 존재하는지 확인할 때는 <code>containsValue()</code> 메소드를 사용한다.</p>
<pre><code class="language-dart">bool hasScore95 = scores.containsValue(95);  // 결과: true
</code></pre>
<h4 id="map_2">Map 병합</h4>
<p>Dart에서 두 개 이상의 Map을 병합할 수 있다. 이 작업은 <code>addAll()</code> 메소드를 사용하여 수행할 수 있으며, 만약 동일한 키가 존재할 경우 마지막으로 추가된 Map의 값이 우선된다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; map1 = {'John': 90};
Map&lt;String, int&gt; map2 = {'Alice': 95, 'John': 92};
map1.addAll(map2);  // 결과: {'John': 92, 'Alice': 95}
</code></pre>
<h4 id="map_3">Map의 기본값 설정</h4>
<p>Dart에서는 존재하지 않는 키를 조회할 때 기본값을 설정할 수 있다. 이 작업은 <code>putIfAbsent()</code> 메소드를 통해 가능하다. 키가 존재하지 않으면 기본값이 추가되며, 이미 존재하는 경우는 무시된다.</p>
<pre><code class="language-dart">scores.putIfAbsent('Bob', () =&gt; 85);  // 결과: {'John': 92, 'Alice': 95, 'Bob': 85}
</code></pre>
<h4 id="map_4">Map의 순회</h4>
<p>Map의 모든 키와 값을 순회할 때는 <code>forEach()</code> 메소드를 사용한다. 이 메소드는 각 키-값 쌍에 대해 제공된 함수를 호출한다.</p>
<pre><code class="language-dart">scores.forEach((key, value) {
  print('$key:$value');
});
// 출력 결과: 
// John: 92
// Alice: 95
// Bob: 85
</code></pre>
<h3 id="map_5">Map 변환 및 필터링</h3>
<h4 id="map_6">Map 변환</h4>
<p>Map의 모든 값을 특정 방식으로 변환하려면 <code>map()</code> 메소드를 사용할 수 있다. 이 메소드는 새로운 Map을 반환하며, 기존의 키-값 쌍에 변환 로직을 적용한다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; updatedScores = scores.map((key, value) =&gt; MapEntry(key, value + 5));  
// 결과: {'John': 97, 'Alice': 100, 'Bob': 90}
</code></pre>
<h4 id="map_7">Map 필터링</h4>
<p>Map에서 조건에 맞는 요소만 추출하려면 <code>where()</code> 메소드를 사용할 수 있다. 이 메소드는 주어진 조건을 만족하는 키-값 쌍을 필터링하여 새로운 Map을 생성한다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; highScores = scores.where((key, value) =&gt; value &gt; 90);  
// 결과: {'John': 92, 'Alice': 95}
</code></pre>
<h3 id="map_8">Map에서의 복잡도 분석</h3>
<p>Map에서의 주요 연산들의 시간 복잡도는 HashMap 구조를 기준으로 다음과 같이 분석된다.</p>
<ul>
<li>요소 추가: <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span></li>
<li>요소 제거: <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span></li>
<li>키 또는 값 존재 여부 확인: <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span></li>
<li>Map 순회: <span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span></li>
</ul>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>은 Map에 포함된 키-값 쌍의 개수이다. 이러한 복잡도는 일반적인 HashMap 구조의 시간 복잡도와 유사하다.</p>
<h4 id="map_9">Map의 메모리 효율성</h4>
<p>Dart의 Map은 메모리 효율성 면에서도 적절한 구조를 제공한다. 키-값 쌍을 효율적으로 저장하기 위해 해시 테이블이 사용되며, 충돌 처리를 위한 메커니즘도 내장되어 있다.</p>
<h3 id="map_10">Map의 키와 값 변환</h3>
<p>Map의 키 또는 값을 변환하는 작업은 <code>map()</code> 메소드와 달리, 특정적으로 키만 또는 값만 변경하는 방법으로도 가능하다. Dart에서는 각각의 키와 값을 변환한 후 새로운 Map을 반환하는 방식으로 이러한 작업을 처리할 수 있다.</p>
<h4 id="_34">값 변환</h4>
<p>Map의 값을 특정 방식으로 변환하려면 <code>mapValues()</code> 패턴을 적용할 수 있다. Dart는 직접적인 <code>mapValues()</code> 메소드를 제공하지 않지만, <code>map()</code> 메소드를 활용하여 동일한 기능을 수행할 수 있다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; updatedScores = scores.map((key, value) =&gt; MapEntry(key, value * 2));  
// 결과: {'John': 184, 'Alice': 190, 'Bob': 170}
</code></pre>
<h4 id="_35">키 변환</h4>
<p>키를 변환하는 작업은 조금 더 복잡할 수 있는데, 주로 키에 대한 변경이 이루어질 때 새로운 Map을 반환하여야 한다. Dart는 <code>map()</code> 메소드를 사용하여 키를 변환할 수 있으며, 기존의 키-값 쌍에 변환 로직을 적용할 수 있다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; updatedKeys = scores.map((key, value) =&gt; MapEntry('$key_score', value));  
// 결과: {'John_score': 92, 'Alice_score': 95, 'Bob_score': 85}
</code></pre>
<h3 id="map_11">Map의 깊은 복사와 얕은 복사</h3>
<p>Dart에서 Map을 복사할 때는 얕은 복사(shallow copy)와 깊은 복사(deep copy)를 구분해야 한다. 얕은 복사는 단순히 참조를 복사하는 반면, 깊은 복사는 각 요소의 값을 모두 새롭게 복사하여 완전히 독립적인 Map을 생성한다.</p>
<h4 id="_36">얕은 복사</h4>
<p>얕은 복사는 기본적으로 <code>addAll()</code> 메소드를 사용하여 이루어진다. 이 경우 복사된 Map은 원본 Map의 참조를 그대로 사용하게 된다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; shallowCopy = {};
shallowCopy.addAll(scores);
// shallowCopy는 scores와 동일한 참조를 가짐
</code></pre>
<h4 id="_37">깊은 복사</h4>
<p>깊은 복사는 모든 키-값 쌍을 새롭게 할당하여 새로운 Map을 생성하는 방법이다. 이를 위해서는 모든 값을 명시적으로 복사해야 한다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; deepCopy = scores.map((key, value) =&gt; MapEntry(key, value));
// deepCopy는 scores와 독립적인 복사본
</code></pre>
<h3 id="map_12">Map의 기본 값 설정</h3>
<p>Dart에서는 Map에서 특정 키에 값이 없을 때 기본값을 설정하는 방법으로 <code>putIfAbsent()</code> 메소드를 사용할 수 있다. 이 메소드는 해당 키가 이미 존재하면 아무 작업도 하지 않고, 키가 존재하지 않으면 기본값을 삽입한다.</p>
<pre><code class="language-dart">Map&lt;String, int&gt; scores = {'John': 92, 'Alice': 95};
scores.putIfAbsent('Bob', () =&gt; 85);  // Bob이 없을 경우 85 추가
</code></pre>
<p>이 방법은 데이터가 부족할 때 기본값을 설정하는 유용한 방식이다.</p>
<h3 id="map_13">Map의 키 리스트와 값 리스트</h3>
<p>Map의 키와 값을 각각 리스트 형태로 추출하고 싶을 때는 <code>keys</code>와 <code>values</code> 속성을 사용할 수 있다. 이 속성들은 <code>Iterable</code> 타입을 반환하며, <code>toList()</code> 메소드를 사용하여 리스트로 변환할 수 있다.</p>
<pre><code class="language-dart">List&lt;String&gt; keyList = scores.keys.toList();   // 결과: ['John', 'Alice', 'Bob']
List&lt;int&gt; valueList = scores.values.toList();  // 결과: [92, 95, 85]
</code></pre>
<h3 id="map_14">Map의 구조 시각화</h3>
<p>Map의 기본 구조와 데이터를 시각적으로 나타낼 수 있다. Dart에서의 Map은 키-값 쌍으로 구성되며, 이를 시각적으로 표현하면 다음과 같다:</p>
<div class="mermaid">graph TD;
    A["Map"] --&gt; B["John: 92"];
    A --&gt; C["Alice: 95"];
    A --&gt; D["Bob: 85"];
</div>
<p>이 다이어그램은 Map의 기본 구조를 시각적으로 보여주며, 각 키-값 쌍이 어떻게 연결되어 있는지를 나타낸다.</p>
<h3 id="map_15">Map의 병합과 필터링의 복잡도 분석</h3>
<p>Map에서 병합 및 필터링 작업은 다음과 같은 시간 복잡도를 갖는다:</p>
<ul>
<li>병합: 두 Map을 병합하는 경우 시간 복잡도는 <span class="arithmatex"><span class="MathJax_Preview">O(n + m)</span><script type="math/tex">O(n + m)</script></span>, 여기서 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 각각 병합할 Map의 크기이다.</li>
<li>필터링: Map에서 조건을 만족하는 요소를 필터링할 때의 시간 복잡도는 <span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>, 여기서 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>은 Map의 크기이다.</li>
</ul>
<p>이러한 복잡도는 Map의 크기에 따라 성능이 좌우되며, 매우 큰 Map을 처리할 때 성능 최적화가 중요한 요소가 된다.</p>
<h3 id="map_16">Map의 고급 기능과 활용 사례</h3>
<p>Dart의 Map은 다양한 데이터 구조와 복잡한 데이터 저장소를 처리하는 데 매우 유용하다. 특히 JSON과 같은 데이터를 다룰 때 Dart의 Map은 매우 직관적이고 강력한 도구로 활용된다.</p>
<h4 id="json-map">JSON과 Map</h4>
<p>JSON 데이터를 Dart에서 다룰 때 Map을 사용하여 쉽게 파싱하고 조작할 수 있다. Dart는 <code>dart:convert</code> 라이브러리를 통해 JSON 데이터를 Map으로 변환할 수 있다.</p>
<pre><code class="language-dart">import 'dart:convert';

String jsonData = '{"John": 92, "Alice": 95, "Bob": 85}';
Map&lt;String, int&gt; scores = jsonDecode(jsonData);

print(scores);  // 결과: {John: 92, Alice: 95, Bob: 85}
</code></pre>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../../chapter_07/0701/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../../chapter_07/0701/">
        제너릭 클래스
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0603/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0603/">
        Map
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>