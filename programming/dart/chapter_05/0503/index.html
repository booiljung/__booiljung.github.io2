<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/programming/dart/chapter_05/0503/" rel="canonical"/>
<link href="../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>상속과 다형성 - 실험 도서관</title>
<link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc0c1\uc18d(Inheritance)", url: "#_top", children: [
              {title: "\uc0c1\uc18d\uc758 \uae30\ubcf8 \ubb38\ubc95", url: "#_1" },
          ]},
          {title: "\ub2e4\ud615\uc131(Polymorphism)", url: "#polymorphism", children: [
              {title: "\ub2e4\ud615\uc131\uc758 \uc608\uc2dc", url: "#_2" },
          ]},
          {title: "\uc0c1\uc18d\uacfc \ub2e4\ud615\uc131\uc758 \uc218\ud559\uc801 \ubaa8\ub378\ub9c1", url: "#_3", children: [
              {title: "\uc0c1\uc18d\uc758 \uc218\ud559\uc801 \uad00\uacc4", url: "#_4" },
          ]},
          {title: "\ub2e4\ud615\uc131\uc758 \uc218\ud559\uc801 \ubaa8\ub378\ub9c1", url: "#_5", children: [
          ]},
          {title: "\ub2e4\ud615\uc131\uc758 \ub3d9\uc801 \ubc14\uc778\ub529(Dynamic Binding)", url: "#dynamic-binding", children: [
              {title: "\ub3d9\uc801 \ubc14\uc778\ub529\uc758 \uc608\uc2dc", url: "#_6" },
          ]},
          {title: "\uc218\ud559\uc801\uc73c\ub85c \ub3d9\uc801 \ubc14\uc778\ub529 \uc124\uba85", url: "#_7", children: [
          ]},
          {title: "\ub2e4\ud615\uc131\uc758 \uc774\uc810", url: "#_8", children: [
              {title: "\ucf54\ub4dc\uc758 \uc7ac\uc0ac\uc6a9\uc131", url: "#_9" },
              {title: "\uc720\uc5f0\ud55c \uc124\uacc4", url: "#_10" },
          ]},
          {title: "\uc0c1\uc18d\uacfc \ub2e4\ud615\uc131\uc758 \uc608\uc2dc\ub97c \ud1b5\ud55c \uad6c\uccb4\ud654", url: "#_11", children: [
              {title: "\uc608\uc2dc \ud504\ub85c\uadf8\ub7a8: \ub3d9\ubb3c\uc6d0 \uc2dc\ubbac\ub808\uc774\uc158", url: "#_12" },
          ]},
          {title: "\uc0c1\uc18d\uacfc \ub2e4\ud615\uc131\uc758 \ud55c\uacc4", url: "#_13", children: [
              {title: "\ub2e4\uc911 \uc0c1\uc18d\uc758 \uc81c\ud55c", url: "#_14" },
              {title: "\uc608\uc2dc: mixin\uc744 \ud65c\uc6a9\ud55c \ub2e4\uc911 \uc0c1\uc18d \ub300\uccb4", url: "#mixin" },
          ]},
          {title: "\uc0c1\uc18d\uacfc \ub2e4\ud615\uc131\uc758 \uc124\uacc4 \ud328\ud134", url: "#_15", children: [
              {title: "\ud15c\ud50c\ub9bf \uba54\uc18c\ub4dc \ud328\ud134(Template Method Pattern)", url: "#template-method-pattern" },
              {title: "\ud329\ud1a0\ub9ac \ud328\ud134(Factory Pattern)", url: "#factory-pattern" },
          ]},
          {title: "\uc0c1\uc18d\uacfc \ub2e4\ud615\uc131\uc758 \ubaa8\ubc94 \uc0ac\ub840", url: "#_16", children: [
              {title: "\uc0c1\uc18d\uc744 \ub0a8\uc6a9\ud558\uc9c0 \uc54a\uae30", url: "#_17" },
              {title: "\uc778\ud130\ud398\uc774\uc2a4 \ud65c\uc6a9\ud558\uae30", url: "#_18" },
          ]},
        ];

    </script>
<script src="../../../../js/base.js"></script>
<script src="../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0504/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0504/">
        추상 클래스와 인터페이스
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0502/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0502/">
        생성자와 소멸자
      </a>
</div>
</div>
<p>상속과 다형성은 객체 지향 프로그래밍의 핵심 개념으로, 코드 재사용성을 높이고 확장 가능성을 제공하는 강력한 도구이다. 이 섹션에서는 Dart에서 상속과 다형성을 어떻게 구현하고 사용하는지에 대해 깊이 있게 다루겠다.</p>
<h3 id="inheritance">상속(Inheritance)</h3>
<p>상속은 하나의 클래스가 다른 클래스의 속성과 메소드를 물려받는 개념이다. Dart에서는 <code>extends</code> 키워드를 사용하여 상속을 구현할 수 있다. 상속은 코드 재사용을 촉진하고, 클래스 간의 관계를 계층적으로 표현할 수 있게 한다.</p>
<h4 id="_1">상속의 기본 문법</h4>
<p>상속의 기본적인 구조는 다음과 같다.</p>
<pre><code class="language-dart">class Parent {
  void speak() {
    print('Parent is speaking');
  }
}

class Child extends Parent {
  @override
  void speak() {
    print('Child is speaking');
  }
}
</code></pre>
<p>여기서 <code>Child</code> 클래스는 <code>Parent</code> 클래스를 상속받았으며, <code>speak()</code> 메소드를 오버라이딩하여 고유한 동작을 정의하였다. 하지만 부모 클래스인 <code>Parent</code>의 메소드와 속성을 그대로 사용할 수도 있다.</p>
<h3 id="polymorphism">다형성(Polymorphism)</h3>
<p>다형성은 동일한 인터페이스 또는 상속 계층 구조를 따르는 객체들이 다른 방식으로 동작할 수 있는 능력을 의미한다. Dart에서는 객체가 여러 형태를 가질 수 있게 하여 유연한 코드를 작성할 수 있다. 다형성은 주로 상속과 인터페이스를 통해 구현된다.</p>
<h4 id="_2">다형성의 예시</h4>
<pre><code class="language-dart">class Animal {
  void sound() {
    print('Animal makes a sound');
  }
}

class Dog extends Animal {
  @override
  void sound() {
    print('Dog barks');
  }
}

class Cat extends Animal {
  @override
  void sound() {
    print('Cat meows');
  }
}

void makeSound(Animal animal) {
  animal.sound();
}

void main() {
  var dog = Dog();
  var cat = Cat();

  makeSound(dog);  // Dog barks
  makeSound(cat);  // Cat meows
}
</code></pre>
<p>이 코드에서 <code>Dog</code>와 <code>Cat</code>은 모두 <code>Animal</code> 클래스를 상속받았으며, <code>sound()</code> 메소드를 각자의 방식으로 오버라이딩하였다. <code>makeSound()</code> 함수는 <code>Animal</code> 타입의 매개변수를 받기 때문에 <code>Dog</code>와 <code>Cat</code> 객체를 동일한 방식으로 처리하지만, 각 객체의 메소드가 다르게 실행된다. 이게 바로 다형성의 강력한 특징이다.</p>
<h3 id="_3">상속과 다형성의 수학적 모델링</h3>
<p>상속과 다형성을 수학적으로 표현하면, 기본적으로 계층 구조에서 각 클래스가 어떤 역할을 하는지 설명할 수 있다. 예를 들어, 클래스 간의 상속 관계는 트리 구조로 표현된다. 클래스 <span class="arithmatex"><span class="MathJax_Preview">C_1</span><script type="math/tex">C_1</script></span>이 클래스 <span class="arithmatex"><span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script></span>을 상속받을 경우, 이를 트리로 나타내면 다음과 같다:</p>
<div class="mermaid">classDiagram
    Parent &lt;|-- Child
    class Parent {
      +speak() void
    }
    class Child {
      +speak() void
    }
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script></span>은 부모 클래스, <span class="arithmatex"><span class="MathJax_Preview">C_1</span><script type="math/tex">C_1</script></span>은 자식 클래스를 나타내며, 자식 클래스는 부모 클래스의 속성과 메소드를 상속받는다.</p>
<h4 id="_4">상속의 수학적 관계</h4>
<p>상속을 수학적으로 모델링할 때는 자식 클래스가 부모 클래스의 속성과 메소드를 상속받는 구조를 함수적 관계로 정의할 수 있다. 부모 클래스에서 정의된 메소드를 <span class="arithmatex"><span class="MathJax_Preview">f_P(x)</span><script type="math/tex">f_P(x)</script></span>로 표현하고, 자식 클래스에서 이를 오버라이드한 메소드를 <span class="arithmatex"><span class="MathJax_Preview">f_C(x)</span><script type="math/tex">f_C(x)</script></span>로 정의할 수 있다. </p>
<p>자식 클래스에서 부모 클래스의 메소드를 오버라이딩하는 경우, 다음과 같은 함수 관계를 만족한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f_C(x) = f_P(x) + \delta f(x)
</div>
<script type="math/tex; mode=display">
f_C(x) = f_P(x) + \delta f(x)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\delta f(x)</span><script type="math/tex">\delta f(x)</script></span>는 자식 클래스에서 추가적으로 정의된 메소드의 차이를 나타낸다. 이 관계는 다형성의 원리를 수학적으로 설명한다.</p>
<h3 id="_5">다형성의 수학적 모델링</h3>
<p>다형성은 여러 클래스로부터 파생된 객체들이 동일한 메소드를 호출하더라도 다른 결과를 반환하는 구조를 의미한다. 이를 수학적으로 표현하면, 다양한 함수의 집합에서 특정 객체가 어느 함수에 대응되는지 결정하는 매핑으로 나타낼 수 있다.</p>
<p>예를 들어, 여러 하위 클래스의 메소드를 다음과 같이 정의할 수 있다:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">f_{C1}(x)</span><script type="math/tex">f_{C1}(x)</script></span>: 첫 번째 자식 클래스의 메소드</li>
<li><span class="arithmatex"><span class="MathJax_Preview">f_{C2}(x)</span><script type="math/tex">f_{C2}(x)</script></span>: 두 번째 자식 클래스의 메소드</li>
</ul>
<p>이때, 다형성에 의해 호출된 메소드는 다음과 같은 조건을 만족한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f_{Parent}(x) \in \{ f_{C1}(x), f_{C2}(x), \dots \}
</div>
<script type="math/tex; mode=display">
f_{Parent}(x) \in \{ f_{C1}(x), f_{C2}(x), \dots \}
</script>
</div>
<p>이는 상위 클래스에서 정의된 메소드가 여러 하위 클래스의 메소드 중 하나로 대체될 수 있음을 의미한다.</p>
<h3 id="dynamic-binding">다형성의 동적 바인딩(Dynamic Binding)</h3>
<p>다형성은 동적 바인딩(Dynamic Binding)이라는 개념을 통해 구현된다. 동적 바인딩은 컴파일 시간에 결정되지 않고, 실행 시간에 객체의 타입에 따라 해당 메소드가 호출되는 방식이다. Dart는 런타임에 객체의 타입을 결정하여 적절한 메소드를 호출한다.</p>
<h4 id="_6">동적 바인딩의 예시</h4>
<pre><code class="language-dart">class Shape {
  void draw() {
    print('Drawing a shape');
  }
}

class Circle extends Shape {
  @override
  void draw() {
    print('Drawing a circle');
  }
}

class Square extends Shape {
  @override
  void draw() {
    print('Drawing a square');
  }
}

void render(Shape shape) {
  shape.draw();
}

void main() {
  var circle = Circle();
  var square = Square();

  render(circle);  // Drawing a circle
  render(square);  // Drawing a square
}
</code></pre>
<p>위의 코드에서 <code>Shape</code> 클래스는 기본적인 <code>draw()</code> 메소드를 제공하지만, <code>Circle</code>과 <code>Square</code> 클래스는 이 메소드를 각각 자신들의 방식으로 오버라이딩한다. <code>render()</code> 함수는 <code>Shape</code> 타입을 받아서 다형성을 이용해 실행 시간에 적절한 <code>draw()</code> 메소드를 호출한다. 이를 동적 바인딩이라고 한다.</p>
<h3 id="_7">수학적으로 동적 바인딩 설명</h3>
<p>수학적으로 동적 바인딩을 표현하면, 특정 부모 클래스의 메소드가 여러 자식 클래스에 의해 동적으로 결정될 수 있는 매핑을 의미한다. 이를 다음과 같이 나타낼 수 있다.</p>
<p>부모 클래스의 메소드를 <span class="arithmatex"><span class="MathJax_Preview">f_P(x)</span><script type="math/tex">f_P(x)</script></span>, 자식 클래스의 메소드를 <span class="arithmatex"><span class="MathJax_Preview">f_{C1}(x), f_{C2}(x), \dots</span><script type="math/tex">f_{C1}(x), f_{C2}(x), \dots</script></span>로 표현할 때, 런타임에서 메소드는 다음과 같은 조건을 만족하는 함수로 결정된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(x) = 
\begin{cases}
f_{C1}(x) &amp; \text{if } \text{instance of } C1 \\
f_{C2}(x) &amp; \text{if } \text{instance of } C2 \\
\vdots \\
f_P(x)   &amp; \text{otherwise}
\end{cases}
</div>
<script type="math/tex; mode=display">
f(x) = 
\begin{cases}
f_{C1}(x) & \text{if } \text{instance of } C1 \\
f_{C2}(x) & \text{if } \text{instance of } C2 \\
\vdots \\
f_P(x)   & \text{otherwise}
\end{cases}
</script>
</div>
<p>여기서 조건에 따라 자식 클래스의 메소드가 호출되며, 부모 클래스의 메소드가 기본적으로 호출될 수 있다. 이 관계는 다형성과 동적 바인딩의 수학적 기초를 나타낸다.</p>
<h3 id="_8">다형성의 이점</h3>
<h4 id="_9">코드의 재사용성</h4>
<p>다형성은 코드 재사용성을 높인다. 여러 클래스에서 공통 인터페이스나 부모 클래스를 상속받아 구현할 경우, 동일한 함수에서 다양한 객체들을 처리할 수 있다. 이로 인해 코드의 확장성과 유지보수성이 향상된다.</p>
<h4 id="_10">유연한 설계</h4>
<p>다형성은 설계의 유연성을 제공한다. 클래스 구조를 계층적으로 설계하고, 필요에 따라 새로운 하위 클래스를 추가하는 방식으로 프로그램을 확장할 수 있다. 새로운 클래스는 기존의 코드를 수정하지 않고도 추가될 수 있으며, 동작은 런타임에 결정된다.</p>
<h3 id="_11">상속과 다형성의 예시를 통한 구체화</h3>
<p>상속과 다형성은 구체적인 프로그램 예시를 통해 더욱 명확하게 이해할 수 있다. 상속을 통한 기본 기능의 재사용과 다형성을 활용한 객체 간의 유연한 상호작용을 예시 프로그램으로 설명한다.</p>
<h4 id="_12">예시 프로그램: 동물원 시뮬레이션</h4>
<pre><code class="language-dart">class Animal {
  void sound() {
    print('Animal sound');
  }
}

class Lion extends Animal {
  @override
  void sound() {
    print('Lion roars');
  }
}

class Elephant extends Animal {
  @override
  void sound() {
    print('Elephant trumpets');
  }
}

void makeSound(Animal animal) {
  animal.sound();
}

void main() {
  var lion = Lion();
  var elephant = Elephant();

  makeSound(lion);  // Lion roars
  makeSound(elephant);  // Elephant trumpets
}
</code></pre>
<p>이 예제에서는 <code>Animal</code> 클래스를 상속받는 <code>Lion</code>과 <code>Elephant</code> 클래스가 각각 자신들의 방식으로 <code>sound()</code> 메소드를 구현하였다. <code>makeSound()</code> 함수는 다형성을 활용하여 <code>Animal</code> 타입의 객체를 받아들이다. 그 결과, <code>Lion</code>과 <code>Elephant</code> 객체에 따라 각각의 <code>sound()</code> 메소드가 호출된다. </p>
<h3 id="_13">상속과 다형성의 한계</h3>
<p>상속과 다형성은 강력한 개념이지만, 남용할 경우 코드가 복잡해지거나 유지보수가 어려워질 수 있다. 상속 계층이 깊어질수록 클래스 간의 의존성이 커지기 때문에 신중하게 사용해야 한다.</p>
<h4 id="_14">다중 상속의 제한</h4>
<p>Dart에서는 다중 상속을 지원하지 않는다. 즉, 한 클래스는 오직 하나의 부모 클래스만 상속받을 수 있다. 이는 다중 상속이 복잡성을 증가시키고 메소드 충돌을 일으킬 수 있기 때문에 Dart에서는 이를 방지하고 있다. 대신 <code>mixin</code>을 사용하여 여러 클래스의 기능을 조합할 수 있다.</p>
<h4 id="mixin">예시: mixin을 활용한 다중 상속 대체</h4>
<pre><code class="language-dart">mixin Flyable {
  void fly() {
    print('Flying');
  }
}

mixin Swimmable {
  void swim() {
    print('Swimming');
  }
}

class Duck with Flyable, Swimmable {
  void quack() {
    print('Quacking');
  }
}

void main() {
  var duck = Duck();
  duck.fly();  // Flying
  duck.swim();  // Swimming
  duck.quack();  // Quacking
}
</code></pre>
<p>여기서 <code>Duck</code> 클래스는 <code>Flyable</code>과 <code>Swimmable</code>이라는 mixin을 사용하여 두 가지 기능을 모두 구현할 수 있다. Dart에서 mixin은 다중 상속의 대안으로 사용되며, 여러 클래스의 메소드를 조합하여 사용 가능한 유연한 방식을 제공한다.</p>
<h3 id="_15">상속과 다형성의 설계 패턴</h3>
<p>객체 지향 설계에서는 상속과 다형성을 효과적으로 사용하는 다양한 패턴들이 있다. 그중 가장 대표적인 패턴으로 <strong>템플릿 메소드 패턴</strong>과 <strong>팩토리 패턴</strong>을 들 수 있다. 이 패턴들은 상속과 다형성의 특성을 극대화하여 코드의 재사용성과 유연성을 향상시킨다.</p>
<h4 id="template-method-pattern">템플릿 메소드 패턴(Template Method Pattern)</h4>
<p>템플릿 메소드 패턴은 상위 클래스에서 기본적인 알고리즘의 구조를 정의하고, 하위 클래스에서 세부적인 구현을 제공하는 패턴이다. 이를 통해 상위 클래스에서는 공통적인 로직을 정의하고, 하위 클래스에서는 특수한 동작을 구현할 수 있다.</p>
<pre><code class="language-dart">abstract class Game {
  void start() {
    print('Game started');
  }

  void play();  // Template method

  void end() {
    print('Game ended');
  }

  // Template method
  void run() {
    start();
    play();
    end();
  }
}

class Soccer extends Game {
  @override
  void play() {
    print('Playing soccer');
  }
}

class Basketball extends Game {
  @override
  void play() {
    print('Playing basketball');
  }
}

void main() {
  var soccer = Soccer();
  var basketball = Basketball();

  soccer.run();  // Template method is executed
  basketball.run();  // Template method is executed
}
</code></pre>
<p>여기서 <code>Game</code> 클래스는 템플릿 메소드인 <code>run()</code>을 통해 게임의 전반적인 흐름을 제어한다. 각 하위 클래스인 <code>Soccer</code>와 <code>Basketball</code>은 게임의 구체적인 플레이 방식을 정의하며, <code>run()</code> 메소드는 상위 클래스의 로직을 따르면서도 다형성을 통해 각각의 동작을 수행한다.</p>
<h4 id="factory-pattern">팩토리 패턴(Factory Pattern)</h4>
<p>팩토리 패턴은 객체 생성 로직을 별도의 메소드나 클래스에서 처리하여 코드의 의존성을 낮추고 확장성을 높이는 패턴이다. 상속과 다형성을 활용하여 팩토리 패턴을 구현할 수 있다.</p>
<pre><code class="language-dart">abstract class Animal {
  void speak();
}

class Dog extends Animal {
  @override
  void speak() {
    print('Woof');
  }
}

class Cat extends Animal {
  @override
  void speak() {
    print('Meow');
  }
}

class AnimalFactory {
  static Animal createAnimal(String type) {
    if (type == 'dog') {
      return Dog();
    } else if (type == 'cat') {
      return Cat();
    } else {
      throw Exception('Unknown animal type');
    }
  }
}

void main() {
  var dog = AnimalFactory.createAnimal('dog');
  var cat = AnimalFactory.createAnimal('cat');

  dog.speak();  // Woof
  cat.speak();  // Meow
}
</code></pre>
<p>팩토리 패턴에서는 <code>AnimalFactory</code> 클래스가 객체 생성의 책임을 맡으며, 이로 인해 클라이언트 코드가 구체적인 객체의 타입에 의존하지 않게 된다. 팩토리 메소드는 다형성을 이용하여 다양한 타입의 객체를 유연하게 생성할 수 있다.</p>
<h3 id="_16">상속과 다형성의 모범 사례</h3>
<p>상속과 다형성을 효과적으로 사용하기 위해서는 몇 가지 모범 사례를 따르는 것이 좋다. 올바른 설계를 통해 상속의 장점을 최대화하고, 불필요한 복잡성을 피할 수 있다.</p>
<h4 id="_17">상속을 남용하지 않기</h4>
<p>상속을 남용하면 클래스 간의 강한 결합이 발생하여, 유지보수 및 확장이 어려워질 수 있다. 상속은 "is-a" 관계를 나타내는 데 적합하며, 클래스 간의 일반적인 관계를 정의하는 데 사용해야 한다.</p>
<h4 id="_18">인터페이스 활용하기</h4>
<p>상속보다 인터페이스나 mixin을 사용하는 것이 더 적합한 경우가 많다. 인터페이스는 클래스 간의 결합도를 낮추며, 코드의 유연성을 높일 수 있다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0504/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0504/">
        추상 클래스와 인터페이스
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0502/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0502/">
        생성자와 소멸자
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>