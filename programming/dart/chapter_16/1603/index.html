<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/programming/dart/chapter_16/1603/" rel="canonical"/>
<link href="../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>Flutter 위젯 시스템 - 실험 도서관</title>
<link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc704\uc82f\uc758 \uae30\ubcf8 \uac1c\ub150", url: "#_top", children: [
          ]},
          {title: "Stateless \uc704\uc82f\uacfc Stateful \uc704\uc82f", url: "#stateless-stateful", children: [
              {title: "Stateless \uc704\uc82f", url: "#stateless" },
              {title: "Stateful \uc704\uc82f", url: "#stateful" },
          ]},
          {title: "\uc704\uc82f \ud2b8\ub9ac\uc640 \ub80c\ub354\ub9c1", url: "#_2", children: [
          ]},
          {title: "\uc704\uc82f\uc758 \uc218\uba85 \uc8fc\uae30", url: "#_3", children: [
              {title: "\uc218\uba85 \uc8fc\uae30 \uc608\uc2dc \ucf54\ub4dc", url: "#_4" },
          ]},
          {title: "\uc704\uc82f \uc870\ud569\uacfc \ub808\uc774\uc544\uc6c3", url: "#_5", children: [
              {title: "\ub300\ud45c\uc801\uc778 \ub808\uc774\uc544\uc6c3 \uc704\uc82f", url: "#_6" },
          ]},
          {title: "\uc704\uc82f\uc758 \uc7ac\uad6c\uc131", url: "#_7", children: [
          ]},
          {title: "\uc704\uc82f \ud2b8\ub9ac\uc758 \ucd5c\uc801\ud654", url: "#_8", children: [
              {title: "const \ud0a4\uc6cc\ub4dc", url: "#const" },
              {title: "Key\uc758 \uc0ac\uc6a9", url: "#key" },
          ]},
          {title: "BuildContext\uc640 InheritedWidget", url: "#buildcontext-inheritedwidget", children: [
              {title: "BuildContext\uc758 \uc5ed\ud560", url: "#buildcontext" },
              {title: "InheritedWidget", url: "#inheritedwidget" },
          ]},
          {title: "\uc704\uc82f\uc758 \uc0c1\ud0dc \uad00\ub9ac", url: "#_9", children: [
              {title: "setState()\ub97c \uc774\uc6a9\ud55c \uc0c1\ud0dc \uad00\ub9ac", url: "#setstate" },
          ]},
          {title: "\uc0c1\ud0dc \uad00\ub9ac: Provider \ud328\ud134", url: "#provider", children: [
              {title: "Provider \uc0ac\uc6a9 \uc608\uc2dc", url: "#provider_1" },
          ]},
          {title: "BLoC \ud328\ud134", url: "#bloc", children: [
              {title: "BLoC \ud328\ud134\uc758 \uad6c\uc131", url: "#bloc_1" },
              {title: "BLoC \ud328\ud134 \uc608\uc2dc", url: "#bloc_2" },
          ]},
          {title: "Riverpod \ud328\ud134", url: "#riverpod", children: [
              {title: "Riverpod\uc758 \uad6c\uc131", url: "#riverpod_1" },
              {title: "Riverpod \uc608\uc2dc", url: "#riverpod_2" },
          ]},
        ];

    </script>
<script src="../../../../js/base.js"></script>
<script src="../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../../chapter_17/1701/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../../chapter_17/1701/">
        Dart 코드 최적화 기법
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../1602/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../1602/">
        모바일 UI 구성
      </a>
</div>
</div>
<p>Flutter 위젯 시스템은 Flutter 애플리케이션의 핵심이며, UI를 구성하는 기본 요소이다. 모든 것이 위젯으로 정의되며, Flutter 애플리케이션의 모든 시각적 요소는 위젯의 조합으로 이루어져 있다. 이러한 위젯 시스템은 재사용 가능하고 직관적인 구조로, 애플리케이션의 상태와 UI를 효율적으로 관리할 수 있게 해준다.</p>
<h3 id="_1">위젯의 기본 개념</h3>
<p>Flutter에서 <strong>위젯</strong>은 화면에 나타나는 시각적인 요소를 나타낸다. 이러한 위젯들은 컨테이너, 텍스트, 버튼 등과 같은 간단한 것부터 더 복잡한 레이아웃 구조를 포함하는 복합 위젯까지 다양한다. 위젯의 특성은 크게 두 가지로 나눌 수 있다:</p>
<ol>
<li><strong>Stateless 위젯</strong>: 상태를 가지지 않으며, 한 번 생성되면 이후에 변화하지 않는 위젯이다.</li>
<li><strong>Stateful 위젯</strong>: 자체적으로 상태를 관리하며, 사용자 입력이나 내부 로직에 따라 동적으로 변할 수 있는 위젯이다.</li>
</ol>
<h3 id="stateless-stateful">Stateless 위젯과 Stateful 위젯</h3>
<p>Flutter는 위젯을 <strong>Stateless</strong>와 <strong>Stateful</strong>로 나누어 관리한다. 이 둘의 차이는 상태 관리 여부에 있으며, 이를 통해 Flutter는 성능 최적화와 유지보수성을 동시에 고려한다.</p>
<h4 id="stateless">Stateless 위젯</h4>
<p><strong>Stateless 위젯</strong>은 상태가 없는 위젯이다. 한 번 생성되면 그 상태가 바뀌지 않으며, 사용자 입력에 따라 변하지 않는다. 예를 들어, 단순히 텍스트를 출력하는 위젯은 Stateless 위젯으로 구현될 수 있다.</p>
<pre><code class="language-dart">class MyStatelessWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Text('This is a stateless widget');
  }
}
</code></pre>
<h4 id="stateful">Stateful 위젯</h4>
<p>반대로 <strong>Stateful 위젯</strong>은 상태를 가지며, 상태의 변화에 따라 UI가 동적으로 업데이트된다. 이 위젯은 두 가지로 구성된다:</p>
<ol>
<li><strong>StatefulWidget</strong>: 실제 위젯 구조를 나타내는 클래스.</li>
<li><strong>State</strong>: 상태 관리 로직을 포함하는 클래스.</li>
</ol>
<p>Stateful 위젯은 다음과 같이 상태를 관리한다.</p>
<pre><code class="language-dart">class MyStatefulWidget extends StatefulWidget {
  @override
  _MyStatefulWidgetState createState() =&gt; _MyStatefulWidgetState();
}

class _MyStatefulWidgetState extends State&lt;MyStatefulWidget&gt; {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Counter: $_counter'),
        ElevatedButton(
          onPressed: _incrementCounter,
          child: Text('Increment'),
        ),
      ],
    );
  }
}
</code></pre>
<p>이 코드에서 <strong>setState()</strong> 메서드는 상태를 갱신하고, Flutter는 자동으로 화면을 다시 렌더링하여 UI를 업데이트한다.</p>
<h3 id="_2">위젯 트리와 렌더링</h3>
<p>Flutter 애플리케이션은 위젯을 트리 구조로 관리한다. 각 위젯은 다른 위젯의 자식이 될 수 있으며, 이러한 트리 구조는 Flutter의 렌더링 엔진에서 UI를 그리는 데 사용된다. <strong>위젯 트리</strong>는 부모-자식 관계를 명확하게 정의하며, 최상위 위젯에서 하위 위젯으로 UI 구조를 전달한다.</p>
<div class="mermaid">graph TD;
  A[MyApp] --&gt; B[Scaffold]
  B --&gt; C[AppBar]
  B --&gt; D[Body]
  D --&gt; E[Text]
  D --&gt; F[Button]
</div>
<p>이와 같은 트리 구조에서 <strong>MyApp</strong>이 최상위 위젯이며, <strong>Scaffold</strong>는 화면의 전반적인 구조를 정의한다. 그 아래로 <strong>AppBar</strong>와 <strong>Body</strong>가 위치하며, <strong>Body</strong> 내부에는 <strong>Text</strong>와 <strong>Button</strong>과 같은 위젯이 포함된다.</p>
<h3 id="_3">위젯의 수명 주기</h3>
<p>Stateful 위젯은 여러 단계의 <strong>수명 주기</strong>(lifecycle)를 거치며, 각 단계마다 적절한 메서드를 호출하여 상태를 관리한다. Flutter는 이러한 수명 주기를 통해 위젯의 생성, 상태 갱신, 소멸 과정을 관리한다.</p>
<p>Stateful 위젯의 주요 수명 주기 메서드는 다음과 같다:</p>
<ol>
<li><strong>initState()</strong>: 위젯이 처음 생성될 때 호출된다. 여기에서 초기 상태를 설정할 수 있다.</li>
<li><strong>didChangeDependencies()</strong>: 위젯의 종속성이 변경될 때 호출된다. 이 메서드는 보통 위젯 트리에서 부모 위젯이 변경될 때 호출된다.</li>
<li><strong>build()</strong>: 위젯을 화면에 그리는 메서드이다. <strong>setState()</strong>가 호출되면 다시 호출된다.</li>
<li><strong>dispose()</strong>: 위젯이 더 이상 필요하지 않게 되었을 때 호출된다. 여기에서 리소스 해제를 수행한다.</li>
</ol>
<h4 id="_4">수명 주기 예시 코드</h4>
<p>아래의 코드에서는 각 수명 주기 메서드를 사용한 예시를 보여준다:</p>
<pre><code class="language-dart">class MyStatefulWidget extends StatefulWidget {
  @override
  _MyStatefulWidgetState createState() =&gt; _MyStatefulWidgetState();
}

class _MyStatefulWidgetState extends State&lt;MyStatefulWidget&gt; {
  @override
  void initState() {
    super.initState();
    print('initState called');
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    print('didChangeDependencies called');
  }

  @override
  Widget build(BuildContext context) {
    return Text('Hello, Flutter!');
  }

  @override
  void dispose() {
    print('dispose called');
    super.dispose();
  }
}
</code></pre>
<p>이 코드에서는 <strong>initState</strong>, <strong>didChangeDependencies</strong>, <strong>build</strong>, <strong>dispose</strong> 메서드를 각각 사용하여 수명 주기의 흐름을 확인할 수 있다. 위젯이 생성될 때 <strong>initState</strong>가 호출되고, 위젯의 종속성이 변경될 때 <strong>didChangeDependencies</strong>가 호출된다. 위젯이 화면에 그려질 때 <strong>build</strong>가 호출되며, 위젯이 제거될 때 <strong>dispose</strong>가 호출된다.</p>
<h3 id="_5">위젯 조합과 레이아웃</h3>
<p>Flutter의 위젯 시스템은 레이아웃을 만드는 데 유연하게 활용될 수 있다. Flutter에서 <strong>레이아웃</strong>을 구성하는 위젯은 부모 위젯의 크기와 자식 위젯의 크기를 결정한다. 위젯 조합을 통해 복잡한 UI를 설계할 수 있으며, 이를 효율적으로 처리하기 위한 다양한 레이아웃 위젯들이 제공된다.</p>
<h4 id="_6">대표적인 레이아웃 위젯</h4>
<ol>
<li><strong>Column</strong>: 자식 위젯들을 세로로 정렬한다.</li>
<li><strong>Row</strong>: 자식 위젯들을 가로로 정렬한다.</li>
<li><strong>Stack</strong>: 자식 위젯들을 겹쳐서 배치한다.</li>
<li><strong>Container</strong>: 자식 위젯의 크기, 여백, 테두리 등을 제어하는 다용도 위젯이다.</li>
</ol>
<pre><code class="language-dart">Column(
  children: &lt;Widget&gt;[
    Text('First Line'),
    Text('Second Line'),
    ElevatedButton(
      onPressed: () {},
      child: Text('Press me'),
    ),
  ],
);
</code></pre>
<p>위 코드에서는 <strong>Column</strong> 위젯을 사용하여 여러 자식 위젯을 세로로 나열하고 있다. <strong>Text</strong> 위젯과 <strong>ElevatedButton</strong> 위젯이 순서대로 정렬된다.</p>
<h3 id="_7">위젯의 재구성</h3>
<p>Flutter의 <strong>위젯 재구성</strong>(rebuild)은 위젯 트리 내에서 UI가 변경될 때 중요한 과정이다. Stateful 위젯은 상태가 변경되면 <strong>setState()</strong>가 호출되고, 그에 따라 위젯의 일부가 재구성된다. 그러나 Stateless 위젯은 상태를 가지지 않으므로, 외부 입력이나 부모 위젯의 변화에 의해서만 재구성된다.</p>
<p>Flutter는 성능을 위해 효율적인 재구성 전략을 가지고 있다. 변경된 부분만 다시 렌더링하며, 나머지 부분은 그대로 유지된다. 이 방식은 앱이 복잡해지더라도 성능을 유지하는 데 중요한 역할을 한다.</p>
<h3 id="_8">위젯 트리의 최적화</h3>
<p>Flutter에서 UI의 성능을 유지하려면 위젯 트리를 효율적으로 관리하는 것이 매우 중요하다. 위젯 트리가 너무 자주 재구성되거나, 불필요한 부분까지 재구성되는 경우 성능 저하가 발생할 수 있다. 이를 방지하기 위한 몇 가지 최적화 기법을 사용할 수 있다.</p>
<h4 id="const">const 키워드</h4>
<p><strong>const</strong> 키워드는 위젯을 상수로 정의하여 해당 위젯이 재구성되지 않도록 하는 역할을 한다. 만약 위젯이 한 번 생성된 이후 변경되지 않는다면 <strong>const</strong> 키워드를 사용하여 불필요한 재구성을 방지할 수 있다. 다음은 <strong>const</strong> 키워드를 사용한 예시이다:</p>
<pre><code class="language-dart">const Text('This is a constant text widget');
</code></pre>
<p>위 코드에서는 <strong>Text</strong> 위젯이 상수로 정의되었기 때문에 Flutter는 이 위젯을 다시 렌더링하지 않고, 성능 최적화를 이루게 된다.</p>
<h4 id="key">Key의 사용</h4>
<p>Flutter는 <strong>Key</strong>를 사용하여 위젯을 고유하게 식별할 수 있다. 위젯 트리 내에서 동일한 타입의 위젯이 여러 개 사용되는 경우, Flutter는 <strong>Key</strong>를 통해 위젯을 추적하여 올바르게 재구성할 수 있다. 예를 들어, 동적으로 생성된 리스트에서 위젯이 재배치될 때 <strong>Key</strong>를 사용하면 위치가 올바르게 유지된다.</p>
<pre><code class="language-dart">ListView(
  children: [
    Container(key: Key('item1'), child: Text('Item 1')),
    Container(key: Key('item2'), child: Text('Item 2')),
    Container(key: Key('item3'), child: Text('Item 3')),
  ],
);
</code></pre>
<p>이와 같이 <strong>Key</strong>를 명시적으로 설정하면, Flutter는 트리 구조 내에서 각 위젯의 위치를 명확하게 인식하여 성능을 최적화한다.</p>
<h3 id="buildcontext-inheritedwidget">BuildContext와 InheritedWidget</h3>
<p><strong>BuildContext</strong>는 Flutter의 위젯 트리에서 각 위젯의 위치를 나타내는 중요한 객체이다. 이를 통해 부모 위젯과의 관계를 파악하고, 하위 위젯에 데이터를 전달하거나 상호작용할 수 있다.</p>
<h4 id="buildcontext">BuildContext의 역할</h4>
<p><strong>BuildContext</strong>는 위젯 트리의 구조를 관리하는 중요한 객체이다. 각 위젯은 <strong>BuildContext</strong>를 통해 자신의 부모, 자식 위젯과 소통하며, <strong>Navigator</strong>, <strong>Theme</strong>, <strong>MediaQuery</strong> 등 Flutter의 전역적인 객체에도 접근할 수 있다.</p>
<pre><code class="language-dart">@override
Widget build(BuildContext context) {
  return Text(
    'Screen width: ${MediaQuery.of(context).size.width}',
  );
}
</code></pre>
<p>위 코드에서는 <strong>MediaQuery</strong>를 통해 화면의 가로 크기를 가져오고 있으며, 이를 <strong>BuildContext</strong>를 통해 접근하고 있다.</p>
<h4 id="inheritedwidget">InheritedWidget</h4>
<p><strong>InheritedWidget</strong>은 데이터를 하위 위젯에 효율적으로 전달하는 역할을 한다. Flutter는 <strong>InheritedWidget</strong>을 통해 상위 위젯에서 하위 위젯으로 데이터를 전파하고, 필요한 경우 위젯 트리에서 특정 위젯만을 재구성한다. 이 방식은 특히 상태 관리 라이브러리인 <strong>Provider</strong>에서 많이 사용된다.</p>
<pre><code class="language-dart">class MyInheritedWidget extends InheritedWidget {
  final int counter;

  MyInheritedWidget({required this.counter, required Widget child}) : super(child: child);

  @override
  bool updateShouldNotify(MyInheritedWidget oldWidget) {
    return oldWidget.counter != counter;
  }

  static MyInheritedWidget? of(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType&lt;MyInheritedWidget&gt;();
  }
}
</code></pre>
<p>이 코드에서 <strong>MyInheritedWidget</strong>은 상위 위젯의 <strong>counter</strong> 값을 하위 위젯들에 전달하며, <strong>updateShouldNotify</strong> 메서드를 통해 변경된 경우에만 하위 위젯을 다시 렌더링한다.</p>
<h3 id="_9">위젯의 상태 관리</h3>
<p>Flutter 애플리케이션에서 상태 관리는 매우 중요한 주제이다. 복잡한 애플리케이션일수록 많은 데이터와 사용자 상호작용을 관리해야 하며, 이러한 데이터를 효율적으로 처리하는 방법이 필요하다. Flutter는 다양한 상태 관리 방식을 지원한다.</p>
<h4 id="setstate">setState()를 이용한 상태 관리</h4>
<p>가장 기본적인 상태 관리 방법은 Stateful 위젯 내에서 <strong>setState()</strong>를 사용하는 것이다. <strong>setState()</strong>는 상태가 변경될 때 호출되며, Flutter는 이에 맞추어 UI를 다시 렌더링한다.</p>
<pre><code class="language-dart">class CounterWidget extends StatefulWidget {
  @override
  _CounterWidgetState createState() =&gt; _CounterWidgetState();
}

class _CounterWidgetState extends State&lt;CounterWidget&gt; {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Counter: $_counter'),
        ElevatedButton(
          onPressed: _incrementCounter,
          child: Text('Increment'),
        ),
      ],
    );
  }
}
</code></pre>
<h3 id="provider">상태 관리: Provider 패턴</h3>
<p><strong>Provider</strong>는 Flutter에서 권장하는 상태 관리 방식 중 하나이다. <strong>Provider</strong> 패턴은 <strong>InheritedWidget</strong>을 기반으로 하여, 애플리케이션의 상태를 효율적으로 관리하고 하위 위젯에 데이터를 전달할 수 있다. <strong>Provider</strong>를 사용하면 애플리케이션의 상태를 전역에서 공유하거나, 특정 트리 구조에서만 상태를 공유할 수 있다.</p>
<h4 id="provider_1">Provider 사용 예시</h4>
<ol>
<li><strong>ChangeNotifier</strong>를 사용하여 상태를 관리할 수 있다. <strong>ChangeNotifier</strong>는 상태가 변경될 때 리스너에게 알리는 기능을 제공한다.</li>
</ol>
<pre><code class="language-dart">class Counter with ChangeNotifier {
  int _count = 0;

  int get count =&gt; _count;

  void increment() {
    _count++;
    notifyListeners();  // 상태가 변경되었음을 알림
  }
}
</code></pre>
<ol>
<li><strong>Provider</strong>를 사용하여 <strong>ChangeNotifier</strong>를 하위 위젯에 제공할 수 있다.</li>
</ol>
<pre><code class="language-dart">void main() {
  runApp(
    ChangeNotifierProvider(
      create: (context) =&gt; Counter(),
      child: MyApp(),
    ),
  );
}
</code></pre>
<ol>
<li><strong>Consumer</strong> 위젯을 사용하여 <strong>Provider</strong>에서 제공하는 데이터를 화면에 출력할 수 있다.</li>
</ol>
<pre><code class="language-dart">class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Provider Example')),
      body: Center(
        child: Consumer&lt;Counter&gt;(
          builder: (context, counter, child) {
            return Text('Counter: ${counter.count}');
          },
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () =&gt; context.read&lt;Counter&gt;().increment(),
        child: Icon(Icons.add),
      ),
    );
  }
}
</code></pre>
<p>이 예시에서 <strong>ChangeNotifierProvider</strong>를 통해 <strong>Counter</strong> 객체를 위젯 트리 전체에 제공하고 있으며, <strong>Consumer</strong> 위젯을 사용하여 <strong>Counter</strong>의 상태를 읽고 UI에 반영한다.</p>
<h3 id="bloc">BLoC 패턴</h3>
<p><strong>BLoC</strong>(Business Logic Component)는 Flutter에서 비즈니스 로직과 UI를 분리하는 패턴 중 하나이다. BLoC 패턴은 <strong>Stream</strong>을 사용하여 비동기적으로 상태를 관리하며, UI와 상태 로직을 명확하게 구분할 수 있게 해준다. 이 패턴은 특히 복잡한 애플리케이션에서 자주 사용된다.</p>
<h4 id="bloc_1">BLoC 패턴의 구성</h4>
<ol>
<li><strong>BLoC 클래스</strong>: 비즈니스 로직을 처리하고 <strong>Stream</strong>을 통해 데이터를 제공하는 클래스이다.</li>
<li><strong>StreamController</strong>: <strong>Stream</strong>을 생성하고 데이터를 입력하는 컨트롤러이다.</li>
<li><strong>StreamBuilder</strong>: <strong>Stream</strong>에서 전달된 데이터를 기반으로 UI를 업데이트하는 Flutter 위젯이다.</li>
</ol>
<h4 id="bloc_2">BLoC 패턴 예시</h4>
<pre><code class="language-dart">class CounterBloc {
  int _counter = 0;

  final _counterController = StreamController&lt;int&gt;();

  Stream&lt;int&gt; get counterStream =&gt; _counterController.stream;

  void increment() {
    _counter++;
    _counterController.sink.add(_counter);
  }

  void dispose() {
    _counterController.close();
  }
}
</code></pre>
<p><strong>CounterBloc</strong> 클래스는 내부적으로 <strong>StreamController</strong>를 사용하여 상태를 관리하며, <strong>increment</strong> 메서드를 통해 카운터를 증가시키고 <strong>Stream</strong>에 새로운 값을 제공한다.</p>
<p>UI에서는 <strong>StreamBuilder</strong>를 사용하여 <strong>Stream</strong>의 데이터를 받아 화면을 업데이트한다.</p>
<pre><code class="language-dart">class MyHomePage extends StatelessWidget {
  final CounterBloc _bloc = CounterBloc();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('BLoC Example')),
      body: Center(
        child: StreamBuilder&lt;int&gt;(
          stream: _bloc.counterStream,
          builder: (context, snapshot) {
            if (!snapshot.hasData) {
              return CircularProgressIndicator();
            }
            return Text('Counter: ${snapshot.data}');
          },
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _bloc.increment,
        child: Icon(Icons.add),
      ),
    );
  }

  @override
  void dispose() {
    _bloc.dispose();
    super.dispose();
  }
}
</code></pre>
<p>이 예시에서 <strong>StreamBuilder</strong>는 <strong>CounterBloc</strong>에서 제공하는 <strong>Stream</strong>을 구독하여, 새로운 데이터가 전송될 때마다 UI를 업데이트한다. <strong>BLoC</strong> 패턴을 사용하면 비즈니스 로직을 보다 명확하게 분리할 수 있으며, 재사용 가능한 코드를 작성하는 데 도움이 된다.</p>
<h3 id="riverpod">Riverpod 패턴</h3>
<p><strong>Riverpod</strong>는 Flutter에서 최근에 각광받고 있는 상태 관리 패턴이다. <strong>Provider</strong> 패턴을 발전시킨 형태로, 더 나은 성능과 오류 처리 기능을 제공한다. <strong>Riverpod</strong>의 특징은 상태를 전역으로 관리할 수 있고, 종속성 주입을 통한 테스트 및 유지보수성 향상이다.</p>
<h4 id="riverpod_1">Riverpod의 구성</h4>
<ol>
<li><strong>Provider</strong>: 상태나 객체를 제공하는 기본 단위이다.</li>
<li><strong>ConsumerWidget</strong>: <strong>Provider</strong>에서 제공하는 상태를 읽고 UI를 업데이트하는 위젯이다.</li>
<li><strong>ProviderContainer</strong>: 테스트 환경에서 <strong>Provider</strong>를 주입하는 역할을 한다.</li>
</ol>
<h4 id="riverpod_2">Riverpod 예시</h4>
<pre><code class="language-dart">final counterProvider = StateProvider((ref) =&gt; 0);

class MyHomePage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final counter = ref.watch(counterProvider);
    return Scaffold(
      appBar: AppBar(title: Text('Riverpod Example')),
      body: Center(
        child: Text('Counter: $counter'),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          ref.read(counterProvider.state).state++;
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
</code></pre>
<p>이 예시에서 <strong>StateProvider</strong>는 상태를 제공하고, <strong>ConsumerWidget</strong>은 상태를 구독하여 UI를 업데이트한다. <strong>Riverpod</strong>는 <strong>Provider</strong> 패턴과 달리, 더 안전하고 예측 가능한 상태 관리 방식을 제공한다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../../chapter_17/1701/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../../chapter_17/1701/">
        Dart 코드 최적화 기법
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../1602/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../1602/">
        모바일 UI 구성
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>