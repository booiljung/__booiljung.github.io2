<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/programming/dart/chapter_16/1601/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Flutter와의 연계 - 소프트웨어 융합</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Flutter \uac1c\uc694", url: "#_top", children: [
          ]},
          {title: "Flutter\uc640 Dart\uc758 \ud1b5\ud569", url: "#flutter-dart", children: [
              {title: "Stateful \uc704\uc82f\uacfc Stateless \uc704\uc82f", url: "#stateful-stateless" },
          ]},
          {title: "Hot Reload \uae30\ub2a5", url: "#hot-reload", children: [
          ]},
          {title: "Flutter\uc5d0\uc11c\uc758 \ub808\uc774\uc544\uc6c3 \uc2dc\uc2a4\ud15c", url: "#flutter_1", children: [
          ]},
          {title: "\uc560\ub2c8\uba54\uc774\uc158 \ucc98\ub9ac", url: "#_1", children: [
          ]},
          {title: "Dart\uc758 Null Safety\uc640 Flutter", url: "#dart-null-safety-flutter", children: [
          ]},
          {title: "Flutter\uc758 \ube4c\ub4dc \ud504\ub85c\uc138\uc2a4", url: "#flutter_2", children: [
          ]},
          {title: "\ud50c\ub7ec\uadf8\uc778 \ubc0f \ud328\ud0a4\uc9c0 \uc0ac\uc6a9", url: "#_2", children: [
          ]},
          {title: "Flutter\uc640 \uc0c1\ud0dc \uad00\ub9ac", url: "#flutter_3", children: [
              {title: "setState\ub97c \uc774\uc6a9\ud55c \uc0c1\ud0dc \uad00\ub9ac", url: "#setstate" },
              {title: "InheritedWidget\uc744 \uc774\uc6a9\ud55c \uc0c1\ud0dc \uad00\ub9ac", url: "#inheritedwidget" },
              {title: "Provider \ud328\ud0a4\uc9c0\ub97c \uc774\uc6a9\ud55c \uc0c1\ud0dc \uad00\ub9ac", url: "#provider" },
          ]},
          {title: "\ub124\uc774\ud2f0\ube0c \uae30\ub2a5\uacfc\uc758 \uc5f0\ub3d9", url: "#_3", children: [
              {title: "Flutter\uc5d0\uc11c \ub124\uc774\ud2f0\ube0c \ucf54\ub4dc \ud638\ucd9c", url: "#flutter_4" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1602/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1602/" class="btn btn-xs btn-link">
        모바일 UI 구성
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_15/1503/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_15/1503/" class="btn btn-xs btn-link">
        서버와의 데이터 통신
      </a>
    </div>
    
  </div>

    

    <p>Flutter는 Dart 언어의 가장 중요한 모바일 프레임워크로, 크로스 플랫폼 모바일 개발을 가능하게 한다. 이 절에서는 Flutter와 Dart의 연계를 중심으로 다양한 측면에서 접근하여 설명하겠다.</p>
<h3 id="flutter">Flutter 개요</h3>
<p>Flutter는 Google에서 개발한 오픈 소스 UI 소프트웨어 개발 키트(SDK)이다. 하나의 코드베이스로 Android와 iOS 등 다양한 플랫폼에서 동일한 성능과 사용자 경험을 제공하는 앱을 개발할 수 있다. Flutter의 기반 언어는 Dart로, Dart의 강력한 기능을 활용하여 모바일 UI 개발을 효율적으로 할 수 있다.</p>
<h3 id="flutter-dart">Flutter와 Dart의 통합</h3>
<p>Dart는 Flutter 프레임워크의 주 언어로 사용된다. Dart의 고유한 기능 덕분에 Flutter는 빠른 렌더링 속도와 높은 성능을 자랑하며, 개발자는 명확한 코드 구조와 유연한 디자인을 구축할 수 있다.</p>
<h4 id="stateful-stateless">Stateful 위젯과 Stateless 위젯</h4>
<p>Flutter는 UI를 구성하는 요소를 위젯으로 처리한다. 위젯은 크게 두 가지로 나뉜다:</p>
<ol>
<li><strong>Stateless 위젯</strong>: 상태가 없는 위젯으로, UI의 변동 사항 없이 단순히 데이터를 표시하는 역할을 한다.</li>
<li><strong>Stateful 위젯</strong>: 상태를 가지며, 사용자의 입력이나 데이터 변화에 따라 UI가 동적으로 변하는 위젯이다.</li>
</ol>
<p>다음은 두 위젯의 기본적인 차이를 설명하는 코드 예제이다:</p>
<pre><code class="language-dart">class MyStatelessWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Text('This is a stateless widget');
  }
}

class MyStatefulWidget extends StatefulWidget {
  @override
  _MyStatefulWidgetState createState() =&gt; _MyStatefulWidgetState();
}

class _MyStatefulWidgetState extends State&lt;MyStatefulWidget&gt; {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Counter: $_counter'),
        ElevatedButton(
          onPressed: _incrementCounter,
          child: Text('Increment'),
        ),
      ],
    );
  }
}
</code></pre>
<h3 id="hot-reload">Hot Reload 기능</h3>
<p>Dart와 Flutter의 연계에서 가장 주목할 기능 중 하나가 <strong>Hot Reload</strong>이다. 이 기능은 코드 변경 후 앱을 다시 컴파일하지 않고도 UI 변경 사항을 즉시 반영할 수 있어 개발 시간을 크게 단축시킨다. Flutter의 기본 아키텍처와 Dart의 컴파일러가 이 기능을 지원하며, 이를 통해 모바일 UI 개발 과정에서 반복적인 테스트와 수정 작업이 빠르고 효과적으로 이루어진다.</p>
<h3 id="flutter_1">Flutter에서의 레이아웃 시스템</h3>
<p>Flutter의 레이아웃 시스템은 Dart에서 제공하는 <strong>Flexbox</strong>와 유사한 방식으로 작동한다. Flutter에서는 다양한 레이아웃 위젯을 통해 UI 요소를 배치할 수 있다. 가장 많이 사용하는 레이아웃 위젯은 <strong>Row</strong>, <strong>Column</strong>, 그리고 <strong>Container</strong>이다. 각 위젯은 부모 위젯의 크기와 자식 위젯들의 크기 제약을 반영하여 크기를 결정하며, Dart의 강력한 타입 시스템 덕분에 이러한 배치 과정이 효율적으로 이루어진다.</p>
<p>다음은 Column을 사용하는 예제 코드이다:</p>
<pre><code class="language-dart">Column(
  children: &lt;Widget&gt;[
    Text('First item'),
    Text('Second item'),
    Text('Third item'),
  ],
)
</code></pre>
<h3 id="_1">애니메이션 처리</h3>
<p>Flutter는 <strong>AnimationController</strong>와 <strong>Tween</strong> 클래스를 이용한 애니메이션 기능을 제공한다. 애니메이션 처리에 있어 중요한 개념은 <strong>애니메이션 상태</strong>이다. Dart의 비동기 처리 기능과 결합하여 애니메이션의 시작, 중지, 리셋 등의 상태를 관리할 수 있다. </p>
<p>애니메이션에서 사용되는 주요 클래스는 아래와 같다:</p>
<ul>
<li><strong>AnimationController</strong>: 애니메이션을 제어하는 클래스.</li>
<li><strong>Tween</strong>: 두 값 사이를 보간하는 애니메이션을 제공.</li>
</ul>
<p>아래는 간단한 애니메이션 예제 코드이다:</p>
<pre><code class="language-dart">class AnimatedBox extends StatefulWidget {
  @override
  _AnimatedBoxState createState() =&gt; _AnimatedBoxState();
}

class _AnimatedBoxState extends State&lt;AnimatedBox&gt; with SingleTickerProviderStateMixin {
  AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(seconds: 1),
      vsync: this,
    )..repeat(reverse: true);
  }

  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _controller,
      child: Container(
        width: 200,
        height: 200,
        color: Colors.blue,
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}
</code></pre>
<h3 id="dart-null-safety-flutter">Dart의 Null Safety와 Flutter</h3>
<p>Dart의 <strong>null safety</strong>는 Flutter 개발에 있어 매우 중요한 기능이다. Null safety는 변수에 null이 할당되는 것을 방지하며, 컴파일 시점에서 null 관련 오류를 검출하여 런타임 오류를 줄여준다. 이로 인해 개발자는 코드의 안정성을 더욱 높일 수 있다.</p>
<pre><code class="language-dart">String? name;
name = 'Dart';  // null safe
</code></pre>
<p>Dart의 null safety는 Flutter에서 발생할 수 있는 잠재적 오류를 줄이고, 코드의 가독성과 유지보수성을 크게 향상시킨다.</p>
<h3 id="flutter_2">Flutter의 빌드 프로세스</h3>
<p>Flutter는 Dart 코드를 <strong>Ahead-of-Time (AOT)</strong> 컴파일하여 앱을 빌드한다. 이를 통해 Flutter 앱은 네이티브 성능을 유지하면서도 Dart의 동적 성격을 이용할 수 있다. Flutter는 다음과 같은 빌드 단계를 따른다:</p>
<ol>
<li><strong>Widget Tree 생성</strong>: Flutter는 Dart 코드를 바탕으로 위젯 트리를 생성한다.</li>
<li><strong>레이아웃 및 렌더링</strong>: 생성된 위젯 트리는 레이아웃 단계에서 배치되고, 렌더링 단계에서 화면에 표시된다.</li>
<li><strong>애니메이션 및 이벤트 처리</strong>: 위젯 트리는 사용자 입력이나 애니메이션에 따라 동적으로 갱신된다.</li>
</ol>
<p>이와 같은 빌드 프로세스를 통해 Flutter는 즉각적인 UI 반응성과 높은 성능을 제공할 수 있다.</p>
<h3 id="_2">플러그인 및 패키지 사용</h3>
<p>Flutter와 Dart의 연계에서 중요한 요소는 <strong>패키지</strong>와 <strong>플러그인</strong>이다. Dart의 패키지 관리 시스템인 <strong>pub.dev</strong>를 통해 다양한 플러그인과 라이브러리를 사용할 수 있으며, 이를 통해 네이티브 기능을 쉽게 호출하거나 추가 기능을 확장할 수 있다.</p>
<p>예를 들어, 카메라 기능을 호출하는 Flutter 패키지를 사용하는 방법은 다음과 같다:</p>
<pre><code class="language-dart">import 'package:camera/camera.dart';

Future&lt;void&gt; main() async {
  final cameras = await availableCameras();
  final firstCamera = cameras.first;
}
</code></pre>
<h3 id="flutter_3">Flutter와 상태 관리</h3>
<p>Flutter는 <strong>상태 관리(state management)</strong>가 중요한 프레임워크다. 앱의 상태는 사용자 인터페이스(UI)가 사용자와의 상호작용에 반응하는 방식을 결정하며, Flutter에서는 다양한 방식으로 상태를 관리할 수 있다. 대표적인 방법은 <strong>setState</strong> 함수, <strong>InheritedWidget</strong>, 그리고 <strong>Provider</strong> 같은 패키지들이다.</p>
<h4 id="setstate">setState를 이용한 상태 관리</h4>
<p><strong>setState</strong>는 가장 간단한 상태 관리 방법이다. <strong>StatefulWidget</strong>에서 사용되는 이 방법은 내부 상태가 변경될 때마다 UI를 갱신하는 역할을 한다.</p>
<p>다음은 <strong>setState</strong>를 사용하는 간단한 상태 관리 예제다:</p>
<pre><code class="language-dart">class CounterApp extends StatefulWidget {
  @override
  _CounterAppState createState() =&gt; _CounterAppState();
}

class _CounterAppState extends State&lt;CounterApp&gt; {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Counter: $_counter'),
        ElevatedButton(
          onPressed: _incrementCounter,
          child: Text('Increment'),
        ),
      ],
    );
  }
}
</code></pre>
<h4 id="inheritedwidget">InheritedWidget을 이용한 상태 관리</h4>
<p><strong>InheritedWidget</strong>은 상태를 위젯 트리에서 하위 위젯에 전달하는 고급 상태 관리 기법이다. 이 방법은 부모 위젯에서 하위 자식 위젯에게 상태를 효율적으로 전달할 수 있게 해준다.</p>
<p><strong>InheritedWidget</strong>을 사용하는 방식은 아래와 같다:</p>
<pre><code class="language-dart">class MyInheritedWidget extends InheritedWidget {
  final int counter;

  MyInheritedWidget({
    required this.counter,
    required Widget child,
  }) : super(child: child);

  @override
  bool updateShouldNotify(MyInheritedWidget oldWidget) {
    return oldWidget.counter != counter;
  }

  static MyInheritedWidget? of(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType&lt;MyInheritedWidget&gt;();
  }
}
</code></pre>
<h4 id="provider">Provider 패키지를 이용한 상태 관리</h4>
<p><strong>Provider</strong>는 Flutter에서 많이 사용되는 상태 관리 패키지다. <strong>Provider</strong> 패턴을 사용하면 전역 상태를 쉽게 관리할 수 있고, <strong>InheritedWidget</strong>의 복잡성을 줄일 수 있다.</p>
<p>Provider를 사용하는 예제는 다음과 같다:</p>
<pre><code class="language-dart">import 'package:provider/provider.dart';

class CounterModel with ChangeNotifier {
  int _counter = 0;

  int get counter =&gt; _counter;

  void increment() {
    _counter++;
    notifyListeners();
  }
}

void main() {
  runApp(
    ChangeNotifierProvider(
      create: (context) =&gt; CounterModel(),
      child: MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          Text('Counter: ${context.watch&lt;CounterModel&gt;().counter}'),
          ElevatedButton(
            onPressed: () =&gt; context.read&lt;CounterModel&gt;().increment(),
            child: Text('Increment'),
          ),
        ],
      ),
    );
  }
}
</code></pre>
<h3 id="_3">네이티브 기능과의 연동</h3>
<p>Flutter와 Dart의 연계 중에서도 <strong>네이티브 기능 호출</strong>은 매우 중요한 부분이다. Flutter는 안드로이드와 iOS 같은 네이티브 플랫폼의 API를 호출할 수 있도록 다양한 플러그인과 도구를 제공한다.</p>
<h4 id="flutter_4">Flutter에서 네이티브 코드 호출</h4>
<p>Flutter는 <strong>Platform Channels</strong>라는 메커니즘을 통해 네이티브 코드(Java, Kotlin, Swift, Objective-C 등)를 호출할 수 있다. 이 과정에서 Dart 코드는 네이티브 플랫폼에 메시지를 전달하고, 네이티브 코드는 Dart로 메시지를 반환하는 방식으로 통신이 이루어진다.</p>
<p>Platform Channels의 기본 구조는 다음과 같다:</p>
<ul>
<li><strong>MethodChannel</strong>: Dart와 네이티브 코드 간의 함수 호출을 가능하게 하는 채널.</li>
<li><strong>EventChannel</strong>: Dart에서 네이티브 코드의 이벤트 스트림을 수신할 수 있게 하는 채널.</li>
<li><strong>BasicMessageChannel</strong>: 단순 메시지를 주고받는 채널.</li>
</ul>
<p>다음은 MethodChannel을 이용해 네이티브 플랫폼에서 데이터를 가져오는 코드이다:</p>
<pre><code class="language-dart">import 'package:flutter/services.dart';

class BatteryLevel {
  static const platform = MethodChannel('com.example.battery');

  Future&lt;int&gt; getBatteryLevel() async {
    try {
      final int batteryLevel = await platform.invokeMethod('getBatteryLevel');
      return batteryLevel;
    } on PlatformException catch (e) {
      return -1;
    }
  }
}
</code></pre>
<p>이 Dart 코드에서 <code>getBatteryLevel</code> 메소드는 네이티브 플랫폼에서 배터리 정보를 가져오는 역할을 한다. Android의 네이티브 코드는 Kotlin으로 작성된 다음과 같은 형태가 될 수 있다:</p>
<pre><code class="language-kotlin">class MainActivity : FlutterActivity() {
  private val CHANNEL = &quot;com.example.battery&quot;

  override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
    super.configureFlutterEngine(flutterEngine)
    MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result -&gt;
      if (call.method == &quot;getBatteryLevel&quot;) {
        val batteryLevel = getBatteryLevel()

        if (batteryLevel != -1) {
          result.success(batteryLevel)
        } else {
          result.error(&quot;UNAVAILABLE&quot;, &quot;Battery level not available.&quot;, null)
        }
      } else {
        result.notImplemented()
      }
    }
  }

  private fun getBatteryLevel(): Int {
    val batteryManager = getSystemService(BATTERY_SERVICE) as BatteryManager
    return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
  }
}
</code></pre>
<p>이와 같은 방식으로 Flutter와 네이티브 플랫폼 간의 데이터 교환이 가능하다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1602/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1602/" class="btn btn-xs btn-link">
        모바일 UI 구성
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_15/1503/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_15/1503/" class="btn btn-xs btn-link">
        서버와의 데이터 통신
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>