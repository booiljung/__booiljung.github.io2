<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/programming/dart/chapter_07/0702/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>제너릭 메소드 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc758 \uae30\ubcf8 \uad6c\uc870", url: "#_top", children: [
          ]},
          {title: "\ud0c0\uc785 \ub9e4\uac1c\ubcc0\uc218 \uc81c\ud55c", url: "#_2", children: [
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc5d0\uc11c \ud0c0\uc785 \ucd94\ub860", url: "#_3", children: [
          ]},
          {title: "\uc5ec\ub7ec \ud0c0\uc785 \ub9e4\uac1c\ubcc0\uc218\ub97c \uc0ac\uc6a9\ud558\ub294 \uc81c\ub108\ub9ad \uba54\uc18c\ub4dc", url: "#_4", children: [
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc640 \uceec\ub809\uc158", url: "#_5", children: [
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc758 \uc7a5\uc810", url: "#_6", children: [
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc640 \ud0c0\uc785 \uc548\uc804\uc131", url: "#_7", children: [
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc640 \ud0c0\uc785 \uc81c\ud55c\uc758 \uc218\ud559\uc801 \ud574\uc11d", url: "#_8", children: [
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc640 \ub2e4\ud615\uc131", url: "#_9", children: [
              {title: "\ub2e4\ud615\uc131 \uc608\uc81c", url: "#_10" },
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc758 \uc131\ub2a5 \uace0\ub824\uc0ac\ud56d", url: "#_11", children: [
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc640 \ud615 \ubcc0\ud658", url: "#_12", children: [
              {title: "\uba85\uc2dc\uc801 \ud0c0\uc785 \uce90\uc2a4\ud305\uc758 \uc608\uc2dc", url: "#_13" },
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc758 \uc2e4\uc804 \ud65c\uc6a9", url: "#_14", children: [
              {title: "JSON \ub370\uc774\ud130\ub97c \ucc98\ub9ac\ud558\ub294 \uc81c\ub108\ub9ad \uba54\uc18c\ub4dc \uc608\uc2dc", url: "#json" },
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc758 \ud55c\uacc4\uc640 \uc81c\uc57d \uc0ac\ud56d", url: "#_15", children: [
              {title: "1. \ub7f0\ud0c0\uc784\uc5d0 \ud0c0\uc785 \uc815\ubcf4 \uc190\uc2e4 (Type Erasure)", url: "#1-type-erasure" },
              {title: "2. \uc81c\ub108\ub9ad \ud0c0\uc785\uc5d0 \ub300\ud55c new \uc5f0\uc0b0\uc790 \uc0ac\uc6a9 \uc81c\ud55c", url: "#2-new" },
              {title: "3. static \uba54\uc18c\ub4dc\uc640 \uc81c\ub108\ub9ad \ud0c0\uc785", url: "#3-static" },
          ]},
          {title: "\uc81c\ub108\ub9ad \uba54\uc18c\ub4dc\uc640 \ud568\uc218\ud615 \ud504\ub85c\uadf8\ub798\ubc0d", url: "#_16", children: [
              {title: "\ube44\ub3d9\uae30 \ub370\uc774\ud130 \ucc98\ub9ac\ub97c \uc704\ud55c \uc81c\ub108\ub9ad \uba54\uc18c\ub4dc", url: "#_17" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0703/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0703/" class="btn btn-xs btn-link">
        제너릭 타입 제한
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0701/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0701/" class="btn btn-xs btn-link">
        제너릭 클래스
      </a>
    </div>
    
  </div>

    

    <p>Dart에서 제너릭 프로그래밍은 코드의 재사용성을 높이고 다양한 데이터 타입에 대해 유연하게 동작할 수 있는 방법을 제공한다. 제너릭 메소드는 메소드 자체가 다양한 타입을 처리할 수 있도록 만들어지며, 구체적인 타입을 메소드가 호출될 때 결정할 수 있다. 이로 인해 불필요한 코드 중복을 피할 수 있고, 타입 안전성을 유지할 수 있다. </p>
<h3 id="_1">제너릭 메소드의 기본 구조</h3>
<p>제너릭 메소드의 선언은 메소드 이름 앞에 타입 매개변수를 추가하여 이루어진다. 예를 들어, <code>T</code>라는 타입 매개변수를 사용하는 제너릭 메소드는 아래와 같은 형태를 갖는다.</p>
<pre><code class="language-dart">T exampleMethod&lt;T&gt;(T value) {
  return value;
}
</code></pre>
<p>여기서 <code>T</code>는 메소드가 호출될 때 특정 타입으로 치환되며, 반환 타입과 매개변수 타입이 모두 <code>T</code>로 지정되어 다양한 타입을 처리할 수 있다.</p>
<h3 id="_2">타입 매개변수 제한</h3>
<p>제너릭 메소드를 작성할 때, 타입 매개변수에 제한을 두는 것이 가능한다. 이렇게 하면 제너릭 메소드가 특정 클래스나 인터페이스를 상속받는 타입만 허용하도록 할 수 있다. 타입 제한을 추가하기 위해서는 <code>extends</code> 키워드를 사용한다.</p>
<p>예를 들어, <code>Comparable</code>을 상속받는 타입으로만 제한된 제너릭 메소드는 아래와 같이 선언할 수 있다.</p>
<pre><code class="language-dart">T exampleMethod&lt;T extends Comparable&gt;(T value) {
  // T는 Comparable을 상속받는 타입이어야 한다.
  return value;
}
</code></pre>
<p>이와 같이 제한을 추가함으로써 제너릭 메소드에서 사용할 수 있는 타입을 보다 구체적으로 제어할 수 있다.</p>
<h3 id="_3">제너릭 메소드에서 타입 추론</h3>
<p>Dart는 메소드 호출 시에 전달된 인수의 타입을 바탕으로 타입 매개변수를 추론할 수 있다. 즉, 호출할 때 명시적으로 타입을 지정하지 않아도, 전달된 인수의 타입에 따라 적절한 타입이 자동으로 결정된다. 예를 들어, 아래 코드를 보면:</p>
<pre><code class="language-dart">T returnFirst&lt;T&gt;(T first, T second) {
  return first;
}

void main() {
  var result = returnFirst(10, 20); // Dart가 int 타입으로 추론한다.
  print(result);
}
</code></pre>
<p>이 코드는 <code>returnFirst</code> 메소드를 호출할 때 두 인수가 <code>int</code> 타입이므로 <code>T</code>가 <code>int</code>로 추론되어 메소드가 작동하게 된다.</p>
<h3 id="_4">여러 타입 매개변수를 사용하는 제너릭 메소드</h3>
<p>제너릭 메소드는 단일 타입 매개변수만을 사용할 필요는 없다. 다수의 타입 매개변수를 사용하여 더 복잡한 제너릭 메소드를 만들 수 있다. 아래 예시는 두 개의 타입 매개변수를 사용하는 제너릭 메소드이다.</p>
<pre><code class="language-dart">R combine&lt;T, R&gt;(T value1, R value2) {
  print('$value1 and$value2');
  return value2;
}
</code></pre>
<p>여기서 <code>combine</code> 메소드는 <code>T</code> 타입의 값과 <code>R</code> 타입의 값을 받아들여, <code>R</code> 타입의 값을 반환한다. 이처럼 여러 타입을 자유롭게 결합하여 사용할 수 있다.</p>
<h3 id="_5">제너릭 메소드와 컬렉션</h3>
<p>제너릭 메소드는 특히 컬렉션을 다룰 때 유용하다. Dart의 <code>List</code>, <code>Set</code>, <code>Map</code>과 같은 컬렉션은 모두 제너릭 클래스로 구현되어 있어, 제너릭 메소드를 사용하여 다양한 데이터 타입의 컬렉션을 처리할 수 있다.</p>
<p>예를 들어, <code>List</code>에 제너릭 메소드를 적용하면, 서로 다른 타입의 리스트에 대해 같은 메소드를 사용할 수 있다.</p>
<pre><code class="language-dart">T getFirstElement&lt;T&gt;(List&lt;T&gt; list) {
  return list[0];
}

void main() {
  var intList = [1, 2, 3];
  var stringList = ['a', 'b', 'c'];

  print(getFirstElement(intList)); // 1
  print(getFirstElement(stringList)); // 'a'
}
</code></pre>
<p>이 메소드는 <code>List&lt;T&gt;</code>를 매개변수로 받아, 리스트의 첫 번째 요소를 반환한다. Dart는 이 메소드에서 <code>T</code>가 <code>List</code>의 요소 타입으로 추론되어, <code>int</code> 리스트와 <code>String</code> 리스트에 대해 모두 사용할 수 있다.</p>
<h3 id="_6">제너릭 메소드의 장점</h3>
<ol>
<li>
<p><strong>코드 재사용성</strong>: 제너릭 메소드는 여러 데이터 타입에 대해 동작하도록 설계되므로, 동일한 로직을 다양한 상황에서 재사용할 수 있다. 예를 들어, 데이터를 처리하는 함수가 여러 타입에 대해 동작해야 한다면, 각각의 타입마다 별도의 함수를 작성할 필요가 없고, 제너릭 메소드를 통해 이를 해결할 수 있다.</p>
</li>
<li>
<p><strong>타입 안전성</strong>: 제너릭 메소드는 타입을 안전하게 다룰 수 있도록 도와준다. 잘못된 타입의 데이터를 처리하는 경우를 방지할 수 있으며, 컴파일 타임에 타입 오류를 감지할 수 있다.</p>
</li>
</ol>
<p>예를 들어, 제너릭 메소드를 사용하지 않는 경우와 비교하면, 제너릭 메소드는 데이터 타입이 잘못 전달되는 상황을 방지한다. 아래는 제너릭 메소드를 사용한 예시이다.</p>
<pre><code class="language-dart">T identity&lt;T&gt;(T value) {
  return value;
}

void main() {
  var number = identity(10); // int로 추론
  var text = identity('Hello'); // String으로 추론
}
</code></pre>
<p>컴파일 타임에 오류를 미리 방지할 수 있으므로, 더 안정적인 코드를 작성할 수 있다.</p>
<h3 id="_7">제너릭 메소드와 타입 안전성</h3>
<p>Dart에서 제너릭 메소드는 다양한 타입에 대해 안전하게 작동하는 방식을 제공한다. 이를 통해 런타임 오류를 줄이고 컴파일 타임에 타입 관련 오류를 미리 잡을 수 있다. 수학적인 예시로 표현하자면, 일반적인 함수가 여러 타입을 처리할 수 있다면 다음과 같은 수식을 고려할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f : \mathbb{T} \to \mathbb{T}
</div>
<script type="math/tex; mode=display">
f : \mathbb{T} \to \mathbb{T}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbb{T}</span><script type="math/tex">\mathbb{T}</script></span>는 타입의 집합을 나타내며, 입력과 출력이 모두 같은 타입의 데이터를 처리할 수 있음을 의미한다.</p>
<h3 id="_8">제너릭 메소드와 타입 제한의 수학적 해석</h3>
<p>제너릭 메소드에서 타입 제한을 사용하면 메소드가 처리할 수 있는 타입을 제한할 수 있다. 이는 수학적으로 특정 집합 <span class="arithmatex"><span class="MathJax_Preview">\mathbb{T}</span><script type="math/tex">\mathbb{T}</script></span>에 속하는 타입들 중에서 특정 부분집합 <span class="arithmatex"><span class="MathJax_Preview">\mathbb{S} \subseteq \mathbb{T}</span><script type="math/tex">\mathbb{S} \subseteq \mathbb{T}</script></span>만을 허용하는 것과 비슷한다. 즉, 타입 제한이 추가된 제너릭 메소드는 함수의 정의역을 좁히는 역할을 한다.</p>
<p>예를 들어, <code>Comparable</code>을 상속하는 타입에 대해서만 제너릭 메소드를 허용한다고 할 때, 이를 수식으로 표현하면 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f : \mathbb{S} \to \mathbb{S}, \quad \text{where} \quad \mathbb{S} \subseteq \mathbb{T}, \quad T \text{ extends Comparable}
</div>
<script type="math/tex; mode=display">
f : \mathbb{S} \to \mathbb{S}, \quad \text{where} \quad \mathbb{S} \subseteq \mathbb{T}, \quad T \text{ extends Comparable}
</script>
</div>
<p>즉, 함수 <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>는 여전히 제너릭 타입 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>에 대해 정의되지만, <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 이제 <span class="arithmatex"><span class="MathJax_Preview">\mathbb{S} \subseteq \mathbb{T}</span><script type="math/tex">\mathbb{S} \subseteq \mathbb{T}</script></span>, 즉 <code>Comparable</code>을 상속하는 타입만을 허용하게 된다.</p>
<p>이렇게 하면 함수가 특정 타입들에 대해서만 동작하도록 제한할 수 있으며, 함수 내에서 그 타입이 제공하는 특성(예: 비교 연산)을 안전하게 사용할 수 있다.</p>
<h3 id="_9">제너릭 메소드와 다형성</h3>
<p>제너릭 메소드는 다형성을 구현하는 중요한 도구 중 하나이다. 다형성(polymorphism)은 동일한 인터페이스를 통해 다양한 타입의 객체를 처리할 수 있게 해주는 개념이다. Dart에서 제너릭 메소드는 타입 매개변수에 따라 다양한 형태로 메소드가 동작하게 해준다.</p>
<p>이와 같은 다형성의 수학적 개념을 생각해보면, 다형성은 일반적인 함수가 여러 다른 타입의 인자를 받아 처리할 수 있는 함수로 표현될 수 있다. 다형성 제너릭 메소드에서의 함수는 다음과 같은 수학적 표현을 따른다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(T) : T \to T
</div>
<script type="math/tex; mode=display">
f(T) : T \to T
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 여러 가능한 타입을 나타내며, 함수 <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>는 그 타입에 맞춰 적응할 수 있다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">f(T)</span><script type="math/tex">f(T)</script></span>가 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>에 맞는 동작을 수행하며, 입력과 출력 모두 같은 타입의 객체가 된다.</p>
<h4 id="_10">다형성 예제</h4>
<pre><code class="language-dart">T findMax&lt;T extends Comparable&gt;(T a, T b) {
  if (a.compareTo(b) &gt; 0) {
    return a;
  } else {
    return b;
  }
}

void main() {
  var maxInt = findMax(3, 5);
  print(maxInt); // 5

  var maxString = findMax('apple', 'banana');
  print(maxString); // 'banana'
}
</code></pre>
<p>이 예제에서 <code>findMax</code> 메소드는 타입 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>에 대해 정의된다. 그러나 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 <code>Comparable</code>을 상속하는 타입으로 제한되므로, 비교 연산이 가능한 타입에 대해서만 이 메소드를 사용할 수 있다. Dart는 타입 추론을 통해 <code>int</code>와 <code>String</code> 타입 모두에 대해 이 메소드를 적용할 수 있다.</p>
<h3 id="_11">제너릭 메소드의 성능 고려사항</h3>
<p>제너릭 메소드는 다양한 타입에 대해 유연성을 제공하지만, 성능 측면에서 주의가 필요하다. Dart는 동적 언어이지만, 제너릭은 컴파일 타임에 타입을 확인하는 정적 언어의 특성을 갖는다. 따라서 Dart에서 제너릭 메소드를 사용할 때는 컴파일 타임에 타입 안전성을 제공받으면서도, 동적 바인딩의 오버헤드를 피할 수 있는 장점이 있다.</p>
<p>다만, 너무 많은 타입 매개변수를 사용하거나 제너릭 메소드를 복잡하게 정의하는 경우, 성능이 저하될 수 있는 상황이 발생할 수 있다. 특히 Dart에서 제너릭 타입이 특정 조건에서 <code>dynamic</code>으로 처리되는 경우, 런타임에 불필요한 타입 체크가 발생하여 성능에 영향을 미칠 수 있다. 이러한 문제를 피하기 위해서는 코드가 예상대로 타입을 잘 추론하는지 확인해야 하며, 필요할 경우 명시적으로 타입을 지정하는 것이 좋다.</p>
<h3 id="_12">제너릭 메소드와 형 변환</h3>
<p>Dart에서는 제너릭 메소드 사용 시 타입 캐스팅(형 변환)에 주의해야 한다. 잘못된 형 변환은 런타임 오류를 발생시킬 수 있으므로, 타입이 올바르게 적용되는지 항상 확인해야 한다. Dart는 일반적으로 타입 추론을 제공하지만, 경우에 따라 명시적 타입 캐스팅이 필요할 수 있다.</p>
<h4 id="_13">명시적 타입 캐스팅의 예시</h4>
<pre><code class="language-dart">T asType&lt;T&gt;(dynamic value) {
  return value as T;
}

void main() {
  var number = asType&lt;int&gt;(10);  // 명시적으로 int 타입을 지정
  var text = asType&lt;String&gt;('Hello');  // 명시적으로 String 타입을 지정

  print(number);  // 10
  print(text);  // Hello
}
</code></pre>
<p>이 예제에서는 동적으로 받은 값을 특정 타입으로 변환하기 위해 <code>as</code> 키워드를 사용하여 명시적으로 타입 캐스팅을 수행한다. 그러나 타입을 잘못 캐스팅할 경우, Dart는 런타임에 오류를 발생시킨다. 따라서 제너릭 메소드에서 형 변환을 수행할 때는 타입 안전성을 신경 써야 한다.</p>
<h3 id="_14">제너릭 메소드의 실전 활용</h3>
<p>제너릭 메소드는 실전에서 다양한 상황에서 활용될 수 있다. 예를 들어, 여러 종류의 데이터를 처리하는 API를 개발하거나, 다양한 타입의 컬렉션을 다루는 라이브러리를 구현할 때 매우 유용하다.</p>
<h4 id="json">JSON 데이터를 처리하는 제너릭 메소드 예시</h4>
<p>Dart에서 JSON 데이터를 처리할 때 제너릭 메소드를 사용할 수 있다. 데이터를 특정 타입으로 변환할 때 제너릭 메소드가 활용된다.</p>
<pre><code class="language-dart">T parseJson&lt;T&gt;(String jsonString, T Function(Map&lt;String, dynamic&gt;) fromJson) {
  final jsonMap = jsonDecode(jsonString);
  return fromJson(jsonMap);
}

void main() {
  var jsonString = '{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30}';

  Person person = parseJson&lt;Person&gt;(jsonString, (json) =&gt; Person.fromJson(json));

  print(person.name);  // Alice
}

class Person {
  String name;
  int age;

  Person(this.name, this.age);

  factory Person.fromJson(Map&lt;String, dynamic&gt; json) {
    return Person(json['name'], json['age']);
  }
}
</code></pre>
<p>이 예제에서 <code>parseJson</code> 제너릭 메소드는 JSON 문자열을 특정 타입으로 변환한다. <code>T</code> 타입 매개변수를 사용하여 다양한 객체로 변환할 수 있으며, <code>fromJson</code> 함수를 통해 변환 로직을 사용자 정의할 수 있다.</p>
<h3 id="_15">제너릭 메소드의 한계와 제약 사항</h3>
<p>제너릭 메소드는 많은 장점을 제공하지만, 모든 경우에 사용할 수 있는 것은 아니다. Dart에서 제너릭 메소드를 사용할 때 몇 가지 중요한 제약 사항이 있다.</p>
<h4 id="1-type-erasure">1. 런타임에 타입 정보 손실 (Type Erasure)</h4>
<p>Dart의 제너릭은 컴파일 타임에는 타입 정보를 유지하지만, 런타임에는 제네릭 타입 정보가 제거된다. 이를 <strong>타입 소거</strong>(Type Erasure)라고 한다. 이로 인해 런타임에서는 제너릭 타입 정보를 사용할 수 없으며, 이로 인해 특정한 제약 사항이 생깁니다. 예를 들어, 런타임에 제네릭 타입의 타입을 확인할 수 없기 때문에 다음과 같은 코드는 잘못된 동작을 할 수 있다.</p>
<pre><code class="language-dart">void checkType&lt;T&gt;(T value) {
  if (value is List&lt;int&gt;) {
    print('This is a List of int');
  } else if (value is List&lt;T&gt;) {
    print('This is a List of $T');
  }
}
</code></pre>
<p>위 코드에서 <code>value</code>가 제너릭 타입인 <code>List&lt;T&gt;</code>로 타입을 체크하려고 하지만, 런타임에 제너릭 타입 정보는 사라지기 때문에 <code>List&lt;T&gt;</code> 타입의 확인이 불가능한다. 이로 인해 제너릭 타입을 사용한 특정한 타입 확인이나 인스턴스 생성 등의 작업은 제약을 받게 된다.</p>
<h4 id="2-new">2. 제너릭 타입에 대한 new 연산자 사용 제한</h4>
<p>Dart에서는 제너릭 타입 매개변수에 대해 직접적으로 인스턴스를 생성할 수 없다. 이는 런타임에 제너릭 타입 정보가 제거되기 때문에, Dart는 <code>new T()</code>와 같은 구문을 허용하지 않는다.</p>
<pre><code class="language-dart">class Container&lt;T&gt; {
  T createInstance() {
    return new T();  // 오류 발생
  }
}
</code></pre>
<p>이 문제를 해결하려면 팩토리 함수나 콜백 함수를 사용하여 타입 인스턴스를 생성하는 방법을 사용할 수 있다.</p>
<h4 id="3-static">3. static 메소드와 제너릭 타입</h4>
<p>Dart에서 제너릭 타입은 인스턴스와 연관되어 있다. 따라서 <code>static</code> 메소드나 <code>static</code> 필드에서는 제너릭 타입 매개변수를 사용할 수 없다. 아래 예제처럼 <code>static</code> 메소드에서는 타입 매개변수를 정의할 수 없다.</p>
<pre><code class="language-dart">class Example&lt;T&gt; {
  static T getValue() {
    // 오류 발생: static 메소드에서는 제너릭 타입을 사용할 수 없다.
    return T();
  }
}
</code></pre>
<p>이 경우 제너릭 매개변수가 인스턴스화되지 않기 때문에, 정적 메소드나 필드에서 제너릭 타입을 사용할 수 없다.</p>
<h3 id="_16">제너릭 메소드와 함수형 프로그래밍</h3>
<p>Dart에서는 제너릭 메소드를 사용하여 함수형 프로그래밍 스타일을 구현할 수 있다. 특히, Dart의 <code>Future</code>나 <code>Stream</code>과 같은 클래스에서 제너릭 메소드를 활용하여 비동기 데이터를 처리할 수 있다. 이러한 함수형 프로그래밍 방식은 제너릭 메소드와 매우 자연스럽게 결합된다.</p>
<h4 id="_17">비동기 데이터 처리를 위한 제너릭 메소드</h4>
<pre><code class="language-dart">Future&lt;T&gt; fetchData&lt;T&gt;(String url) async {
  var response = await http.get(Uri.parse(url));
  if (response.statusCode == 200) {
    return jsonDecode(response.body) as T;
  } else {
    throw Exception('Failed to load data');
  }
}

void main() async {
  var data = await fetchData&lt;Map&lt;String, dynamic&gt;&gt;('https://api.example.com/data');
  print(data);
}
</code></pre>
<p>이 예제에서 <code>fetchData</code> 메소드는 제너릭 타입을 사용하여 JSON 데이터를 동적으로 처리할 수 있다. URL에서 가져온 데이터를 다양한 형태로 반환할 수 있으며, Dart의 비동기 프로그래밍 스타일과 제너릭 메소드를 결합하여 유연하고 안전한 코드를 작성할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0703/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0703/" class="btn btn-xs btn-link">
        제너릭 타입 제한
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0701/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0701/" class="btn btn-xs btn-link">
        제너릭 클래스
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>