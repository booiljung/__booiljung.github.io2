<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/programming/dart/chapter_13/1302/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>통합 테스트 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc758 \ubaa9\uc801", url: "#_top", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc758 \uc885\ub958", url: "#_2", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc758 \uc8fc\uc694 \ud2b9\uc9d5", url: "#_3", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8 \uc791\uc131 \uc2dc\uc758 \uace0\ub824\uc0ac\ud56d", url: "#_4", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8 \ucf54\ub4dc \uc791\uc131", url: "#_5", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc758 \uc804\ub7b5", url: "#_6", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc758 \uc608\uc2dc", url: "#_7", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc758 \uc5b4\ub824\uc6c0\uacfc \ud574\uacb0 \ubc29\uc548", url: "#_8", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc640 \ubaa8\uc758 \uac1d\uccb4(Mock Object)", url: "#mock-object", children: [
          ]},
          {title: "\ubaa8\uc758 \uac1d\uccb4 \uc0ac\uc6a9 \uc608\uc2dc", url: "#_9", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc5d0\uc11c\uc758 \uc131\ub2a5 \ucd5c\uc801\ud654", url: "#_10", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc758 \ube44\ub3d9\uae30 \ud750\ub984", url: "#_11", children: [
              {title: "Future\uc640 Stream \ucc98\ub9ac", url: "#future-stream" },
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc5d0\uc11c\uc758 \uc0c1\ud0dc \uad00\ub9ac", url: "#_12", children: [
              {title: "\uc804\uc5ed \uc0c1\ud0dc \ud14c\uc2a4\ud2b8", url: "#_13" },
              {title: "\uc758\uc874\uc131 \uc8fc\uc785\uc744 \ud1b5\ud55c \uc0c1\ud0dc \uad00\ub9ac", url: "#_14" },
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8\uc758 \ud55c\uacc4\uc640 \uadf9\ubcf5 \ubc29\ubc95", url: "#_15", children: [
          ]},
          {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8 \uc790\ub3d9\ud654", url: "#_16", children: [
              {title: "CI/CD \ud30c\uc774\ud504\ub77c\uc778\uc5d0\uc11c \ud1b5\ud569 \ud14c\uc2a4\ud2b8 \uc2e4\ud589", url: "#cicd" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1303/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1303/" class="btn btn-xs btn-link">
        Dart에서 디버깅하는 방법
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1301/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1301/" class="btn btn-xs btn-link">
        단위 테스트 작성
      </a>
    </div>
    
  </div>

    

    <p>통합 테스트는 다양한 모듈이나 컴포넌트들이 상호작용할 때 발생할 수 있는 문제를 찾기 위한 테스트 기법이다. Dart에서는 다양한 컴포넌트를 통합하여 작동을 확인하는 것이 중요하며, 이를 통해 개별 단위 테스트로는 발견하기 어려운 버그를 찾을 수 있다. 통합 테스트는 시스템의 여러 부분이 함께 동작하는 방식을 확인하는데 중점을 둔다.</p>
<h3 id="_1">통합 테스트의 목적</h3>
<p>통합 테스트의 주된 목적은 여러 모듈이나 클래스가 서로 의존하는 환경에서 이들이 올바르게 상호작용하는지를 확인하는 것이다. 일반적으로 애플리케이션의 모듈이 단일 기능을 제공하는 경우는 거의 없고, 여러 모듈이 협력하여 기능을 수행하게 된다. 이러한 상황에서 개별 모듈이 각각 올바르게 작동한다고 하더라도, 상호작용 과정에서 문제를 일으킬 가능성이 있다. 통합 테스트는 바로 이 부분을 찾아내는 데 중점을 둔다.</p>
<h3 id="_2">통합 테스트의 종류</h3>
<ol>
<li>
<p><strong>빅뱅 통합 테스트</strong><br />
   빅뱅 방식의 통합 테스트는 모든 모듈을 한꺼번에 결합한 후 테스트를 수행하는 방법이다. 이 방법은 모든 모듈이 완성된 후에야 테스트를 진행할 수 있다는 단점이 있지만, 대규모 프로젝트에서 통합 단계의 마지막에 사용될 수 있다. 모듈 간의 결합 문제를 빠르게 파악할 수 있지만, 디버깅이 어려울 수 있다.</p>
</li>
<li>
<p><strong>상향식 통합 테스트</strong><br />
   상향식 통합은 가장 작은 단위의 모듈부터 점진적으로 상위 모듈과 결합해 테스트하는 방법이다. 이 방식은 하위 모듈의 안정성을 먼저 확인한 후 상위 모듈과 통합하기 때문에 단계적으로 안정성을 높일 수 있다.</p>
</li>
<li>
<p><strong>하향식 통합 테스트</strong><br />
   하향식 통합은 상위 모듈을 먼저 테스트하고, 차례로 하위 모듈과 통합하는 방법이다. 상위 모듈의 논리적 흐름을 먼저 확인하고, 하위 모듈의 동작을 테스트할 수 있기 때문에 구조적인 문제를 빠르게 파악할 수 있다.</p>
</li>
</ol>
<h3 id="_3">통합 테스트의 주요 특징</h3>
<p>통합 테스트는 특히 비동기 처리나 네트워킹 같은 외부 의존성이 있는 부분에서 중요하다. Dart의 비동기 기능, <code>Future</code>, <code>Stream</code>, 그리고 <code>await</code>과 같은 메커니즘은 개별적으로는 잘 동작할 수 있지만, 이들이 결합된 상황에서 다양한 동시성 문제나 지연 문제가 발생할 수 있다. 예를 들어, 네트워크 요청을 처리하는 여러 모듈이 있을 때, 각각의 요청이 순차적으로 잘 처리되는지를 확인해야 한다.</p>
<h3 id="_4">통합 테스트 작성 시의 고려사항</h3>
<ol>
<li>
<p><strong>의존성 관리</strong><br />
   통합 테스트를 작성할 때는 외부 의존성을 최소화하는 것이 좋다. 예를 들어, 네트워크 연결이 필요한 모듈을 테스트할 때 실제 네트워크에 의존하지 않고 모의 객체(Mock Object)를 사용하여 네트워크 동작을 흉내내는 방식이 있다. 이를 통해 통합 테스트의 신뢰성과 재현성을 높일 수 있다.</p>
</li>
<li>
<p><strong>테스트 환경 설정</strong><br />
   통합 테스트는 시스템의 전반적인 동작을 테스트하기 때문에, 단위 테스트보다 더 복잡한 환경 설정이 필요할 수 있다. 여러 의존성을 가진 모듈을 테스트할 때, 환경 설정이 적절히 이루어지지 않으면 테스트가 실패할 가능성이 높다. 또한, 테스트가 끝난 후에는 테스트 환경을 원래대로 복원하는 과정도 필요하다.</p>
</li>
</ol>
<h3 id="_5">통합 테스트 코드 작성</h3>
<p>Dart에서 통합 테스트를 작성하는 일반적인 방법은 <code>test</code> 패키지를 사용하는 것이다. <code>test</code> 패키지는 단위 테스트뿐만 아니라 통합 테스트도 쉽게 작성할 수 있는 유연한 기능을 제공한다. 일반적인 통합 테스트는 다음과 같이 구성된다.</p>
<pre><code class="language-dart">import 'package:test/test.dart';
import 'my_app.dart';

void main() {
  group('통합 테스트 그룹', () {
    setUp(() {
      // 테스트 환경 설정
    });

    tearDown(() {
      // 테스트 환경 정리
    });

    test('모듈 A와 모듈 B의 통합 테스트', () {
      final moduleA = ModuleA();
      final moduleB = ModuleB();

      // 모듈 A와 B의 상호작용 테스트
      expect(moduleA.doSomethingWith(moduleB), isTrue);
    });
  });
}
</code></pre>
<p>위 코드에서 <code>setUp</code>과 <code>tearDown</code>을 통해 각 테스트가 시작되기 전후에 실행될 코드를 정의할 수 있다. 예를 들어, 데이터베이스를 초기화하거나 파일 시스템을 설정하는 작업을 할 수 있다.</p>
<h3 id="_6">통합 테스트의 전략</h3>
<p>통합 테스트를 효과적으로 수행하기 위해서는 적절한 전략을 수립하는 것이 중요하다. 여기서는 통합 테스트를 보다 체계적으로 진행하기 위한 몇 가지 중요한 전략을 설명한다.</p>
<ol>
<li><strong>점진적 통합</strong><br />
   점진적 통합은 모듈을 하나씩 또는 소규모 그룹으로 묶어 통합하는 방법이다. 이 방식은 여러 테스트 단계를 거치면서 오류를 빠르게 찾아낼 수 있다는 장점이 있다. 또한, 모듈 간의 상호작용을 독립적으로 테스트할 수 있기 때문에 문제의 원인을 정확히 파악할 수 있다.</li>
</ol>
<p><strong>예시:</strong>
   - 처음에 <code>ModuleA</code>와 <code>ModuleB</code>를 통합하여 테스트한 후,
   - 성공적인 결과가 나오면 <code>ModuleC</code>를 추가로 통합해 점차 확장해 나간다.</p>
<ol>
<li>
<p><strong>의존성 주입</strong><br />
   의존성 주입(Dependency Injection)은 통합 테스트를 보다 원활하게 작성할 수 있게 해주는 기법 중 하나다. 통합 테스트에서 실제 환경과 유사한 객체 또는 모의 객체를 주입함으로써 외부 의존성(예: 데이터베이스, API 서버 등)에서 발생할 수 있는 문제를 격리시킬 수 있다.</p>
</li>
<li>
<p><strong>통합 경로 추적</strong><br />
   모듈 간의 데이터 흐름이 복잡할 경우, 통합 경로를 추적하면서 테스트하는 것이 필요하다. 각 모듈이 특정한 입력을 받았을 때 어떤 출력을 생성하는지 추적하는 방식으로 진행하며, 데이터가 제대로 흐르고 상호작용하는지를 점검한다.</p>
</li>
</ol>
<h3 id="_7">통합 테스트의 예시</h3>
<p>Dart에서 통합 테스트는 여러 모듈이 협력하여 동작하는 시나리오를 가정하고 작성된다. 예를 들어, 네트워크 요청을 처리하는 <code>APIClient</code>와 이를 통해 데이터를 얻어와 화면에 표시하는 <code>DataPresenter</code>를 통합 테스트하는 경우를 생각해 보자.</p>
<pre><code class="language-dart">import 'package:test/test.dart';
import 'api_client.dart';
import 'data_presenter.dart';

void main() {
  group('APIClient와 DataPresenter 통합 테스트', () {
    APIClient apiClient;
    DataPresenter presenter;

    setUp(() {
      apiClient = APIClient();
      presenter = DataPresenter(apiClient);
    });

    test('API에서 데이터를 성공적으로 받아와 화면에 표시하는지 테스트', () async {
      // 모의 데이터 설정
      apiClient.setMockResponse('{&quot;data&quot;: &quot;테스트 데이터&quot;}');

      // 데이터를 가져오는 함수 호출
      await presenter.loadData();

      // 화면에 표시된 데이터가 기대한 값과 일치하는지 확인
      expect(presenter.displayedData, equals('테스트 데이터'));
    });
  });
}
</code></pre>
<p>이 예시에서 <code>setUp</code> 함수는 테스트 환경을 설정하는 데 사용된다. <code>APIClient</code>는 모의 데이터를 반환하도록 설정되어 있으며, <code>DataPresenter</code>는 이를 사용해 데이터를 가져와 화면에 표시하는 역할을 한다. <code>expect</code> 문은 실제 데이터가 기대한 값과 일치하는지를 확인하는 부분이다.</p>
<h3 id="_8">통합 테스트의 어려움과 해결 방안</h3>
<p>통합 테스트는 종종 복잡한 환경에서 실행되기 때문에 어려움을 겪을 수 있다. 대표적인 어려움과 그에 대한 해결 방안을 알아본다.</p>
<ol>
<li><strong>테스트 간 상호 의존성</strong><br />
   통합 테스트는 종종 여러 모듈 간의 상호작용을 다루기 때문에 테스트 간의 의존성이 생길 수 있다. 이러한 경우 테스트 결과에 따라 다른 테스트가 영향을 받을 수 있다.</li>
</ol>
<p><strong>해결 방안:</strong>
   각 테스트는 독립적이어야 하며, 가능한 한 상태를 공유하지 않도록 해야 한다. <code>setUp</code>과 <code>tearDown</code> 함수를 통해 테스트 전후에 환경을 초기화하고 복원하는 방식이 필요하다.</p>
<ol>
<li><strong>비동기 코드 테스트</strong><br />
   Dart는 비동기적 실행을 지원하는 언어이기 때문에 비동기 코드가 포함된 모듈 간의 통합 테스트를 작성하는 것이 까다로울 수 있다. 예를 들어, 여러 비동기 요청이 순차적으로 처리되는지 확인하는 것이 필요할 때도 있다.</li>
</ol>
<p><strong>해결 방안:</strong>
   <code>Future</code>나 <code>async/await</code> 패턴을 사용하여 비동기 작업이 완료된 후에야 검증을 진행할 수 있도록 테스트 코드를 작성해야 한다. 또한, <code>Stream</code>을 사용하는 경우에는 스트림의 각 이벤트를 처리하는 흐름을 확인하는 것도 중요하다.</p>
<h3 id="mock-object">통합 테스트와 모의 객체(Mock Object)</h3>
<p>모의 객체는 통합 테스트에서 실제 시스템을 대신하여 사용할 수 있는 객체를 의미한다. 모의 객체는 외부 시스템과의 상호작용을 시뮬레이션하는 데 사용되며, 이를 통해 테스트를 독립적으로 수행할 수 있다. 특히, 네트워크, 데이터베이스, 파일 시스템 등 외부 의존성이 있는 시스템에서는 모의 객체를 통해 예상되는 결과를 설정할 수 있기 때문에 통합 테스트의 신뢰성을 높일 수 있다.</p>
<p>모의 객체를 사용함으로써, 다음과 같은 이점을 얻을 수 있다.</p>
<ol>
<li><strong>외부 의존성 제거</strong>: 테스트 환경이 실제 데이터베이스나 네트워크에 연결되지 않더라도, 모의 객체를 사용하여 동일한 상황을 시뮬레이션할 수 있다.  </li>
<li><strong>예상된 결과 제어</strong>: 실제 시스템에서는 결과가 비동기적으로 도착하거나, 네트워크 지연 등으로 인해 예측 불가능한 상황이 발생할 수 있지만, 모의 객체는 항상 동일한 결과를 반환하도록 설정할 수 있다.  </li>
<li><strong>테스트 속도 향상</strong>: 실제 시스템을 사용하지 않기 때문에 테스트 실행 시간이 짧아지고, 테스트 반복에 따른 부하도 적어진다.</li>
</ol>
<h3 id="_9">모의 객체 사용 예시</h3>
<p>아래 예시는 <code>HttpClient</code> 클래스를 모의 객체로 대체하여 통합 테스트를 수행하는 방법을 보여준다. 여기서는 실제로 HTTP 요청을 보내지 않고, 모의 데이터를 사용하여 테스트를 진행한다.</p>
<pre><code class="language-dart">import 'package:test/test.dart';
import 'package:mockito/mockito.dart';
import 'http_client.dart';
import 'data_presenter.dart';

// Mock 클래스 정의
class MockHttpClient extends Mock implements HttpClient {}

void main() {
  group('MockHttpClient를 사용한 통합 테스트', () {
    MockHttpClient mockHttpClient;
    DataPresenter presenter;

    setUp(() {
      mockHttpClient = MockHttpClient();
      presenter = DataPresenter(mockHttpClient);
    });

    test('모의 객체를 사용하여 HTTP 요청 테스트', () async {
      // 모의 응답 설정
      when(mockHttpClient.getData())
          .thenAnswer((_) async =&gt; '{&quot;data&quot;: &quot;모의 데이터&quot;}');

      // 데이터를 가져오는 함수 호출
      await presenter.loadData();

      // 기대한 결과와 일치하는지 확인
      expect(presenter.displayedData, equals('모의 데이터'));
    });
  });
}
</code></pre>
<p>이 예시에서는 <code>Mockito</code> 패키지를 사용하여 <code>HttpClient</code>를 모의 객체로 설정하고, <code>when-thenAnswer</code> 패턴을 통해 특정 입력에 대해 모의 응답을 반환하도록 정의했다. 이를 통해 실제 네트워크 요청을 보내지 않고도, <code>DataPresenter</code> 클래스의 동작을 테스트할 수 있다.</p>
<h3 id="_10">통합 테스트에서의 성능 최적화</h3>
<p>통합 테스트는 여러 모듈을 결합하여 테스트하기 때문에, 단위 테스트에 비해 성능이 떨어질 수 있다. 통합 테스트의 성능을 최적화하는 방법은 다음과 같다.</p>
<ol>
<li><strong>불필요한 외부 의존성 제거</strong>: 모의 객체를 활용하여 불필요한 네트워크 요청이나 데이터베이스 연결을 제거함으로써, 테스트 속도를 높일 수 있다.  </li>
<li><strong>테스트 병렬 실행</strong>: Dart의 테스트 도구는 기본적으로 테스트를 병렬로 실행할 수 있다. 이를 통해 테스트 실행 시간을 단축시킬 수 있다.  </li>
<li><strong>테스트 분리</strong>: 통합 테스트가 너무 커지면 테스트 간의 경합이 발생할 수 있다. 테스트를 여러 그룹으로 나누어 실행하거나, 중요도가 높은 테스트만 우선적으로 실행하는 전략을 사용할 수 있다.</li>
</ol>
<h3 id="_11">통합 테스트의 비동기 흐름</h3>
<p>Dart에서 통합 테스트를 작성할 때, 비동기 코드는 통합 테스트에서 특히 주의해야 한다. Dart의 <code>Future</code>와 <code>Stream</code>은 비동기적 처리를 쉽게 할 수 있는 구조를 제공하지만, 이러한 비동기 흐름이 여러 모듈 간에 복잡하게 얽혀 있을 때는 예기치 못한 버그가 발생할 가능성이 있다.</p>
<h4 id="future-stream">Future와 Stream 처리</h4>
<p>비동기 함수는 통합 테스트에서도 매우 중요한 역할을 한다. 예를 들어, <code>Future</code> 객체는 비동기적으로 완료되며, <code>await</code> 키워드를 사용하여 이를 기다릴 수 있다. 반면, <code>Stream</code>은 연속적인 데이터를 전달하며, 각 이벤트를 처리해야 한다.</p>
<pre><code class="language-dart">test('비동기 함수 통합 테스트', () async {
  final result = await fetchDataFromServer();
  expect(result, equals('서버 응답 데이터'));
});
</code></pre>
<p>이 코드는 서버로부터 데이터를 비동기적으로 받아오는 <code>fetchDataFromServer</code> 함수를 테스트한다. Dart의 <code>await</code> 키워드를 통해 <code>Future</code>가 완료되기를 기다린 후, 결과를 검증하는 방식이다.</p>
<p><code>Stream</code>을 처리할 때는, 각 이벤트에 대한 기대치를 확인할 수 있다.</p>
<pre><code class="language-dart">test('Stream 데이터 통합 테스트', () async {
  final stream = getDataStream();
  await expectLater(stream, emitsInOrder(['첫 번째 데이터', '두 번째 데이터']));
});
</code></pre>
<p>이 코드는 스트림에서 연속적으로 전달되는 데이터를 검증하는 예시다. <code>emitsInOrder</code>를 사용하여 데이터가 예상 순서대로 전달되는지를 테스트할 수 있다.</p>
<h3 id="_12">통합 테스트에서의 상태 관리</h3>
<p>통합 테스트에서 중요한 개념 중 하나는 상태 관리다. 여러 모듈이 상호작용하는 과정에서 상태가 변경되는지, 또는 올바르게 유지되는지 확인하는 것은 통합 테스트의 중요한 부분이다. 특히, 애플리케이션이 여러 사용자 세션이나 비동기 작업을 다룰 때 상태가 정확히 관리되지 않으면 심각한 오류가 발생할 수 있다.</p>
<h4 id="_13">전역 상태 테스트</h4>
<p>애플리케이션에서 전역 상태를 관리하는 경우, 통합 테스트는 전역 상태가 올바르게 설정되고 수정되는지 확인하는 데 집중해야 한다. Dart에서 전역 상태를 관리할 때는 일반적으로 <code>ChangeNotifier</code>나 <code>Stream</code>을 사용한다. 이러한 상태 변경을 확인하는 테스트 예시는 다음과 같다.</p>
<pre><code class="language-dart">import 'package:test/test.dart';
import 'state_manager.dart';

void main() {
  group('전역 상태 관리 통합 테스트', () {
    test('상태가 변경될 때 알림이 발생하는지 테스트', () {
      final stateManager = StateManager();

      // 상태 변경 전 초기 상태 확인
      expect(stateManager.currentState, equals('초기 상태'));

      // 상태 변경
      stateManager.changeState('새 상태');

      // 상태 변경 후 확인
      expect(stateManager.currentState, equals('새 상태'));
    });
  });
}
</code></pre>
<p>이 예시에서는 <code>StateManager</code> 클래스가 상태를 관리하며, 상태가 변경된 후 이를 통합 테스트에서 확인하고 있다.</p>
<h4 id="_14">의존성 주입을 통한 상태 관리</h4>
<p>통합 테스트에서 상태 관리를 테스트할 때, 의존성 주입(Dependency Injection)을 활용하여 모듈 간의 상태를 주입하는 방식도 효과적이다. 예를 들어, 특정 모듈이 외부에서 주입된 상태를 통해 동작하는 경우, 그 상태를 모의 객체로 대체할 수 있다.</p>
<pre><code class="language-dart">import 'package:test/test.dart';
import 'state_manager.dart';
import 'data_presenter.dart';

class MockStateManager extends Mock implements StateManager {}

void main() {
  group('의존성 주입을 통한 상태 관리 통합 테스트', () {
    MockStateManager mockStateManager;
    DataPresenter presenter;

    setUp(() {
      mockStateManager = MockStateManager();
      presenter = DataPresenter(mockStateManager);
    });

    test('상태가 변경된 후의 동작 테스트', () {
      // 상태 변경 모의
      when(mockStateManager.currentState).thenReturn('모의 상태');

      // 상태에 따라 데이터 표시 확인
      presenter.updateView();
      expect(presenter.displayedData, equals('모의 상태에 따른 데이터'));
    });
  });
}
</code></pre>
<p>위 예시는 <code>MockStateManager</code>를 통해 모의 상태를 주입하고, 이를 기반으로 <code>DataPresenter</code>가 동작하는 방식을 테스트하는 코드다.</p>
<h3 id="_15">통합 테스트의 한계와 극복 방법</h3>
<p>통합 테스트는 시스템의 전반적인 동작을 검증할 수 있지만, 몇 가지 한계를 지니고 있다. 대표적인 한계는 다음과 같다.</p>
<ol>
<li><strong>복잡한 설정과 느린 실행</strong><br />
   통합 테스트는 단위 테스트에 비해 복잡한 설정이 필요하며, 외부 의존성까지 포함될 경우 실행 속도가 느릴 수 있다. 이는 특히 큰 프로젝트에서 문제가 될 수 있다.</li>
</ol>
<p><strong>극복 방법</strong>: 복잡한 통합 테스트는 가능한 한 최소한의 설정으로 간소화하고, 테스트 병렬화를 통해 실행 속도를 최적화할 수 있다.</p>
<ol>
<li><strong>디버깅의 어려움</strong><br />
   통합 테스트는 여러 모듈 간의 상호작용을 다루기 때문에, 오류가 발생했을 때 그 원인을 추적하기가 어려울 수 있다. 모듈 간의 상호작용에서 발생하는 오류는 개별 모듈의 문제인지, 상호작용의 문제인지 판단하기가 까다롭다.</li>
</ol>
<p><strong>극복 방법</strong>: 통합 테스트를 여러 작은 테스트 그룹으로 나누고, 각 그룹에서 발생하는 문제를 별도로 분석하여 문제를 단계적으로 해결할 수 있다. 또한, 로그 기록이나 디버깅 도구를 활용하여 문제의 근본 원인을 파악하는 데 도움을 받을 수 있다.</p>
<h3 id="_16">통합 테스트 자동화</h3>
<p>통합 테스트는 자동화 시스템과 잘 맞물려 작동할 때 가장 효과적이다. Dart의 <code>test</code> 패키지는 CI/CD(Continuous Integration/Continuous Deployment) 파이프라인에서 통합 테스트를 자동으로 실행할 수 있는 기능을 제공한다. 이를 통해 코드 변경 사항이 발생할 때마다 자동으로 테스트를 실행하여 시스템의 안정성을 유지할 수 있다.</p>
<h4 id="cicd">CI/CD 파이프라인에서 통합 테스트 실행</h4>
<p>통합 테스트는 보통 CI/CD 도구를 통해 자동화된다. 대표적인 도구로는 Jenkins, GitHub Actions, GitLab CI 등이 있으며, 이들은 코드 변경 시 통합 테스트를 자동으로 실행하고 결과를 보고하는 기능을 제공한다. Dart 프로젝트에서는 다음과 같은 <code>.yaml</code> 설정 파일을 사용하여 GitHub Actions에서 통합 테스트를 실행할 수 있다.</p>
<pre><code class="language-yaml">name: Dart CI

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Install Dart SDK
      uses: dart-lang/setup-dart@v1
      with:
        sdk: 'stable'
    - name: Run tests
      run: dart test
</code></pre>
<p>위 설정은 코드가 <code>push</code>될 때 자동으로 Dart SDK를 설치하고 통합 테스트를 실행하는 간단한 예시다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1303/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1303/" class="btn btn-xs btn-link">
        Dart에서 디버깅하는 방법
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1301/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1301/" class="btn btn-xs btn-link">
        단위 테스트 작성
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>