<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/applied_math/optimization_theory/linear_programming/chapter_09/0903/" rel="canonical"/>
<link href="../../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>경계점 방법과의 비교 - 실험 도서관</title>
<link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uacbd\uacc4\uc810 \ubc29\ubc95\uc758 \uac1c\ub150", url: "#_top", children: [
          ]},
          {title: "\ub0b4\ubd80\uc810 \ubc29\ubc95\uacfc\uc758 \ucc28\uc774\uc810", url: "#_2", children: [
          ]},
          {title: "\uc218\ud559\uc801 \ud45c\ud604", url: "#_3", children: [
          ]},
          {title: "\uadf8\ub798\ud53d \ud45c\ud604", url: "#_4", children: [
          ]},
          {title: "\uacbd\uacc4\uc810 \ubc29\ubc95\uacfc \ub0b4\ubd80\uc810 \ubc29\ubc95\uc758 \uc218\ub834 \ud2b9\uc131", url: "#_5", children: [
          ]},
          {title: "\uacbd\uacc4\uc810\uacfc \ub0b4\ubd80\uc810\uc758 \uc2e4\uc81c \ubb38\uc81c \uc801\uc6a9", url: "#_6", children: [
          ]},
          {title: "\uacbd\uacc4\uc810 \ubc29\ubc95\uacfc \ub0b4\ubd80\uc810 \ubc29\ubc95\uc758 \uc7a5\ub2e8\uc810 \uc694\uc57d", url: "#_7", children: [
          ]},
          {title: "\uadf8\ub798\ud53d \ud45c\ud604", url: "#_8", children: [
          ]},
        ];

    </script>
<script src="../../../../../js/base.js"></script>
<script src="../../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0904/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0904/">
        프리멀-듀얼 내부점 방법
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0902/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0902/">
        카르마르카르 알고리즘
      </a>
</div>
</div>
<h3 id="_1">경계점 방법의 개념</h3>
<p>경계점 방법은 선형계획법에서 가능한 영역의 경계를 따라 최적해를 찾는 방법이다. 이는 주어진 제약 조건 하에서 목적 함수의 값을 최적화하는 과정에서, 해가 항상 경계점(극점)에서 발생한다는 사실을 이용한다. 경계점 방법은 다음과 같은 주요 개념을 기반으로 한다:</p>
<ol>
<li><strong>기저 해</strong>: 선형계획 문제에서의 해는 기저 해로 표현된다. 기저 해는 행렬 방정식의 기저 벡터들에 의해 정의되며, 이러한 기저 해는 보통 다면체의 한 극점에 해당한다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{A} \mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</div>
<script type="math/tex; mode=display">
   \mathbf{A} \mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 제약 조건을 나타내는 행렬이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>는 변수 벡터, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>는 우변의 상수 벡터이다.</p>
<ol>
<li><strong>다면체와 극점</strong>: 가능한 해의 공간은 다면체로 표현되며, 그 다면체의 꼭짓점(극점)이 최적해가 될 가능성이 높다. 경계점 방법은 이러한 극점을 탐색하며 최적해를 찾는 과정을 거친다.</li>
</ol>
<h3 id="_2">내부점 방법과의 차이점</h3>
<p>경계점 방법은 해가 항상 경계점에서 나타난다고 가정하고, 가능한 영역의 경계를 따라 이동하며 최적해를 탐색한다. 이에 반해, 내부점 방법은 해를 경계가 아닌 내부에서 시작하여 최적해를 향해 나아간다.</p>
<ol>
<li>
<p><strong>탐색 경로</strong>: 경계점 방법은 다면체의 한 극점에서 다른 극점으로 이동하며 최적해를 찾는다. 반면, 내부점 방법은 해의 공간 내부에서 최적해로 접근하는 과정을 거친다. 즉, 내부점 방법은 다면체의 내부 경로를 탐색하는 방식이다.</p>
</li>
<li>
<p><strong>초기 해의 설정</strong>: 경계점 방법에서는 초기 해가 다면체의 한 극점에서 설정되며, 그 다음 인접한 극점으로 이동하는 방식으로 이루어진다. 반면, 내부점 방법은 다면체 내부의 임의의 점에서 시작하여 최적화 경로를 찾는다.</p>
</li>
<li>
<p><strong>해의 계산 복잡도</strong>: 경계점 방법은 탐색할 극점의 수가 많은 경우, 특히 고차원 문제에서는 계산 비용이 매우 커질 수 있다. 반면, 내부점 방법은 이러한 극점 탐색의 복잡성을 줄일 수 있으며, 더 빠르게 수렴할 수 있다.</p>
</li>
</ol>
<h3 id="_3">수학적 표현</h3>
<p>경계점 방법에서 최적해는 다음과 같은 형태로 주어진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</div>
<script type="math/tex; mode=display">
\mathbf{A} \mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 제약 조건 행렬이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>는 변수 벡터, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>는 상수 벡터이다. 경계점 방법은 이 방정식을 만족하는 극점들을 따라 이동하며 최적해를 찾는다.</p>
<p>반면, 내부점 방법은 다음과 같은 최적화 문제를 해결하는 과정에서 내부의 해를 찾는다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{x}} \mathbf{c}^\top \mathbf{x} \quad \text{subject to} \quad \mathbf{A} \mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{x}} \mathbf{c}^\top \mathbf{x} \quad \text{subject to} \quad \mathbf{A} \mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span>는 목적 함수의 계수 벡터이다.</p>
<p>경계점 방법의 경우에는 극점들 간의 이동이 필요하며, 이는 다음과 같은 방식으로 이루어진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{k+1} = \mathbf{x}_k + \alpha_k \mathbf{d}_k
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{k+1} = \mathbf{x}_k + \alpha_k \mathbf{d}_k
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_k</span><script type="math/tex">\mathbf{d}_k</script></span>는 이동 방향 벡터이고, <span class="arithmatex"><span class="MathJax_Preview">\alpha_k</span><script type="math/tex">\alpha_k</script></span>는 이동의 크기를 결정하는 스칼라 값이다. 이 과정은 최적해를 찾을 때까지 반복된다.</p>
<h3 id="_4">그래픽 표현</h3>
<p>경계점 방법과 내부점 방법의 탐색 경로 차이를 시각적으로 표현하면 다음과 같다:</p>
<div class="mermaid">graph TD;
    A[시작점] --&gt; B[경계점 탐색] --&gt; C[다른 경계점으로 이동] --&gt; D[최적 해 도달]
    A --&gt; E[내부점 탐색] --&gt; F[내부 경로를 통해 최적해로 접근] --&gt; D
</div>
<h3 id="_5">경계점 방법과 내부점 방법의 수렴 특성</h3>
<ol>
<li><strong>수렴 속도</strong>:<br/>
   경계점 방법은 다면체의 경계에서 하나의 극점에서 다음 극점으로 이동하는 방식이다. 따라서, 문제의 차원이 커질수록 탐색해야 할 극점의 수가 증가하여 수렴 속도가 느려질 수 있다. 특히, 최적해가 다면체의 모서리나 경계에 가까이 있을 경우, 수렴 속도가 매우 느려질 수 있다.</li>
</ol>
<p>반면, 내부점 방법은 해의 공간 내부에서 시작하여, 목적 함수가 최적해로 수렴할 때까지 탐색 경로를 내부에서 찾는다. 내부점 방법은 선형 수렴을 가지며, 종종 경계점 방법보다 빠르게 수렴하는 경향이 있다. 이는 특히 고차원 문제에서 두드러지며, 경계점 방법에서 발생할 수 있는 극점 간의 긴 경로를 피할 수 있기 때문이다.</p>
<p>수렴 속도는 다음과 같은 수식으로 설명될 수 있다:</p>
<p>경계점 방법에서 다음 극점으로 이동할 때:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{x}_{k+1} = \mathbf{x}_k + \alpha_k \mathbf{d}_k
</div>
<script type="math/tex; mode=display">
   \mathbf{x}_{k+1} = \mathbf{x}_k + \alpha_k \mathbf{d}_k
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\alpha_k</span><script type="math/tex">\alpha_k</script></span>는 이동 크기, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_k</span><script type="math/tex">\mathbf{d}_k</script></span>는 방향 벡터이다.</p>
<p>내부점 방법의 경우, 뉴턴 방식이나 선형 로그 배리어 함수 방법을 사용하여 내부에서 목적 함수를 최적화하며, 해는 다음과 같은 형태로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{x}_{k+1} = \mathbf{x}_k - \eta \nabla f(\mathbf{x}_k)
</div>
<script type="math/tex; mode=display">
   \mathbf{x}_{k+1} = \mathbf{x}_k - \eta \nabla f(\mathbf{x}_k)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\eta</span><script type="math/tex">\eta</script></span>는 학습률, <span class="arithmatex"><span class="MathJax_Preview">\nabla f(\mathbf{x}_k)</span><script type="math/tex">\nabla f(\mathbf{x}_k)</script></span>는 목적 함수 <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>에 대한 그레디언트이다.</p>
<ol>
<li><strong>계산 비용</strong>:
   경계점 방법은 각 반복마다 새로운 기저 해를 계산하며, 이 과정에서 새로운 극점을 탐색하는 계산 비용이 발생한다. 특히, 고차원 문제의 경우 가능한 극점의 수가 많아져 전체 계산 비용이 증가할 수 있다. 따라서, 많은 제약 조건이 있는 문제에서는 경계점 방법이 상대적으로 비효율적일 수 있다.</li>
</ol>
<p>내부점 방법은 해의 공간 내부에서 경계로 수렴하는 경로를 따라 이동하며, 각 반복에서 목적 함수의 그레디언트를 계산하는 방식으로 해결한다. 뉴턴 방법을 사용하는 내부점 방법은 각 반복에서의 계산량이 더 많을 수 있지만, 전체적으로는 더 적은 반복으로 최적해에 도달할 수 있어 큰 문제에서 더 효율적이다.</p>
<h3 id="_6">경계점과 내부점의 실제 문제 적용</h3>
<ol>
<li><strong>작은 문제 vs. 큰 문제</strong>:<br/>
   경계점 방법은 작은 규모의 문제에서는 효율적으로 작동할 수 있다. 특히, 극점 간의 이동이 빠르게 이루어지는 문제에서는 경계점 방법이 더 간단하고 명확한 해법을 제공할 수 있다.</li>
</ol>
<p>그러나 대규모 문제에서는 내부점 방법이 더 효율적인 경향이 있다. 내부점 방법은 고차원 문제에서도 빠르게 수렴할 수 있는 장점이 있어, 큰 문제에서는 경계점 방법보다 더 적합하다.</p>
<ol>
<li><strong>실제 응용에서의 차이점</strong>:<br/>
   경계점 방법은 전통적으로 제조, 물류, 운송 등에서 활용되는 경우가 많았다. 그러나 현대적인 대규모 최적화 문제, 예를 들어 금융 포트폴리오 최적화, 에너지 네트워크 최적화 등에서는 내부점 방법이 더 널리 사용되고 있다.</li>
</ol>
<h3 id="_7">경계점 방법과 내부점 방법의 장단점 요약</h3>
<ol>
<li><strong>경계점 방법</strong> </li>
<li>장점:  <ul>
<li>작은 문제에 효과적  </li>
<li>단순한 계산 과정과 명확한 극점 이동</li>
</ul>
</li>
<li>
<p>단점:  </p>
<ul>
<li>고차원 문제에서 느린 수렴  </li>
<li>극점 탐색 시 계산 비용 증가</li>
</ul>
</li>
<li>
<p><strong>내부점 방법</strong> </p>
</li>
<li>장점:  <ul>
<li>대규모 문제에서 빠른 수렴  </li>
<li>내부 경로 탐색을 통해 효율적인 해 탐색</li>
</ul>
</li>
<li>단점:  <ul>
<li>각 반복에서의 계산 복잡도 증가  </li>
<li>초기 설정이 복잡할 수 있음</li>
</ul>
</li>
</ol>
<h3 id="_8">그래픽 표현</h3>
<p>경계점 방법과 내부점 방법의 탐색 과정을 시각적으로 비교하면 다음과 같다:</p>
<div class="mermaid">graph LR;
    A[초기 해 설정] --&gt; B[경계점 방법 경로] --&gt; C[극점 탐색] --&gt; D[최적 해 도달]
    A --&gt; E[내부점 방법 경로] --&gt; F[내부 탐색] --&gt; G[최적 해 도달]
</div>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0904/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0904/">
        프리멀-듀얼 내부점 방법
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0902/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0902/">
        카르마르카르 알고리즘
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>