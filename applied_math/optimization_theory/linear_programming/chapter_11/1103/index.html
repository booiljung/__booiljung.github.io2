<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/applied_math/optimization_theory/linear_programming/chapter_11/1103/" rel="canonical"/>
<link href="../../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>병렬 계산과 대규모 문제 해결 - 소프트웨어 융합</title>
<link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ubcd1\ub82c \uacc4\uc0b0\uc758 \ud544\uc694\uc131", url: "#_top", children: [
          ]},
          {title: "\ubcd1\ub82c \uacc4\uc0b0\uc758 \uac1c\ub150", url: "#_2", children: [
          ]},
          {title: "\ubcd1\ub82c \ub2e8\uccb4\ubc95", url: "#_3", children: [
              {title: "\uc218\uc2dd\uc73c\ub85c \ud45c\ud604\ub41c \ub2e8\uccb4\ubc95", url: "#_4" },
          ]},
          {title: "\ubd84\ud574 \uae30\ubc95\uacfc \ubcd1\ub82c \uacc4\uc0b0", url: "#_5", children: [
              {title: "\ubd84\ud574 \uae30\ubc95\uc758 \uc608: \ub4c0\uc5bc \ubd84\ud574", url: "#_6" },
          ]},
          {title: "\ud504\ub9ac\ucee8\ub514\uc154\ub2dd(Preconditioning)\uacfc \ubcd1\ub82c \uacc4\uc0b0", url: "#preconditioning", children: [
              {title: "\ud504\ub9ac\ucee8\ub514\uc154\ub2dd\uc758 \uac1c\ub150", url: "#_7" },
          ]},
          {title: "\ub0b4\ubd80\uc810 \ubc29\ubc95\uacfc \ubcd1\ub82c \uacc4\uc0b0", url: "#_8", children: [
              {title: "\ub0b4\ubd80\uc810 \ubc29\ubc95\uc758 \uc218\uc2dd", url: "#_9" },
              {title: "\ubcd1\ub82c\ud654\ub41c \ub0b4\ubd80\uc810 \ubc29\ubc95", url: "#_10" },
          ]},
          {title: "\ub2e4\uc911 \uacbd\ub85c \ud0d0\uc0c9(Multi-Path Search) \uae30\ubc95", url: "#multi-path-search", children: [
              {title: "\ub2e4\uc911 \uacbd\ub85c \ud0d0\uc0c9\uc758 \uac1c\ub150", url: "#_11" },
          ]},
          {title: "\ubd84\ud574 \uae30\ubc95\uacfc \ubcd1\ub82c \uacc4\uc0b0", url: "#_12", children: [
              {title: "\ubc6c\ub354 \ubd84\ud574 \ubc29\ubc95", url: "#_13" },
              {title: "\ub4c0\uc5bc \ubd84\ud574 \ubc29\ubc95", url: "#_14" },
          ]},
          {title: "\ub300\uaddc\ubaa8 \uc120\ud615\uacc4\ud68d \ubb38\uc81c\uc5d0\uc11c\uc758 \ubcd1\ub82c \uc54c\uace0\ub9ac\uc998", url: "#_15", children: [
              {title: "\ubd84\ud560 \uc218\uc9d1 \uc54c\uace0\ub9ac\uc998(Split-and-Gather Algorithm)", url: "#split-and-gather-algorithm" },
              {title: "\ubd84\uc9c0\ud55c\uc815\ubc95(Branch-and-Bound Method) \ubcd1\ub82c\ud654", url: "#branch-and-bound-method" },
              {title: "\ub2e8\uccb4\ubc95\uc758 \ubcd1\ub82c\ud654", url: "#_16" },
          ]},
          {title: "\ub300\uaddc\ubaa8 \ubb38\uc81c \ud574\uacb0\uc5d0\uc11c\uc758 \ub370\uc774\ud130 \ubd84\ud560 \uae30\ubc95", url: "#_17", children: [
              {title: "\ube14\ub85d \ubd84\ud560(Block Partitioning)", url: "#block-partitioning" },
          ]},
          {title: "\ub300\uaddc\ubaa8 \ud589\ub82c \uc5f0\uc0b0\uc758 \ubcd1\ub82c\ud654", url: "#_18", children: [
              {title: "\ud589\ub82c \uacf1\uc148\uc758 \ubcd1\ub82c\ud654", url: "#_19" },
          ]},
          {title: "\ubd84\uc0b0 \uacc4\uc0b0 \uc2dc\uc2a4\ud15c\uc5d0\uc11c\uc758 \uc120\ud615\uacc4\ud68d\ubc95", url: "#_20", children: [
              {title: "\ubd84\uc0b0 \uacc4\uc0b0\uc758 \uae30\ubcf8 \uc6d0\ub9ac", url: "#_21" },
          ]},
          {title: "MapReduce\ub97c \uc774\uc6a9\ud55c \uc120\ud615\uacc4\ud68d \ubb38\uc81c \ud574\uacb0", url: "#mapreduce", children: [
              {title: "Map \ub2e8\uacc4", url: "#map" },
              {title: "Reduce \ub2e8\uacc4", url: "#reduce" },
          ]},
          {title: "\ubcd1\ub82c \uacc4\uc0b0\uc5d0\uc11c\uc758 GPU \ud65c\uc6a9", url: "#gpu", children: [
              {title: "GPU\ub97c \ud65c\uc6a9\ud55c \ud589\ub82c \uc5f0\uc0b0", url: "#gpu_1" },
              {title: "CUDA\ub97c \uc774\uc6a9\ud55c \ubcd1\ub82c \uacc4\uc0b0", url: "#cuda" },
              {title: "CUDA\uc5d0\uc11c\uc758 \ud589\ub82c \uacf1\uc148 \uc608\uc2dc", url: "#cuda_1" },
          ]},
          {title: "\ub300\uaddc\ubaa8 \uc120\ud615\uacc4\ud68d\ubc95 \ubb38\uc81c\uc758 \ud074\ub7ec\uc2a4\ud130\ub9c1(Clustering)", url: "#clustering", children: [
              {title: "\ud074\ub7ec\uc2a4\ud130\ub9c1\uc758 \uc6d0\ub9ac", url: "#_22" },
              {title: "\ud074\ub7ec\uc2a4\ud130\ub9c1\uacfc \ubd84\ud560 \uc218\uc9d1 \uc54c\uace0\ub9ac\uc998\uc758 \uacb0\ud569", url: "#_23" },
          ]},
          {title: "\ubcd1\ub82c \uacc4\uc0b0\uc5d0\uc11c\uc758 \ub3d9\uae30\ud654(Synchronization) \ubb38\uc81c", url: "#synchronization", children: [
              {title: "\ub3d9\uae30\ud654 \uae30\ubc95", url: "#_24" },
              {title: "\ubcd1\ub82c \uc5f0\uc0b0\uc5d0\uc11c\uc758 \ub3d9\uae30\ud654 \uc774\uc288 \ud574\uacb0", url: "#_25" },
          ]},
        ];

    </script>
<script src="../../../../../js/base.js"></script>
<script src="../../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../1104/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../1104/">
        대규모 산업 응용 사례
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../1102/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../1102/">
        분해 기법의 적용 사례
      </a>
</div>
</div>
<h3 id="_1">병렬 계산의 필요성</h3>
<p>대규모의 선형계획법 문제를 다룰 때는 일반적인 연산 방법으로는 계산 시간이 급격히 증가하게 된다. 특히, 변수의 개수와 제약 조건이 수천에서 수만 개에 이를 경우 기존의 단일 프로세서 방식으로는 실시간 또는 빠른 시간 내에 해를 구하기 어렵다. 따라서 이러한 대규모 문제를 해결하기 위해서는 병렬 계산 기법을 적용하는 것이 필수적이다.</p>
<p>병렬 계산을 통해 각 처리 단계를 분할하고, 이를 동시에 수행함으로써 계산 시간을 단축할 수 있다. 이를 위해서는 선형계획 문제의 구조적 특성을 잘 이해하고, 문제를 적절히 분할하는 것이 중요하다.</p>
<h3 id="_2">병렬 계산의 개념</h3>
<p>병렬 계산에서는 여러 개의 프로세서가 동시에 연산을 수행할 수 있는 환경에서 선형계획 문제를 처리한다. 일반적으로 다음과 같은 두 가지 병렬 계산 모델을 사용할 수 있다.</p>
<ol>
<li><strong>데이터 병렬성(Data Parallelism)</strong>: 데이터를 분할하여 각 프로세서가 서로 다른 부분의 데이터를 처리한다.</li>
<li><strong>작업 병렬성(Task Parallelism)</strong>: 서로 다른 작업을 동시에 처리할 수 있도록 각 프로세서에 다른 작업을 할당한다.</li>
</ol>
<p>선형계획 문제의 경우, 병렬 계산은 대규모 행렬의 연산 및 단체법과 같은 알고리즘의 반복적인 계산 과정을 병렬화하여 성능을 극대화하는 방식으로 구현할 수 있다.</p>
<h3 id="_3">병렬 단체법</h3>
<p>단체법(Simplex Method)은 선형계획 문제를 해결하는 대표적인 알고리즘으로, 일반적으로 다음과 같은 과정으로 병렬화할 수 있다.</p>
<ol>
<li>
<p><strong>표 형식의 분할</strong>: 단체법에서 사용하는 표 형식(테이블)을 병렬로 분할하여 각 부분을 다른 프로세서에서 계산한다. 이러한 방식으로 단체법의 계산 시간 중 가장 많은 비중을 차지하는 행렬 연산을 병렬화할 수 있다.</p>
</li>
<li>
<p><strong>선택 기준의 병렬화</strong>: 단체법에서 피봇팅(pivoting)을 결정하는 과정에서도 병렬화를 적용할 수 있다. 각 열에 대한 평가를 병렬로 처리하여 피봇팅할 열을 선택하는 과정을 가속화할 수 있다.</p>
</li>
</ol>
<h4 id="_4">수식으로 표현된 단체법</h4>
<p>단체법에서는 표 형식으로 변환된 선형계획 문제를 단계적으로 최적화된 해로 수렴시키기 위해, 다음과 같은 기본 수식을 사용한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{k+1} = \mathbf{x}_k + \theta \mathbf{d}_k
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{k+1} = \mathbf{x}_k + \theta \mathbf{d}_k
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_k</span><script type="math/tex">\mathbf{x}_k</script></span>는 현재의 해 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_k</span><script type="math/tex">\mathbf{d}_k</script></span>는 이동할 방향 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>는 이동할 거리(스칼라 값)이다.</p>
<p>각 반복 단계에서는 <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_k</span><script type="math/tex">\mathbf{d}_k</script></span>를 계산하여 다음 반복의 해를 갱신하게 된다.</p>
<h3 id="_5">분해 기법과 병렬 계산</h3>
<p>대규모 선형계획 문제에서는 전체 문제를 여러 작은 하위 문제로 분해하는 기법이 유용하다. 이를 <strong>분해 기법(Decomposition Methods)</strong>이라 하며, 병렬 계산과 결합하면 더 효율적으로 문제를 해결할 수 있다.</p>
<h4 id="_6">분해 기법의 예: 듀얼 분해</h4>
<p>듀얼 분해(Dual Decomposition)는 대규모 문제를 병렬화하는 대표적인 방법 중 하나이다. 이 기법에서는 다음과 같은 최적화 문제를 분해할 수 있다.</p>
<p>최적화 문제:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{x}} \mathbf{c}^T \mathbf{x} \quad \text{subject to} \quad \mathbf{A} \mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{x}} \mathbf{c}^T \mathbf{x} \quad \text{subject to} \quad \mathbf{A} \mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</script>
</div>
<p>이 문제는 라그랑주 승수를 사용하여 다음과 같이 분해할 수 있다.</p>
<p>라그랑주 승수 문제:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
L(\lambda) = \min_{\mathbf{x}} \left[ \mathbf{c}^T \mathbf{x} + \lambda^T (\mathbf{A} \mathbf{x} - \mathbf{b}) \right]
</div>
<script type="math/tex; mode=display">
L(\lambda) = \min_{\mathbf{x}} \left[ \mathbf{c}^T \mathbf{x} + \lambda^T (\mathbf{A} \mathbf{x} - \mathbf{b}) \right]
</script>
</div>
<p>라그랑주 함수 <span class="arithmatex"><span class="MathJax_Preview">L(\lambda)</span><script type="math/tex">L(\lambda)</script></span>는 병렬로 각 하위 문제를 해결할 수 있는 형태로 변환된다.</p>
<h3 id="preconditioning">프리컨디셔닝(Preconditioning)과 병렬 계산</h3>
<p>대규모의 선형계획 문제에서는 병렬 계산의 효율성을 높이기 위해 <strong>프리컨디셔닝(Preconditioning)</strong> 기법을 사용하는 것이 중요하다. 프리컨디셔닝은 연립 방정식의 해를 구할 때 계산 과정을 더 빠르게 수렴시키기 위해 사용된다. 병렬 계산에서 특히 유용한 이유는, 각 프로세서에서 계산할 작업의 상태를 보다 균일하게 만들어 연산 속도를 향상시킬 수 있기 때문이다.</p>
<h4 id="_7">프리컨디셔닝의 개념</h4>
<p>프리컨디셔닝은 문제의 조건수를 줄여서 계산을 더 안정적으로 수행하게 만드는 과정이다. 선형 시스템 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}\mathbf{x} = \mathbf{b}</span><script type="math/tex">\mathbf{A}\mathbf{x} = \mathbf{b}</script></span>를 해결할 때, 프리컨디셔닝을 사용하면 새로운 시스템</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{M}^{-1}\mathbf{A}\mathbf{x} = \mathbf{M}^{-1}\mathbf{b}
</div>
<script type="math/tex; mode=display">
\mathbf{M}^{-1}\mathbf{A}\mathbf{x} = \mathbf{M}^{-1}\mathbf{b}
</script>
</div>
<p>을 해결하게 되며, 여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span>은 적절한 프리컨디셔너이다. 이 새로운 시스템에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 더 잘 조정된 행렬이 되어, 해를 구하는 과정에서 수렴 속도를 개선할 수 있다.</p>
<h3 id="_8">내부점 방법과 병렬 계산</h3>
<p><strong>내부점 방법(Interior Point Methods)</strong>은 대규모의 선형계획 문제를 해결하는 또 다른 중요한 방법이다. 내부점 방법은 단체법과는 달리 경계가 아닌, 다면체의 내부에서 최적해를 찾아가는 방식으로, 병렬 계산에 적합한 특성을 가지고 있다.</p>
<h4 id="_9">내부점 방법의 수식</h4>
<p>내부점 방법은 다음과 같은 최적화 문제를 해결하는 데 사용된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{x}} \mathbf{c}^T \mathbf{x} \quad \text{subject to} \quad \mathbf{A}\mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{x}} \mathbf{c}^T \mathbf{x} \quad \text{subject to} \quad \mathbf{A}\mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</script>
</div>
<p>여기서, 내부점 방법은 문제의 라그랑주 승수와 중심성 조건을 만족시키는 해를 찾아가는 방식으로 작동한다. 이를 위해 <strong>장벽 함수(Barrier Function)</strong>를 사용하여 문제를 내부에서 해결한다.</p>
<p>장벽 함수는 다음과 같이 표현될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\phi(\mathbf{x}) = -\sum_{i=1}^n \ln(x_i)
</div>
<script type="math/tex; mode=display">
\phi(\mathbf{x}) = -\sum_{i=1}^n \ln(x_i)
</script>
</div>
<p>이 장벽 함수는 제약 조건 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x} \geq 0</span><script type="math/tex">\mathbf{x} \geq 0</script></span>을 만족시키도록 하는 역할을 한다. 이와 같은 방식으로 내부점 방법은 다면체 내부에서 점진적으로 최적해로 수렴하게 된다.</p>
<h4 id="_10">병렬화된 내부점 방법</h4>
<p>내부점 방법의 병렬화는 주로 다음과 같은 두 부분에서 적용될 수 있다.</p>
<ol>
<li>
<p><strong>헤시안(Hessian) 행렬의 병렬 계산</strong>: 내부점 방법에서 중요한 부분은 라그랑주 승수와 관련된 헤시안 행렬을 계산하는 것이다. 이 행렬의 크기가 매우 클 수 있기 때문에, 이를 병렬로 분할하여 각 프로세서가 일부분씩 계산하게 하면 효율성을 높일 수 있다.</p>
</li>
<li>
<p><strong>뉴턴 단계의 병렬화</strong>: 내부점 방법은 뉴턴 방법을 사용하여 반복적으로 해를 갱신한다. 각 반복 단계에서의 뉴턴 방법 계산을 병렬화하여, 해를 더욱 빠르게 갱신할 수 있다.</p>
</li>
</ol>
<p>이러한 병렬화 전략을 적용하면 대규모 선형계획 문제도 보다 효율적으로 해결할 수 있다.</p>
<h3 id="multi-path-search">다중 경로 탐색(Multi-Path Search) 기법</h3>
<p>대규모 선형계획법 문제를 해결할 때는 다중 경로 탐색 기법을 통해 문제를 더욱 효율적으로 풀 수 있다. 이 기법은 여러 개의 경로를 동시에 탐색하여 최적해에 도달할 가능성을 높이는 방법이다. 병렬 계산 환경에서, 다중 경로 탐색은 각 경로를 서로 다른 프로세서에서 동시에 계산함으로써 성능을 향상시킬 수 있다.</p>
<h4 id="_11">다중 경로 탐색의 개념</h4>
<p>다중 경로 탐색은 여러 초기 조건에서 시작하여 각 경로가 독립적으로 해를 탐색하는 방식이다. 각 경로는 서로 다른 알고리즘이나 변수 선택 방법을 사용할 수 있으며, 이를 통해 문제의 복잡한 해 공간을 더 효율적으로 탐색할 수 있다.</p>
<p>다음은 간단한 다중 경로 탐색의 흐름도이다:</p>
<div class="mermaid">graph TD
    A[초기 조건 1] --&gt; B[탐색 경로 1]
    A[초기 조건 2] --&gt; C[탐색 경로 2]
    A[초기 조건 3] --&gt; D[탐색 경로 3]
    B --&gt; E[최적해 도달]
    C --&gt; E[최적해 도달]
    D --&gt; E[최적해 도달]
</div>
<p>이 방식에서는 각 탐색 경로가 독립적으로 병렬로 계산되며, 최종적으로 가장 우수한 해를 선택하게 된다.</p>
<h3 id="_12">분해 기법과 병렬 계산</h3>
<p>분해 기법은 대규모 문제를 여러 작은 하위 문제로 분해하여 해결하는 방식이다. 이러한 기법을 사용하면 각 하위 문제를 독립적으로 병렬화하여 계산할 수 있다. 선형계획법에서는 주로 다음과 같은 두 가지 분해 기법이 사용된다.</p>
<ol>
<li>
<p><strong>뱬더 분해 방법(Benders Decomposition)</strong>: 이 기법은 주로 결정 변수들이 두 개 이상의 하위 집합으로 자연스럽게 나뉘는 경우에 유용하다. 각 하위 문제는 서로 다른 변수 집합을 포함하며, 독립적으로 해결될 수 있다.</p>
</li>
<li>
<p><strong>듀얼 분해 방법(Dual Decomposition)</strong>: 듀얼 분해는 라그랑주 승수를 이용하여 원래 문제를 여러 작은 문제로 분해하는 방식이다. 각 하위 문제는 병렬로 해결할 수 있으며, 최종 해는 하위 문제들의 해를 결합하여 구한다.</p>
</li>
</ol>
<h4 id="_13">뱬더 분해 방법</h4>
<p>뱬더 분해 방법은 주로 다음과 같은 구조를 가진 선형계획 문제에 적용된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{x}, \mathbf{y}} \mathbf{c}^T \mathbf{x} + \mathbf{d}^T \mathbf{y}
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{x}, \mathbf{y}} \mathbf{c}^T \mathbf{x} + \mathbf{d}^T \mathbf{y}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{subject to} \quad \mathbf{A}\mathbf{x} + \mathbf{B}\mathbf{y} = \mathbf{b}, \quad \mathbf{x} \geq 0, \quad \mathbf{y} \geq 0
</div>
<script type="math/tex; mode=display">
\text{subject to} \quad \mathbf{A}\mathbf{x} + \mathbf{B}\mathbf{y} = \mathbf{b}, \quad \mathbf{x} \geq 0, \quad \mathbf{y} \geq 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}</span><script type="math/tex">\mathbf{y}</script></span>는 두 개의 독립적인 변수 집합이다. 이 문제를 뱬더 분해 방법을 사용하여 다음과 같이 분해할 수 있다.</p>
<ol>
<li><strong>주 문제(Master Problem)</strong>: <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>만을 포함하는 주 문제를 정의하고, 이를 먼저 해결한다.</li>
<li><strong>하위 문제(Subproblem)</strong>: 주 문제에서 구한 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>의 값을 이용하여, 하위 문제를 정의하고 이를 해결한다.</li>
</ol>
<p>이러한 분해 방식은 하위 문제들을 병렬로 계산하는 데 적합하며, 각 하위 문제는 서로 독립적으로 해결될 수 있다.</p>
<h4 id="_14">듀얼 분해 방법</h4>
<p>듀얼 분해 방법은 라그랑주 승수를 사용하여 원래 문제를 여러 하위 문제로 분해한다. 듀얼 분해는 다음과 같은 구조의 문제에 적용될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{x}} \mathbf{c}^T \mathbf{x} \quad \text{subject to} \quad \mathbf{A}\mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{x}} \mathbf{c}^T \mathbf{x} \quad \text{subject to} \quad \mathbf{A}\mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</script>
</div>
<p>이 문제는 라그랑주 승수 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>를 도입하여 다음과 같이 듀얼 문제로 변환된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
L(\lambda) = \min_{\mathbf{x}} \left( \mathbf{c}^T \mathbf{x} + \lambda^T (\mathbf{A}\mathbf{x} - \mathbf{b}) \right)
</div>
<script type="math/tex; mode=display">
L(\lambda) = \min_{\mathbf{x}} \left( \mathbf{c}^T \mathbf{x} + \lambda^T (\mathbf{A}\mathbf{x} - \mathbf{b}) \right)
</script>
</div>
<p>듀얼 문제는 각 하위 문제로 분해되어 병렬로 계산될 수 있으며, 최종 해는 각 하위 문제의 해를 결합하여 구한다.</p>
<h3 id="_15">대규모 선형계획 문제에서의 병렬 알고리즘</h3>
<p>대규모 선형계획 문제를 해결하기 위한 병렬 알고리즘은 주로 반복적인 행렬 연산, 벡터 연산, 그리고 제약 조건 처리 과정을 병렬화하는 데 집중된다. 다음은 대규모 문제에서 주로 사용되는 병렬 알고리즘의 몇 가지 예이다.</p>
<h4 id="split-and-gather-algorithm">분할 수집 알고리즘(Split-and-Gather Algorithm)</h4>
<p>분할 수집 알고리즘은 큰 문제를 여러 작은 문제로 나누고, 각 문제를 독립적으로 병렬 계산한 후, 그 결과를 수집하여 최종 해를 도출하는 방식이다.</p>
<p>다음은 분할 수집 알고리즘의 흐름도이다:</p>
<div class="mermaid">graph TD
    A[큰 문제] --&gt; B[작은 문제 1]
    A[큰 문제] --&gt; C[작은 문제 2]
    A[큰 문제] --&gt; D[작은 문제 3]
    B --&gt; E[결과 수집]
    C --&gt; E[결과 수집]
    D --&gt; E[결과 수집]
</div>
<p>이 알고리즘은 각 작은 문제를 병렬로 해결할 수 있으므로, 전체 계산 시간을 크게 줄일 수 있다.</p>
<h4 id="branch-and-bound-method">분지한정법(Branch-and-Bound Method) 병렬화</h4>
<p>분지한정법은 주로 정수계획법이나 혼합 정수계획법 문제에서 사용되는 기법이다. 이 방법은 문제를 여러 하위 문제로 분할한 후, 각 하위 문제를 해결하여 최적해를 찾아가는 방식이다. 병렬 계산에서는 각 하위 문제를 독립적으로 해결할 수 있으므로, 계산 성능을 크게 향상시킬 수 있다.</p>
<h4 id="_16">단체법의 병렬화</h4>
<p>단체법의 병렬화는 각 피봇팅 단계에서 병렬 연산을 적용하여 계산을 가속화하는 방식이다. 단체법에서는 표 형식(Simplex Tableau)을 사용하여 각 반복 단계에서 최적해를 찾아가는데, 이 표를 병렬로 처리하면 전체 연산 속도를 크게 향상시킬 수 있다.</p>
<h3 id="_17">대규모 문제 해결에서의 데이터 분할 기법</h3>
<p>대규모 선형계획 문제에서는 행렬의 크기가 커짐에 따라 메모리와 계산 자원이 빠르게 소모된다. 이러한 문제를 해결하기 위해, <strong>데이터 분할(Data Partitioning)</strong> 기법을 활용할 수 있다. 데이터 분할 기법은 문제의 데이터를 여러 개의 블록으로 나누어 병렬로 처리하는 방식이다.</p>
<h4 id="block-partitioning">블록 분할(Block Partitioning)</h4>
<p>블록 분할 기법은 큰 행렬을 여러 작은 블록으로 나누고, 각 블록을 독립적으로 처리하는 방식이다. 이를 통해 메모리 사용량을 줄일 수 있으며, 각 블록은 병렬로 처리될 수 있다.</p>
<p>다음은 큰 행렬을 블록으로 나누는 예시이다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} =
\begin{bmatrix}
\mathbf{A}_{11} &amp; \mathbf{A}_{12} \\
\mathbf{A}_{21} &amp; \mathbf{A}_{22}
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} =
\begin{bmatrix}
\mathbf{A}_{11} & \mathbf{A}_{12} \\
\mathbf{A}_{21} & \mathbf{A}_{22}
\end{bmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{ij}</span><script type="math/tex">\mathbf{A}_{ij}</script></span>는 작은 블록 행렬이며, 각 블록은 별도의 프로세서에서 병렬로 처리될 수 있다.</p>
<h3 id="_18">대규모 행렬 연산의 병렬화</h3>
<p>대규모 선형계획 문제에서는 반복적인 행렬 연산이 빈번하게 발생한다. 특히, 행렬 곱셈과 같은 연산은 계산 복잡도가 높기 때문에 병렬화의 효과가 크다. 일반적으로 다음과 같은 방식으로 병렬화를 적용할 수 있다.</p>
<h4 id="_19">행렬 곱셈의 병렬화</h4>
<p>행렬 곱셈은 다음과 같은 형태의 수식으로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \mathbf{A} \mathbf{B}
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \mathbf{A} \mathbf{B}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">m \times n</span><script type="math/tex">m \times n</script></span> 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">n \times p</span><script type="math/tex">n \times p</script></span> 행렬이며, 결과 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">m \times p</span><script type="math/tex">m \times p</script></span>의 크기를 갖는다.</p>
<p>병렬 계산에서는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>의 각 블록을 분할하여 병렬로 곱할 수 있다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>를 각각 다음과 같이 블록으로 분할할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} =
\begin{bmatrix}
\mathbf{A}_{11} &amp; \mathbf{A}_{12} \\
\mathbf{A}_{21} &amp; \mathbf{A}_{22}
\end{bmatrix}, \quad
\mathbf{B} =
\begin{bmatrix}
\mathbf{B}_{11} &amp; \mathbf{B}_{12} \\
\mathbf{B}_{21} &amp; \mathbf{B}_{22}
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} =
\begin{bmatrix}
\mathbf{A}_{11} & \mathbf{A}_{12} \\
\mathbf{A}_{21} & \mathbf{A}_{22}
\end{bmatrix}, \quad
\mathbf{B} =
\begin{bmatrix}
\mathbf{B}_{11} & \mathbf{B}_{12} \\
\mathbf{B}_{21} & \mathbf{B}_{22}
\end{bmatrix}
</script>
</div>
<p>그러면 결과 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>의 각 블록은 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C}_{11} = \mathbf{A}_{11} \mathbf{B}_{11} + \mathbf{A}_{12} \mathbf{B}_{21}
</div>
<script type="math/tex; mode=display">
\mathbf{C}_{11} = \mathbf{A}_{11} \mathbf{B}_{11} + \mathbf{A}_{12} \mathbf{B}_{21}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C}_{12} = \mathbf{A}_{11} \mathbf{B}_{12} + \mathbf{A}_{12} \mathbf{B}_{22}
</div>
<script type="math/tex; mode=display">
\mathbf{C}_{12} = \mathbf{A}_{11} \mathbf{B}_{12} + \mathbf{A}_{12} \mathbf{B}_{22}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C}_{21} = \mathbf{A}_{21} \mathbf{B}_{11} + \mathbf{A}_{22} \mathbf{B}_{21}
</div>
<script type="math/tex; mode=display">
\mathbf{C}_{21} = \mathbf{A}_{21} \mathbf{B}_{11} + \mathbf{A}_{22} \mathbf{B}_{21}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C}_{22} = \mathbf{A}_{21} \mathbf{B}_{12} + \mathbf{A}_{22} \mathbf{B}_{22}
</div>
<script type="math/tex; mode=display">
\mathbf{C}_{22} = \mathbf{A}_{21} \mathbf{B}_{12} + \mathbf{A}_{22} \mathbf{B}_{22}
</script>
</div>
<p>이 방식은 각 블록을 독립적으로 병렬로 처리할 수 있으므로, 대규모 행렬 곱셈에서 병렬화를 통해 성능을 크게 향상시킬 수 있다.</p>
<h3 id="_20">분산 계산 시스템에서의 선형계획법</h3>
<p>대규모 선형계획 문제를 해결하기 위해 분산 계산 시스템을 사용할 수도 있다. 분산 계산에서는 여러 개의 컴퓨터 노드가 네트워크를 통해 서로 연결되어, 각 노드가 독립적으로 연산을 수행한다. 이를 통해 단일 시스템에서 처리할 수 없는 대규모 문제를 해결할 수 있다.</p>
<h4 id="_21">분산 계산의 기본 원리</h4>
<p>분산 계산에서는 큰 문제를 여러 개의 작은 문제로 나눈 후, 각 노드에 할당하여 병렬로 처리한다. 각 노드는 독립적으로 계산을 수행하고, 그 결과를 중앙 서버로 전송하여 최종 해를 구하게 된다.</p>
<p>다음은 분산 계산의 기본 흐름도이다:</p>
<div class="mermaid">graph TD
    A[중앙 서버] --&gt; B[노드 1]
    A[중앙 서버] --&gt; C[노드 2]
    A[중앙 서버] --&gt; D[노드 3]
    B --&gt; E[결과 집합]
    C --&gt; E[결과 집합]
    D --&gt; E[결과 집합]
</div>
<h3 id="mapreduce">MapReduce를 이용한 선형계획 문제 해결</h3>
<p><strong>MapReduce</strong>는 대규모 데이터 처리를 위한 분산 계산 모델 중 하나로, 선형계획 문제에서도 적용할 수 있다. 이 모델에서는 데이터를 여러 개의 작은 블록으로 나누고, 각 블록을 병렬로 처리하여 결과를 수집한다.</p>
<h4 id="map">Map 단계</h4>
<p>Map 단계에서는 주어진 데이터를 여러 블록으로 나누고, 각 블록에서 독립적으로 연산을 수행한다. 이 과정에서 병렬 처리가 이루어지며, 각 블록의 처리 결과는 중간 데이터로 저장된다.</p>
<h4 id="reduce">Reduce 단계</h4>
<p>Reduce 단계에서는 Map 단계에서 생성된 중간 데이터를 수집하여 최종 결과를 도출한다. 이 과정에서도 병렬 처리가 적용될 수 있으며, 각 중간 데이터는 독립적으로 처리된다.</p>
<p>다음은 MapReduce의 흐름도이다:</p>
<div class="mermaid">graph TD
    A[입력 데이터] --&gt; B[Map 작업 1]
    A[입력 데이터] --&gt; C[Map 작업 2]
    A[입력 데이터] --&gt; D[Map 작업 3]
    B --&gt; E[중간 결과 1]
    C --&gt; F[중간 결과 2]
    D --&gt; G[중간 결과 3]
    E --&gt; H[Reduce 작업]
    F --&gt; H[Reduce 작업]
    G --&gt; H[Reduce 작업]
    H --&gt; I[최종 결과]
</div>
<h3 id="gpu">병렬 계산에서의 GPU 활용</h3>
<p>대규모 선형계획법 문제를 해결하기 위한 또 다른 중요한 방법은 <strong>그래픽 처리 장치(GPU, Graphics Processing Unit)</strong>를 활용한 병렬 계산이다. GPU는 많은 수의 코어를 가지고 있어 다중 스레드 병렬 계산에 매우 적합한다. 특히, 행렬 곱셈과 같은 벡터 연산이 빈번한 선형계획법 문제에서는 GPU의 성능을 활용하면 계산 속도를 크게 향상시킬 수 있다.</p>
<h4 id="gpu_1">GPU를 활용한 행렬 연산</h4>
<p>GPU는 수천 개의 작은 코어로 구성되어 있기 때문에, 각 코어에서 독립적인 연산을 동시에 수행할 수 있다. 다음은 GPU에서의 병렬 행렬 곱셈 과정이다.</p>
<p>행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>를 구하는 과정에서, 각 코어는 행렬의 원소 하나에 대한 연산을 담당하게 된다. 예를 들어, 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>의 곱을 계산할 때, GPU의 각 코어는 결과 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>의 한 원소 <span class="arithmatex"><span class="MathJax_Preview">C_{ij}</span><script type="math/tex">C_{ij}</script></span>를 계산한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
C_{ij} = \sum_{k} A_{ik} \cdot B_{kj}
</div>
<script type="math/tex; mode=display">
C_{ij} = \sum_{k} A_{ik} \cdot B_{kj}
</script>
</div>
<p>이 과정에서 <span class="arithmatex"><span class="MathJax_Preview">i, j</span><script type="math/tex">i, j</script></span>에 해당하는 각 <span class="arithmatex"><span class="MathJax_Preview">C_{ij}</span><script type="math/tex">C_{ij}</script></span>는 각각 다른 코어에서 병렬로 계산되며, 이를 통해 전체 행렬 곱셈이 매우 빠르게 이루어진다.</p>
<h4 id="cuda">CUDA를 이용한 병렬 계산</h4>
<p>CUDA(Compute Unified Device Architecture)는 GPU에서 병렬 처리를 지원하는 프로그래밍 모델로, 선형계획법 문제 해결에도 널리 사용된다. CUDA를 활용하면 다음과 같은 병렬 연산을 효율적으로 수행할 수 있다:</p>
<ol>
<li><strong>행렬 곱셈</strong>: GPU의 수천 개의 코어를 이용하여 행렬 곱셈을 병렬화할 수 있다.</li>
<li><strong>벡터 연산</strong>: 벡터 덧셈, 내적, 외적 등 벡터 연산을 병렬로 수행할 수 있다.</li>
<li><strong>최적화 문제의 반복 계산</strong>: 선형계획법의 반복적 알고리즘에서 각 반복을 병렬로 처리할 수 있다.</li>
</ol>
<h4 id="cuda_1">CUDA에서의 행렬 곱셈 예시</h4>
<p>다음은 CUDA에서 GPU를 활용한 간단한 행렬 곱셈 코드의 예시이다:</p>
<pre><code class="language-cpp">__global__ void matrixMultiply(float* A, float* B, float* C, int N) {
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int col = blockIdx.x * blockDim.x + threadIdx.x;

    float sum = 0.0;
    for (int k = 0; k &lt; N; k++) {
        sum += A[row * N + k] * B[k * N + col];
    }

    C[row * N + col] = sum;
}
</code></pre>
<p>이 코드는 GPU에서 병렬로 행렬 곱셈을 수행하는 방식이다. 각 스레드가 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>의 한 원소 <span class="arithmatex"><span class="MathJax_Preview">C_{ij}</span><script type="math/tex">C_{ij}</script></span>를 계산하고, 그 결과를 저장한다.</p>
<h3 id="clustering">대규모 선형계획법 문제의 클러스터링(Clustering)</h3>
<p><strong>클러스터링(Clustering)</strong>은 대규모 문제를 해결하는 또 다른 방법이다. 이 기법은 데이터나 문제의 구조를 분석하여, 유사한 성격을 가진 부분 문제들을 그룹화하고, 각 그룹을 독립적으로 병렬 처리하는 방식이다.</p>
<h4 id="_22">클러스터링의 원리</h4>
<p>클러스터링은 주어진 문제를 여러 개의 작은 클러스터로 나누고, 각 클러스터를 독립적으로 처리하는 기법이다. 예를 들어, 선형계획법에서 수많은 제약 조건이 있을 때, 이 제약 조건들을 유사한 특성을 가진 그룹으로 나누고, 각 그룹을 별도의 프로세서에서 병렬로 해결할 수 있다.</p>
<h4 id="_23">클러스터링과 분할 수집 알고리즘의 결합</h4>
<p>클러스터링과 분할 수집 알고리즘을 결합하면 더욱 효율적으로 대규모 문제를 해결할 수 있다. 클러스터링을 통해 문제를 여러 그룹으로 나눈 후, 각 그룹을 분할하여 병렬로 처리하고, 그 결과를 수집하여 최종 해를 도출하는 방식이다.</p>
<p>다음은 클러스터링과 분할 수집 알고리즘의 결합 흐름도이다:</p>
<div class="mermaid">graph TD
    A[입력 데이터] --&gt; B[클러스터링]
    B --&gt; C[클러스터 1]
    B --&gt; D[클러스터 2]
    B --&gt; E[클러스터 3]
    C --&gt; F[분할 처리 1]
    D --&gt; G[분할 처리 2]
    E --&gt; H[분할 처리 3]
    F --&gt; I[결과 수집]
    G --&gt; I[결과 수집]
    H --&gt; I[결과 수집]
    I --&gt; J[최종 해 도출]
</div>
<p>이 방식을 사용하면 각 클러스터가 독립적으로 병렬 처리되므로, 대규모 문제 해결 속도가 크게 향상된다.</p>
<h3 id="synchronization">병렬 계산에서의 동기화(Synchronization) 문제</h3>
<p>병렬 계산을 수행할 때는 각 프로세서가 독립적으로 작업을 수행하지만, 계산의 중간 단계에서 결과를 공유하거나 결합할 때 <strong>동기화(Synchronization)</strong>가 필요하다. 동기화가 제대로 이루어지지 않으면 계산 결과가 왜곡되거나 충돌이 발생할 수 있다.</p>
<h4 id="_24">동기화 기법</h4>
<p>병렬 계산에서 동기화를 효과적으로 처리하기 위한 여러 가지 기법이 있다. 그 중 가장 일반적인 방법은 다음과 같다:</p>
<ol>
<li>
<p><strong>배리어 동기화(Barrier Synchronization)</strong>: 모든 프로세서가 특정 지점에 도달할 때까지 기다린 후, 다음 단계로 이동한다. 이를 통해 모든 프로세서가 동일한 상태에서 다음 연산을 시작할 수 있다.</p>
</li>
<li>
<p><strong>락(Lock)</strong>과 <strong>뮤텍스(Mutex)</strong>: 특정 자원에 대해 동시에 접근하지 못하게 하여 충돌을 방지하는 방법이다. 프로세서가 특정 자원을 사용하려고 할 때, 락을 걸어 다른 프로세서가 접근하지 못하도록 한다.</p>
</li>
</ol>
<h4 id="_25">병렬 연산에서의 동기화 이슈 해결</h4>
<p>동기화 문제를 해결하는 가장 중요한 요소는 각 프로세서가 독립적으로 수행할 수 있는 작업을 최대한으로 분할하고, 필요한 최소한의 시점에서만 동기화를 수행하는 것이다. 이렇게 하면 병렬 처리의 성능을 최대화하면서도 동기화로 인한 문제를 최소화할 수 있다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../1104/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../1104/">
        대규모 산업 응용 사례
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../1102/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../1102/">
        분해 기법의 적용 사례
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>