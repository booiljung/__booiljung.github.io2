<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/applied_math/optimization_theory/linear_programming/chapter_15/1503/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>연속형 문제 해결을 위한 방법론 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "1. \uc5f0\uc18d\ud615 \ubb38\uc81c\uc758 \uc815\uc758", url: "#_top", children: [
          ]},
          {title: "2. \uc5f0\uc18d\ud615 \ubb38\uc81c \ud574\uacb0\uc758 \uae30\ubcf8 \uc6d0\ub9ac", url: "#2", children: [
              {title: "2.1 \ub2e8\uccb4\ubc95 (Simplex Method)", url: "#21-simplex-method" },
          ]},
          {title: "2.2 \ub0b4\ubd80\uc810 \ubc29\ubc95 (Interior-Point Method)", url: "#22-interior-point-method", children: [
          ]},
          {title: "3. \ud504\ub9ac\uba40-\ub4c0\uc5bc \ub0b4\ubd80\uc810 \ubc29\ubc95", url: "#3-", children: [
              {title: "3.1 \uc54c\uace0\ub9ac\uc998 \uc808\ucc28", url: "#31" },
              {title: "3.2 \ub0b4\ubd80\uc810 \ubc29\ubc95\uc758 \uc774\uc810", url: "#32" },
          ]},
          {title: "4. \uce74\ub974\ub9c8\ub974\uce74\ub974 \uc54c\uace0\ub9ac\uc998 (Karmarkar\u0027s Algorithm)", url: "#4-karmarkars-algorithm", children: [
              {title: "4.1 \uce74\ub974\ub9c8\ub974\uce74\ub974 \uc54c\uace0\ub9ac\uc998\uc758 \uae30\ubcf8 \uc6d0\ub9ac", url: "#41" },
              {title: "4.2 \ubcc0\ud658 \ubc0f \uc2a4\ucf00\uc77c\ub9c1", url: "#42" },
              {title: "4.3 \uc54c\uace0\ub9ac\uc998 \uc808\ucc28", url: "#43" },
              {title: "4.4 \uce74\ub974\ub9c8\ub974\uce74\ub974 \uc54c\uace0\ub9ac\uc998\uc758 \uc131\ub2a5", url: "#44" },
          ]},
          {title: "5. \uacbd\uacc4\uc810 \ubc29\ubc95\uacfc\uc758 \ube44\uad50", url: "#5", children: [
              {title: "5.1 \uacbd\uacc4\uc810 \ubc29\ubc95\uc758 \ud2b9\uc9d5", url: "#51" },
              {title: "5.2 \ub0b4\ubd80\uc810 \ubc29\ubc95\uacfc \uacbd\uacc4\uc810 \ubc29\ubc95\uc758 \ube44\uad50", url: "#52" },
              {title: "5.3 \uc120\ud0dd \uae30\uc900", url: "#53" },
          ]},
          {title: "6. \ud504\ub9ac\uba40-\ub4c0\uc5bc \ub0b4\ubd80\uc810 \ubc29\ubc95\uc758 \uad6c\uccb4\uc801\uc778 \uc801\uc6a9", url: "#6-", children: [
              {title: "6.1 \ucd08\uae30 \ud574 \uc124\uc815", url: "#61" },
              {title: "6.2 \ubaa9\uc801 \ud568\uc218 \ubc0f \uc81c\uc57d \uc870\uac74 \ud45c\ud604", url: "#62" },
              {title: "6.3 \ubc18\ubcf5\uc801 \uac31\uc2e0 \uacfc\uc815", url: "#63" },
              {title: "6.4 \uc218\ub834 \uc870\uac74", url: "#64" },
          ]},
          {title: "7. \ub300\uaddc\ubaa8 \ubb38\uc81c\uc5d0 \ub300\ud55c \uc801\uc6a9", url: "#7", children: [
              {title: "7.1 \ubcd1\ub82c \uacc4\uc0b0 \uae30\ubc95", url: "#71" },
              {title: "7.2 \uc2e4\uc6a9\uc801\uc778 \uc751\uc6a9 \uc0ac\ub840", url: "#72" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1504/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1504/" class="btn btn-xs btn-link">
        경계점 분석 및 해석
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1502/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1502/" class="btn btn-xs btn-link">
        연속형 최적화의 특성
      </a>
    </div>
    
  </div>

    

    <h3 id="1">1. 연속형 문제의 정의</h3>
<p>연속형 선형계획법에서 다루는 문제는 변수들이 연속적으로 변화할 수 있는 범위를 가진다. 기본적인 선형계획 문제와 마찬가지로 목적 함수는 선형식이며, 제약 조건 역시 선형식으로 주어진다. 연속형 문제는 특히 생산 계획, 자원 배분 등의 실세계 문제에서 유용하게 사용된다.</p>
<p>연속형 선형계획 문제는 일반적으로 다음과 같은 형태로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{최소화 혹은 최대화:} \quad \mathbf{c}^\top \mathbf{x}
</div>
<script type="math/tex; mode=display">
\text{최소화 혹은 최대화:} \quad \mathbf{c}^\top \mathbf{x}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{제약 조건:} \quad \mathbf{A}\mathbf{x} \leq \mathbf{b}, \quad \mathbf{x} \geq \mathbf{0}
</div>
<script type="math/tex; mode=display">
\text{제약 조건:} \quad \mathbf{A}\mathbf{x} \leq \mathbf{b}, \quad \mathbf{x} \geq \mathbf{0}
</script>
</div>
<p>여기서,<br />
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span>는 목적 함수의 계수 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>는 결정 변수 벡터,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 제약 조건을 정의하는 계수 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>는 제약 조건 벡터이다.</p>
<h3 id="2">2. 연속형 문제 해결의 기본 원리</h3>
<p>연속형 문제는 본질적으로 단체법(Simplex Method)이나 내부점 방법(Interior-Point Method)으로 해결된다. 이 중 단체법은 기저해를 탐색하는 방식으로 극점을 순차적으로 이동하며 최적해를 구하는 반면, 내부점 방법은 문제의 내부에서 시작해 최적해를 향해 접근하는 방식이다.</p>
<h4 id="21-simplex-method">2.1 단체법 (Simplex Method)</h4>
<p>단체법은 가장 오래된 선형계획 문제 해결 알고리즘 중 하나로, 단체법의 핵심은 기저 해의 개념을 바탕으로 한다. 선형계획 문제의 가능 영역은 다면체로 표현될 수 있으며, 단체법은 이 다면체의 꼭짓점을 순차적으로 탐색하면서 목적 함수 값을 개선해 나간다.</p>
<p>단체법의 일반적인 절차는 다음과 같다:
1. 초기 기저 해를 선택한다.
2. 현재 해가 최적인지 확인한다. 그렇지 않으면, 목적 함수 값을 개선할 수 있는 변수를 선택한다.
3. 선택된 변수에 대해 피벗 연산을 수행하여 새로운 기저 해를 얻는다.
4. 최적해에 도달할 때까지 2~3단계를 반복한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{B}\mathbf{x}_B = \mathbf{b}, \quad \mathbf{N}\mathbf{x}_N = 0
</div>
<script type="math/tex; mode=display">
\mathbf{B}\mathbf{x}_B = \mathbf{b}, \quad \mathbf{N}\mathbf{x}_N = 0
</script>
</div>
<p>여기서,<br />
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 기저 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_B</span><script type="math/tex">\mathbf{x}_B</script></span>는 기저 변수,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{N}</span><script type="math/tex">\mathbf{N}</script></span>는 비기저 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_N</span><script type="math/tex">\mathbf{x}_N</script></span>는 비기저 변수이다.</p>
<p>단체법은 가능 영역의 꼭짓점을 따라 이동하기 때문에 매우 효율적일 수 있지만, 대규모의 문제에서는 피벗 연산의 복잡성으로 인해 계산 시간이 길어질 수 있다.</p>
<h3 id="22-interior-point-method">2.2 내부점 방법 (Interior-Point Method)</h3>
<p>내부점 방법은 단체법과는 다르게, 문제의 경계에서 시작하지 않고 내부에서부터 해를 찾는다. 이 방법은 연속적으로 변하는 결정 변수를 다루기 때문에, 연속형 문제 해결에 있어 매우 효율적이다.</p>
<p>내부점 방법의 기본 아이디어는 불가능 영역을 침범하지 않으면서 가능 영역 내부에서 최적화 경로를 찾는 것이다. 이 과정에서 카르마르카르 알고리즘(Karmarkar's Algorithm)이 대표적인 방법 중 하나로 사용된다.</p>
<p>카르마르카르 알고리즘은 선형계획 문제를 변환하여 다음과 같은 형태로 만든다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min \quad \mathbf{c}^\top \mathbf{x} \quad \text{subject to} \quad \mathbf{A}\mathbf{x} = \mathbf{b}, \quad \mathbf{x} &gt; 0
</div>
<script type="math/tex; mode=display">
\min \quad \mathbf{c}^\top \mathbf{x} \quad \text{subject to} \quad \mathbf{A}\mathbf{x} = \mathbf{b}, \quad \mathbf{x} > 0
</script>
</div>
<p>내부점 방법은 대규모 문제에서도 좋은 성능을 보이며, 특히 고차원의 문제나 변수가 많은 문제에서 효과적이다. 내부점 방법은 기본적으로 프리멀-듀얼 알고리즘(Primal-Dual Algorithm)을 사용하여 최적해에 수렴한다.</p>
<h3 id="3-">3. 프리멀-듀얼 내부점 방법</h3>
<p>프리멀-듀얼 내부점 방법은 연속형 선형계획 문제를 해결할 때 자주 사용되는 알고리즘이다. 이 방법은 프리멀 문제와 그에 대응하는 듀얼 문제를 동시에 풀어나가며, 두 문제의 해가 최적점에서 수렴하도록 유도한다.</p>
<p>프리멀 문제는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min \mathbf{c}^\top \mathbf{x} \quad \text{subject to} \quad \mathbf{A}\mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</div>
<script type="math/tex; mode=display">
\min \mathbf{c}^\top \mathbf{x} \quad \text{subject to} \quad \mathbf{A}\mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</script>
</div>
<p>이에 대응하는 듀얼 문제는:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\max \mathbf{b}^\top \mathbf{y} \quad \text{subject to} \quad \mathbf{A}^\top \mathbf{y} \leq \mathbf{c}
</div>
<script type="math/tex; mode=display">
\max \mathbf{b}^\top \mathbf{y} \quad \text{subject to} \quad \mathbf{A}^\top \mathbf{y} \leq \mathbf{c}
</script>
</div>
<p>프리멀-듀얼 내부점 방법은 이 두 문제를 동시에 고려하여 해를 찾아 나가는 과정이다. 알고리즘은 프리멀 해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>와 듀얼 해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}</span><script type="math/tex">\mathbf{y}</script></span>를 반복적으로 업데이트하면서 최적화 경로를 형성한다.</p>
<h4 id="31">3.1 알고리즘 절차</h4>
<p>프리멀-듀얼 내부점 방법은 일반적으로 다음과 같은 절차를 따른다:</p>
<ol>
<li>초기 프리멀 해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_0</span><script type="math/tex">\mathbf{x}_0</script></span>와 듀얼 해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}_0</span><script type="math/tex">\mathbf{y}_0</script></span>를 설정한다.</li>
<li>라그랑주 승수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\lambda}</span><script type="math/tex">\mathbf{\lambda}</script></span>를 도입하여 목적 함수와 제약 조건을 하나의 식으로 결합한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
L(\mathbf{x}, \mathbf{y}, \mathbf{\lambda}) = \mathbf{c}^\top \mathbf{x} - \mathbf{\lambda}^\top (\mathbf{A}\mathbf{x} - \mathbf{b}) - \mathbf{y}^\top (\mathbf{A}^\top \mathbf{y} - \mathbf{c})
</div>
<script type="math/tex; mode=display">
L(\mathbf{x}, \mathbf{y}, \mathbf{\lambda}) = \mathbf{c}^\top \mathbf{x} - \mathbf{\lambda}^\top (\mathbf{A}\mathbf{x} - \mathbf{b}) - \mathbf{y}^\top (\mathbf{A}^\top \mathbf{y} - \mathbf{c})
</script>
</div>
<ol>
<li>KKT 조건(Karush-Kuhn-Tucker Conditions)을 이용해 최적해를 찾는 시스템을 구축한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
    \nabla_{\mathbf{x}} L(\mathbf{x}, \mathbf{y}, \mathbf{\lambda}) &amp;= \mathbf{c} - \mathbf{A}^\top \mathbf{\lambda} = 0 \\
    \nabla_{\mathbf{y}} L(\mathbf{x}, \mathbf{y}, \mathbf{\lambda}) &amp;= \mathbf{b} - \mathbf{A}\mathbf{x} = 0 \\
    \mathbf{x} &amp;\geq 0, \quad \mathbf{y} \geq 0
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
    \nabla_{\mathbf{x}} L(\mathbf{x}, \mathbf{y}, \mathbf{\lambda}) &= \mathbf{c} - \mathbf{A}^\top \mathbf{\lambda} = 0 \\
    \nabla_{\mathbf{y}} L(\mathbf{x}, \mathbf{y}, \mathbf{\lambda}) &= \mathbf{b} - \mathbf{A}\mathbf{x} = 0 \\
    \mathbf{x} &\geq 0, \quad \mathbf{y} \geq 0
\end{aligned}
</script>
</div>
<ol>
<li>각 반복 단계에서, 프리멀 해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>와 듀얼 해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}</span><script type="math/tex">\mathbf{y}</script></span>를 업데이트하여 수렴해 나간다. 이때 내부점 방법 특유의 중심 경로(central path)를 따르는 방식으로, 프리멀-듀얼 해가 점차 최적화된다.</li>
</ol>
<h4 id="32">3.2 내부점 방법의 이점</h4>
<p>프리멀-듀얼 내부점 방법은 특히 고차원 문제나 제약 조건이 복잡한 문제에서 강력한 성능을 발휘한다. 대규모 선형계획 문제에서 단체법과 비교했을 때, 내부점 방법은 더 적은 반복을 통해 해를 찾을 수 있는 경향이 있다. 특히 수천 개 이상의 변수를 가진 문제에서 이점이 크다.</p>
<p>프리멀-듀얼 내부점 방법은 대규모 문제에서 계산 시간을 줄일 수 있도록 병렬 계산과도 잘 호환되며, 많은 상용 선형계획 소프트웨어에서 사용되고 있다.</p>
<h3 id="4-karmarkars-algorithm">4. 카르마르카르 알고리즘 (Karmarkar's Algorithm)</h3>
<p>카르마르카르 알고리즘은 내부점 방법 중 가장 대표적인 알고리즘 중 하나로, 특히 대규모 선형계획 문제에서 매우 효과적이다. 1984년 개발된 이 알고리즘은 단체법과는 달리 가능 영역의 경계에 도달하지 않고 내부에서 최적화 경로를 찾아간다.</p>
<h4 id="41">4.1 카르마르카르 알고리즘의 기본 원리</h4>
<p>카르마르카르 알고리즘은 문제를 다음과 같은 표준 형태로 변환하여 처리한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min \quad \mathbf{c}^\top \mathbf{x} \quad \text{subject to} \quad \mathbf{A}\mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</div>
<script type="math/tex; mode=display">
\min \quad \mathbf{c}^\top \mathbf{x} \quad \text{subject to} \quad \mathbf{A}\mathbf{x} = \mathbf{b}, \quad \mathbf{x} \geq 0
</script>
</div>
<p>카르마르카르 알고리즘은 기본적으로 고정된 크기의 스텝을 사용하여 중심 경로를 따라 이동하며 해를 찾는다. 이 과정에서 불가능 영역을 넘어서지 않도록 스텝의 크기를 조절하고, 점차 최적해에 접근한다.</p>
<h4 id="42">4.2 변환 및 스케일링</h4>
<p>카르마르카르 알고리즘의 핵심은 문제를 표준 형태로 변환한 후, 좌표 변환을 통해 새로운 공간에서 문제를 풀어 나가는 것이다. 이 좌표 변환은 가능 영역의 크기를 축소시켜 문제를 더욱 쉽게 해결할 수 있도록 도와준다.</p>
<p>구체적으로, 현재의 해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_k</span><script type="math/tex">\mathbf{x}_k</script></span>에서 새로운 변수를 정의하여 변환을 수행한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y} = \mathbf{D}^{-1}\mathbf{x}
</div>
<script type="math/tex; mode=display">
\mathbf{y} = \mathbf{D}^{-1}\mathbf{x}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>는 대각 행렬로, 각 변수의 스케일을 조절하여 문제를 변환한다.</p>
<h4 id="43">4.3 알고리즘 절차</h4>
<p>카르마르카르 알고리즘의 기본 절차는 다음과 같다:</p>
<ol>
<li>초기 해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_0</span><script type="math/tex">\mathbf{x}_0</script></span>를 설정하고, 이를 표준 형태로 변환한다.</li>
<li>새로운 좌표계로 변환된 문제에서 목적 함수 값을 개선할 수 있는 방향을 찾는다.</li>
<li>선택된 방향으로 고정된 크기의 스텝을 이동한다. 이때 스텝의 크기는 가능 영역을 벗어나지 않도록 조정된다.</li>
<li>반복적으로 해를 개선해 나가며, 최적해에 도달할 때까지 이 과정을 반복한다.</li>
</ol>
<p>카르마르카르 알고리즘의 각 단계에서, 다음과 같은 형태로 목적 함수가 갱신된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{k+1} = \mathbf{x}_k + \alpha \mathbf{d}_k
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{k+1} = \mathbf{x}_k + \alpha \mathbf{d}_k
</script>
</div>
<p>여기서,<br />
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{k+1}</span><script type="math/tex">\mathbf{x}_{k+1}</script></span>는 새로운 해,
- <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 스텝 크기,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_k</span><script type="math/tex">\mathbf{d}_k</script></span>는 개선 방향 벡터이다.</p>
<h4 id="44">4.4 카르마르카르 알고리즘의 성능</h4>
<p>카르마르카르 알고리즘은 대규모 문제에서 특히 강력한 성능을 보이며, 수천 개의 변수를 가진 문제에서도 비교적 빠르게 수렴한다. 내부점 방법이기 때문에, 단체법처럼 다면체의 경계에서 꼭짓점들을 순차적으로 탐색하는 대신, 중앙 경로를 따라가며 문제를 해결한다.</p>
<p>카르마르카르 알고리즘은 실제 응용 분야에서 널리 사용되고 있으며, 많은 선형계획 소프트웨어에서 구현되어 있다. </p>
<h3 id="5">5. 경계점 방법과의 비교</h3>
<p>연속형 선형계획 문제를 해결할 때 내부점 방법과 경계점 방법은 서로 상반된 방식으로 접근한다. 경계점 방법은 주로 단체법(SIMPLEX Method)을 기반으로 하여, 문제의 가능 영역 경계를 따라 이동하며 최적해를 찾는 방식이다. 반면 내부점 방법은 가능 영역의 내부에서 출발하여 해를 탐색한다.</p>
<h4 id="51">5.1 경계점 방법의 특징</h4>
<p>경계점 방법의 핵심은 다면체로 표현되는 가능 영역의 꼭짓점(극점)을 따라 이동하면서, 각 꼭짓점에서 목적 함수 값을 개선하는 것이다. 경계점 방법은 가능 영역 내의 기저 해가 꼭짓점에서 형성된다는 사실을 활용하여 최적해를 찾는다. 따라서, 해를 구하는 과정에서 항상 다면체의 경계를 따라 이동하게 된다.</p>
<p>경계점 방법의 대표적인 예는 단체법이며, 그 과정은 다음과 같다:
1. 초기 기저 해를 설정한다.
2. 현재 해에서 목적 함수 값을 개선할 수 있는 방향으로 이동할 다음 극점을 선택한다.
3. 다음 극점에서 다시 목적 함수 값을 개선할 수 있는지 확인하고, 더 이상 개선할 수 없는 시점에서 최적해에 도달한다.</p>
<p>경계점 방법의 장점은 다음과 같다:
- 해를 찾는 과정이 직관적이고, 각 단계에서 목적 함수 값이 확실하게 개선된다.
- 경계점에서 최적해가 존재할 경우, 빠르게 수렴할 수 있다.</p>
<p>하지만, 경계점 방법의 단점은 다음과 같다:
- 문제의 규모가 커질수록 가능한 기저 해(극점)의 수가 급격하게 증가하여 계산 시간이 길어질 수 있다.
- 퇴행(degeneracy) 현상이 발생할 경우, 해를 개선하지 못하는 상황에서 같은 극점을 반복적으로 방문하는 문제가 생길 수 있다.</p>
<h4 id="52">5.2 내부점 방법과 경계점 방법의 비교</h4>
<p>내부점 방법과 경계점 방법은 서로 다른 방식으로 선형계획 문제를 해결하지만, 두 방법 모두 선형 문제에서의 해를 찾는 데 매우 유효하다. 내부점 방법은 가능 영역 내부에서 최적화 경로를 따라 이동하며, 경계점 방법은 가능 영역의 극점들을 순차적으로 탐색한다.</p>
<p><strong>내부점 방법의 장점:</strong>
- 대규모 문제에서도 빠르게 수렴하는 경향이 있다.
- 가능 영역의 내부에서 최적화를 수행하므로 퇴행 문제를 겪지 않는다.
- 프리멀-듀얼 알고리즘을 사용하여 문제를 효율적으로 해결할 수 있다.</p>
<p><strong>경계점 방법의 장점:</strong>
- 경계점에서 최적해를 구할 수 있는 경우, 직관적으로 해를 찾을 수 있다.
- 단체법과 같은 방법은 역사적으로 널리 연구되고, 다양한 문제에 적용되어 왔다.</p>
<p><strong>내부점 방법의 단점:</strong>
- 초기 해 설정이 중요하며, 잘못된 초기 해로 인해 수렴 속도가 느려질 수 있다.
- 문제의 구조에 따라 계산 비용이 높아질 수 있다.</p>
<p><strong>경계점 방법의 단점:</strong>
- 고차원 문제에서 극점의 수가 기하급수적으로 증가하여 계산 시간이 길어질 수 있다.
- 퇴행 문제로 인해 같은 극점을 반복적으로 방문할 수 있다.</p>
<h4 id="53">5.3 선택 기준</h4>
<p>문제를 해결할 때 내부점 방법을 사용할지, 경계점 방법을 사용할지는 주로 문제의 규모와 특성에 따라 결정된다. 내부점 방법은 대규모 문제에서 유리하며, 경계점 방법은 비교적 작은 문제에서 직관적인 해를 빠르게 구할 수 있다. 대규모 문제에서는 내부점 방법이 더 효율적이지만, 작은 규모의 문제에서는 경계점 방법이 여전히 실용적이다.</p>
<h3 id="6-">6. 프리멀-듀얼 내부점 방법의 구체적인 적용</h3>
<p>프리멀-듀얼 내부점 방법은 대규모 선형계획 문제에서도 높은 효율을 보이며, 다양한 산업과 연구 분야에서 활용된다. 이 방법은 연속형 선형계획 문제를 해결하는 데 있어 매우 일반적이며, 다양한 소프트웨어 도구에도 적용되어 있다. 여기에서는 프리멀-듀얼 내부점 방법의 구체적인 적용 과정을 설명한다.</p>
<h4 id="61">6.1 초기 해 설정</h4>
<p>프리멀-듀얼 내부점 방법을 사용하기 위해서는 우선 초기 프리멀 해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_0</span><script type="math/tex">\mathbf{x}_0</script></span>와 듀얼 해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}_0</span><script type="math/tex">\mathbf{y}_0</script></span>를 설정해야 한다. 초기 해는 임의로 설정될 수 있지만, 보통 문제의 성질에 맞춰 적절하게 선택되는 것이 중요하다. 초기 해는 가능 영역 내에 존재해야 하며, 이를 위해 인공 변수를 사용하거나 다양한 초기화 방법을 통해 시작점을 설정할 수 있다.</p>
<h4 id="62">6.2 목적 함수 및 제약 조건 표현</h4>
<p>프리멀-듀얼 내부점 방법에서 목적 함수와 제약 조건은 라그랑주 승수를 도입하여 하나의 최적화 문제로 결합된다. 이를 통해 프리멀 문제와 듀얼 문제를 동시에 풀어나가는 방식으로 최적해에 접근한다.</p>
<p>목적 함수는 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
L(\mathbf{x}, \mathbf{y}, \mathbf{\lambda}) = \mathbf{c}^\top \mathbf{x} - \mathbf{\lambda}^\top (\mathbf{A}\mathbf{x} - \mathbf{b}) - \mathbf{y}^\top (\mathbf{A}^\top \mathbf{y} - \mathbf{c})
</div>
<script type="math/tex; mode=display">
L(\mathbf{x}, \mathbf{y}, \mathbf{\lambda}) = \mathbf{c}^\top \mathbf{x} - \mathbf{\lambda}^\top (\mathbf{A}\mathbf{x} - \mathbf{b}) - \mathbf{y}^\top (\mathbf{A}^\top \mathbf{y} - \mathbf{c})
</script>
</div>
<p>여기서,<br />
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>는 프리멀 변수,<br />
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}</span><script type="math/tex">\mathbf{y}</script></span>는 듀얼 변수,<br />
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\lambda}</span><script type="math/tex">\mathbf{\lambda}</script></span>는 라그랑주 승수이다.</p>
<p>제약 조건은 프리멀 문제의 경우 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}\mathbf{x} = \mathbf{b}</span><script type="math/tex">\mathbf{A}\mathbf{x} = \mathbf{b}</script></span>, 듀얼 문제의 경우 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}^\top \mathbf{y} \leq \mathbf{c}</span><script type="math/tex">\mathbf{A}^\top \mathbf{y} \leq \mathbf{c}</script></span>로 주어진다. 이 제약 조건을 만족시키면서 해를 구하는 것이 목표이다.</p>
<h4 id="63">6.3 반복적 갱신 과정</h4>
<p>프리멀-듀얼 내부점 방법은 반복적으로 프리멀 변수와 듀얼 변수를 갱신해 나가면서 최적해에 수렴한다. 이 과정은 중심 경로를 따라 이동하는 방식으로 진행되며, 각 반복 단계에서 새로운 프리멀 해와 듀얼 해를 계산한다.</p>
<p>각 단계에서 프리멀 변수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_k</span><script type="math/tex">\mathbf{x}_k</script></span>와 듀얼 변수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}_k</span><script type="math/tex">\mathbf{y}_k</script></span>는 다음과 같이 갱신된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{k+1} = \mathbf{x}_k + \alpha \mathbf{d}_k^x
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{k+1} = \mathbf{x}_k + \alpha \mathbf{d}_k^x
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}_{k+1} = \mathbf{y}_k + \alpha \mathbf{d}_k^y
</div>
<script type="math/tex; mode=display">
\mathbf{y}_{k+1} = \mathbf{y}_k + \alpha \mathbf{d}_k^y
</script>
</div>
<p>여기서,<br />
- <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 스텝 크기,<br />
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_k^x</span><script type="math/tex">\mathbf{d}_k^x</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_k^y</span><script type="math/tex">\mathbf{d}_k^y</script></span>는 각각 프리멀 해와 듀얼 해의 개선 방향이다.</p>
<p>각 반복 단계에서 스텝 크기 <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 주어진 제약 조건을 침범하지 않도록 조정되며, 개선 방향 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_k^x</span><script type="math/tex">\mathbf{d}_k^x</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_k^y</span><script type="math/tex">\mathbf{d}_k^y</script></span>는 목적 함수 값을 최대한 빠르게 개선할 수 있도록 결정된다.</p>
<h4 id="64">6.4 수렴 조건</h4>
<p>프리멀-듀얼 내부점 방법에서 수렴 조건은 두 가지로 나뉜다:
1. 프리멀 해와 듀얼 해가 모두 최적 조건을 만족하는가?
2. 프리멀 해와 듀얼 해가 서로 충분히 가까운가?</p>
<p>최종적으로 프리멀 해와 듀얼 해가 수렴하면, 해당 해는 최적해로 간주된다. 이때 프리멀 문제와 듀얼 문제 모두에서 최적화 조건을 만족해야 한다.</p>
<h3 id="7">7. 대규모 문제에 대한 적용</h3>
<p>프리멀-듀얼 내부점 방법은 대규모 문제에 대해서도 매우 효율적이다. 이는 특히 많은 변수를 다루는 문제에서, 경계점 방법에 비해 더 빠르게 수렴할 수 있다는 장점이 있다. 프리멀-듀얼 내부점 방법은 병렬 처리가 가능하여, 고성능 컴퓨팅 환경에서 더 빠르게 해를 구할 수 있다.</p>
<h4 id="71">7.1 병렬 계산 기법</h4>
<p>내부점 방법은 병렬 계산에 적합한 알고리즘 구조를 가지고 있다. 프리멀 변수와 듀얼 변수를 독립적으로 갱신할 수 있는 구조이기 때문에, 각 변수의 갱신 과정에서 병렬 처리를 활용할 수 있다. 이는 대규모 문제에서 계산 시간을 대폭 단축시키는 중요한 요소이다.</p>
<h4 id="72">7.2 실용적인 응용 사례</h4>
<p>대규모 문제에서 프리멀-듀얼 내부점 방법은 여러 산업 분야에 걸쳐 응용되고 있다. 예를 들어, 에너지 최적화 문제, 물류 최적화 문제, 금융 포트폴리오 최적화 문제 등에서 널리 사용되며, 상용 소프트웨어에서도 자주 구현된다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1504/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1504/" class="btn btn-xs btn-link">
        경계점 분석 및 해석
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1502/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1502/" class="btn btn-xs btn-link">
        연속형 최적화의 특성
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>