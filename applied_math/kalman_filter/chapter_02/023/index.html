<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/applied_math/kalman_filter/chapter_02/023/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>선형 시스템의 기본 이론 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc120\ud615 \uc2dc\uc2a4\ud15c\uc758 \uc815\uc758", url: "#_top", children: [
          ]},
          {title: "\uc120\ud615 \uc2dc\uc2a4\ud15c\uc758 \uc2dc\uac04 \ubd88\ubcc0\uc131 (Time-Invariance)", url: "#time-invariance", children: [
          ]},
          {title: "\uc120\ud615 \uc5f0\uc0b0\uc790\uc758 \ud2b9\uc131", url: "#_2", children: [
          ]},
          {title: "\uc0c1\ud0dc \uacf5\uac04 \ud45c\ud604(State-Space Representation)", url: "#state-space-representation", children: [
          ]},
          {title: "\uc120\ud615 \uc2dc\uc2a4\ud15c\uc758 \uc804\ub2ec \ud568\uc218 (Transfer Function)", url: "#transfer-function", children: [
          ]},
          {title: "\uc0c1\ud0dc \ucc9c\uc774 \ud589\ub82c (State Transition Matrix)", url: "#state-transition-matrix", children: [
          ]},
          {title: "\uace0\uc720\uac12\uacfc \uace0\uc720\ubca1\ud130 (Eigenvalues and Eigenvectors)", url: "#eigenvalues-and-eigenvectors", children: [
              {title: "\uace0\uc720\uac12\uc758 \uc758\ubbf8", url: "#_3" },
              {title: "\uace0\uc720\ubca1\ud130\uc758 \uc5ed\ud560", url: "#_4" },
              {title: "\ud589\ub82c \ub300\uac01\ud654\uc640 \uc2dc\uc2a4\ud15c \ubd84\uc11d", url: "#_5" },
          ]},
          {title: "\uc548\uc815\uc131 \ubd84\uc11d (Stability Analysis)", url: "#stability-analysis", children: [
          ]},
          {title: "\uc751\ub2f5 \ubd84\uc11d (Response Analysis)", url: "#response-analysis", children: [
          ]},
          {title: "\ucee8\ud2b8\ub864\ub7ec \uc124\uacc4\uc758 \uae30\ucd08 (Basic Concepts in Controller Design)", url: "#basic-concepts-in-controller-design", children: [
              {title: "\uc0c1\ud0dc \ud53c\ub4dc\ubc31 \uc81c\uc5b4 (State Feedback Control)", url: "#state-feedback-control" },
              {title: "\uace0\uc720\uac12 \ubc30\uce58 (Eigenvalue Placement)", url: "#eigenvalue-placement" },
          ]},
          {title: "\uc2dc\uc2a4\ud15c \uc751\ub2f5\uc758 \uc2dc\uac04 \ub3c4\uba54\uc778 \ud574\uc11d (Time-Domain Analysis of System Response)", url: "#time-domain-analysis-of-system-response", children: [
              {title: "\uc0c1\ud0dc \ubc29\uc815\uc2dd\uc758 \ud574 (Solution to the State Equation)", url: "#solution-to-the-state-equation" },
              {title: "\uc2dc\uac04 \uc751\ub2f5 \ud2b9\uc131", url: "#_6" },
          ]},
          {title: "\uc8fc\ud30c\uc218 \ub3c4\uba54\uc778 \ud574\uc11d (Frequency-Domain Analysis)", url: "#frequency-domain-analysis", children: [
              {title: "\uc804\ub2ec \ud568\uc218\uc640 \uc8fc\ud30c\uc218 \uc751\ub2f5", url: "#_7" },
              {title: "\ubcf4\ub4dc \ud50c\ub86f (Bode Plot)", url: "#bode-plot" },
          ]},
          {title: "\uc0c1\ud0dc \uad00\uce21 \uac00\ub2a5\uc131 (State Observability)", url: "#state-observability", children: [
              {title: "\uad00\uce21 \uac00\ub2a5\uc131 \uae30\uc900 (Observability Criterion)", url: "#observability-criterion" },
              {title: "\uad00\uce21 \uac00\ub2a5\uc131\uacfc \uc2dc\uc2a4\ud15c \uc124\uacc4", url: "#_8" },
          ]},
          {title: "\uc0c1\ud0dc \uc81c\uc5b4 \uac00\ub2a5\uc131 (State Controllability)", url: "#state-controllability", children: [
              {title: "\uc81c\uc5b4 \uac00\ub2a5\uc131 \uae30\uc900 (Controllability Criterion)", url: "#controllability-criterion" },
              {title: "\uc81c\uc5b4 \uac00\ub2a5\uc131\uacfc \uc2dc\uc2a4\ud15c \uc124\uacc4", url: "#_9" },
          ]},
          {title: "\uc2dc\uc2a4\ud15c\uc758 \uc548\uc815\uc131 \ubd84\uc11d\uacfc \uc81c\uc5b4 \uac00\ub2a5\uc131\uc758 \uad00\uacc4", url: "#_10", children: [
              {title: "\uc81c\uc5b4 \uac00\ub2a5\uc131\uacfc \uace0\uc720\uac12 \ubc30\uce58", url: "#_11" },
              {title: "\uc608\uc81c: \uc81c\uc5b4 \uac00\ub2a5\uc131 \ubd84\uc11d", url: "#_12" },
          ]},
          {title: "\uad00\uce21 \uac00\ub2a5\uc131\uacfc \uc81c\uc5b4 \uac00\ub2a5\uc131\uc758 \uc774\uc911\uc131 (Duality of Observability and Controllability)", url: "#duality-of-observability-and-controllability", children: [
              {title: "\uc774\uc911\uc131\uc758 \uc751\uc6a9", url: "#_13" },
          ]},
          {title: "\uc120\ud615 \uc2dc\uc2a4\ud15c\uc758 \uc548\uc815\uc131 \ud574\uc11d (Stability Analysis of Linear Systems)", url: "#stability-analysis-of-linear-systems", children: [
              {title: "\ub9ac\uc544\ud504\ub178\ud504 \uc548\uc815\uc131 (Lyapunov Stability)", url: "#lyapunov-stability" },
              {title: "\ub8e8\uc2a4-\ud6c4\ub974\ube44\uce20 \uae30\uc900 (Routh-Hurwitz Criterion)", url: "#-routh-hurwitz-criterion" },
          ]},
          {title: "\ub2e4\uc911\uc785\ucd9c\ub825 \uc2dc\uc2a4\ud15c (MIMO Systems)", url: "#mimo-systems", children: [
              {title: "\uc0c1\ud0dc \uacf5\uac04 \ud45c\ud604\uc5d0\uc11c\uc758 MIMO \uc2dc\uc2a4\ud15c", url: "#mimo" },
              {title: "\uc804\ub2ec \ud589\ub82c (Transfer Matrix)", url: "#transfer-matrix" },
              {title: "\ub2e4\uc911\uc785\ucd9c\ub825 \uc2dc\uc2a4\ud15c\uc758 \uc548\uc815\uc131", url: "#_14" },
          ]},
          {title: "\uc0c1\ud0dc \uada4\uc801 \ucd94\uc801\uacfc \uc81c\uc5b4 (State Trajectory Tracking and Control)", url: "#state-trajectory-tracking-and-control", children: [
              {title: "\uada4\uc801 \ucd94\uc801 \uc81c\uc5b4\uae30 \uc124\uacc4", url: "#_15" },
              {title: "\uada4\uc801 \ucd94\uc801\uc758 \uc548\uc815\uc131", url: "#_16" },
          ]},
          {title: "\uc120\ud615 \uc2dc\uc2a4\ud15c\uc758 \uc81c\uc5b4 \uc124\uacc4 \uae30\ubc95 (Control Design Techniques for Linear Systems)", url: "#control-design-techniques-for-linear-systems", children: [
              {title: "\uc0c1\ud0dc \ud53c\ub4dc\ubc31 \uc81c\uc5b4 (State Feedback Control)", url: "#state-feedback-control_1" },
              {title: "\ucd5c\uc801 \uc81c\uc5b4 (Optimal Control)", url: "#optimal-control" },
              {title: "\uace0\uc804 \uc81c\uc5b4\uae30 \uc124\uacc4 (Classical Controller Design)", url: "#classical-controller-design" },
              {title: "\uc0c1\ud0dc \uad00\uce21\uae30 \uc124\uacc4 (State Observer Design)", url: "#state-observer-design" },
              {title: "\ub0b4\ubd80 \ubaa8\ub378 \uc81c\uc5b4 (Internal Model Control, IMC)", url: "#internal-model-control-imc" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../024/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../024/" class="btn btn-xs btn-link">
        최소 제곱 추정법과 칼만 필터의 관계
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../022/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../022/" class="btn btn-xs btn-link">
        확률적 모델링 가우시안 분포의 중요성
      </a>
    </div>
    
  </div>

    

    <h3 id="_1">선형 시스템의 정의</h3>
<p>선형 시스템은 입력과 출력 사이의 관계가 선형적으로 표현될 수 있는 시스템을 말한다. 이러한 시스템에서는 중첩의 원리가 적용되며, 이는 시스템의 출력이 입력의 선형 결합으로 표현될 수 있음을 의미한다. 즉, 두 개의 입력에 대해 각각의 출력이 존재할 때, 이 입력의 선형 결합에 대해 출력도 동일한 방식으로 결합된다.</p>
<p>수학적으로, 선형 시스템은 다음과 같은 형태로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}(t) = \mathbf{A} \cdot \mathbf{x}(t) + \mathbf{B} \cdot \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{y}(t) = \mathbf{A} \cdot \mathbf{x}(t) + \mathbf{B} \cdot \mathbf{u}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}(t)</span><script type="math/tex">\mathbf{y}(t)</script></span>는 출력, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 상태 벡터, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>는 입력 벡터를 의미하며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 시스템 행렬이다. 이 시스템 행렬들은 상태와 입력이 시간에 따라 어떻게 변하는지를 정의한다.</p>
<h3 id="time-invariance">선형 시스템의 시간 불변성 (Time-Invariance)</h3>
<p>시간 불변성(Time-Invariance)은 선형 시스템의 중요한 속성 중 하나로, 시스템의 성능이 시간에 따라 변화하지 않음을 의미한다. 즉, 입력이 시간 축에서 이동하면, 출력도 동일한 양만큼 이동하게 된다. </p>
<p>시간 불변 시스템은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}(t - \tau) = \mathcal{S} \{ \mathbf{u}(t - \tau) \}
</div>
<script type="math/tex; mode=display">
\mathbf{y}(t - \tau) = \mathcal{S} \{ \mathbf{u}(t - \tau) \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span>는 시간 이동 양을 나타내며, <span class="arithmatex"><span class="MathJax_Preview">\mathcal{S}</span><script type="math/tex">\mathcal{S}</script></span>는 시스템 연산자를 의미한다. 이러한 시간 불변성을 통해 시스템의 동작을 시간 축의 임의의 위치에서 동일하게 분석할 수 있다.</p>
<h3 id="_2">선형 연산자의 특성</h3>
<p>선형 시스템의 핵심 요소는 선형 연산자이다. 선형 연산자는 시스템의 입력과 출력 사이의 관계를 결정하며, 이는 주로 행렬 형태로 표현된다. 이러한 선형 연산자는 다음과 같은 두 가지 주요 특성을 가진다:</p>
<ol>
<li><strong>가법성 (Additivity)</strong>: 
   두 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_1(t)</span><script type="math/tex">\mathbf{u}_1(t)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_2(t)</span><script type="math/tex">\mathbf{u}_2(t)</script></span>에 대해 시스템이 선형이라면, 그 합에 대한 출력은 개별 출력의 합과 동일하다:</li>
</ol>
<p>$$
   \mathcal{S}{\mathbf{u}_1(t) + \mathbf{u}_2(t)} = \mathcal{S}{\mathbf{u}_1(t)} + \mathcal{S}{\mathbf{u}_2(t)}</p>
<p>$$</p>
<ol>
<li><strong>동차성 (Homogeneity)</strong>:
   입력이 어떤 스칼라 상수 <span class="arithmatex"><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span>로 곱해질 때, 출력도 동일한 상수로 곱해진다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathcal{S}\{c \cdot \mathbf{u}(t)\} = c \cdot \mathcal{S}\{\mathbf{u}(t)\}
</div>
<script type="math/tex; mode=display">
\mathcal{S}\{c \cdot \mathbf{u}(t)\} = c \cdot \mathcal{S}\{\mathbf{u}(t)\}
</script>
</div>
<p>이 두 가지 특성은 선형 시스템의 근본적인 성질로, 다양한 복잡한 시스템을 단순한 구성 요소로 분해하여 분석할 수 있게 한다.</p>
<h3 id="state-space-representation">상태 공간 표현(State-Space Representation)</h3>
<p>선형 시스템은 상태 공간 표현을 통해 시간에 따른 시스템의 동작을 기술할 수 있다. 상태 공간 표현은 시스템의 상태를 나타내는 벡터와 이를 시간에 따라 변화시키는 행렬을 사용하여 시스템을 모델링한다. 이러한 모델은 연립 1차 미분 방정식의 형태로 주어지며, 일반적으로 다음과 같은 두 가지 방정식으로 구성된다:</p>
<ol>
<li><strong>상태 방정식</strong>:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\dot{\mathbf{x}}(t) = \mathbf{A} \cdot \mathbf{x}(t) + \mathbf{B} \cdot \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\dot{\mathbf{x}}(t) = \mathbf{A} \cdot \mathbf{x}(t) + \mathbf{B} \cdot \mathbf{u}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\dot{x}(t)</span><script type="math/tex">\dot{x}(t)</script></span>는 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">x(t)</span><script type="math/tex">x(t)</script></span>의 시간에 대한 미분, 즉 시스템의 동적 변화를 나타낸다.</p>
<ol>
<li><strong>출력 방정식</strong>:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}(t) = \mathbf{C} \cdot \mathbf{x}(t) + \mathbf{D} \cdot \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{y}(t) = \mathbf{C} \cdot \mathbf{x}(t) + \mathbf{D} \cdot \mathbf{u}(t)
</script>
</div>
<p>이 방정식은 시스템의 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>와 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>로부터 실제로 관측 가능한 출력 <span class="arithmatex"><span class="MathJax_Preview">{y}(t)</span><script type="math/tex">{y}(t)</script></span>을 결정한다.</p>
<h3 id="transfer-function">선형 시스템의 전달 함수 (Transfer Function)</h3>
<p>선형 시스템은 전달 함수(Transfer Function)를 통해 주파수 영역에서 분석될 수 있다. 전달 함수는 시스템의 입출력 관계를 주파수 도메인에서 나타내며, 주로 라플라스 변환(Laplace Transform)을 통해 유도된다. 전달 함수 <span class="arithmatex"><span class="MathJax_Preview">H(s)</span><script type="math/tex">H(s)</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
H(s) = \frac{Y(s)}{U(s)}
</div>
<script type="math/tex; mode=display">
H(s) = \frac{Y(s)}{U(s)}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">Y(s)</span><script type="math/tex">Y(s)</script></span>는 출력의 라플라스 변환, <span class="arithmatex"><span class="MathJax_Preview">U(s)</span><script type="math/tex">U(s)</script></span>는 입력의 라플라스 변환이다. 전달 함수는 시스템의 입력이 특정 주파수를 가질 때, 출력이 어떻게 변화하는지를 분석하는 데 사용된다.</p>
<h3 id="state-transition-matrix">상태 천이 행렬 (State Transition Matrix)</h3>
<p>상태 천이 행렬(State Transition Matrix)은 시간에 따른 시스템의 상태 변화를 나타내는 중요한 도구이다. 상태 천이 행렬 <span class="arithmatex"><span class="MathJax_Preview">\Phi(t)</span><script type="math/tex">\Phi(t)</script></span>는 다음과 같은 형태로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = \Phi(t) \cdot \mathbf{x}(t_0) + \int_{t_0}^{t} \Phi(t-\tau) \cdot \mathbf{B} \cdot \mathbf{u}(\tau) d\tau
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = \Phi(t) \cdot \mathbf{x}(t_0) + \int_{t_0}^{t} \Phi(t-\tau) \cdot \mathbf{B} \cdot \mathbf{u}(\tau) d\tau
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\Phi(t)</span><script type="math/tex">\Phi(t)</script></span>는 상태 벡터가 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서 시간 <span class="arithmatex"><span class="MathJax_Preview">t_0</span><script type="math/tex">t_0</script></span>로 어떻게 변하는지를 나타내며, 이는 <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> 행렬의 지수 함수로 계산된다.</p>
<h3 id="eigenvalues-and-eigenvectors">고유값과 고유벡터 (Eigenvalues and Eigenvectors)</h3>
<p>선형 시스템의 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 특성은 고유값(eigenvalues)과 고유벡터(eigenvectors)를 통해 깊이 이해할 수 있다. 고유값과 고유벡터는 시스템의 동작을 분석하고 시스템의 안정성, 응답 특성 등을 평가하는 데 중요한 역할을 한다.</p>
<p><strong>고유값 문제</strong>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \cdot \mathbf{v} = \lambda \cdot \mathbf{v}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \cdot \mathbf{v} = \lambda \cdot \mathbf{v}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>는 고유벡터, <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>는 고유값이다. 고유값은 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>가 어떤 스칼라 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>로 변환할 수 있는지를 나타내며, 고유벡터는 이러한 변환을 이루는 방향을 나타낸다.</p>
<h4 id="_3">고유값의 의미</h4>
<p>고유값 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>는 시스템의 모드의 자연 진동수와 감쇠율을 나타낸다. 예를 들어, 시스템의 고유값이 실수일 경우, 시스템은 지수적으로 증가하거나 감소하는 응답을 보인다. 고유값이 복소수일 경우, 시스템은 진동을 하며 그 진폭이 증가하거나 감소하는 응답을 보인다.</p>
<ul>
<li><strong>실수 고유값</strong>: 시스템이 감쇠(damping)하거나 발산(divergent)하는 모드를 가진다.</li>
<li><strong>복소수 고유값</strong>: 시스템이 진동성(resonant) 모드를 가진다. 여기서 실수부는 감쇠율, 허수부는 진동 주파수를 나타낸다.</li>
</ul>
<h4 id="_4">고유벡터의 역할</h4>
<p>고유벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>는 시스템이 특정 모드로 동작할 때 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>의 방향을 나타낸다. 이는 시스템의 각 고유 모드에 대응하는 방향으로 상태가 변화하는 방식을 설명한다. 여러 고유벡터로 구성된 고유 공간(eigenspace)은 상태 공간에서 시스템의 동작을 분해하는 데 사용된다.</p>
<h4 id="_5">행렬 대각화와 시스템 분석</h4>
<p>행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>가 대각화 가능할 때, 즉 고유벡터가 선형 독립인 경우, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 다음과 같이 대각화될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{v} \Lambda \mathbf{v}^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{v} \Lambda \mathbf{v}^{-1}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>는 고유벡터로 이루어진 행렬, <span class="arithmatex"><span class="MathJax_Preview">\Lambda</span><script type="math/tex">\Lambda</script></span>는 고유값이 대각선에 위치한 대각 행렬이다. 대각화된 행렬을 사용하면, 시스템의 동작을 각 고유 모드로 분리하여 분석할 수 있다. 이는 복잡한 시스템을 단순한 선형 결합으로 해석하는 데 큰 도움을 준다.</p>
<h3 id="stability-analysis">안정성 분석 (Stability Analysis)</h3>
<p>선형 시스템의 안정성은 고유값을 통해 평가할 수 있다. 시스템이 안정적이기 위해서는 모든 고유값의 실수부가 음수여야 한다. 이러한 조건을 만족할 때, 시스템은 시간이 지남에 따라 안정된 상태로 수렴하게 된다.</p>
<ul>
<li><strong>안정 시스템</strong>: 모든 고유값의 실수부가 음수일 때, 시스템은 안정적이다. 상태는 시간이 지남에 따라 평형점으로 수렴한다.</li>
<li><strong>불안정 시스템</strong>: 하나 이상의 고유값이 실수부가 양수일 때, 시스템은 불안정하다. 상태는 시간이 지남에 따라 발산한다.</li>
<li><strong>경계 안정 시스템</strong>: 고유값의 실수부가 0인 경우, 시스템은 경계 안정 상태로 시간에 따라 변화하지 않거나 진동할 수 있다.</li>
</ul>
<p>고유값 분포를 통해 시스템의 장기적인 동작을 예측할 수 있으며, 이는 시스템 설계와 제어 전략 수립에 중요한 정보를 제공한다.</p>
<h3 id="response-analysis">응답 분석 (Response Analysis)</h3>
<p>선형 시스템의 응답은 입력 신호에 대한 시스템의 반응을 나타낸다. 이러한 응답은 고유값과 고유벡터를 이용하여 각 모드로 분해할 수 있다. 시스템의 응답은 크게 두 가지로 분류된다:</p>
<ol>
<li>
<p><strong>자유 응답 (Free Response)</strong>:
   초기 조건에 의해서만 결정되는 시스템의 응답을 자유 응답이라 한다. 이는 외부 입력이 없을 때 시스템이 어떻게 동작하는지를 나타낸다. 자유 응답은 주로 시스템의 고유 모드에 따라 결정된다.</p>
</li>
<li>
<p><strong>강제 응답 (Forced Response)</strong>:
   외부 입력에 의해 유도되는 시스템의 응답을 강제 응답이라 한다. 이는 입력 신호가 시스템에 어떤 영향을 미치는지를 설명하며, 시스템의 전달 함수에 의해 결정된다.</p>
</li>
</ol>
<p>이 두 응답의 조합으로 시스템의 전체 응답이 형성되며, 이는 시스템의 초기 상태와 입력 신호에 따라 달라진다.</p>
<h3 id="basic-concepts-in-controller-design">컨트롤러 설계의 기초 (Basic Concepts in Controller Design)</h3>
<p>선형 시스템 이론은 컨트롤러 설계에 직접적으로 적용될 수 있다. 시스템의 상태를 원하는 대로 조절하기 위해 상태 피드백을 활용한 컨트롤러 설계가 이루어지며, 이는 주로 고유값 배치(Eigenvalue Placement) 기법을 통해 구현된다. 컨트롤러는 시스템의 고유값을 조정하여 원하는 동적 특성을 달성한다.</p>
<h4 id="state-feedback-control">상태 피드백 제어 (State Feedback Control)</h4>
<p>상태 피드백 제어는 시스템의 상태 벡터를 측정하고, 이를 바탕으로 제어 입력을 생성하는 방식이다. 상태 피드백의 기본 형태는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(t) = -\mathbf{K} \cdot \mathbf{x}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{u}(t) = -\mathbf{K} \cdot \mathbf{x}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>는 상태 피드백 게인(gain) 행렬이다. 이 제어법은 시스템의 고유값을 원하는 위치로 배치하여 시스템의 동적 특성을 개선할 수 있다.</p>
<h4 id="eigenvalue-placement">고유값 배치 (Eigenvalue Placement)</h4>
<p>고유값 배치는 제어 설계에서 핵심적인 역할을 한다. 원하는 시스템 성능을 얻기 위해, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span> 행렬을 설계하여 시스템의 고유값을 특정 위치로 이동시킨다. 이 방법을 통해 시스템의 안정성, 응답 속도, 진동 특성 등을 조정할 수 있다.</p>
<p>고유값 배치 기법은 다양한 응용 분야에서 사용되며, 선형 시스템 이론의 핵심적인 응용 중 하나로 여겨진다.</p>
<h3 id="time-domain-analysis-of-system-response">시스템 응답의 시간 도메인 해석 (Time-Domain Analysis of System Response)</h3>
<p>선형 시스템의 시간 도메인 해석은 시스템이 시간에 따라 어떻게 변하는지를 직접적으로 분석하는 방법이다. 시간 도메인 해석은 시스템의 상태 방정식을 풀어 시스템의 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>와 출력 <span class="arithmatex"><span class="MathJax_Preview">{y}(t)</span><script type="math/tex">{y}(t)</script></span>를 구하는 과정으로 이루어진다.</p>
<h4 id="solution-to-the-state-equation">상태 방정식의 해 (Solution to the State Equation)</h4>
<p>상태 방정식 <span class="arithmatex"><span class="MathJax_Preview">\dot{\mathbf{x}}(t) = \mathbf{A} \cdot \mathbf{x}(t) + \mathbf{B} \cdot \mathbf{u}(t)</span><script type="math/tex">\dot{\mathbf{x}}(t) = \mathbf{A} \cdot \mathbf{x}(t) + \mathbf{B} \cdot \mathbf{u}(t)</script></span>의 해를 구하는 방법은 크게 두 가지로 나눌 수 있다:</p>
<ol>
<li><strong>자유 응답</strong>: 초기 조건 <span class="arithmatex"><span class="MathJax_Preview">x(0)</span><script type="math/tex">x(0)</script></span>에 의해 결정되는 해</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{\text{free}}(t) = \Phi(t) \cdot \mathbf{x}(0)
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{\text{free}}(t) = \Phi(t) \cdot \mathbf{x}(0)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\Phi(t)</span><script type="math/tex">\Phi(t)</script></span>는 상태 천이 행렬(State Transition Matrix)로, 다음과 같이 정의된다:</p>
<p>$$
   \Phi(t) = e^{At}</p>
<p>$$</p>
<p>이는 시스템이 외부 입력이 없을 때, 시간에 따라 어떻게 변하는지를 나타낸다.</p>
<ol>
<li><strong>강제 응답</strong>: 외부 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>에 의해 유도되는 해
$$
\mathbf{x}<em>{\text{forced}}(t) = \int</em>{0}^{t} \Phi(t - \tau) \cdot \mathbf{B} \cdot \mathbf{u}(\tau) \, d\tau
$$</li>
</ol>
<p>이 식은 외부 입력이 시스템 상태에 미치는 영향을 나타내며, 이 결과는 시간에 따라 적분으로 표현된다.</p>
<p>전체 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>는 자유 응답과 강제 응답의 합으로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}(t) = \Phi(t) \cdot \mathbf{x}(0) + \int_{0}^{t} \Phi(t - \tau) \cdot \mathbf{B} \cdot \mathbf{u}(\tau) \, d\tau
</div>
<script type="math/tex; mode=display">
\mathbf{x}(t) = \Phi(t) \cdot \mathbf{x}(0) + \int_{0}^{t} \Phi(t - \tau) \cdot \mathbf{B} \cdot \mathbf{u}(\tau) \, d\tau
</script>
</div>
<h4 id="_6">시간 응답 특성</h4>
<p>시간 도메인에서 시스템의 응답 특성은 다음과 같은 주요 지표를 통해 평가된다:</p>
<ol>
<li>
<p><strong>과도 응답(Transient Response)</strong>: 시스템이 새로운 평형 상태에 도달하기 전까지의 응답. 이는 고유값에 의해 결정되는 지수적 감소 또는 진동 형태로 나타난다.</p>
</li>
<li>
<p><strong>정상 상태 응답(Steady-State Response)</strong>: 시스템이 시간이 충분히 경과한 후 안정된 상태에 도달했을 때의 응답. 이는 시스템의 입력이 일정할 때 출력이 일정한 값에 도달하는 상태를 나타낸다.</p>
</li>
<li>
<p><strong>정착 시간(Settling Time)</strong>: 시스템 응답이 최종 값의 일정 범위 내로 들어가서 더 이상 그 범위를 벗어나지 않는 데 걸리는 시간.</p>
</li>
<li>
<p><strong>최대 오버슈트(Maximum Overshoot)</strong>: 응답이 최종 정착 값 이상으로 초과하는 정도. 이는 시스템의 진동성과 관련이 깊다.</p>
</li>
</ol>
<p>이러한 시간 응답 특성은 시스템의 동적 성능을 평가하는 데 매우 중요한 요소이며, 설계 목표에 따라 조정된다.</p>
<h3 id="frequency-domain-analysis">주파수 도메인 해석 (Frequency-Domain Analysis)</h3>
<p>선형 시스템의 주파수 도메인 해석은 시스템이 다양한 주파수의 입력에 어떻게 반응하는지를 분석하는 방법이다. 이는 주파수 영역에서 시스템의 동작을 해석하며, 특히 전달 함수와 보드(Bode) 플롯과 같은 도구를 사용한다.</p>
<h4 id="_7">전달 함수와 주파수 응답</h4>
<p>전달 함수 <span class="arithmatex"><span class="MathJax_Preview">H(s)</span><script type="math/tex">H(s)</script></span>는 시스템의 입력과 출력 사이의 관계를 주파수 도메인에서 표현한 함수이다. 주파수 응답은 <span class="arithmatex"><span class="MathJax_Preview">s = j\omega</span><script type="math/tex">s = j\omega</script></span>로 대체하여 <span class="arithmatex"><span class="MathJax_Preview">H(j\omega)</span><script type="math/tex">H(j\omega)</script></span> 형태로 표현되며, 이는 특정 주파수 <span class="arithmatex"><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span>에서의 시스템 응답을 나타낸다.</p>
<p>전달 함수의 주파수 응답은 다음과 같은 중요한 특성을 분석할 수 있게 한다:</p>
<ul>
<li>
<p><strong>이득(Gain)</strong>: 특정 주파수에서 입력 신호의 크기가 출력 신호의 크기에 어떻게 영향을 미치는지 나타낸다. 이는 주로 데시벨(dB)로 표현된다.</p>
</li>
<li>
<p><strong>위상(Phase)</strong>: 입력 신호와 출력 신호 사이의 위상 차이를 나타내며, 이는 시스템의 동작 속도와 관련이 있다.</p>
</li>
</ul>
<h4 id="bode-plot">보드 플롯 (Bode Plot)</h4>
<p>보드 플롯은 주파수 응답을 시각적으로 나타내는 도구로, 시스템의 이득과 위상을 주파수에 대해 플롯한다. 이 플롯을 통해 시스템의 안정성, 대역폭, 그리고 주파수 특성을 쉽게 분석할 수 있다.</p>
<ul>
<li>
<p><strong>이득 플롯</strong>: 주파수에 따른 이득을 로그-로그 축에 나타낸다. 이 플롯은 시스템이 주파수에 따라 입력 신호의 크기를 어떻게 변화시키는지 보여준다.</p>
</li>
<li>
<p><strong>위상 플롯</strong>: 주파수에 따른 위상 차이를 로그-선형 축에 나타낸다. 이 플롯은 입력 신호의 주파수에 따라 시스템이 얼마나 빠르게 반응하는지를 시각적으로 표현한다.</p>
</li>
</ul>
<p>보드 플롯은 컨트롤러 설계에서 중요한 역할을 하며, 특히 시스템의 안정성과 성능을 주파수 영역에서 분석할 때 사용된다.</p>
<h3 id="state-observability">상태 관측 가능성 (State Observability)</h3>
<p>상태 관측 가능성(Observability)은 시스템의 상태를 외부 출력 신호를 통해 완전히 추정할 수 있는지를 나타내는 개념이다. 이는 시스템의 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">x(t)</span><script type="math/tex">x(t)</script></span>가 관측 가능한지 여부를 판단하는 중요한 지표로, 시스템 설계에서 필수적인 역할을 한다.</p>
<h4 id="observability-criterion">관측 가능성 기준 (Observability Criterion)</h4>
<p>관측 가능성은 다음의 관측 가능성 행렬(Observability Matrix)을 통해 평가할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathcal{O} = \begin{bmatrix}
C \\
CA \\
CA^2 \\
\vdots \\
CA^{n-1}
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathcal{O} = \begin{bmatrix}
C \\
CA \\
CA^2 \\
\vdots \\
CA^{n-1}
\end{bmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{O}</span><script type="math/tex">\mathcal{O}</script></span>가 풀 랭크(Full Rank)를 가지면, 시스템은 관측 가능하다고 할 수 있다. 즉, 행렬의 랭크가 시스템 상태의 차원과 같으면 모든 상태를 외부 출력으로부터 완전히 재구성할 수 있다.</p>
<h4 id="_8">관측 가능성과 시스템 설계</h4>
<p>관측 가능성은 상태 추정기(State Estimator)나 관측기(Observer)를 설계할 때 중요한 역할을 한다. 특히 칼만 필터와 같은 알고리즘에서 상태의 정확한 추정은 시스템의 관측 가능성에 크게 의존한다.</p>
<p>관측 가능성의 결여는 시스템의 특정 상태를 완전히 추적하지 못하게 하며, 이는 시스템 제어에 있어서 심각한 문제를 초래할 수 있다. 따라서 시스템 설계 초기 단계에서 관측 가능성을 철저히 분석하고, 필요에 따라 시스템의 구조를 조정하는 것이 중요하다.</p>
<h3 id="state-controllability">상태 제어 가능성 (State Controllability)</h3>
<p>상태 제어 가능성(Controllability)은 시스템의 입력 신호를 통해 시스템의 모든 상태를 원하는 상태로 제어할 수 있는지를 나타내는 개념이다. 제어 가능성은 시스템 설계에서 중요한 요소로, 시스템이 원하는 대로 동작하도록 보장하는 데 필수적인 조건이다.</p>
<h4 id="controllability-criterion">제어 가능성 기준 (Controllability Criterion)</h4>
<p>제어 가능성은 제어 가능성 행렬(Controllability Matrix)을 사용하여 평가된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathcal{C} = \begin{bmatrix}
B &amp; AB &amp; A^2B &amp; \cdots &amp; A^{n-1}B
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathcal{C} = \begin{bmatrix}
B & AB & A^2B & \cdots & A^{n-1}B
\end{bmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{C}</span><script type="math/tex">\mathcal{C}</script></span>가 풀 랭크(Full Rank)를 가지면, 시스템은 제어 가능하다고 판단된다. 즉, 제어 가능성 행렬의 랭크가 상태 벡터의 차원과 같다면, 초기 상태에서 원하는 임의의 상태로 제어 입력을 통해 이동할 수 있다.</p>
<h4 id="_9">제어 가능성과 시스템 설계</h4>
<p>제어 가능성은 시스템 제어기(Controller)를 설계할 때 결정적인 요소로 작용한다. 제어 가능성이 확보되지 않으면, 특정 상태로 시스템을 제어할 수 없게 되어 설계된 제어기가 원하는 성능을 발휘하지 못하게 된다.</p>
<ul>
<li><strong>완전 제어 가능 시스템</strong>: 시스템의 모든 상태가 입력을 통해 제어 가능하다.</li>
<li><strong>부분 제어 가능 시스템</strong>: 특정 상태만이 입력을 통해 제어 가능하다.</li>
<li><strong>비제어 가능 시스템</strong>: 입력에 관계없이 특정 상태를 제어할 수 없다.</li>
</ul>
<p>제어 가능성의 확보는 주로 제어기 설계와 관련된 고유값 배치(Eigenvalue Placement)와 관련이 있다. 시스템이 완전히 제어 가능할 때, 고유값을 원하는 위치로 배치하여 시스템의 동작을 원하는 대로 조절할 수 있다.</p>
<h3 id="_10">시스템의 안정성 분석과 제어 가능성의 관계</h3>
<p>제어 가능성과 시스템의 안정성은 밀접하게 연관되어 있다. 특히, 제어 가능한 시스템은 외부 입력을 통해 불안정한 상태를 안정된 상태로 이동시킬 수 있다. 반대로, 제어 가능하지 않은 시스템은 특정 불안정한 모드를 제어할 수 없게 되어 시스템이 불안정하게 유지될 수 있다.</p>
<h4 id="_11">제어 가능성과 고유값 배치</h4>
<p>제어 가능성의 중요한 응용 중 하나는 고유값 배치를 통해 시스템의 동적 특성을 변경하는 것이다. 시스템이 제어 가능하다면, 모든 고유값을 원하는 위치로 배치하여 안정성을 확보하거나 응답 속도를 조정할 수 있다. 이는 상태 피드백 제어(State Feedback Control)와 같은 기법을 사용하여 구현된다.</p>
<h4 id="_12">예제: 제어 가능성 분석</h4>
<p>하나의 간단한 예로, 2차 시스템을 고려해보자:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \begin{bmatrix} 0 &amp; 1 \\ -2 &amp; -3 \end{bmatrix},
\quad 
\mathbf{B} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \begin{bmatrix} 0 & 1 \\ -2 & -3 \end{bmatrix},
\quad 
\mathbf{B} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}
</script>
</div>
<p>이 시스템의 제어 가능성 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{C}</span><script type="math/tex">\mathcal{C}</script></span>는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathcal{C} = \begin{bmatrix} \mathbf{B} &amp; \mathbf{A}\mathbf{B} \end{bmatrix} = \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; -3 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathcal{C} = \begin{bmatrix} \mathbf{B} & \mathbf{A}\mathbf{B} \end{bmatrix} = \begin{bmatrix} 0 & 1 \\ 1 & -3 \end{bmatrix}
</script>
</div>
<p>이 행렬의 행렬식이 0이 아닌 경우, 즉 풀 랭크를 가지므로, 이 시스템은 완전히 제어 가능하다. 따라서 적절한 입력 신호를 통해 시스템의 상태를 원하는 대로 조정할 수 있다.</p>
<h3 id="duality-of-observability-and-controllability">관측 가능성과 제어 가능성의 이중성 (Duality of Observability and Controllability)</h3>
<p>관측 가능성과 제어 가능성 사이에는 수학적으로 밀접한 관계가 있으며, 이는 이중성(Duality)이라고 불린다. 두 개념은 시스템 행렬의 전치(Transpose)를 통해 서로 변환될 수 있다. 즉, 관측 가능성 문제는 제어 가능성 문제와 이중적 관계에 있으며, 다음과 같이 나타낼 수 있다:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">(\mathbf{A}, \mathbf{B})</span><script type="math/tex">(\mathbf{A}, \mathbf{B})</script></span>가 제어 가능하다면, <span class="arithmatex"><span class="MathJax_Preview">(\mathbf{A}^T, \mathbf{C}^T)</span><script type="math/tex">(\mathbf{A}^T, \mathbf{C}^T)</script></span>는 관측 가능하다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">(\mathbf{A}, \mathbf{C})</span><script type="math/tex">(\mathbf{A}, \mathbf{C})</script></span>가 관측 가능하다면, <span class="arithmatex"><span class="MathJax_Preview">(\mathbf{A}^T, \mathbf{B}^T)</span><script type="math/tex">(\mathbf{A}^T, \mathbf{B}^T)</script></span>는 제어 가능하다.</li>
</ul>
<p>이 이중성은 시스템의 상태 추정기와 제어기의 설계에서 중요한 역할을 하며, 하나의 개념을 이해함으로써 다른 개념도 쉽게 이해할 수 있게 해준다.</p>
<h4 id="_13">이중성의 응용</h4>
<p>이중성은 특히 칼만 필터(Kalman Filter)와 같은 상태 추정 알고리즘을 설계할 때 중요하다. 칼만 필터는 본질적으로 관측 가능성을 기반으로 상태를 추정하지만, 이 이중성을 활용하면 제어 가능성에 기반한 설계 접근법도 가능하게 된다. 이를 통해 시스템의 성능을 더 정교하게 조정할 수 있다.</p>
<h3 id="stability-analysis-of-linear-systems">선형 시스템의 안정성 해석 (Stability Analysis of Linear Systems)</h3>
<p>선형 시스템의 안정성은 시스템이 시간 경과에 따라 어떤 동작을 보이는지를 이해하는 데 매우 중요하다. 안정성 해석은 시스템의 모든 초기 조건에서 시스템이 일정한 상태로 수렴하는지, 또는 특정 상태로부터 멀어지며 발산하는지를 분석하는 과정이다.</p>
<h4 id="lyapunov-stability">리아프노프 안정성 (Lyapunov Stability)</h4>
<p>리아프노프 안정성은 시스템이 특정 평형점(Equilibrium Point) 주위에서 안정적인지를 평가하는 방법 중 하나이다. 리아프노프의 제1 안정성 이론은 선형 시스템의 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 대해 다음과 같은 조건을 통해 안정성을 평가한다:</p>
<ol>
<li>행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 모든 고유값의 실수부가 음수이면, 시스템은 <strong>점근 안정(Asymptotically Stable)</strong>하다.</li>
<li>행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 고유값 중 하나라도 실수부가 양수이면, 시스템은 <strong>불안정(Unstable)</strong>하다.</li>
<li>고유값의 실수부가 모두 음수거나 0이지만, 0이 아닌 고유값이 존재하면, 시스템은 <strong>경계 안정(Marginally Stable)</strong>하다.</li>
</ol>
<p>리아프노프 함수 <span class="arithmatex"><span class="MathJax_Preview">V(\mathbf{x})</span><script type="math/tex">V(\mathbf{x})</script></span>를 이용해 안정성을 분석할 수도 있다. <span class="arithmatex"><span class="MathJax_Preview">V(\mathbf{x})</span><script type="math/tex">V(\mathbf{x})</script></span>는 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>에 대한 양의 정부호 함수로 정의되며, 다음 조건을 만족해야 한다:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">V(x)</span><script type="math/tex">V(x)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x} = 0</span><script type="math/tex">\mathbf{x} = 0</script></span>에서 0이고, 다른 모든 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>에서 양수이다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\dot{V}(\mathbf{x})</span><script type="math/tex">\dot{V}(\mathbf{x})</script></span>, 즉 <span class="arithmatex"><span class="MathJax_Preview">V(\mathbf{x})</span><script type="math/tex">V(\mathbf{x})</script></span>의 시간에 따른 변화율이 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x} = 0</span><script type="math/tex">\mathbf{x} = 0</script></span>에서 음수이면, 시스템은 점근 안정적이다.</li>
</ul>
<p>이 방법은 비선형 시스템에서도 적용될 수 있지만, 선형 시스템에서는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 고유값 분석을 통해 직접 안정성을 평가하는 것이 더 일반적이다.</p>
<h4 id="-routh-hurwitz-criterion">루스-후르비츠 기준 (Routh-Hurwitz Criterion)</h4>
<p>루스-후르비츠 기준은 선형 시스템의 특성 방정식의 계수를 이용하여 시스템의 안정성을 평가하는 고전적인 방법이다. 이 기준은 시스템의 특성 방정식이 다음과 같은 일반적인 형태를 가질 때 적용된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
p(s) = a_n s^n + a_{n-1} s^{n-1} + \cdots + a_1 s + a_0
</div>
<script type="math/tex; mode=display">
p(s) = a_n s^n + a_{n-1} s^{n-1} + \cdots + a_1 s + a_0
</script>
</div>
<p>루스-후르비츠 기준은 이 방정식의 계수를 사용하여 루스 배열(Routh Array)을 구성하고, 배열의 첫 번째 열의 부호 변화를 분석함으로써 시스템의 안정성을 판단한다. 배열의 첫 번째 열에 음수 항이 없으면, 시스템은 안정적이다. 음수 항이 존재하면, 시스템은 불안정하다.</p>
<p>이 방법은 시스템의 고유값을 직접 계산하지 않고도 안정성을 평가할 수 있는 장점이 있다. 특히, 고차 방정식의 경우 고유값을 계산하는 것이 복잡할 수 있으므로, 루스-후르비츠 기준은 유용한 도구가 된다.</p>
<h3 id="mimo-systems">다중입출력 시스템 (MIMO Systems)</h3>
<p>다중입출력(MIMO: Multiple Input Multiple Output) 시스템은 여러 개의 입력과 출력을 가지는 시스템을 의미한다. 이러한 시스템에서는 입력과 출력 사이의 상호작용이 복잡하며, 시스템의 동적 특성 분석이 단일입출력(SISO: Single Input Single Output) 시스템에 비해 훨씬 어렵다.</p>
<h4 id="mimo">상태 공간 표현에서의 MIMO 시스템</h4>
<p>MIMO 시스템의 상태 공간 표현은 다음과 같은 형태로 주어진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\dot{\mathbf{x}}(t) = \mathbf{A} \cdot \mathbf{x}(t) + \mathbf{B} \cdot \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\dot{\mathbf{x}}(t) = \mathbf{A} \cdot \mathbf{x}(t) + \mathbf{B} \cdot \mathbf{u}(t)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}(t) = \mathbf{C} \cdot \mathbf{x}(t) + \mathbf{D} \cdot \mathbf{u}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{y}(t) = \mathbf{C} \cdot \mathbf{x}(t) + \mathbf{D} \cdot \mathbf{u}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(t)</span><script type="math/tex">\mathbf{u}(t)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}(t)</span><script type="math/tex">\mathbf{y}(t)</script></span>는 각각 다중 입력 벡터와 다중 출력 벡터이다. 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>는 각각 입력, 출력, 그리고 직접 전달 경로를 나타내며, 이들이 MIMO 시스템의 복잡한 상호작용을 정의한다.</p>
<h4 id="transfer-matrix">전달 행렬 (Transfer Matrix)</h4>
<p>MIMO 시스템에서는 단일 전달 함수 대신, 전달 행렬(Transfer Matrix)을 사용하여 시스템의 주파수 응답을 분석한다. 전달 행렬 <span class="arithmatex"><span class="MathJax_Preview">H(s)</span><script type="math/tex">H(s)</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{H}(s) = \mathbf{C} \cdot (s\mathbf{I} - \mathbf{A})^{-1} \cdot \mathbf{B} + \mathbf{D}
</div>
<script type="math/tex; mode=display">
\mathbf{H}(s) = \mathbf{C} \cdot (s\mathbf{I} - \mathbf{A})^{-1} \cdot \mathbf{B} + \mathbf{D}
</script>
</div>
<p>이 행렬은 각 입력 신호에 대한 모든 출력 신호 간의 주파수 응답을 나타내며, MIMO 시스템의 동적 특성을 분석하는 데 중요한 역할을 한다. 전달 행렬의 행렬 요소들은 각 입력에서 특정 출력으로의 전달 함수를 나타낸다.</p>
<h4 id="_14">다중입출력 시스템의 안정성</h4>
<p>MIMO 시스템의 안정성 분석은 SISO 시스템보다 복잡하다. MIMO 시스템의 안정성을 평가하려면 시스템의 모든 모드(mode)를 분석해야 하며, 이는 각 모드가 고유값과 고유벡터에 의해 정의된다.</p>
<p>MIMO 시스템의 안정성은 일반적으로 다음과 같은 방법을 통해 평가된다:</p>
<ul>
<li><strong>모드 해석(Mode Analysis)</strong>: 시스템의 모든 모드의 고유값을 분석하여 안정성을 평가한다. 모든 고유값의 실수부가 음수이면, 시스템은 안정적이다.</li>
<li><strong>포괄적 기준(Comprehensive Criteria)</strong>: 각 출력에 대해 독립적인 안정성 분석을 수행한 후, 전체 시스템의 안정성을 종합적으로 평가한다.</li>
</ul>
<h3 id="state-trajectory-tracking-and-control">상태 궤적 추적과 제어 (State Trajectory Tracking and Control)</h3>
<p>선형 시스템에서 상태 궤적 추적(State Trajectory Tracking)은 시스템이 시간에 따라 특정 경로를 따라가도록 제어하는 것을 의미한다. 이는 목표 궤적(Target Trajectory)을 정의하고, 시스템의 상태가 이 목표를 따라가도록 제어 입력을 설계하는 과정이다.</p>
<h4 id="_15">궤적 추적 제어기 설계</h4>
<p>궤적 추적을 위한 제어기는 일반적으로 다음과 같은 형태를 갖는다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(t) = -\mathbf{K} \cdot (\mathbf{x}(t) - \mathbf{x}_r(t)) + \mathbf{u}_r(t)
</div>
<script type="math/tex; mode=display">
\mathbf{u}(t) = -\mathbf{K} \cdot (\mathbf{x}(t) - \mathbf{x}_r(t)) + \mathbf{u}_r(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_r(t)</span><script type="math/tex">\mathbf{x}_r(t)</script></span>는 목표 상태 궤적, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_r(t)</span><script type="math/tex">\mathbf{u}_r(t)</script></span>는 목표 입력이다. <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>는 상태 피드백 게인으로, 시스템의 상태가 목표 궤적을 따라가도록 하는 역할을 한다.</p>
<p>이 제어기의 목표는 시스템의 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>가 목표 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_r(t)</span><script type="math/tex">\mathbf{x}_r(t)</script></span>와 최대한 가깝게 유지되도록 하는 것이다. 이를 위해 상태 오차 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{e}(t) = \mathbf{x}(t) - \mathbf{x}_r(t)</span><script type="math/tex">\mathbf{e}(t) = \mathbf{x}(t) - \mathbf{x}_r(t)</script></span>를 최소화하는 것이 핵심이다.</p>
<h4 id="_16">궤적 추적의 안정성</h4>
<p>궤적 추적의 안정성을 확보하기 위해서는 상태 피드백 게인 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>가 적절히 설계되어야 한다. 시스템이 궤적을 추적하는 동안 상태 오차가 수렴하고, 시스템이 목표 궤적에서 벗어나지 않도록 보장해야 한다.</p>
<p>상태 궤적 추적은 로봇 공학, 항법 시스템, 자동화 제어 등 다양한 응용 분야에서 중요하게 다루어진다. 특히, 선형 시스템에서는 궤적 추적을 위한 제어 입력을 설계할 때 리아프노프 이론이나 고유값 배치와 같은 방법들이 활용된다.</p>
<h3 id="control-design-techniques-for-linear-systems">선형 시스템의 제어 설계 기법 (Control Design Techniques for Linear Systems)</h3>
<p>선형 시스템의 제어 설계는 시스템이 원하는 성능을 발휘하도록 입력 신호를 조정하는 방법을 연구하는 분야이다. 다양한 제어 설계 기법이 있으며, 각각의 방법은 특정한 시스템 특성이나 요구 사항에 적합하다.</p>
<h4 id="state-feedback-control_1">상태 피드백 제어 (State Feedback Control)</h4>
<p>상태 피드백 제어는 시스템의 상태 벡터를 측정하여 이를 바탕으로 제어 입력을 생성하는 방식이다. 상태 피드백 제어법의 가장 기본적인 형태는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}(t) = -\mathbf{K} \cdot \mathbf{x}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{u}(t) = -\mathbf{K} \cdot \mathbf{x}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>는 상태 피드백 게인 벡터 또는 행렬이다. <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>의 설계를 통해 시스템의 고유값을 원하는 위치로 이동시켜, 시스템의 안정성 및 동적 성능을 조절할 수 있다.</p>
<p><strong>고유값 배치(Eigenvalue Placement)</strong> 기법은 상태 피드백 제어에서 가장 많이 사용되는 방법 중 하나이다. 이 방법은 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span>를 선택하여 시스템의 고유값을 특정 위치로 배치함으로써, 시스템의 응답 특성을 조정한다. 고유값 배치는 제어 가능성 행렬의 풀 랭크 여부를 확인한 후 수행된다. 제어 가능성이 있는 시스템에서는 고유값을 임의로 배치할 수 있다.</p>
<h4 id="optimal-control">최적 제어 (Optimal Control)</h4>
<p>최적 제어는 시스템의 성능 지표를 최적화하기 위해 제어 입력을 설계하는 방법이다. <strong>LQR(Linear Quadratic Regulator)</strong>은 가장 널리 사용되는 최적 제어 기법 중 하나이다. LQR은 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">x(t)</span><script type="math/tex">x(t)</script></span>와 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>의 제곱합을 최소화하는 제어 입력을 찾는 데 사용된다.</p>
<p>LQR의 성능 지표(성능 함수)는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
J = \int_{0}^{\infty} \left( x(t)^T Q x(t) + u(t)^T R u(t) \right) dt
</div>
<script type="math/tex; mode=display">
J = \int_{0}^{\infty} \left( x(t)^T Q x(t) + u(t)^T R u(t) \right) dt
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>은 각각 상태와 제어 입력의 가중치를 나타내는 대칭 양의 정부호 행렬이다. 이 성능 지표를 최소화하는 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>는 리카티 방정식(Riccati Equation)을 통해 계산되며, 이로부터 상태 피드백 게인 <span class="arithmatex"><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>가 도출된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
u(t) = -K \cdot x(t) = -(R^{-1} B^T P) \cdot x(t)
</div>
<script type="math/tex; mode=display">
u(t) = -K \cdot x(t) = -(R^{-1} B^T P) \cdot x(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>는 리카티 방정식의 해이다.</p>
<h4 id="classical-controller-design">고전 제어기 설계 (Classical Controller Design)</h4>
<p>고전 제어는 주로 주파수 도메인에서 시스템을 분석하고 설계하는 방법을 포함한다. 이 방법에서는 PID 제어기(Proportional-Integral-Derivative Controller)와 같은 간단한 제어 구조를 사용하여 시스템의 동작을 조절한다.</p>
<p><strong>PID 제어기</strong>는 다음과 같은 형태로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
u(t) = K_p e(t) + K_i \int e(t) dt + K_d \frac{de(t)}{dt}
</div>
<script type="math/tex; mode=display">
u(t) = K_p e(t) + K_i \int e(t) dt + K_d \frac{de(t)}{dt}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">e(t)</span><script type="math/tex">e(t)</script></span>는 목표값과 실제 출력 간의 오차, <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span>는 각각 비례, 적분, 미분 게인이다. PID 제어기는 다양한 시스템에서 널리 사용되며, 오차를 최소화하고 시스템 응답을 개선하는 데 효과적이다.</p>
<p>PID 제어기의 설계는 보드 플롯(Bode Plot), 니콜스 차트(Nichols Chart)와 같은 주파수 응답 도구를 통해 수행되며, 이를 통해 제어기의 안정성, 대역폭, 그리고 주파수 응답을 최적화할 수 있다.</p>
<h4 id="state-observer-design">상태 관측기 설계 (State Observer Design)</h4>
<p>상태 관측기는 시스템의 일부 또는 전체 상태를 직접 측정할 수 없을 때, 출력 신호를 바탕으로 상태를 추정하는 장치이다. 칼만 필터(Kalman Filter)는 가장 대표적인 상태 관측기 설계 방법 중 하나이다.</p>
<p>선형 시스템의 상태 관측기는 일반적으로 다음과 같은 형태를 가진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\hat{\mathbf{x}}(t) = \mathbf{A} \hat{\mathbf{x}}(t) + \mathbf{B} \mathbf{u}(t) + \mathbf{L}(\mathbf{y}(t) - \mathbf{C} \hat{\mathbf{x}}(t))
</div>
<script type="math/tex; mode=display">
\hat{\mathbf{x}}(t) = \mathbf{A} \hat{\mathbf{x}}(t) + \mathbf{B} \mathbf{u}(t) + \mathbf{L}(\mathbf{y}(t) - \mathbf{C} \hat{\mathbf{x}}(t))
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{x}}(t)</span><script type="math/tex">\hat{\mathbf{x}}(t)</script></span>는 추정된 상태 벡터, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>은 관측기 게인(Observer Gain)이다. 관측기 게인 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>은 시스템의 상태와 측정된 출력 간의 오차를 최소화하도록 설계된다. </p>
<p><strong>루엔버거 관측기(Luenberger Observer)</strong>는 상태 관측기의 가장 기본적인 형태로, 시스템의 안정성과 성능을 보장하기 위해 관측기 게인 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>을 적절히 선택한다. <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>의 설계는 고유값 배치 방법을 사용하여, 관측기 고유값을 원하는 위치로 배치함으로써 이루어진다.</p>
<h4 id="internal-model-control-imc">내부 모델 제어 (Internal Model Control, IMC)</h4>
<p>내부 모델 제어는 제어 대상 시스템의 모델을 사용하여 시스템의 동작을 직접적으로 제어하는 방법이다. IMC는 시스템의 역모델을 이용하여 제어기를 설계하는데, 이를 통해 시스템의 정확한 제어가 가능하다.</p>
<p>IMC는 다음과 같은 구조를 가진다:</p>
<ol>
<li><strong>모델링 단계</strong>: 시스템의 수학적 모델을 구축한다.</li>
<li><strong>역모델 설계</strong>: 시스템 모델의 역을 계산하여 제어 입력을 설계한다.</li>
<li><strong>제어 입력 생성</strong>: 시스템의 출력이 목표 값에 정확히 도달하도록 제어 입력을 생성한다.</li>
</ol>
<p>IMC는 주로 시스템의 정확한 제어가 필요할 때 사용되며, 특히 시스템의 모델이 잘 알려진 경우 효과적이다. 그러나 모델링 오류가 있는 경우 제어 성능이 저하될 수 있으므로, 이를 보정하기 위한 추가적인 설계가 필요하다.</p>
<hr />
<p>지금까지 선형 시스템의 기본 이론에 대한 내용을 다루었다. 선형 시스템 이론은 다양한 제어 설계 및 분석 방법을 포함하며, 이는 실제 시스템의 제어 문제를 해결하는 데 필수적인 기초를 제공한다. 이론적으로 확립된 다양한 기법들은 실제 시스템의 특성에 맞추어 응용될 수 있으며, 제어 공학 전반에서 중요한 역할을 한다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../024/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../024/" class="btn btn-xs btn-link">
        최소 제곱 추정법과 칼만 필터의 관계
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../022/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../022/" class="btn btn-xs btn-link">
        확률적 모델링 가우시안 분포의 중요성
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>