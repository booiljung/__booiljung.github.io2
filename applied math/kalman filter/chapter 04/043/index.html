<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/applied%20math/kalman%20filter/chapter%2004/043/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>리카티 방정식 (Riccati Equation) - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \ub3c4\ucd9c", url: "#_top", children: [
          ]},
          {title: "\uc2dc\uac04 \uac31\uc2e0 \ub2e8\uacc4\uc5d0\uc11c\uc758 \ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd", url: "#_2", children: [
          ]},
          {title: "\uce21\uc815 \uac31\uc2e0 \ub2e8\uacc4\uc5d0\uc11c\uc758 \ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd", url: "#_3", children: [
          ]},
          {title: "\uc218\ub834\uc131 \ubc0f \uc548\uc815\uc131 \ubd84\uc11d", url: "#_4", children: [
          ]},
          {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd (Riccati Equation)", url: "#riccati-equation", children: [
              {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \uac1c\uc694", url: "#_5" },
              {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \uc720\ub3c4", url: "#_6" },
              {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \uc218\uce58\uc801 \uc131\uc9c8", url: "#_7" },
              {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \ud574\uc11d\uc801 \uc131\uc9c8", url: "#_8" },
              {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \uc218\uce58\uc801 \ud574\uacb0 \ubc29\ubc95", url: "#_9" },
              {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \uc801\uc6a9 \uc608", url: "#_10" },
              {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \uace0\uae09 \uc8fc\uc81c", url: "#_11" },
              {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \ud2b9\uc218 \ud574", url: "#_12" },
              {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \uc548\uc815\uc131 \ubd84\uc11d", url: "#_13" },
              {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd\uc758 \uace0\uae09 \uc751\uc6a9", url: "#_14" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../044/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../044/" class="btn btn-xs btn-link">
        칼만 필터의 수렴성 분석
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../042/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../042/" class="btn btn-xs btn-link">
        칼만 필터 알고리즘의 유도
      </a>
    </div>
    
  </div>

    

    <h3 id="_1">리카티 방정식의 도출</h3>
<p>칼만 필터의 핵심 중 하나는 상태 추정의 오차 공분산 행렬을 계산하는 것이다. 이 오차 공분산 행렬은 필터의 성능을 평가하는 중요한 요소로, 칼만 필터의 알고리즘 내에서 지속적으로 업데이트된다. 리카티 방정식은 이 오차 공분산 행렬을 시간에 따라 갱신하는 데 사용되는 비선형 행렬 미분 방정식이다.</p>
<p>칼만 필터에서 상태 추정 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>는 다음과 같은 리카티 방정식에 의해 갱신된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k+1} = \mathbf{A}_k \mathbf{P}_k \mathbf{A}_k^\top - \mathbf{A}_k \mathbf{P}_k \mathbf{C}_k^\top (\mathbf{C}_k \mathbf{P}_k \mathbf{C}_k^\top + \mathbf{R}_k)^{-1} \mathbf{C}_k \mathbf{P}_k \mathbf{A}_k^\top + \mathbf{Q}_k
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k+1} = \mathbf{A}_k \mathbf{P}_k \mathbf{A}_k^\top - \mathbf{A}_k \mathbf{P}_k \mathbf{C}_k^\top (\mathbf{C}_k \mathbf{P}_k \mathbf{C}_k^\top + \mathbf{R}_k)^{-1} \mathbf{C}_k \mathbf{P}_k \mathbf{A}_k^\top + \mathbf{Q}_k
</script>
</div>
<p>위 식에서,</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>: 시간 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>에서의 상태 추정 오차 공분산 행렬.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_k</span><script type="math/tex">\mathbf{A}_k</script></span>: 시스템 상태 전이 행렬.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}_k</span><script type="math/tex">\mathbf{C}_k</script></span>: 관측 모델 행렬.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}_k</span><script type="math/tex">\mathbf{Q}_k</script></span>: 프로세스 잡음 공분산 행렬.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_k</span><script type="math/tex">\mathbf{R}_k</script></span>: 측정 잡음 공분산 행렬.</li>
</ul>
<p>리카티 방정식은 비선형이므로 해를 구하는 데 있어 다양한 수치적 방법이 필요하다. 하지만 이 방정식의 근본적인 중요성은 칼만 필터가 주어진 시스템에서 최적의 상태 추정을 수행하도록 하는 데 있다.</p>
<h3 id="_2">시간 갱신 단계에서의 리카티 방정식</h3>
<p>리카티 방정식은 칼만 필터의 시간 갱신(Time Update) 단계에서 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k+1|k}</span><script type="math/tex">\mathbf{P}_{k+1|k}</script></span>를 예측하는 데 사용된다. 이 단계에서는 시스템이 다음 상태로 전이함에 따라 오차 공분산이 어떻게 변하는지 계산한다.</p>
<p>시간 갱신 단계에서 오차 공분산의 예측은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k+1|k} = \mathbf{A}_k \mathbf{P}_k \mathbf{A}_k^\top + \mathbf{Q}_k
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k+1|k} = \mathbf{A}_k \mathbf{P}_k \mathbf{A}_k^\top + \mathbf{Q}_k
</script>
</div>
<p>이 식은 현재 시간 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>에서 예측한 시간 <span class="arithmatex"><span class="MathJax_Preview">k+1</span><script type="math/tex">k+1</script></span>에서의 오차 공분산을 나타낸다. 여기서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_k</span><script type="math/tex">\mathbf{A}_k</script></span>는 상태 전이 행렬로, 시스템이 시간에 따라 어떻게 변화하는지를 나타내며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}_k</span><script type="math/tex">\mathbf{Q}_k</script></span>는 시스템에 존재하는 내부 잡음의 공분산을 나타낸다. 이 과정은 오차 공분산이 상태 전이와 잡음에 의해 어떻게 증가하는지를 반영한다.</p>
<h3 id="_3">측정 갱신 단계에서의 리카티 방정식</h3>
<p>측정 갱신(Measurement Update) 단계에서는 시스템이 관측된 데이터를 통해 예측된 상태를 수정하며, 이 때 오차 공분산도 함께 갱신된다. 칼만 이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_k</span><script type="math/tex">\mathbf{K}_k</script></span>는 이 단계에서 계산되며, 이는 리카티 방정식을 통해 계산된 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>에 의해 결정된다.</p>
<p>측정 갱신 단계에서의 오차 공분산 갱신은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_k = \mathbf{P}_{k|k-1} - \mathbf{K}_k \mathbf{C}_k \mathbf{P}_{k|k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_k = \mathbf{P}_{k|k-1} - \mathbf{K}_k \mathbf{C}_k \mathbf{P}_{k|k-1}
</script>
</div>
<p>여기서 칼만 이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_k</span><script type="math/tex">\mathbf{K}_k</script></span>는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{C}_k^\top (\mathbf{C}_k \mathbf{P}_{k|k-1} \mathbf{C}_k^\top + \mathbf{R}_k)^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{C}_k^\top (\mathbf{C}_k \mathbf{P}_{k|k-1} \mathbf{C}_k^\top + \mathbf{R}_k)^{-1}
</script>
</div>
<p>이 식은 예측된 상태에 대한 측정 데이터를 반영하여 오차 공분산을 갱신한다. 이는 측정의 신뢰도(즉, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_k</span><script type="math/tex">\mathbf{R}_k</script></span>)와 시스템의 모델링 신뢰도(즉, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k|k-1}</span><script type="math/tex">\mathbf{P}_{k|k-1}</script></span>) 간의 상호 작용을 고려하여 이루어진다. </p>
<p>칼만 필터가 이 과정에서 최적의 상태 추정을 수행하기 위해서는 리카티 방정식을 통한 오차 공분산의 정확한 계산이 필수적이다.</p>
<h3 id="_4">수렴성 및 안정성 분석</h3>
<p>리카티 방정식은 칼만 필터의 수렴성과 안정성을 결정하는 중요한 요소이다. 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>의 수렴성은 시스템이 시간이 지남에 따라 안정적인 상태로 수렴하는지를 판단하는 데 사용된다. 이 과정에서 시스템의 성질과 잡음의 특성이 중요한 역할을 하며, 특정 조건하에서 리카티 방정식의 해가 안정적으로 수렴하는지 분석하는 것이 필요하다.</p>
<p>리카티 방정식의 안정성은 시스템의 고유값에 크게 의존하며, 이는 필터가 장기적으로 안정적으로 작동할 수 있는지를 결정한다. 안정적인 칼만 필터는 필터링 과정에서 계산된 오차 공분산 행렬이 특정 조건 하에서 일정한 값으로 수렴하도록 보장한다.</p>
<h2 id="riccati-equation">리카티 방정식 (Riccati Equation)</h2>
<h3 id="_5">리카티 방정식의 개요</h3>
<p>리카티 방정식은 칼만 필터에서 중요한 역할을 하며, 특히 상태 추정의 오차 공분산 행렬을 갱신하는 과정에서 중심적인 위치를 차지한다. 이 방정식은 칼만 필터 알고리즘의 핵심 구성 요소 중 하나로, 필터의 안정성과 성능을 결정짓는 중요한 수학적 도구이다.</p>
<p>리카티 방정식은 일반적으로 다음과 같은 형태로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k+1} = \mathbf{A}_k \mathbf{P}_k \mathbf{A}_k^\top + \mathbf{Q}_k - \mathbf{K}_k \mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^\top \mathbf{K}_k^\top
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k+1} = \mathbf{A}_k \mathbf{P}_k \mathbf{A}_k^\top + \mathbf{Q}_k - \mathbf{K}_k \mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^\top \mathbf{K}_k^\top
</script>
</div>
<p>여기서, 
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>는 k번째 시점에서의 오차 공분산 행렬이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_k</span><script type="math/tex">\mathbf{A}_k</script></span>는 시스템의 상태 전이 행렬(State Transition Matrix)이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}_k</span><script type="math/tex">\mathbf{Q}_k</script></span>는 프로세스 노이즈 공분산 행렬(Process Noise Covariance Matrix)이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_k</span><script type="math/tex">\mathbf{K}_k</script></span>는 칼만 이득(Kalman Gain)이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}_k</span><script type="math/tex">\mathbf{H}_k</script></span>는 관측 모델(Observation Model)이다.</p>
<p>리카티 방정식은 시스템의 상태 추정 오차 공분산을 갱신함으로써 필터가 다음 시간 스텝에서의 상태를 추정할 때의 불확실성을 반영하도록 한다.</p>
<h3 id="_6">리카티 방정식의 유도</h3>
<p>리카티 방정식은 칼만 필터 알고리즘에서 상태 추정 오차 공분산 행렬의 시간적 진화(time evolution)를 설명한다. 이 방정식은 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>의 시간 업데이트(Time Update)와 측정 업데이트(Measurement Update) 단계를 거쳐 도출된다.</p>
<h4 id="1-prediction-step">1. 시간 업데이트 (Prediction Step)</h4>
<p>시간 업데이트 단계에서는 현재 시점에서의 상태 추정치와 오차 공분산 행렬이 시스템의 동적 모델에 따라 다음 시점으로 예측된다. 오차 공분산 행렬의 예측은 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k+1|k} = \mathbf{A}_k \mathbf{P}_k \mathbf{A}_k^\top + \mathbf{Q}_k
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k+1|k} = \mathbf{A}_k \mathbf{P}_k \mathbf{A}_k^\top + \mathbf{Q}_k
</script>
</div>
<p>여기서, 
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k+1|k}</span><script type="math/tex">\mathbf{P}_{k+1|k}</script></span>는 k+1 시점에서의 예측된 오차 공분산 행렬이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>는 k 시점에서의 오차 공분산 행렬이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}_k</span><script type="math/tex">\mathbf{Q}_k</script></span>는 k 시점에서의 프로세스 노이즈 공분산 행렬이다.</p>
<p>이 단계는 시스템의 동적 모델에 의해 결정되며, 오차 공분산 행렬이 시스템의 불확실성(프로세스 노이즈)으로 인해 증가하는 것을 반영한다.</p>
<h4 id="2-update-step">2. 측정 업데이트 (Update Step)</h4>
<p>측정 업데이트 단계에서는 관측 데이터를 사용하여 예측된 상태를 갱신하고, 이에 따라 오차 공분산 행렬도 갱신된다. 갱신된 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k+1}</span><script type="math/tex">\mathbf{P}_{k+1}</script></span>는 다음과 같이 주어진다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k+1} = \mathbf{P}_{k+1|k} - \mathbf{K}_{k+1} \mathbf{H}_{k+1} \mathbf{P}_{k+1|k}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k+1} = \mathbf{P}_{k+1|k} - \mathbf{K}_{k+1} \mathbf{H}_{k+1} \mathbf{P}_{k+1|k}
</script>
</div>
<p>여기서, 
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_{k+1}</span><script type="math/tex">\mathbf{K}_{k+1}</script></span>는 k+1 시점에서의 칼만 이득이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}_{k+1}</span><script type="math/tex">\mathbf{H}_{k+1}</script></span>는 k+1 시점에서의 관측 모델이다.</p>
<p>칼만 이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_{k+1}</span><script type="math/tex">\mathbf{K}_{k+1}</script></span>은 관측 데이터가 상태 추정에 얼마나 기여할지 결정하며, 이는 예측된 오차 공분산과 관측 모델의 관계에 따라 계산된다. 이 과정에서 오차 공분산 행렬은 줄어들며, 이는 필터가 관측치를 사용하여 예측을 조정하는 결과로 나타난다.</p>
<h3 id="_7">리카티 방정식의 수치적 성질</h3>
<p>리카티 방정식은 비선형 행렬 방정식으로, 특히 시간이 흐름에 따라 오차 공분산 행렬의 수렴 특성에 중요한 영향을 미친다. 특정 조건 하에서, 이 방정식은 필터의 수렴성을 보장하고, 시간에 따른 오차 공분산 행렬이 안정화되는지 여부를 결정한다.</p>
<p>리카티 방정식의 해를 수치적으로 구할 때는 다음과 같은 몇 가지 고려사항이 있다.</p>
<ul>
<li>
<p><strong>초기화:</strong> 초기 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_0</span><script type="math/tex">\mathbf{P}_0</script></span>의 설정은 필터의 초기 성능에 크게 영향을 미친다. 적절한 초기화가 이루어지지 않으면, 필터의 수렴이 지연되거나 오차가 발생할 수 있다.</p>
</li>
<li>
<p><strong>안정성:</strong> 리카티 방정식의 수치적 계산에서 행렬의 조건수(condition number)는 필터의 안정성에 영향을 미친다. 조건수가 높으면 수치적 불안정성이 발생할 수 있으므로, 이에 대한 주의가 필요하다.</p>
</li>
<li>
<p><strong>수렴 특성:</strong> 리카티 방정식의 수렴 속도는 필터의 성능과 직결된다. 일반적으로, 필터의 수렴성을 보장하기 위해서는 시스템 모델과 노이즈 공분산 행렬의 적절한 설정이 필요하다.</p>
</li>
</ul>
<h3 id="_8">리카티 방정식의 해석적 성질</h3>
<p>리카티 방정식은 일반적으로 비선형이지만, 일부 특별한 경우에는 해석적 해를 구할 수 있다. 이 해석적 해는 필터의 성능 분석이나 특정 상황에서의 최적 상태 추정에 유용하게 활용된다. 해석적 접근은 주로 다음과 같은 경우에 가능하다.</p>
<h4 id="1-algebraic-riccati-equation">1. 정준 리카티 방정식 (Algebraic Riccati Equation)</h4>
<p>시스템이 시간 불변(time-invariant)이고, 안정적(stable)일 경우, 리카티 방정식은 시간에 따른 변화가 없는 정준 리카티 방정식(Algebraic Riccati Equation, ARE)으로 단순화될 수 있다. 이 경우, 리카티 방정식은 다음과 같은 형태를 취한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P} = \mathbf{A} \mathbf{P} \mathbf{A}^\top + \mathbf{Q} - \mathbf{A} \mathbf{P} \mathbf{H}^\top \left(\mathbf{H} \mathbf{P} \mathbf{H}^\top + \mathbf{R}\right)^{-1} \mathbf{H} \mathbf{P} \mathbf{A}^\top
</div>
<script type="math/tex; mode=display">
\mathbf{P} = \mathbf{A} \mathbf{P} \mathbf{A}^\top + \mathbf{Q} - \mathbf{A} \mathbf{P} \mathbf{H}^\top \left(\mathbf{H} \mathbf{P} \mathbf{H}^\top + \mathbf{R}\right)^{-1} \mathbf{H} \mathbf{P} \mathbf{A}^\top
</script>
</div>
<p>여기서 모든 행렬은 시간에 대해 고정되어 있으며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 관측 노이즈 공분산 행렬이다. 이 방정식은 상태 추정의 오차 공분산 행렬이 수렴된 이후의 상태를 나타내며, 시스템의 장기적 성능을 분석하는 데 사용된다.</p>
<h4 id="2-singularities">2. 리카티 방정식의 특이점 (Singularities)</h4>
<p>리카티 방정식에서 발생할 수 있는 특이점(singularities)은 필터의 수렴성에 중요한 영향을 미친다. 예를 들어, 시스템이 완전히 관측 가능하지 않을 경우, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H} \mathbf{P} \mathbf{H}^\top</span><script type="math/tex">\mathbf{H} \mathbf{P} \mathbf{H}^\top</script></span>의 역행렬이 존재하지 않게 되어 수치적으로 불안정한 상황이 발생할 수 있다. 이러한 특이점을 피하기 위해서는 시스템의 관측 가능성(Observability) 조건을 엄격히 확인해야 한다.</p>
<h3 id="_9">리카티 방정식의 수치적 해결 방법</h3>
<p>리카티 방정식은 일반적으로 반복 알고리즘을 통해 수치적으로 해결된다. 다양한 수치적 방법이 존재하지만, 그 중 대표적인 방법은 다음과 같다.</p>
<h4 id="1-sequential-solution-method">1. 순차적 해결 방법 (Sequential Solution Method)</h4>
<p>순차적 해결 방법은 각 시간 단계마다 리카티 방정식을 계산하고 오차 공분산 행렬을 갱신하는 방법이다. 이는 기본적인 칼만 필터 구현에서 사용되며, 다음의 절차를 따른다.</p>
<ol>
<li>초기 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_0</span><script type="math/tex">\mathbf{P}_0</script></span>를 설정한다.</li>
<li>각 시간 단계 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>에서 리카티 방정식을 풀어 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>를 갱신한다.</li>
<li>갱신된 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>를 사용하여 칼만 이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_k</span><script type="math/tex">\mathbf{K}_k</script></span>를 계산한다.</li>
<li>갱신된 상태 추정을 수행하고, 다음 시간 단계로 이동한다.</li>
</ol>
<p>이 방법은 직관적이며 구현이 비교적 간단하지만, 고차원 시스템에서는 계산 비용이 증가할 수 있다.</p>
<h4 id="2-optimization-based-methods">2. 최적화 기반 방법 (Optimization-Based Methods)</h4>
<p>리카티 방정식을 푸는 또 다른 방법은 최적화 알고리즘을 사용하는 것이다. 이 방법은 리카티 방정식을 최소화 문제로 변환하여 수치적 최적화 알고리즘(예: 뉴턴 방법, 경사 하강법)을 통해 해결한다. 이러한 방법은 대규모 시스템이나 복잡한 동적 모델에서 유용할 수 있다.</p>
<ol>
<li>리카티 방정식을 최소화할 목적 함수로 변환한다.</li>
<li>목적 함수를 최소화하는 방향으로 반복적인 수치적 최적화를 수행한다.</li>
<li>수렴 기준에 도달할 때까지 반복하여 오차 공분산 행렬을 갱신한다.</li>
</ol>
<p>이 방법은 보다 일반적인 상황에서 사용될 수 있지만, 최적화 알고리즘의 수렴 속도와 안정성을 보장하기 위해 추가적인 고려가 필요하다.</p>
<h4 id="3-matrix-decomposition-methods">3. 행렬 분해 방법 (Matrix Decomposition Methods)</h4>
<p>리카티 방정식을 푸는 또 다른 접근은 행렬 분해를 사용하는 방법이다. 이 방법은 수치적 안정성을 개선하고, 계산 효율성을 높이기 위해 자주 사용된다.</p>
<ul>
<li><strong>쇼렌 분해 (Schur Decomposition):</strong> 시스템의 동적 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>를 쇼렌 분해하여 리카티 방정식을 삼각화된 형태로 변환하고, 이를 기반으로 해결한다.</li>
<li><strong>채올레스키 분해 (Cholesky Decomposition):</strong> 오차 공분산 행렬이 대칭 양정치일 경우, 채올레스키 분해를 사용하여 보다 효율적으로 리카티 방정식을 해결할 수 있다.</li>
</ul>
<p>행렬 분해 방법은 수치적으로 매우 안정적이며, 대규모 시스템에서도 효율적인 계산을 가능하게 한다.</p>
<h3 id="_10">리카티 방정식의 적용 예</h3>
<p>리카티 방정식은 다양한 분야에서 응용된다. 칼만 필터의 핵심 구성 요소로서, 리카티 방정식의 해결은 정확한 상태 추정과 필터 성능의 근간을 이룬다. 여기서는 리카티 방정식이 구체적으로 어떻게 응용되는지 몇 가지 사례를 소개한다.</p>
<h4 id="1">1. 항법 시스템</h4>
<p>항법 시스템에서의 칼만 필터는 차량이나 항공기의 위치, 속도 등을 추정하기 위해 사용된다. 이 경우, 리카티 방정식은 시스템의 동적 모델과 관측 모델을 기반으로 오차 공분산 행렬을 지속적으로 갱신하여, 정확한 위치 추정을 가능하게 한다. 항법 시스템에서 리카티 방정식의 안정적 해결은 시스템의 신뢰성을 크게 좌우한다.</p>
<h4 id="2">2. 경제 모델링</h4>
<p>경제학에서 리카티 방정식은 거시경제 변수의 추정에 활용된다. 예를 들어, GDP 성장률이나 인플레이션 등의 변수를 추정하기 위해 칼만 필터를 사용할 때, 리카티 방정식은 이러한 변수들의 오차 공분산을 계산하는 데 사용된다. 경제 시스템은 일반적으로 매우 복잡하고 노이즈가 많기 때문에, 리카티 방정식의 적절한 해결이 필수적이다.</p>
<h4 id="3">3. 제어 시스템</h4>
<p>제어 이론에서도 리카티 방정식은 필수적인 도구로 사용된다. 특히 최적 제어 문제에서, 리카티 방정식은 시스템의 최적 상태 경로를 계산하는 데 사용된다. 이때, 리카티 방정식의 해는 시스템의 안정성과 제어 성능을 보장하기 위한 중요한 요소로 작용한다.</p>
<h3 id="_11">리카티 방정식의 고급 주제</h3>
<p>리카티 방정식은 고급 필터링 및 제어 이론에서도 여러 확장 및 변형이 존재한다. 이러한 고급 주제는 연구 및 응용 분야에서 깊이 있게 다루어지며, 필터링 이론의 확장을 이해하는 데 중요한 역할을 한다.</p>
<h4 id="1-distance-vector-lipschitz-riccati-equation">1. 디스턴스 벡터 립슈츠 리카티 방정식 (Distance Vector Lipschitz Riccati Equation)</h4>
<p>이 방정식은 시스템의 시간 변화를 고려한 변형된 리카티 방정식으로, 시간에 따라 가변적인 시스템에서 상태 추정을 보다 정확하게 할 수 있도록 도와준다. 이러한 방정식은 일반적인 리카티 방정식의 해석적 한계를 극복하고, 시스템의 불확실성이 높을 때 유용하게 사용된다.</p>
<h4 id="2-differential-riccati-equation">2. 미분 리카티 방정식 (Differential Riccati Equation)</h4>
<p>연속 시간 시스템에서 사용되는 리카티 방정식은 미분 형태로 나타난다. 미분 리카티 방정식(DRE)은 연속적인 상태 변화에 대응하는 오차 공분산 행렬의 변화율을 나타내며, 이는 연속 제어 시스템에서 필수적으로 사용된다. 미분 리카티 방정식의 수치적 해결은 시간 스텝에 따른 안정성 분석에 중요한 역할을 한다.</p>
<p>"리카티 방정식" 주제는 칼만 필터의 수학적 기초와 응용에서 핵심적인 역할을 하며, 정확한 상태 추정과 시스템 안정성을 보장하는 데 필수적이다. 이를 통해 다양한 시스템에서 필터링의 효율성과 신뢰성을 확보할 수 있다.</p>
<p>리카티 방정식의 고급 주제에 대한 설명을 이어서 하겠다.</p>
<h3 id="_12">리카티 방정식의 특수 해</h3>
<p>리카티 방정식은 다양한 조건 하에서 여러 형태의 특수 해를 가질 수 있으며, 이러한 특수 해는 칼만 필터의 특정 응용 분야에서 매우 유용하다.</p>
<h4 id="1-steady-state-solution">1. 스테디 스테이트 해 (Steady-State Solution)</h4>
<p>시스템이 시간에 대해 안정적이고, 상태 전이 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>, 관측 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}</span><script type="math/tex">\mathbf{H}</script></span>, 프로세스 노이즈 공분산 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>, 관측 노이즈 공분산 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span> 등이 일정한 경우, 리카티 방정식은 스테디 스테이트 해(steady-state solution)를 가질 수 있다. 이 경우, 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>는 일정한 값을 가지게 되며, 시간에 따라 변화하지 않는다. 이는 다음과 같은 형태로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P} = \mathbf{A} \mathbf{P} \mathbf{A}^\top + \mathbf{Q} - \mathbf{A} \mathbf{P} \mathbf{H}^\top \left(\mathbf{H} \mathbf{P} \mathbf{H}^\top + \mathbf{R}\right)^{-1} \mathbf{H} \mathbf{P} \mathbf{A}^\top
</div>
<script type="math/tex; mode=display">
\mathbf{P} = \mathbf{A} \mathbf{P} \mathbf{A}^\top + \mathbf{Q} - \mathbf{A} \mathbf{P} \mathbf{H}^\top \left(\mathbf{H} \mathbf{P} \mathbf{H}^\top + \mathbf{R}\right)^{-1} \mathbf{H} \mathbf{P} \mathbf{A}^\top
</script>
</div>
<p>스테디 스테이트 해는 필터의 초기 트랜지언트(transient) 단계가 끝난 후 장기적인 성능을 분석하는 데 유용하다. 이 해는 시간 불변 시스템에서 필터의 성능을 예측하는 데 중요한 도구가 된다.</p>
<h4 id="2_1">2. 제어 이론에서의 리카티 방정식</h4>
<p>리카티 방정식은 제어 이론에서도 중요한 역할을 한다. 특히 최적 제어(optimal control) 문제에서, 리카티 방정식은 시스템의 비용 함수(cost function)를 최소화하는 최적 상태 궤적을 계산하는 데 사용된다. 이러한 제어 문제에서 리카티 방정식은 선형 이차 조절기(linear quadratic regulator, LQR) 문제의 해로 사용되며, 이는 다음과 같은 형태를 취한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\dot{\mathbf{P}}(t) = -\mathbf{P}(t) \mathbf{A}(t) - \mathbf{A}(t)^\top \mathbf{P}(t) + \mathbf{P}(t) \mathbf{B}(t) \mathbf{R}^{-1} \mathbf{B}(t)^\top \mathbf{P}(t) - \mathbf{Q}(t)
</div>
<script type="math/tex; mode=display">
\dot{\mathbf{P}}(t) = -\mathbf{P}(t) \mathbf{A}(t) - \mathbf{A}(t)^\top \mathbf{P}(t) + \mathbf{P}(t) \mathbf{B}(t) \mathbf{R}^{-1} \mathbf{B}(t)^\top \mathbf{P}(t) - \mathbf{Q}(t)
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}(t)</span><script type="math/tex">\mathbf{B}(t)</script></span>는 제어 입력에 대한 시스템의 입력 행렬이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 제어 입력에 대한 비용 함수의 가중치를 나타낸다.</p>
<p>이 방정식은 시스템의 상태를 최적화된 경로로 유도하기 위한 제어 입력을 계산하는 데 사용되며, 제어 이론에서 필수적인 역할을 한다.</p>
<h3 id="_13">리카티 방정식의 안정성 분석</h3>
<p>리카티 방정식의 수치적 안정성과 그 해의 수렴성은 필터링 및 제어 시스템의 성능에 중요한 영향을 미친다. 이를 이해하기 위해서는 리카티 방정식의 수치적 특성과 안정성 조건을 깊이 있게 분석할 필요가 있다.</p>
<h4 id="1_1">1. 수렴 조건</h4>
<p>리카티 방정식의 해가 수렴하기 위한 조건은 시스템의 관측 가능성(Observability)과 제어 가능성(Controllability)에 의해 결정된다. 일반적으로, 시스템이 관측 가능하고 제어 가능하다면, 리카티 방정식은 시간에 따라 안정적인 해로 수렴한다. 이는 칼만 필터가 장기적으로 안정적인 상태 추정을 수행할 수 있는 기반을 제공한다.</p>
<h4 id="2_2">2. 수치적 불안정성</h4>
<p>리카티 방정식의 수치적 해결 과정에서 발생할 수 있는 불안정성은 다음과 같은 요인에 의해 발생할 수 있다.
- <strong>조건 수 문제:</strong> 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>의 조건 수가 크면, 수치적으로 불안정한 상황이 발생할 수 있다. 이는 작은 수치적 오차가 필터의 해에 큰 영향을 미치는 결과를 초래할 수 있다.
- <strong>디스패리티(disparity) 문제:</strong> 시스템의 동적 모델과 노이즈 모델 간의 스케일 차이로 인해, 리카티 방정식의 해가 비현실적인 값으로 발산할 수 있다.</p>
<h4 id="3_1">3. 안정화 기법</h4>
<p>리카티 방정식의 수치적 안정성을 확보하기 위해 다양한 기법이 사용된다.
- <strong>상대 공분산 행렬의 재조정:</strong> 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>를 적절히 재조정하여 조건 수를 개선하는 방법이다.
- <strong>축소형 리카티 방정식(Reduced-Order Riccati Equation):</strong> 필터의 차원을 줄이기 위해 축소형 모델을 사용하여, 리카티 방정식을 단순화하고 수치적 안정성을 개선한다.</p>
<h3 id="_14">리카티 방정식의 고급 응용</h3>
<p>리카티 방정식은 필터링과 제어 이론 외에도 다양한 고급 응용 분야에서 사용된다. 이러한 응용은 리카티 방정식의 수학적 특성을 활용하여 복잡한 시스템의 상태 추정 및 제어를 수행한다.</p>
<h4 id="1_2">1. 확률적 제어</h4>
<p>확률적 제어(stochastic control) 분야에서는 리카티 방정식을 확률적 시스템의 최적 제어 문제에 적용한다. 이 경우, 리카티 방정식은 시스템의 상태와 제어 입력 간의 불확실성을 반영하는 방법으로 사용되며, 이는 시스템의 노이즈 특성에 대한 강건한 제어를 가능하게 한다.</p>
<h4 id="2-robust-filtering">2. 로버스트 필터링(Robust Filtering)</h4>
<p>로버스트 필터링 기법은 시스템 모델이나 노이즈 특성에 대한 불확실성이 존재할 때에도 안정적인 필터 성능을 보장하기 위해 개발되었다. 리카티 방정식은 이러한 로버스트 필터의 설계에서 중심적인 역할을 하며, 불확실한 환경에서도 필터가 신뢰할 수 있는 상태 추정을 수행하도록 돕는다.</p>
<p>이로써 리카티 방정식에 대한 설명을 마무리할 수 있으며, 이 주제는 칼만 필터의 핵심적인 수학적 도구로서 다양한 응용 분야에서 매우 중요한 역할을 하고 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../044/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../044/" class="btn btn-xs btn-link">
        칼만 필터의 수렴성 분석
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../042/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../042/" class="btn btn-xs btn-link">
        칼만 필터 알고리즘의 유도
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>