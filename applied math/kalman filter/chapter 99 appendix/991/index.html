<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/applied%20math/kalman%20filter/chapter%2099%20appendix/991/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>주요 수학적 공식과 정리 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc0c1\ud0dc \uacf5\uac04 \ubaa8\ub378\uc758 \uc218\ud559\uc801 \uc815\uc758", url: "#_top", children: [
          ]},
          {title: "\uce7c\ub9cc \ud544\ud130 \uc54c\uace0\ub9ac\uc998\uc758 \uae30\ubcf8 \uacf5\uc2dd", url: "#_2", children: [
              {title: "\uc608\uce21 \ub2e8\uacc4 (Prediction Step)", url: "#prediction-step" },
              {title: "\uac31\uc2e0 \ub2e8\uacc4 (Update Step)", url: "#update-step" },
          ]},
          {title: "\ub9ac\uce74\ud2f0 \ubc29\uc815\uc2dd (Riccati Equation)", url: "#riccati-equation", children: [
          ]},
          {title: "\uc218\ub834 \uc870\uac74\uacfc \uc548\uc815\uc131 \ubd84\uc11d", url: "#_3", children: [
          ]},
          {title: "\uc815\ubcf4 \ud544\ud130(Information Filter) \uacf5\uc2dd", url: "#information-filter", children: [
          ]},
          {title: "\uc2a4\ubb34\ub529 \uae30\ubc95(Smoothing Techniques)", url: "#smoothing-techniques", children: [
          ]},
          {title: "\ub2e4\uc911 \ubaa8\ub378 \uc811\uadfc\ubc95 (Multiple Model Approach)", url: "#multiple-model-approach", children: [
          ]},
          {title: "\uc2e0\ub8b0\uc131 \uc788\ub294 \uc2dc\uc2a4\ud15c \uc124\uacc4\uc640 \uc7a5\uc560 \ub300\uc751", url: "#_4", children: [
              {title: "\uc774\uc0c1 \uac12\uc5d0 \ub300\ud55c \ub300\ucc98 (Outlier Handling)", url: "#outlier-handling" },
              {title: "\uc7a5\uc560 \ub300\uc751 (Fault Detection and Isolation)", url: "#fault-detection-and-isolation" },
              {title: "\uac15\uac74\ud55c \uce7c\ub9cc \ud544\ud130 (Robust Kalman Filter)", url: "#robust-kalman-filter" },
          ]},
          {title: "\uc2dc\uc2a4\ud15c\uc758 \uad00\uce21 \uac00\ub2a5\uc131 (Observability)", url: "#observability", children: [
              {title: "\uad00\uce21 \uac00\ub2a5\uc131\uc758 \uc815\uc758", url: "#_5" },
              {title: "\uad00\uce21 \uac00\ub2a5\uc131 \uc870\uac74", url: "#_6" },
              {title: "\uce74\uc6b4\ud2b8\ub864\ub7ec\ube14\ub9ac\ud2f0\uc640\uc758 \uad00\uacc4", url: "#_7" },
          ]},
          {title: "\uc2dc\uc2a4\ud15c\uc758 \uc81c\uc5b4 \uac00\ub2a5\uc131 (Controllability)", url: "#controllability", children: [
              {title: "\uc81c\uc5b4 \uac00\ub2a5\uc131\uc758 \uc815\uc758", url: "#_8" },
              {title: "\uc81c\uc5b4 \uac00\ub2a5\uc131 \uc870\uac74", url: "#_9" },
              {title: "\uc81c\uc5b4 \uac00\ub2a5\uc131\uacfc \uce7c\ub9cc \ud544\ud130", url: "#_10" },
          ]},
          {title: "\ucd5c\uc801 \ud544\ud130\ub9c1 \ubb38\uc81c (Optimal Filtering Problem)", url: "#optimal-filtering-problem", children: [
              {title: "\ubca0\uc774\uc988 \ud544\ud130\ub9c1\uc758 \uae30\ucd08", url: "#_11" },
              {title: "\ucd5c\uc18c \ubd84\uc0b0 \ucd94\uc815 (Minimum Variance Estimation)", url: "#minimum-variance-estimation" },
          ]},
          {title: "\uc815\ubcf4 \ud589\ub82c\uc758 \uc131\uc9c8 (Properties of Information Matrix)", url: "#properties-of-information-matrix", children: [
              {title: "\uc815\ubcf4 \ud589\ub82c\uacfc \uc624\ucc28 \uacf5\ubd84\uc0b0 \ud589\ub82c\uc758 \uad00\uacc4", url: "#_12" },
              {title: "\uc815\ubcf4 \ud589\ub82c\uc758 \uac31\uc2e0 \uaddc\uce59", url: "#_13" },
          ]},
          {title: "\uc7a1\uc74c \ud2b9\uc131\uacfc \ud544\ud130 \uc131\ub2a5 (Noise Characteristics and Filter Performance)", url: "#noise-characteristics-and-filter-performance", children: [
              {title: "\uac00\uc6b0\uc2dc\uc548 \uc7a1\uc74c\uc758 \uac00\uc815", url: "#_14" },
              {title: "\uc7a1\uc74c \uacf5\ubd84\uc0b0 \ud589\ub82c\uc758 \uc120\ud0dd", url: "#_15" },
              {title: "\uc7a1\uc74c\uc758 \uc0c1\uad00\uc131\uacfc \ud544\ud130 \uc124\uacc4", url: "#_16" },
          ]},
          {title: "\uc0c1\ud0dc \uacf5\uac04 \ubaa8\ub378\uc758 \ud655\uc7a5", url: "#_17", children: [
              {title: "\ube44\uc120\ud615 \uc2dc\uc2a4\ud15c\uc5d0 \ub300\ud55c \uc120\ud615\ud654", url: "#_18" },
          ]},
          {title: "\ud544\ud130 \uc218\ub834\uc131\uacfc \uc131\ub2a5 \ubd84\uc11d", url: "#_19", children: [
              {title: "\uc218\ub834\uc131 \ubd84\uc11d", url: "#_20" },
              {title: "\uc131\ub2a5 \uc9c0\ud45c", url: "#_21" },
          ]},
          {title: "\uce7c\ub9cc \ud544\ud130\uc758 \ud655\uc7a5\uacfc \uc751\uc6a9", url: "#_22", children: [
              {title: "\ube44\uc120\ud615 \uc2dc\uc2a4\ud15c\uc5d0 \ub300\ud55c \uce7c\ub9cc \ud544\ud130\uc758 \uc801\uc6a9", url: "#_23" },
              {title: "\uc608\uce21 \uc774\ub4dd\uacfc \ud544\ud130 \uc131\ub2a5\uc758 \uad00\uacc4", url: "#_24" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../992/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../992/" class="btn btn-xs btn-link">
        칼만 필터의 Matlab/Python 구현 코드
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter%2011%20examples/03%203%EC%B0%A8%EC%9B%90%20%EC%9C%84%EC%B9%98%20%EC%9E%85%EB%A0%A5%20%EC%9C%84%EC%B9%98%20%EC%86%8D%EB%8F%84%20%EC%B6%94%EC%A0%95/32%20C%2B%2B%20Eigen3%20%EC%BD%94%EB%93%9C/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter%2011%20examples/03%203%EC%B0%A8%EC%9B%90%20%EC%9C%84%EC%B9%98%20%EC%9E%85%EB%A0%A5%20%EC%9C%84%EC%B9%98%20%EC%86%8D%EB%8F%84%20%EC%B6%94%EC%A0%95/32%20C%2B%2B%20Eigen3%20%EC%BD%94%EB%93%9C/" class="btn btn-xs btn-link">
        C++ Eigen3 코드
      </a>
    </div>
    
  </div>

    

    <h3 id="_1">상태 공간 모델의 수학적 정의</h3>
<p>상태 공간 모델은 시스템의 동적 상태를 추정하기 위한 기본적인 수학적 표현이다. 이 모델은 상태 전이 방정식과 관측 방정식으로 구성된다.</p>
<p><strong>상태 전이 방정식 (State Transition Equation):</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{k} = \mathbf{A}_{k} \mathbf{x}_{k-1} + \mathbf{B}_{k} \mathbf{u}_{k-1} + \mathbf{w}_{k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{k} = \mathbf{A}_{k} \mathbf{x}_{k-1} + \mathbf{B}_{k} \mathbf{u}_{k-1} + \mathbf{w}_{k-1}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{k}</span><script type="math/tex">\mathbf{x}_{k}</script></span>: k시점의 상태 벡터</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{k}</span><script type="math/tex">\mathbf{A}_{k}</script></span>: 상태 전이 행렬</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}_{k}</span><script type="math/tex">\mathbf{B}_{k}</script></span>: 제어 입력에 대한 상태 변화를 나타내는 행렬</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{k-1}</span><script type="math/tex">\mathbf{u}_{k-1}</script></span>: k-1 시점의 제어 입력 벡터</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{w}_{k-1}</span><script type="math/tex">\mathbf{w}_{k-1}</script></span>: 과정 잡음 벡터, 일반적으로 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{w}_{k-1} \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_{k-1})</span><script type="math/tex">\mathbf{w}_{k-1} \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_{k-1})</script></span></li>
</ul>
<p><strong>관측 방정식 (Measurement Equation):</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{z}_{k} = \mathbf{H}_{k} \mathbf{x}_{k} + \mathbf{v}_{k}
</div>
<script type="math/tex; mode=display">
\mathbf{z}_{k} = \mathbf{H}_{k} \mathbf{x}_{k} + \mathbf{v}_{k}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_{k}</span><script type="math/tex">\mathbf{z}_{k}</script></span>: k시점의 관측 벡터</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}_{k}</span><script type="math/tex">\mathbf{H}_{k}</script></span>: 관측 행렬</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}_{k}</span><script type="math/tex">\mathbf{v}_{k}</script></span>: 관측 잡음 벡터, 일반적으로 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}_{k} \sim \mathcal{N}(\mathbf{0}, \mathbf{R}_{k})</span><script type="math/tex">\mathbf{v}_{k} \sim \mathcal{N}(\mathbf{0}, \mathbf{R}_{k})</script></span></li>
</ul>
<h3 id="_2">칼만 필터 알고리즘의 기본 공식</h3>
<p>칼만 필터는 예측(Prediction) 단계와 갱신(Update) 단계로 나뉜다. 각 단계에서 사용되는 수학적 공식은 다음과 같다.</p>
<h4 id="prediction-step">예측 단계 (Prediction Step)</h4>
<p><strong>상태 예측 (Predicted State):</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\hat{\mathbf{x}}_{k|k-1} = \mathbf{A}_{k} \hat{\mathbf{x}}_{k-1|k-1} + \mathbf{B}_{k} \mathbf{u}_{k-1}
</div>
<script type="math/tex; mode=display">
\hat{\mathbf{x}}_{k|k-1} = \mathbf{A}_{k} \hat{\mathbf{x}}_{k-1|k-1} + \mathbf{B}_{k} \mathbf{u}_{k-1}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{x}}_{k|k-1}</span><script type="math/tex">\hat{\mathbf{x}}_{k|k-1}</script></span>: k 시점에서의 예측된 상태</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{x}}_{k-1|k-1}</span><script type="math/tex">\hat{\mathbf{x}}_{k-1|k-1}</script></span>: k-1 시점에서의 최종 추정 상태</li>
</ul>
<p><strong>오차 공분산 예측 (Predicted Error Covariance):</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k|k-1} = \mathbf{A}_{k} \mathbf{P}_{k-1|k-1} \mathbf{A}_{k}^\top + \mathbf{Q}_{k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k|k-1} = \mathbf{A}_{k} \mathbf{P}_{k-1|k-1} \mathbf{A}_{k}^\top + \mathbf{Q}_{k-1}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k|k-1}</span><script type="math/tex">\mathbf{P}_{k|k-1}</script></span>: k 시점에서의 예측된 오차 공분산</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k-1|k-1}</span><script type="math/tex">\mathbf{P}_{k-1|k-1}</script></span>: k-1 시점에서의 추정된 오차 공분산</li>
</ul>
<h4 id="update-step">갱신 단계 (Update Step)</h4>
<p><strong>칼만 이득 (Kalman Gain):</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{K}_{k} = \mathbf{P}_{k|k-1} \mathbf{H}_{k}^\top \left( \mathbf{H}_{k} \mathbf{P}_{k|k-1} \mathbf{H}_{k}^\top + \mathbf{R}_{k} \right)^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{K}_{k} = \mathbf{P}_{k|k-1} \mathbf{H}_{k}^\top \left( \mathbf{H}_{k} \mathbf{P}_{k|k-1} \mathbf{H}_{k}^\top + \mathbf{R}_{k} \right)^{-1}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_{k}</span><script type="math/tex">\mathbf{K}_{k}</script></span>: k 시점에서의 칼만 이득</li>
</ul>
<p><strong>상태 갱신 (Updated State):</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\hat{\mathbf{x}}_{k|k} = \hat{\mathbf{x}}_{k|k-1} + \mathbf{K}_{k} \left( \mathbf{z}_{k} - \mathbf{H}_{k} \hat{\mathbf{x}}_{k|k-1} \right)
</div>
<script type="math/tex; mode=display">
\hat{\mathbf{x}}_{k|k} = \hat{\mathbf{x}}_{k|k-1} + \mathbf{K}_{k} \left( \mathbf{z}_{k} - \mathbf{H}_{k} \hat{\mathbf{x}}_{k|k-1} \right)
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{x}}_{k|k}</span><script type="math/tex">\hat{\mathbf{x}}_{k|k}</script></span>: k 시점에서의 갱신된 상태 추정</li>
</ul>
<p><strong>오차 공분산 갱신 (Updated Error Covariance):</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k|k} = \left(\mathbf{I} - \mathbf{K}_{k} \mathbf{H}_{k}\right) \mathbf{P}_{k|k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k|k} = \left(\mathbf{I} - \mathbf{K}_{k} \mathbf{H}_{k}\right) \mathbf{P}_{k|k-1}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k|k}</span><script type="math/tex">\mathbf{P}_{k|k}</script></span>: k 시점에서의 갱신된 오차 공분산</li>
</ul>
<h3 id="riccati-equation">리카티 방정식 (Riccati Equation)</h3>
<p>리카티 방정식은 칼만 필터의 오차 공분산을 계산하는 데 중요한 역할을 한다. 이 방정식은 오차 공분산의 예측과 갱신 단계에서 반복적으로 사용된다.</p>
<p><strong>리카티 방정식:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k|k} = \left(\mathbf{I} - \mathbf{K}_{k} \mathbf{H}_{k}\right) \mathbf{P}_{k|k-1} = \mathbf{P}_{k|k-1} - \mathbf{K}_{k} \mathbf{S}_{k} \mathbf{K}_{k}^\top
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k|k} = \left(\mathbf{I} - \mathbf{K}_{k} \mathbf{H}_{k}\right) \mathbf{P}_{k|k-1} = \mathbf{P}_{k|k-1} - \mathbf{K}_{k} \mathbf{S}_{k} \mathbf{K}_{k}^\top
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{S}_{k} = \mathbf{H}_{k} \mathbf{P}_{k|k-1} \mathbf{H}_{k}^\top + \mathbf{R}_{k}</span><script type="math/tex">\mathbf{S}_{k} = \mathbf{H}_{k} \mathbf{P}_{k|k-1} \mathbf{H}_{k}^\top + \mathbf{R}_{k}</script></span>: 잔차 공분산(Residual Covariance)</li>
</ul>
<p>리카티 방정식은 필터의 성능과 안정성을 평가하는 데 매우 중요한 도구이다. 특히 시스템이 안정적일 경우, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k|k}</span><script type="math/tex">\mathbf{P}_{k|k}</script></span>는 수렴하게 된다.</p>
<h3 id="_3">수렴 조건과 안정성 분석</h3>
<p>칼만 필터의 수렴성과 안정성을 보장하기 위해서는 다음과 같은 수렴 조건이 필요하다.</p>
<p><strong>수렴 조건:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\lim_{k \to \infty} \mathbf{P}_{k|k} = \mathbf{P}_{\infty}
</div>
<script type="math/tex; mode=display">
\lim_{k \to \infty} \mathbf{P}_{k|k} = \mathbf{P}_{\infty}
</script>
</div>
<p>이 조건은 필터가 오랜 시간 동안 안정적으로 작동하여 일정한 오차 공분산에 도달함을 의미한다.</p>
<p>칼만 필터의 안정성은 시스템 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{k}</span><script type="math/tex">\mathbf{A}_{k}</script></span>의 성질과 노이즈 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}_{k}</span><script type="math/tex">\mathbf{Q}_{k}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_{k}</span><script type="math/tex">\mathbf{R}_{k}</script></span>의 상대적 크기에 따라 달라진다. 시스템이 제어 가능하고 관측 가능하다면, 필터는 안정적으로 작동할 가능성이 높다.</p>
<h3 id="information-filter">정보 필터(Information Filter) 공식</h3>
<p>정보 필터(Information Filter)는 칼만 필터의 대안적 형태로, 정보 행렬(Information Matrix)과 정보 벡터(Information Vector)를 사용하여 필터링을 수행한다. 이 방식은 대규모 문제나 희소 행렬을 처리하는 데 유리한다.</p>
<p><strong>정보 행렬과 정보 벡터의 정의:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{Y}_{k|k-1} = \mathbf{P}_{k|k-1}^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{Y}_{k|k-1} = \mathbf{P}_{k|k-1}^{-1}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}_{k|k-1} = \mathbf{Y}_{k|k-1} \hat{\mathbf{x}}_{k|k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{y}_{k|k-1} = \mathbf{Y}_{k|k-1} \hat{\mathbf{x}}_{k|k-1}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{Y}_{k|k-1}</span><script type="math/tex">\mathbf{Y}_{k|k-1}</script></span>: 예측 단계에서의 정보 행렬 (오차 공분산의 역행렬)</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}_{k|k-1}</span><script type="math/tex">\mathbf{y}_{k|k-1}</script></span>: 예측 단계에서의 정보 벡터</li>
</ul>
<p><strong>정보 필터의 예측 단계:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{Y}_{k|k-1} = (\mathbf{A}_{k} \mathbf{P}_{k-1|k-1} \mathbf{A}_{k}^\top + \mathbf{Q}_{k-1})^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{Y}_{k|k-1} = (\mathbf{A}_{k} \mathbf{P}_{k-1|k-1} \mathbf{A}_{k}^\top + \mathbf{Q}_{k-1})^{-1}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}_{k|k-1} = \mathbf{A}_{k}^\top \mathbf{P}_{k-1|k-1}^{-1} \hat{\mathbf{x}}_{k-1|k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{y}_{k|k-1} = \mathbf{A}_{k}^\top \mathbf{P}_{k-1|k-1}^{-1} \hat{\mathbf{x}}_{k-1|k-1}
</script>
</div>
<p><strong>정보 필터의 갱신 단계:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{Y}_{k|k} = \mathbf{Y}_{k|k-1} + \mathbf{H}_{k}^\top \mathbf{R}_{k}^{-1} \mathbf{H}_{k}
</div>
<script type="math/tex; mode=display">
\mathbf{Y}_{k|k} = \mathbf{Y}_{k|k-1} + \mathbf{H}_{k}^\top \mathbf{R}_{k}^{-1} \mathbf{H}_{k}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}_{k|k} = \mathbf{y}_{k|k-1} + \mathbf{H}_{k}^\top \mathbf{R}_{k}^{-1} \mathbf{z}_{k}
</div>
<script type="math/tex; mode=display">
\mathbf{y}_{k|k} = \mathbf{y}_{k|k-1} + \mathbf{H}_{k}^\top \mathbf{R}_{k}^{-1} \mathbf{z}_{k}
</script>
</div>
<p><strong>최종 상태 추정:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\hat{\mathbf{x}}_{k|k} = \mathbf{Y}_{k|k}^{-1} \mathbf{y}_{k|k}
</div>
<script type="math/tex; mode=display">
\hat{\mathbf{x}}_{k|k} = \mathbf{Y}_{k|k}^{-1} \mathbf{y}_{k|k}
</script>
</div>
<p>정보 필터는 특히 고차원 상태 벡터나 희소 행렬이 주어졌을 때 효율적으로 사용될 수 있으며, 칼만 필터와 동일한 결과를 제공한다.</p>
<h3 id="smoothing-techniques">스무딩 기법(Smoothing Techniques)</h3>
<p>스무딩은 전체 데이터가 주어졌을 때 상태 추정을 개선하기 위해 사용되는 방법이다. 스무딩 기법에는 여러 가지가 있지만, 가장 일반적인 방법은 뒤로 가는 시간 업데이트(Backward-Time Update)이다.</p>
<p><strong>고전적인 배치 스무딩(Batch Smoothing):</strong></p>
<p><strong>Forward Pass (전방향 계산):</strong>
전방향에서는 칼만 필터를 통해 예측과 추정을 수행한다.</p>
<p><strong>Backward Pass (후방향 계산):</strong>
후방향에서는 다음의 수식을 사용하여 스무딩된 상태를 계산한다.</p>
<p><strong>스무딩된 상태 추정:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\hat{\mathbf{x}}_{k|N} = \hat{\mathbf{x}}_{k|k} + \mathbf{C}_{k} (\hat{\mathbf{x}}_{k+1|N} - \hat{\mathbf{x}}_{k+1|k})
</div>
<script type="math/tex; mode=display">
\hat{\mathbf{x}}_{k|N} = \hat{\mathbf{x}}_{k|k} + \mathbf{C}_{k} (\hat{\mathbf{x}}_{k+1|N} - \hat{\mathbf{x}}_{k+1|k})
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{x}}_{k|N}</span><script type="math/tex">\hat{\mathbf{x}}_{k|N}</script></span>: k 시점에서 N 시점까지의 모든 데이터를 사용한 스무딩된 상태 추정</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}_{k} = \mathbf{P}_{k|k} \mathbf{A}_{k+1}^\top \mathbf{P}_{k+1|k}^{-1}</span><script type="math/tex">\mathbf{C}_{k} = \mathbf{P}_{k|k} \mathbf{A}_{k+1}^\top \mathbf{P}_{k+1|k}^{-1}</script></span>: 스무딩 게인(Smoothing Gain)</li>
</ul>
<p><strong>스무딩된 오차 공분산:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k|N} = \mathbf{P}_{k|k} + \mathbf{C}_{k} (\mathbf{P}_{k+1|N} - \mathbf{P}_{k+1|k}) \mathbf{C}_{k}^\top
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k|N} = \mathbf{P}_{k|k} + \mathbf{C}_{k} (\mathbf{P}_{k+1|N} - \mathbf{P}_{k+1|k}) \mathbf{C}_{k}^\top
</script>
</div>
<p>이 기법은 과거 시점의 상태를 후방으로 업데이트하여 더욱 정확한 상태 추정을 가능하게 한다.</p>
<h3 id="multiple-model-approach">다중 모델 접근법 (Multiple Model Approach)</h3>
<p>다중 모델 접근법은 여러 개의 서로 다른 시스템 모델이 존재할 때, 각 모델에 대해 별도의 칼만 필터를 적용한 후 결과를 조합하는 방식이다. 대표적인 방법으로 인터랙티브 멀티 모델(IMM) 방법이 있다.</p>
<p><strong>모델 확률의 갱신:</strong>
각 모델 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>에 대한 확률 <span class="arithmatex"><span class="MathJax_Preview">\mu_i</span><script type="math/tex">\mu_i</script></span>는 다음과 같이 갱신된다.</p>
<p><strong>사전 모델 확률:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mu_{i}(k|k-1) = \sum_{j=1}^{M} \mu_j(k-1) \pi_{ji}
</div>
<script type="math/tex; mode=display">
\mu_{i}(k|k-1) = \sum_{j=1}^{M} \mu_j(k-1) \pi_{ji}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\pi_{ji}</span><script type="math/tex">\pi_{ji}</script></span>: 모델 전환 확률</li>
</ul>
<p><strong>사후 모델 확률:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mu_{i}(k|k) = \frac{\mu_{i}(k|k-1) p(\mathbf{z}_{k}|\mathbf{x}_{k}, i)}{\sum_{j=1}^{M} \mu_{j}(k|k-1) p(\mathbf{z}_{k}|\mathbf{x}_{k}, j)}
</div>
<script type="math/tex; mode=display">
\mu_{i}(k|k) = \frac{\mu_{i}(k|k-1) p(\mathbf{z}_{k}|\mathbf{x}_{k}, i)}{\sum_{j=1}^{M} \mu_{j}(k|k-1) p(\mathbf{z}_{k}|\mathbf{x}_{k}, j)}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">p(\mathbf{z}_{k}|\mathbf{x}_{k}, i)</span><script type="math/tex">p(\mathbf{z}_{k}|\mathbf{x}_{k}, i)</script></span>: 모델 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>의 관측 확률</li>
</ul>
<p><strong>결합된 상태 추정:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\hat{\mathbf{x}}_{k|k} = \sum_{i=1}^{M} \mu_i(k|k) \hat{\mathbf{x}}_{k|k}^{(i)}
</div>
<script type="math/tex; mode=display">
\hat{\mathbf{x}}_{k|k} = \sum_{i=1}^{M} \mu_i(k|k) \hat{\mathbf{x}}_{k|k}^{(i)}
</script>
</div>
<p>각 모델의 추정치를 모델 확률로 가중평균하여 최종 상태 추정을 수행한다.</p>
<p>이 방법은 시스템의 모델이 불확실하거나 변화하는 환경에서 유용하다.</p>
<h3 id="_4">신뢰성 있는 시스템 설계와 장애 대응</h3>
<p>신뢰성 있는 시스템 설계에서는 칼만 필터를 사용하여 시스템의 상태를 추정하는 과정에서 발생할 수 있는 다양한 문제를 다루는 방법이 필요하다. 특히, 이상 값이나 센서 고장 등 비정상적인 상황에서 필터가 적절하게 작동하도록 하는 방법론이 중요하다.</p>
<h4 id="outlier-handling">이상 값에 대한 대처 (Outlier Handling)</h4>
<p>칼만 필터는 이상 값(Outlier)에 민감할 수 있으며, 이러한 값이 필터의 성능을 저하시키지 않도록 특별한 대처가 필요하다.</p>
<p><strong>이상 값 감지 방법:</strong>
잔차(Residual)를 사용하여 이상 값을 감지할 수 있다. 잔차 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}_k</span><script type="math/tex">\mathbf{r}_k</script></span>는 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{r}_k = \mathbf{z}_k - \mathbf{H}_k \hat{\mathbf{x}}_{k|k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{r}_k = \mathbf{z}_k - \mathbf{H}_k \hat{\mathbf{x}}_{k|k-1}
</script>
</div>
<p>잔차의 크기가 예상 범위를 넘어서면 이상 값으로 간주할 수 있다.</p>
<p><strong>잔차의 통계적 시험:</strong>
잔차의 공분산 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{S}_k</span><script type="math/tex">\mathbf{S}_k</script></span>를 이용하여, 다음과 같이 카이제곱 분포를 사용한 검정을 수행할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{r}_k^\top \mathbf{S}_k^{-1} \mathbf{r}_k &gt; \chi^2_{\alpha}
</div>
<script type="math/tex; mode=display">
\mathbf{r}_k^\top \mathbf{S}_k^{-1} \mathbf{r}_k > \chi^2_{\alpha}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\chi^2_{\alpha}</span><script type="math/tex">\chi^2_{\alpha}</script></span>는 유의수준 <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>에 해당하는 카이제곱 분포의 임계값이다.</p>
<h4 id="fault-detection-and-isolation">장애 대응 (Fault Detection and Isolation)</h4>
<p>장애 대응 시스템에서는 센서 고장이나 시스템의 부분적인 실패를 실시간으로 감지하고, 필터의 동작을 조정해야 한다.</p>
<p><strong>고장 감지 방법:</strong>
잔차의 연속적인 감시와 더불어, 시스템의 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k|k}</span><script type="math/tex">\mathbf{P}_{k|k}</script></span>의 이상적인 증가 여부를 모니터링한다. 만약 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k|k}</span><script type="math/tex">\mathbf{P}_{k|k}</script></span>가 비정상적으로 증가하는 경우, 시스템의 장애 가능성이 높다.</p>
<p><strong>고장 고립 및 대응:</strong>
여러 센서로부터의 데이터를 사용하는 경우, 고장 난 센서를 고립시키기 위해 잔차 분석을 각 센서별로 수행할 수 있다. 고장으로 의심되는 센서를 제외한 나머지 센서의 데이터로 칼만 필터를 재조정하여 추정 성능을 유지할 수 있다.</p>
<h4 id="robust-kalman-filter">강건한 칼만 필터 (Robust Kalman Filter)</h4>
<p>강건한 칼만 필터는 불확실성이나 모델링 오류를 고려하여 필터링 성능을 개선한 버전이다. 이는 잡음의 분포가 가우시안이 아니거나 시스템 모델에 일부 불확실성이 존재할 때 유용하다.</p>
<p><strong>강건한 필터 설계:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{K}_k} \max_{\Delta \mathbf{x}, \Delta \mathbf{z}} \mathbb{E}\left[ \|\mathbf{r}_k\|^2 + \gamma \|\Delta \mathbf{x}\|^2 \right]
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{K}_k} \max_{\Delta \mathbf{x}, \Delta \mathbf{z}} \mathbb{E}\left[ \|\mathbf{r}_k\|^2 + \gamma \|\Delta \mathbf{x}\|^2 \right]
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\Delta \mathbf{x}</span><script type="math/tex">\Delta \mathbf{x}</script></span>는 모델링 오류, <span class="arithmatex"><span class="MathJax_Preview">\Delta \mathbf{z}</span><script type="math/tex">\Delta \mathbf{z}</script></span>는 잡음에 대한 불확실성을 나타내며, <span class="arithmatex"><span class="MathJax_Preview">\gamma</span><script type="math/tex">\gamma</script></span>는 필터의 강건성을 제어하는 파라미터이다. 이 최적화 문제를 해결하여 강건한 칼만 필터를 설계할 수 있다.</p>
<p>이러한 필터는 가우시안 잡음이 아닌 경우에도 더 나은 성능을 발휘할 수 있다.</p>
<p><strong>불확실성에 대한 대응:</strong>
필터의 매 단계에서 불확실성을 모델에 반영하고, 오차 공분산을 동적으로 조정함으로써 시스템의 안전성과 신뢰성을 유지한다.</p>
<hr />
<p>이상으로 칼만 필터와 관련된 주요 수학적 공식과 정리를 다루었다. 이 내용은 칼만 필터의 이론적 배경과 실제 응용에서 매우 중요한 역할을 하며, 다양한 문제 상황에 대한 이해를 돕기 위한 기초를 제공한다.</p>
<h3 id="observability">시스템의 관측 가능성 (Observability)</h3>
<p>시스템의 상태를 정확하게 추정하기 위해서는 시스템이 관측 가능해야 한다. 관측 가능성은 시스템의 상태를 외부에서 주어진 관측 데이터를 통해 완전히 재구성할 수 있는지를 판단하는 중요한 개념이다.</p>
<h4 id="_5">관측 가능성의 정의</h4>
<p>시스템이 관측 가능하다는 것은 초기 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_0</span><script type="math/tex">\mathbf{x}_0</script></span>가 주어진 관측 <span class="arithmatex"><span class="MathJax_Preview">\{\mathbf{z}_1, \mathbf{z}_2, \dots, \mathbf{z}_k\}</span><script type="math/tex">\{\mathbf{z}_1, \mathbf{z}_2, \dots, \mathbf{z}_k\}</script></span>로부터 유일하게 결정될 수 있음을 의미한다.</p>
<h4 id="_6">관측 가능성 조건</h4>
<p>관측 가능성의 수학적 조건은 다음과 같은 관측 가능성 행렬을 통해 정의된다.</p>
<p><strong>관측 가능성 행렬:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{O} = \begin{bmatrix}
\mathbf{H} \\
\mathbf{H}\mathbf{A} \\
\mathbf{H}\mathbf{A}^2 \\
\vdots \\
\mathbf{H}\mathbf{A}^{n-1}
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{O} = \begin{bmatrix}
\mathbf{H} \\
\mathbf{H}\mathbf{A} \\
\mathbf{H}\mathbf{A}^2 \\
\vdots \\
\mathbf{H}\mathbf{A}^{n-1}
\end{bmatrix}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>: 시스템 상태 벡터의 차원</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}</span><script type="math/tex">\mathbf{O}</script></span>: 관측 가능성 행렬</li>
</ul>
<p>이 행렬이 풀랭크(Full Rank)를 가질 경우, 시스템은 관측 가능하다고 말할 수 있다.</p>
<h4 id="_7">카운트롤러블리티와의 관계</h4>
<p>관측 가능성과 제어 가능성(Controllability)은 이중성을 가지며, 제어 가능성 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>와 관측 가능성 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}</span><script type="math/tex">\mathbf{O}</script></span> 사이에는 다음과 같은 관계가 성립한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Rank}(\mathbf{C}) = n \iff \text{Rank}(\mathbf{O}) = n
</div>
<script type="math/tex; mode=display">
\text{Rank}(\mathbf{C}) = n \iff \text{Rank}(\mathbf{O}) = n
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>: 제어 가능성 행렬</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}</span><script type="math/tex">\mathbf{O}</script></span>: 관측 가능성 행렬</li>
</ul>
<p>이 두 개념은 시스템의 상태 추정과 제어 설계에서 필수적인 조건을 형성한다.</p>
<h3 id="controllability">시스템의 제어 가능성 (Controllability)</h3>
<p>제어 가능성은 주어진 제어 입력으로 시스템의 상태를 원하는 상태로 변화시킬 수 있는지를 나타내는 성질이다. 이는 시스템의 안정성과 제어 설계의 기초를 형성한다.</p>
<h4 id="_8">제어 가능성의 정의</h4>
<p>시스템이 제어 가능하다는 것은 초기 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_0</span><script type="math/tex">\mathbf{x}_0</script></span>에서 원하는 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_f</span><script type="math/tex">\mathbf{x}_f</script></span>로 제어 입력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}</span><script type="math/tex">\mathbf{u}</script></span>를 통해 이동할 수 있음을 의미한다.</p>
<h4 id="_9">제어 가능성 조건</h4>
<p>제어 가능성은 제어 가능성 행렬을 사용하여 다음과 같이 표현된다.</p>
<p><strong>제어 가능성 행렬:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \begin{bmatrix}
\mathbf{B} &amp; \mathbf{A}\mathbf{B} &amp; \mathbf{A}^2\mathbf{B} &amp; \dots &amp; \mathbf{A}^{n-1}\mathbf{B}
\end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \begin{bmatrix}
\mathbf{B} & \mathbf{A}\mathbf{B} & \mathbf{A}^2\mathbf{B} & \dots & \mathbf{A}^{n-1}\mathbf{B}
\end{bmatrix}
</script>
</div>
<p>이 행렬이 풀랭크를 가질 경우, 시스템은 제어 가능하다고 한다.</p>
<h4 id="_10">제어 가능성과 칼만 필터</h4>
<p>칼만 필터를 적용하기 위해서는 시스템이 제어 가능하며 동시에 관측 가능해야 한다. 이 두 가지 조건은 시스템의 전체 상태를 추정하고 제어하는 데 필수적이다.</p>
<p><strong>제어 가능성의 확인:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Rank}(\mathbf{C}) = n
</div>
<script type="math/tex; mode=display">
\text{Rank}(\mathbf{C}) = n
</script>
</div>
<p>이 조건이 만족되지 않으면, 일부 상태는 제어할 수 없거나 추정할 수 없게 되며, 칼만 필터의 성능이 저하된다.</p>
<h3 id="optimal-filtering-problem">최적 필터링 문제 (Optimal Filtering Problem)</h3>
<p>최적 필터링 문제는 주어진 시스템의 상태를 가장 정확하게 추정하는 문제로, 칼만 필터는 이 문제에 대한 최적해를 제공한다.</p>
<h4 id="_11">베이즈 필터링의 기초</h4>
<p>칼만 필터는 베이즈 필터링의 특수한 경우로, 선형 시스템과 가우시안 잡음이 주어진 상황에서의 최적 필터링을 수행한다.</p>
<p><strong>베이즈 필터링:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
p(\mathbf{x}_k | \mathbf{z}_{1:k}) = \frac{p(\mathbf{z}_k | \mathbf{x}_k) p(\mathbf{x}_k | \mathbf{z}_{1:k-1})}{p(\mathbf{z}_k | \mathbf{z}_{1:k-1})}
</div>
<script type="math/tex; mode=display">
p(\mathbf{x}_k | \mathbf{z}_{1:k}) = \frac{p(\mathbf{z}_k | \mathbf{x}_k) p(\mathbf{x}_k | \mathbf{z}_{1:k-1})}{p(\mathbf{z}_k | \mathbf{z}_{1:k-1})}
</script>
</div>
<p>여기서, 칼만 필터는 상태의 추정치를 가우시안 분포로 가정하여 베이즈 업데이트를 수행한다.</p>
<h4 id="minimum-variance-estimation">최소 분산 추정 (Minimum Variance Estimation)</h4>
<p>칼만 필터는 상태의 추정 오차 공분산을 최소화하는 필터로, 다음의 최적화 문제를 해결한다.</p>
<p><strong>최적화 문제:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\hat{\mathbf{x}}_k} \mathbb{E}\left[(\mathbf{x}_k - \hat{\mathbf{x}}_k)(\mathbf{x}_k - \hat{\mathbf{x}}_k)^\top\right]
</div>
<script type="math/tex; mode=display">
\min_{\hat{\mathbf{x}}_k} \mathbb{E}\left[(\mathbf{x}_k - \hat{\mathbf{x}}_k)(\mathbf{x}_k - \hat{\mathbf{x}}_k)^\top\right]
</script>
</div>
<p>이 문제의 해는 앞서 설명한 칼만 필터 공식으로 주어지며, 필터링 과정에서 시간적으로 반복 수행된다.</p>
<h3 id="properties-of-information-matrix">정보 행렬의 성질 (Properties of Information Matrix)</h3>
<p>정보 행렬(Information Matrix)은 오차 공분산의 역행렬로 정의되며, 칼만 필터의 여러 중요한 성질을 반영한다.</p>
<h4 id="_12">정보 행렬과 오차 공분산 행렬의 관계</h4>
<p>정보 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Y}_k</span><script type="math/tex">\mathbf{Y}_k</script></span>는 오차 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>의 역행렬로 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{Y}_k = \mathbf{P}_k^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{Y}_k = \mathbf{P}_k^{-1}
</script>
</div>
<p>이 관계는 정보 필터에서 중요한 역할을 하며, 정보 필터의 예측 및 갱신 단계를 통해 오차 공분산 행렬과 정보 행렬이 서로 어떻게 변환되는지를 이해할 수 있다.</p>
<h4 id="_13">정보 행렬의 갱신 규칙</h4>
<p>정보 행렬은 다음과 같은 방식으로 갱신된다.</p>
<p><strong>예측 단계에서의 정보 행렬 갱신:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{Y}_{k|k-1} = \left(\mathbf{A}_k \mathbf{P}_{k-1|k-1} \mathbf{A}_k^\top + \mathbf{Q}_k\right)^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{Y}_{k|k-1} = \left(\mathbf{A}_k \mathbf{P}_{k-1|k-1} \mathbf{A}_k^\top + \mathbf{Q}_k\right)^{-1}
</script>
</div>
<p><strong>갱신 단계에서의 정보 행렬 갱신:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{Y}_{k|k} = \mathbf{Y}_{k|k-1} + \mathbf{H}_k^\top \mathbf{R}_k^{-1} \mathbf{H}_k
</div>
<script type="math/tex; mode=display">
\mathbf{Y}_{k|k} = \mathbf{Y}_{k|k-1} + \mathbf{H}_k^\top \mathbf{R}_k^{-1} \mathbf{H}_k
</script>
</div>
<p>정보 행렬의 갱신은 필터의 상태 추정 정확도를 높이는 중요한 과정으로, 필터가 시간에 따라 점점 더 정확해지도록 한다.</p>
<h3 id="noise-characteristics-and-filter-performance">잡음 특성과 필터 성능 (Noise Characteristics and Filter Performance)</h3>
<p>잡음 특성은 칼만 필터의 성능에 큰 영향을 미친다. 잡음의 분포, 크기, 상관성 등이 필터링 결과에 직접적인 영향을 미치므로 이를 적절히 이해하고 고려해야 한다.</p>
<h4 id="_14">가우시안 잡음의 가정</h4>
<p>칼만 필터는 상태 잡음 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{w}_k</span><script type="math/tex">\mathbf{w}_k</script></span>와 관측 잡음 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}_k</span><script type="math/tex">\mathbf{v}_k</script></span>가 가우시안 분포를 따른다고 가정한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{w}_k \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_k)
</div>
<script type="math/tex; mode=display">
\mathbf{w}_k \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_k)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v}_k \sim \mathcal{N}(\mathbf{0}, \mathbf{R}_k)
</div>
<script type="math/tex; mode=display">
\mathbf{v}_k \sim \mathcal{N}(\mathbf{0}, \mathbf{R}_k)
</script>
</div>
<p>이 가정은 필터의 최적성을 보장하는 데 중요한 역할을 하며, 만약 잡음이 가우시안 분포를 따르지 않는다면 필터의 성능이 저하될 수 있다.</p>
<h4 id="_15">잡음 공분산 행렬의 선택</h4>
<p>잡음 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}_k</span><script type="math/tex">\mathbf{Q}_k</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_k</span><script type="math/tex">\mathbf{R}_k</script></span>의 선택은 필터 성능에 중요한 영향을 미친다. 일반적으로, 잡음 공분산이 과소추정되면 필터가 비현실적으로 정확한 예측을 하게 되어 불안정해질 수 있으며, 과대추정되면 필터가 반응을 너무 늦게 할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k|k-1} = \mathbf{A}_k \mathbf{P}_{k-1|k-1} \mathbf{A}_k^\top + \mathbf{Q}_k
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k|k-1} = \mathbf{A}_k \mathbf{P}_{k-1|k-1} \mathbf{A}_k^\top + \mathbf{Q}_k
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{S}_k = \mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^\top + \mathbf{R}_k
</div>
<script type="math/tex; mode=display">
\mathbf{S}_k = \mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^\top + \mathbf{R}_k
</script>
</div>
<p>이 행렬들의 선택은 실험적으로 조정되거나 시스템의 물리적 특성을 기반으로 결정된다.</p>
<h4 id="_16">잡음의 상관성과 필터 설계</h4>
<p>잡음이 상관관계를 가질 경우, 필터의 설계가 더 복잡해진다. 상관된 잡음을 처리하기 위해서는 잡음의 상관구조를 반영한 상태 공간 모델이 필요하다.</p>
<p><strong>상관된 잡음 모델링:</strong></p>
<p>잡음이 상관되어 있을 때, 상태 공간 모델에 추가적인 변수나 상관구조를 반영하여 모델을 확장해야 한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{w}_k = \mathbf{L}_k \mathbf{\eta}_k
</div>
<script type="math/tex; mode=display">
\mathbf{w}_k = \mathbf{L}_k \mathbf{\eta}_k
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\eta}_k</span><script type="math/tex">\mathbf{\eta}_k</script></span>는 독립적인 가우시안 잡음을 나타내고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}_k</span><script type="math/tex">\mathbf{L}_k</script></span>는 상관구조를 반영하는 행렬이다.</p>
<p>이러한 모델링 기법은 필터가 잡음의 실제 특성을 더 잘 반영할 수 있게 하여, 성능을 개선하는 데 기여한다.</p>
<h3 id="_17">상태 공간 모델의 확장</h3>
<p>기본적인 상태 공간 모델은 시스템의 선형성과 가우시안 잡음을 가정하지만, 실제 시스템은 종종 비선형성을 가지거나 비가우시안 잡음을 포함한다. 이때 상태 공간 모델을 확장하여 이러한 복잡성을 반영할 수 있다.</p>
<h4 id="_18">비선형 시스템에 대한 선형화</h4>
<p>비선형 시스템에 대해서는 칼만 필터를 적용하기 위해 시스템을 선형화하는 방법이 사용된다. 이 과정은 테일러 급수 전개를 통해 이루어지며, 주로 확장 칼만 필터에서 사용된다.</p>
<p><strong>선형화 방법:</strong></p>
<p>비선형 시스템의 선형화는 주어진 동적 시스템의 점근선 주변에서 테일러 급수의 1차 항을 사용하여 근사한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}_k \approx \frac{\partial f(\mathbf{x}, \mathbf{u})}{\partial \mathbf{x}} \bigg|_{\mathbf{x} = \hat{\mathbf{x}}_{k-1|k-1}}
</div>
<script type="math/tex; mode=display">
\mathbf{A}_k \approx \frac{\partial f(\mathbf{x}, \mathbf{u})}{\partial \mathbf{x}} \bigg|_{\mathbf{x} = \hat{\mathbf{x}}_{k-1|k-1}}
</script>
</div>
<p>이 선형화는 시스템이 비선형적일 경우에도 칼만 필터를 적용할 수 있게 한다.</p>
<h3 id="_19">필터 수렴성과 성능 분석</h3>
<p>칼만 필터의 성능은 필터가 시간이 지남에 따라 안정적으로 수렴하는지, 그리고 추정된 상태가 실제 상태에 얼마나 가깝게 접근하는지에 따라 평가된다. 필터의 수렴성과 성능을 분석하기 위한 수학적 도구들이 존재한다.</p>
<h4 id="_20">수렴성 분석</h4>
<p>칼만 필터의 수렴성은 시스템이 시간이 지남에 따라 안정적으로 동작하며, 오차 공분산이 수렴하는지 여부를 평가하는 과정이다.</p>
<p><strong>수렴 조건:</strong>
일반적인 조건으로, 시스템이 제어 가능하고 관측 가능하다면 필터는 안정적으로 동작하며 오차 공분산이 수렴한다. 이는 다음과 같은 형태로 수학적으로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\lim_{k \to \infty} \mathbf{P}_{k|k} = \mathbf{P}_{\infty}
</div>
<script type="math/tex; mode=display">
\lim_{k \to \infty} \mathbf{P}_{k|k} = \mathbf{P}_{\infty}
</script>
</div>
<p>이때, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\infty}</span><script type="math/tex">\mathbf{P}_{\infty}</script></span>는 고정된 오차 공분산을 나타내며, 이는 리카티 방정식의 고정점 해이다.</p>
<h4 id="_21">성능 지표</h4>
<p>필터의 성능을 평가하기 위한 지표로는 다음과 같은 것들이 있다.</p>
<p><strong>추정 오차(E)와 공분산(P):</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{E}_k = \mathbf{x}_k - \hat{\mathbf{x}}_{k|k}
</div>
<script type="math/tex; mode=display">
\mathbf{E}_k = \mathbf{x}_k - \hat{\mathbf{x}}_{k|k}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_k = \mathbb{E}[\mathbf{E}_k \mathbf{E}_k^\top]
</div>
<script type="math/tex; mode=display">
\mathbf{P}_k = \mathbb{E}[\mathbf{E}_k \mathbf{E}_k^\top]
</script>
</div>
<p>오차 공분산 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>는 필터의 성능을 평가하는 가장 중요한 지표로, 이 값이 작을수록 필터의 성능이 좋다고 할 수 있다.</p>
<p><strong>추정 오차의 평균 제곱근 오차(RMSE):</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{RMSE} = \sqrt{\frac{1}{N} \sum_{k=1}^{N} \|\mathbf{E}_k\|^2}
</div>
<script type="math/tex; mode=display">
\text{RMSE} = \sqrt{\frac{1}{N} \sum_{k=1}^{N} \|\mathbf{E}_k\|^2}
</script>
</div>
<p>이 지표는 필터가 전체 시간 동안 얼마나 잘 작동했는지를 나타내는 대표적인 성능 척도이다.</p>
<h3 id="_22">칼만 필터의 확장과 응용</h3>
<p>기본적인 칼만 필터는 선형 시스템에 대해 최적화된 상태 추정을 제공하지만, 비선형 시스템에 대해서는 확장된 형태가 필요하다. 이와 관련된 내용은 다음과 같다.</p>
<h4 id="_23">비선형 시스템에 대한 칼만 필터의 적용</h4>
<p>기본적인 칼만 필터는 선형 시스템에서 최적화되지만, 실세계의 많은 시스템은 비선형성을 포함한다. 비선형 시스템에서는 비선형성에 대한 처리가 필요하며, 이때 선형화된 근사 방법을 사용한다.</p>
<p><strong>비선형 시스템의 모델링:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_k = \mathbf{f}(\mathbf{x}_{k-1}, \mathbf{u}_{k-1}) + \mathbf{w}_{k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{x}_k = \mathbf{f}(\mathbf{x}_{k-1}, \mathbf{u}_{k-1}) + \mathbf{w}_{k-1}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{z}_k = \mathbf{h}(\mathbf{x}_k) + \mathbf{v}_k
</div>
<script type="math/tex; mode=display">
\mathbf{z}_k = \mathbf{h}(\mathbf{x}_k) + \mathbf{v}_k
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{h}</span><script type="math/tex">\mathbf{h}</script></span>는 각각 시스템의 상태 전이와 관측 방정식을 나타내는 비선형 함수이다. 이러한 시스템에 대해, 칼만 필터는 보통 확장 칼만 필터(Extended Kalman Filter, EKF)로 확장된다.</p>
<p><strong>선형화 방법:</strong>
비선형 함수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{h}</span><script type="math/tex">\mathbf{h}</script></span>는 테일러 급수를 사용하여 선형화되며, 이 과정에서 야코비안(Jacobian) 행렬이 사용된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}_k = \frac{\partial \mathbf{f}}{\partial \mathbf{x}} \bigg|_{\hat{\mathbf{x}}_{k-1|k-1}, \mathbf{u}_{k-1}}
</div>
<script type="math/tex; mode=display">
\mathbf{A}_k = \frac{\partial \mathbf{f}}{\partial \mathbf{x}} \bigg|_{\hat{\mathbf{x}}_{k-1|k-1}, \mathbf{u}_{k-1}}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{H}_k = \frac{\partial \mathbf{h}}{\partial \mathbf{x}} \bigg|_{\hat{\mathbf{x}}_{k|k-1}}
</div>
<script type="math/tex; mode=display">
\mathbf{H}_k = \frac{\partial \mathbf{h}}{\partial \mathbf{x}} \bigg|_{\hat{\mathbf{x}}_{k|k-1}}
</script>
</div>
<p>이러한 선형화 방법은 비선형 시스템에서의 상태 추정을 가능하게 하며, 이로 인해 칼만 필터는 비선형 시스템에서도 유용하게 사용될 수 있다.</p>
<h4 id="_24">예측 이득과 필터 성능의 관계</h4>
<p>칼만 필터에서의 예측 이득(Kalman Gain)은 필터의 성능에 큰 영향을 미친다. 이득이 너무 크거나 작을 경우 필터가 불안정해지거나 성능이 저하될 수 있다.</p>
<p><strong>이득의 최적화:</strong>
이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_k</span><script type="math/tex">\mathbf{K}_k</script></span>는 잔차 공분산과 예측된 오차 공분산 사이의 비율로 결정되며, 다음과 같이 최적화된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}_k^\top (\mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^\top + \mathbf{R}_k)^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}_k^\top (\mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^\top + \mathbf{R}_k)^{-1}
</script>
</div>
<p>이 이득은 필터가 얼마나 공격적이거나 보수적으로 상태를 추정할지를 결정하며, 필터의 전체 성능에 중요한 영향을 미친다.</p>
<p><strong>이득과 필터의 안정성:</strong>
이득 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_k</span><script type="math/tex">\mathbf{K}_k</script></span>가 너무 크면 필터는 관측 데이터에 과도하게 반응하게 되어 잡음에 민감해질 수 있다. 반대로 이득이 너무 작으면 필터가 시스템의 동적 변화를 충분히 반영하지 못할 수 있다. 따라서 이득의 적절한 설정이 필터의 안정성과 성능에 필수적이다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../992/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../992/" class="btn btn-xs btn-link">
        칼만 필터의 Matlab/Python 구현 코드
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter%2011%20examples/03%203%EC%B0%A8%EC%9B%90%20%EC%9C%84%EC%B9%98%20%EC%9E%85%EB%A0%A5%20%EC%9C%84%EC%B9%98%20%EC%86%8D%EB%8F%84%20%EC%B6%94%EC%A0%95/32%20C%2B%2B%20Eigen3%20%EC%BD%94%EB%93%9C/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter%2011%20examples/03%203%EC%B0%A8%EC%9B%90%20%EC%9C%84%EC%B9%98%20%EC%9E%85%EB%A0%A5%20%EC%9C%84%EC%B9%98%20%EC%86%8D%EB%8F%84%20%EC%B6%94%EC%A0%95/32%20C%2B%2B%20Eigen3%20%EC%BD%94%EB%93%9C/" class="btn btn-xs btn-link">
        C++ Eigen3 코드
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>