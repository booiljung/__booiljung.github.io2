<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/mechanics/introduction_to_kinematics/chapter_15/1501/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>운동 경로 계획 - 소프트웨어 융합</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uae30\ubcf8 \uac1c\ub150", url: "#_top", children: [
          ]},
          {title: "\uacbd\ub85c \uacc4\ud68d\uc758 \uc218\ud559\uc801 \uc815\uc758", url: "#_2", children: [
          ]},
          {title: "\uacbd\ub85c \ud45c\ud604 \ubc29\uc2dd", url: "#_3", children: [
          ]},
          {title: "\uacbd\ub85c \uacc4\ud68d \uc54c\uace0\ub9ac\uc998", url: "#_4", children: [
              {title: "1. \ud0d0\uc0c9 \uae30\ubc18 \uc54c\uace0\ub9ac\uc998 (Search-Based Algorithms)", url: "#1-search-based-algorithms" },
              {title: "2. \uc0d8\ud50c\ub9c1 \uae30\ubc18 \uc54c\uace0\ub9ac\uc998 (Sampling-Based Algorithms)", url: "#2-sampling-based-algorithms" },
              {title: "3. \ucd5c\uc801\ud654 \uae30\ubc18 \uc54c\uace0\ub9ac\uc998 (Optimization-Based Algorithms)", url: "#3-optimization-based-algorithms" },
              {title: "4. \ud63c\ud569 \uae30\ubc18 \uc54c\uace0\ub9ac\uc998 (Hybrid Algorithms)", url: "#4-hybrid-algorithms" },
          ]},
          {title: "\uc7a5\uc560\ubb3c \ud68c\ud53c \uacbd\ub85c \uacc4\ud68d", url: "#_5", children: [
              {title: "1. \uc804\uc704\uc7a5 \uae30\ubc95 (Potential Field Method)", url: "#1-potential-field-method" },
              {title: "2. Voronoi \ub2e4\uc774\uc5b4\uadf8\ub7a8 (Voronoi Diagram)", url: "#2-voronoi-voronoi-diagram" },
          ]},
          {title: "\uacbd\ub85c \ucd5c\uc801\ud654 \uae30\ubc95", url: "#_6", children: [
              {title: "1. \uc2a4\ud50c\ub77c\uc778 \uae30\ubc18 \uacbd\ub85c \ucd5c\uc801\ud654 (Spline-Based Path Optimization)", url: "#1-spline-based-path-optimization" },
              {title: "2. \ube44\uc6a9 \ud568\uc218 \uae30\ubc18 \uacbd\ub85c \ucd5c\uc801\ud654 (Cost Function-Based Optimization)", url: "#2-cost-function-based-optimization" },
              {title: "3. \uc81c\uc57d \uc870\uac74\uc744 \uace0\ub824\ud55c \ucd5c\uc801\ud654 (Constrained Optimization)", url: "#3-constrained-optimization" },
              {title: "4. \uacbd\ub85c \uc2a4\ubb34\ub529 (Path Smoothing)", url: "#4-path-smoothing" },
              {title: "5. \ud734\ub9ac\uc2a4\ud2f1 \uae30\ubc95 (Heuristic Methods)", url: "#5-heuristic-methods" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1502/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1502/" class="btn btn-xs btn-link">
        경로 최적화 기법
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_14/1402/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_14/1402/" class="btn btn-xs btn-link">
        동역학과의 차이점
      </a>
    </div>
    
  </div>

    

    <p>운동 경로 계획(Motion Path Planning)은 물체가 시작점에서 목표점까지 이동하는 동안의 경로를 설정하는 과정이다. 이 과정에서는 물리적인 충돌을 방지하고, 원하는 동작을 수행할 수 있도록 최적화된 경로를 계산하는 것이 중요하다. 운동 경로 계획은 로봇공학, 자율주행 차량, 컴퓨터 그래픽스, 그리고 생체역학 등 다양한 분야에서 사용된다.</p>
<h3 id="_1">기본 개념</h3>
<p>운동 경로 계획의 기본 개념은 <strong>시작점</strong>과 <strong>목표점</strong>을 설정한 후, 그 사이의 <strong>충돌 없는 경로</strong>를 찾는 것이다. 이는 주로 2D 혹은 3D 공간에서의 경로를 의미하며, 경로는 직선, 곡선, 또는 복합적인 형태로 나타날 수 있다.</p>
<p>경로 계획을 수학적으로 표현하기 위해, 일반적으로 다음과 같은 요소들을 정의한다:</p>
<ul>
<li><strong>상태 공간 (State Space)</strong>: 로봇 또는 물체의 가능한 모든 위치와 자세를 나타내는 공간이다.</li>
<li>예를 들어, 이차원 평면에서의 로봇의 상태는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x} = [x, y]^{\top}</span><script type="math/tex">\mathbf{x} = [x, y]^{\top}</script></span>로 나타낼 수 있다.</li>
<li>
<p>3D 공간에서의 로봇 상태는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x} = [x, y, z]^{\top}</span><script type="math/tex">\mathbf{x} = [x, y, z]^{\top}</script></span>로 확장될 수 있다.</p>
</li>
<li>
<p><strong>장애물 (Obstacles)</strong>: 물체가 충돌하지 말아야 할 물리적 제약이다. 경로 계획에서 장애물을 고려하는 것이 필수적이다.</p>
</li>
<li>
<p>장애물은 상태 공간에서 특정한 영역을 차지하며, 이를 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{O}</span><script type="math/tex">\mathcal{O}</script></span>로 정의할 수 있다.</p>
</li>
<li>
<p><strong>자유 공간 (Free Space)</strong>: 물체가 자유롭게 이동할 수 있는 공간으로, 장애물을 제외한 상태 공간이다. 이는 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{F} = \mathcal{X} \setminus \mathcal{O}</span><script type="math/tex">\mathcal{F} = \mathcal{X} \setminus \mathcal{O}</script></span>로 정의된다.</p>
</li>
</ul>
<h3 id="_2">경로 계획의 수학적 정의</h3>
<p>경로 계획 문제는 주어진 시작 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_\text{start}</span><script type="math/tex">\mathbf{x}_\text{start}</script></span>와 목표 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_\text{goal}</span><script type="math/tex">\mathbf{x}_\text{goal}</script></span> 사이의 경로 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>를 찾는 것으로 정의된다. 여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에 따른 경로를 나타내는 함수이다.</p>
<p>목표는 다음 조건을 만족하는 경로를 찾는 것이다:</p>
<ol>
<li>경로는 시작 상태에서 출발하여 목표 상태에 도달한다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{p}(0) = \mathbf{x}_\text{start}, \quad \mathbf{p}(T) = \mathbf{x}_\text{goal}
</div>
<script type="math/tex; mode=display">
   \mathbf{p}(0) = \mathbf{x}_\text{start}, \quad \mathbf{p}(T) = \mathbf{x}_\text{goal}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 경로를 완료하는 시간이다.</p>
<ol>
<li>경로는 자유 공간 내에 존재한다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{p}(t) \in \mathcal{F}, \quad \forall t \in [0, T]
</div>
<script type="math/tex; mode=display">
   \mathbf{p}(t) \in \mathcal{F}, \quad \forall t \in [0, T]
</script>
</div>
<h3 id="_3">경로 표현 방식</h3>
<p>경로를 표현하는 방식에는 여러 가지가 있으며, 상황에 따라 적절한 방식을 선택해야 한다.</p>
<ol>
<li><strong>다각형 경로 (Piecewise Linear Path)</strong>: 경로가 여러 직선 구간으로 이루어지는 경우로, 각 구간은 선형 방정식으로 나타낼 수 있다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{p}(t) = \mathbf{x}_i + t (\mathbf{x}_{i+1} - \mathbf{x}_i), \quad t \in [0, 1]
</div>
<script type="math/tex; mode=display">
   \mathbf{p}(t) = \mathbf{x}_i + t (\mathbf{x}_{i+1} - \mathbf{x}_i), \quad t \in [0, 1]
</script>
</div>
<p>이 때, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_i</span><script type="math/tex">\mathbf{x}_i</script></span>는 경로의 분할점이다.</p>
<ol>
<li><strong>곡선 경로 (Curved Path)</strong>: 경로가 곡선으로 나타나는 경우, 곡선은 주로 이차 또는 삼차 다항식으로 표현된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{p}(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3
</div>
<script type="math/tex; mode=display">
   \mathbf{p}(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">a_0, a_1, a_2, a_3</span><script type="math/tex">a_0, a_1, a_2, a_3</script></span>는 곡선의 계수를 나타낸다.</p>
<ol>
<li><strong>파라메트릭 경로 (Parametric Path)</strong>: 경로를 시간이나 다른 파라미터에 대한 함수로 나타내는 방식이다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{p}(t) = [x(t), y(t), z(t)]^{\top}
</div>
<script type="math/tex; mode=display">
   \mathbf{p}(t) = [x(t), y(t), z(t)]^{\top}
</script>
</div>
<p>이 경우, 각 좌표 축의 변화가 시간 함수로 정의된다.</p>
<h3 id="_4">경로 계획 알고리즘</h3>
<p>경로 계획 문제를 해결하기 위해 다양한 알고리즘이 사용된다. 대표적인 경로 계획 알고리즘으로는 다음과 같은 것들이 있다.</p>
<h4 id="1-search-based-algorithms">1. <strong>탐색 기반 알고리즘 (Search-Based Algorithms)</strong></h4>
<p>탐색 기반 알고리즘은 상태 공간을 탐색하여 시작점에서 목표점까지의 경로를 찾는 방법이다. 대표적인 알고리즘으로는 <strong>A*</strong> 알고리즘과 <strong>Dijkstra</strong> 알고리즘이 있다.</p>
<ul>
<li><strong>A*</strong> 알고리즘: 이 알고리즘은 휴리스틱 함수 <span class="arithmatex"><span class="MathJax_Preview">h(\mathbf{x})</span><script type="math/tex">h(\mathbf{x})</script></span>를 사용하여 경로의 최적화를 시도한다. 시작점에서 특정 지점까지의 실제 비용 <span class="arithmatex"><span class="MathJax_Preview">g(\mathbf{x})</span><script type="math/tex">g(\mathbf{x})</script></span>와 휴리스틱 비용을 합산하여 평가한다.</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
  f(\mathbf{x}) = g(\mathbf{x}) + h(\mathbf{x})
</div>
<script type="math/tex; mode=display">
  f(\mathbf{x}) = g(\mathbf{x}) + h(\mathbf{x})
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">g(\mathbf{x})</span><script type="math/tex">g(\mathbf{x})</script></span>는 시작점에서 해당 지점까지의 경로 비용이고, <span class="arithmatex"><span class="MathJax_Preview">h(\mathbf{x})</span><script type="math/tex">h(\mathbf{x})</script></span>는 해당 지점에서 목표점까지의 예상 비용이다. A* 알고리즘은 <span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{x})</span><script type="math/tex">f(\mathbf{x})</script></span> 값을 최소화하는 경로를 탐색한다.</p>
<ul>
<li><strong>Dijkstra 알고리즘</strong>: Dijkstra 알고리즘은 시작점에서 목표점까지의 최단 경로를 찾는 데 주로 사용된다. 이는 경로 비용을 최소화하면서 장애물을 피해가는 경로를 계산하는 방식으로 작동한다. 이 알고리즘은 <span class="arithmatex"><span class="MathJax_Preview">g(\mathbf{x})</span><script type="math/tex">g(\mathbf{x})</script></span>만을 고려하며, 휴리스틱 함수가 없다.</li>
</ul>
<h4 id="2-sampling-based-algorithms">2. <strong>샘플링 기반 알고리즘 (Sampling-Based Algorithms)</strong></h4>
<p>샘플링 기반 알고리즘은 상태 공간 내에서 무작위로 샘플을 생성하여 경로를 계획하는 방식이다. 이 방법은 특히 고차원 공간에서 효과적이다.</p>
<ul>
<li><strong>PRM (Probabilistic Roadmap)</strong>: 이 알고리즘은 상태 공간에서 무작위로 샘플을 생성하고, 이 샘플을 그래프로 연결하여 경로를 찾는다. 이때, 장애물과의 충돌을 피하면서 시작점에서 목표점까지의 경로를 찾는 것이다.</li>
<li>
<p>PRM은 크게 두 가지 단계로 이루어진다:</p>
<ol>
<li><strong>구성 단계 (Construction Phase)</strong>: 상태 공간에서 무작위로 샘플을 생성하고, 샘플들 간의 충돌이 없는 연결을 생성하여 로드맵을 만든다.</li>
<li><strong>질의 단계 (Query Phase)</strong>: 시작점과 목표점이 주어졌을 때, 로드맵 상에서 경로를 찾는다.</li>
</ol>
</li>
<li>
<p><strong>RRT (Rapidly-exploring Random Tree)</strong>: RRT 알고리즘은 시작점에서부터 무작위로 샘플을 탐색하며 트리를 확장해 나가는 방식이다. 이 알고리즘은 특히 복잡한 환경에서 경로를 빠르게 탐색할 수 있다.</p>
</li>
<li>RRT 알고리즘의 핵심은 트리를 확장하면서 목표점에 가까워지는 방향으로 경로를 생성하는 것이다. 이는 상태 공간 내에서 무작위로 샘플을 선택하고, 해당 샘플에 가장 가까운 트리의 노드에서 새 노드를 생성하여 트리를 확장하는 방식으로 작동한다.</li>
</ul>
<h4 id="3-optimization-based-algorithms">3. <strong>최적화 기반 알고리즘 (Optimization-Based Algorithms)</strong></h4>
<p>최적화 기반 알고리즘은 경로의 비용을 최소화하거나 특정한 목적을 달성하기 위해 최적화 문제를 푸는 방식이다.</p>
<ul>
<li><strong>QP (Quadratic Programming)</strong>: 이 방식은 이차 방정식을 이용하여 경로를 최적화한다. <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>가 최소 비용을 갖도록 목적 함수를 설정한 후, 경로 계획 문제를 최적화 문제로 변환하여 해결한다.</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
  \min_{\mathbf{p}(t)} \quad \mathbf{p}(t)^{\top} Q \mathbf{p}(t)
</div>
<script type="math/tex; mode=display">
  \min_{\mathbf{p}(t)} \quad \mathbf{p}(t)^{\top} Q \mathbf{p}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">Q</span><script type="math/tex">Q</script></span>는 경로의 비용을 결정하는 행렬이다.</p>
<ul>
<li><strong>Constrained Optimization</strong>: 경로 계획 문제에서 장애물 회피와 같은 제약 조건을 포함하여 최적화 문제를 해결할 수 있다. 이 경우 목적 함수는 경로의 비용을 최소화하면서 제약 조건을 만족하는 방식으로 설정된다.</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
  \min_{\mathbf{p}(t)} \quad f(\mathbf{p}(t)), \quad \text{subject to} \quad \mathbf{p}(t) \in \mathcal{F}
</div>
<script type="math/tex; mode=display">
  \min_{\mathbf{p}(t)} \quad f(\mathbf{p}(t)), \quad \text{subject to} \quad \mathbf{p}(t) \in \mathcal{F}
</script>
</div>
<h4 id="4-hybrid-algorithms">4. <strong>혼합 기반 알고리즘 (Hybrid Algorithms)</strong></h4>
<p>혼합 기반 알고리즘은 탐색 기반과 최적화 기반 방법을 결합하여 더 나은 경로 계획 성능을 제공하는 방식이다. 탐색과 최적화를 결합하면, 경로 탐색의 초기 단계에서는 탐색 알고리즘을 사용하고, 이후 최적화 알고리즘으로 경로를 미세 조정하는 방식이다.</p>
<ul>
<li><strong>RRT* (RRT Star)</strong>: RRT 알고리즘을 개선한 방식으로, 경로 탐색 후 경로의 최적화를 수행하여 더 짧은 경로를 찾는 방법이다.</li>
<li><strong>PRM*</strong>: PRM 알고리즘을 개선하여 샘플링과 경로 최적화를 동시에 수행하는 방식이다.</li>
</ul>
<h3 id="_5">장애물 회피 경로 계획</h3>
<p>장애물 회피 경로 계획은 경로 계획 과정에서 장애물을 피하는 경로를 찾는 방법이다. 이를 위해 경로는 상태 공간 내에서 장애물과의 충돌을 피하면서 자유 공간 내에 존재해야 한다.</p>
<h4 id="1-potential-field-method">1. <strong>전위장 기법 (Potential Field Method)</strong></h4>
<p>전위장 기법은 로봇이 목표점에 가까워질수록 인력을 받고, 장애물에 가까워질수록 척력을 받는 가상의 전기장처럼 경로를 설정하는 방식이다. 목표점에서의 인력 <span class="arithmatex"><span class="MathJax_Preview">F_{\text{goal}}</span><script type="math/tex">F_{\text{goal}}</script></span>과 장애물에서의 척력 <span class="arithmatex"><span class="MathJax_Preview">F_{\text{obs}}</span><script type="math/tex">F_{\text{obs}}</script></span>을 계산하여 총 힘을 통해 로봇의 경로를 결정한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
F_{\text{total}} = F_{\text{goal}} + F_{\text{obs}}
</div>
<script type="math/tex; mode=display">
F_{\text{total}} = F_{\text{goal}} + F_{\text{obs}}
</script>
</div>
<p>이 방식은 계산이 간단하지만, 지역 최적해에 빠질 수 있는 단점이 있다.</p>
<h4 id="2-voronoi-voronoi-diagram">2. <strong>Voronoi 다이어그램 (Voronoi Diagram)</strong></h4>
<p>Voronoi 다이어그램은 상태 공간에서 장애물로부터 최대한 멀리 떨어진 경로를 찾는 방법이다. 이는 상태 공간을 장애물과의 거리에 따라 분할한 후, 경로가 이러한 분할된 영역의 경계선을 따르도록 설계하는 방식이다. 이를 통해 로봇이 장애물에 최대한 가까워지지 않도록 경로를 찾을 수 있다.</p>
<h3 id="_6">경로 최적화 기법</h3>
<p>경로 계획에서 경로 최적화는 목표 지점에 도달하는 경로를 가능한 한 짧거나 매끄럽게 만드는 것을 목표로 한다. 이는 연속적인 운동에서 에너지를 최소화하거나 충돌을 회피하면서 최적의 경로를 생성하기 위한 필수적인 과정이다.</p>
<h4 id="1-spline-based-path-optimization">1. <strong>스플라인 기반 경로 최적화 (Spline-Based Path Optimization)</strong></h4>
<p>스플라인(Spline)은 주어진 제어점들을 부드럽게 연결하는 곡선을 의미하며, 경로 최적화에서 자주 사용된다. 특히, 3차 스플라인이 경로 최적화에서 많이 사용된다.</p>
<p>스플라인 곡선은 다음과 같이 정의할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}(t) = \sum_{i=0}^{n} \mathbf{a}_i t^i
</div>
<script type="math/tex; mode=display">
\mathbf{p}(t) = \sum_{i=0}^{n} \mathbf{a}_i t^i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}_i</span><script type="math/tex">\mathbf{a}_i</script></span>는 제어점을 나타내는 계수이며, <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>는 매개 변수이다. 이 방식은 매끄러운 경로를 보장하면서 충돌을 피하는 경로를 생성할 수 있다.</p>
<p>또한, 경로의 매끄러움을 보장하기 위해 스플라인의 연속성을 만족하는 제약 조건을 추가할 수 있다. 예를 들어, 경로의 첫 번째 도함수와 두 번째 도함수의 연속성을 다음과 같이 설정할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}'(t_i) = \mathbf{p}'(t_{i+1}), \quad \mathbf{p}''(t_i) = \mathbf{p}''(t_{i+1})
</div>
<script type="math/tex; mode=display">
\mathbf{p}'(t_i) = \mathbf{p}'(t_{i+1}), \quad \mathbf{p}''(t_i) = \mathbf{p}''(t_{i+1})
</script>
</div>
<p>이러한 제약을 통해 경로의 부드러움을 극대화할 수 있다.</p>
<h4 id="2-cost-function-based-optimization">2. <strong>비용 함수 기반 경로 최적화 (Cost Function-Based Optimization)</strong></h4>
<p>경로 최적화 문제는 비용 함수 <span class="arithmatex"><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span>를 최소화하는 최적화 문제로 정의할 수 있다. 비용 함수는 경로의 길이, 매끄러움, 에너지 소비 등을 포함할 수 있으며, 이와 같은 목표들을 달성하기 위해 정의된다.</p>
<p>경로 최적화 문제는 다음과 같은 형태로 표현할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\min_{\mathbf{p}(t)} J(\mathbf{p}(t)), \quad \text{subject to} \quad \mathbf{p}(t) \in \mathcal{F}
</div>
<script type="math/tex; mode=display">
\min_{\mathbf{p}(t)} J(\mathbf{p}(t)), \quad \text{subject to} \quad \mathbf{p}(t) \in \mathcal{F}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">J(\mathbf{p}(t))</span><script type="math/tex">J(\mathbf{p}(t))</script></span>는 경로의 성능을 평가하는 비용 함수이고, <span class="arithmatex"><span class="MathJax_Preview">\mathcal{F}</span><script type="math/tex">\mathcal{F}</script></span>는 자유 공간이다.</p>
<p>예를 들어, 경로의 길이를 최소화하는 비용 함수는 다음과 같이 정의될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
J(\mathbf{p}(t)) = \int_0^T \|\mathbf{p}'(t)\| dt
</div>
<script type="math/tex; mode=display">
J(\mathbf{p}(t)) = \int_0^T \|\mathbf{p}'(t)\| dt
</script>
</div>
<p>이 비용 함수는 경로의 속도를 최소화하여 최단 경로를 찾는 데 사용될 수 있다.</p>
<p>또한, 경로의 매끄러움을 극대화하기 위한 비용 함수는 두 번째 도함수를 최소화하는 방식으로 정의될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
J(\mathbf{p}(t)) = \int_0^T \|\mathbf{p}''(t)\|^2 dt
</div>
<script type="math/tex; mode=display">
J(\mathbf{p}(t)) = \int_0^T \|\mathbf{p}''(t)\|^2 dt
</script>
</div>
<p>이러한 비용 함수를 사용하면 경로의 급격한 변화 없이 매끄러운 경로를 생성할 수 있다.</p>
<h4 id="3-constrained-optimization">3. <strong>제약 조건을 고려한 최적화 (Constrained Optimization)</strong></h4>
<p>경로 최적화에서 제약 조건을 고려한 최적화는 특정 제약 조건을 만족하면서 경로를 최적화하는 방법이다. 대표적인 제약 조건으로는 장애물 회피, 속도 제한, 가속도 제한 등이 있다.</p>
<p>예를 들어, 장애물 회피를 위한 제약 조건은 다음과 같이 정의될 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}(t) \notin \mathcal{O}, \quad \forall t \in [0, T]
</div>
<script type="math/tex; mode=display">
\mathbf{p}(t) \notin \mathcal{O}, \quad \forall t \in [0, T]
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathcal{O}</span><script type="math/tex">\mathcal{O}</script></span>는 장애물 공간을 의미한다.</p>
<p>속도 제한을 위한 제약 조건은 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{p}'(t)\| \leq v_{\text{max}}, \quad \forall t \in [0, T]
</div>
<script type="math/tex; mode=display">
\|\mathbf{p}'(t)\| \leq v_{\text{max}}, \quad \forall t \in [0, T]
</script>
</div>
<p>이러한 제약 조건을 통해 경로 계획에서 물체의 물리적 한계를 고려할 수 있다.</p>
<h4 id="4-path-smoothing">4. <strong>경로 스무딩 (Path Smoothing)</strong></h4>
<p>경로 계획에서 생성된 경로가 직선 구간으로 이루어져 있을 경우, 경로의 급격한 변화가 발생할 수 있다. 이를 해결하기 위해 경로 스무딩 기술이 사용되며, 경로를 매끄럽게 변환하여 이동 과정에서의 불연속성을 제거한다.</p>
<p>스무딩 기법은 주로 스플라인을 사용하여 직선 구간을 곡선으로 변환한다. 특히, <strong>3차 베지어 곡선 (Cubic Bezier Curve)</strong>이 많이 사용된다. 베지어 곡선은 주어진 시작점과 끝점, 그리고 두 개의 제어점을 이용하여 곡선을 정의한다.</p>
<p>3차 베지어 곡선은 다음과 같은 형태로 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}(t) = (1 - t)^3 \mathbf{P}_0 + 3(1 - t)^2 t \mathbf{P}_1 + 3(1 - t) t^2 \mathbf{P}_2 + t^3 \mathbf{P}_3, \quad t \in [0, 1]
</div>
<script type="math/tex; mode=display">
\mathbf{p}(t) = (1 - t)^3 \mathbf{P}_0 + 3(1 - t)^2 t \mathbf{P}_1 + 3(1 - t) t^2 \mathbf{P}_2 + t^3 \mathbf{P}_3, \quad t \in [0, 1]
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_0, \mathbf{P}_1, \mathbf{P}_2, \mathbf{P}_3</span><script type="math/tex">\mathbf{P}_0, \mathbf{P}_1, \mathbf{P}_2, \mathbf{P}_3</script></span>는 제어점이고, <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>는 매개변수이다.</p>
<h4 id="5-heuristic-methods">5. <strong>휴리스틱 기법 (Heuristic Methods)</strong></h4>
<p>휴리스틱 기법은 비용 함수의 전역 최적화를 보장하지 않지만, 비교적 짧은 시간 내에 근사 해를 찾는 데 유용하다. 대표적인 휴리스틱 기법으로는 <strong>유전자 알고리즘 (Genetic Algorithm)</strong>과 <strong>그리디 알고리즘 (Greedy Algorithm)</strong>이 있다.</p>
<ul>
<li>
<p><strong>유전자 알고리즘</strong>: 유전자 알고리즘은 진화론적 모델을 기반으로 최적 경로를 찾는 기법이다. 다양한 경로를 초기 개체로 설정하고, 이 개체들을 교차 및 변이를 통해 새로운 개체를 생성한 후, 적합도가 높은 경로를 선택하는 방식으로 최적의 경로를 찾는다.</p>
</li>
<li>
<p><strong>그리디 알고리즘</strong>: 그리디 알고리즘은 현재 상태에서 최적의 선택을 반복적으로 수행하여 최종 경로를 찾는 방식이다. 이 방법은 항상 전역 최적해를 보장하지는 않지만, 계산량이 적고 빠르게 경로를 찾을 수 있다.</p>
</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1502/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1502/" class="btn btn-xs btn-link">
        경로 최적화 기법
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_14/1402/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_14/1402/" class="btn btn-xs btn-link">
        동역학과의 차이점
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>