<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/mechanics/physics_engine/chapter_18/1804/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>새로운 시뮬레이션 기법 통합 - 소프트웨어 융합</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uae30\ucd08 \uac1c\ub150", url: "#_top", children: [
          ]},
          {title: "\uc218\ud559\uc801 \ubaa8\ub378\ub9c1", url: "#_2", children: [
          ]},
          {title: "\uc218\uce58\uc801 \ubc29\ubc95", url: "#_3", children: [
          ]},
          {title: "\ub370\uc774\ud130 \uad6c\uc870 \uc124\uacc4", url: "#_4", children: [
          ]},
          {title: "\ud544\ub4dc \ubc0f \ud798 \uacc4\uc0b0", url: "#_5", children: [
              {title: "\uc911\ub825 \uacc4\uc0b0", url: "#_6" },
              {title: "\uc804\uae30\ub825 \uacc4\uc0b0", url: "#_7" },
              {title: "\uc810\uc131\ub825 \uacc4\uc0b0", url: "#_8" },
          ]},
          {title: "\uac1c\uc120\ub41c \ucda9\ub3cc \ubc0f \ubc18\ubc1c \ubaa8\ub378", url: "#_9", children: [
          ]},
          {title: "\ud1b5\ud569 \ud504\ub85c\uc138\uc2a4", url: "#_10", children: [
          ]},
          {title: "\uc608\uc81c \ucf54\ub4dc", url: "#_11", children: [
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1805/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1805/" class="btn btn-xs btn-link">
        커스터마이징의 실제 적용 사례
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1803/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1803/" class="btn btn-xs btn-link">
        커스텀 제약 조건 구현
      </a>
    </div>
    
  </div>

    

    <p>물리 엔진에서 새로운 시뮬레이션 기법을 통합하는 것은 기존의 기능을 확장하고, 보다 정교한 물리적 현상을 재현하기 위해 필수적이다. 이 절에서는 이러한 기법을 통합하는 데 필요한 단계와 몇 가지 주요 개념을 다룬다.</p>
<h3 id="_1">기초 개념</h3>
<p>물리 엔진에서 작동하는 대부분의 시뮬레이션은 간단한 운동 방정식이나 입자 시스템 등을 기반으로 한다. 하지만 복잡한 물리 현상을 다루기 위해서는 새로운 기법을 통합해야 할 필요가 생깁니다. 새로운 시뮬레이션 기법을 효과적으로 통합하려면 다음과 같은 단계가 필요하다:</p>
<ol>
<li>
<p><strong>수학적 모델링</strong>: 새로운 물리 기법은 일반적으로 수학적 모델로 표현된다. 이 모델은 시스템의 상태와 그 변화율을 나타내는 미분방정식, 대수방정식 등으로 구성될 수 있다.</p>
</li>
<li>
<p><strong>수치적 방법</strong>: 복잡한 물리 모델을 해결하기 위해 수치적 방법이 필요하다. 수치적 방법에는 유한 차분법, 유한 요소법, 몬테 카를로 시뮬레이션 등이 포함될 수 있다.</p>
</li>
<li>
<p><strong>데이터 구조</strong>: 새로운 물리 기법을 효과적으로 구현하기 위해 적절한 데이터 구조를 설계해야 한다. 예를 들어, 입자 시스템을 시뮬레이션하는 경우, 각 입자의 속성(위치, 속도, 질량 등)을 저장하고 업데이트하는 데이터 구조가 필요하다.</p>
</li>
</ol>
<h3 id="_2">수학적 모델링</h3>
<p>새로운 물리 기법을 통합하기 위해서는 먼저 수학적 모델을 정의해야 한다. 예를 들어, 유체 동력을 시뮬레이션하려면 Navier-Stokes 방정식을 사용할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u}_t + (\mathbf{u} \cdot \nabla) \mathbf{u} = -\nabla p + \nu \Delta \mathbf{u} + \mathbf{f}
</div>
<script type="math/tex; mode=display">
\mathbf{u}_t + (\mathbf{u} \cdot \nabla) \mathbf{u} = -\nabla p + \nu \Delta \mathbf{u} + \mathbf{f}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}</span><script type="math/tex">\mathbf{u}</script></span>는 유체 속도 벡터, <span class="arithmatex"><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>는 압력, <span class="arithmatex"><span class="MathJax_Preview">\nu</span><script type="math/tex">\nu</script></span>는 점성 계수, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span>는 외력이다.</p>
<h3 id="_3">수치적 방법</h3>
<p>수학적 모델을 설정한 후, 이를 수치적으로 해결하기 위한 알고리즘을 선택해야 한다. 예를 들어, 유한 차분법은 PDE(편미분방정식)를 수치적으로 해결하는 데 유용하다. 유한 차분법의 기본 아이디어는 연속적인 도함수를 차분으로 대체하여, 이를 통해 근사적인 해를 구하는 것이다.</p>
<p>아래의 예시는 1차원 열 방정식을 해결하기 위한 유한 차분법의 예이다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
u_t = \alpha u_{xx}
</div>
<script type="math/tex; mode=display">
u_t = \alpha u_{xx}
</script>
</div>
<p>이를 유한 차분법으로 풀면 다음과 같은 형태로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
u_i^{n+1} = u_i^n + \frac{\alpha \Delta t}{(\Delta x)^2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n)
</div>
<script type="math/tex; mode=display">
u_i^{n+1} = u_i^n + \frac{\alpha \Delta t}{(\Delta x)^2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n)
</script>
</div>
<h3 id="_4">데이터 구조 설계</h3>
<p>새로운 물리 기법을 구현하기 위해서는 데이터를 효율적으로 관리할 수 있는 적절한 데이터 구조를 설계해야 한다. 예를 들어, 파티클 시스템을 시뮬레이션한다면 각 파티클의 상태(위치, 속도, 가속도 등)를 저장하고 업데이트할 수 있어야 한다. C++에서는 다음과 같이 구조체를 정의할 수 있다:</p>
<pre><code class="language-cpp">struct Particle {
    Vector3 position;
    Vector3 velocity;
    Vector3 acceleration;
    float mass;
};
</code></pre>
<p>이후에는 이러한 구조체를 배열이나 벡터 등으로 관리하여, 각 시뮬레이션 단계마다 업데이트할 수 있다.</p>
<h3 id="_5">필드 및 힘 계산</h3>
<p>새로운 시뮬레이션 기법을 통합할 때는 각 물리적 현상에 맞는 힘 계산 및 필드 계산이 필요하다. 예를 들어, 입자 간의 중력, 전기력, 유체의 점성력 등을 계산해야 한다.</p>
<h4 id="_6">중력 계산</h4>
<p>중력은 모든 질량을 가진 물체가 서로를 끌어당기는 힘이다. 뉴턴의 중력 법칙에 따라 두 질량 <span class="arithmatex"><span class="MathJax_Preview">m_1</span><script type="math/tex">m_1</script></span>, <span class="arithmatex"><span class="MathJax_Preview">m_2</span><script type="math/tex">m_2</script></span> 사이의 중력은 다음과 같다:
$$
\mathbf{F}_g = G \frac{m_1 m_2}{r^2} \hat{\mathbf{r}}
$$
여기서 <span class="arithmatex"><span class="MathJax_Preview">G</span><script type="math/tex">G</script></span>는 중력 상수, <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>은 두 물체 간의 거리, <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{r}}</span><script type="math/tex">\hat{\mathbf{r}}</script></span>는 거리 벡터의 단위 벡터이다.</p>
<h4 id="_7">전기력 계산</h4>
<p>쿨롱의 법칙에 따르면, 두 전하 <span class="arithmatex"><span class="MathJax_Preview">q_1</span><script type="math/tex">q_1</script></span>, <span class="arithmatex"><span class="MathJax_Preview">q_2</span><script type="math/tex">q_2</script></span> 사이의 전기력은 다음과 같다:
$$
\mathbf{F}_e = k_e \frac{q_1 q_2}{r^2} \hat{\mathbf{r}}
$$
여기서 <span class="arithmatex"><span class="MathJax_Preview">k_e</span><script type="math/tex">k_e</script></span>는 쿨롱 상수이고, 나머지 변수는 중력 법칙과 유사한다.</p>
<h4 id="_8">점성력 계산</h4>
<p>유체 역학에서 점성력은 유체의 층들이 상대속도 <span class="arithmatex"><span class="MathJax_Preview">\Delta \mathbf{u}</span><script type="math/tex">\Delta \mathbf{u}</script></span>를 가질 때 발생하는 저항력이다. 점성력 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}_v</span><script type="math/tex">\mathbf{F}_v</script></span>는 다음과 같이 표현된다:
$$
\mathbf{F}_v = \eta \nabla^2 \mathbf{u}
$$
여기서 <span class="arithmatex"><span class="MathJax_Preview">\eta</span><script type="math/tex">\eta</script></span>는 유체의 점성 계수이고, <span class="arithmatex"><span class="MathJax_Preview">\nabla^2 \mathbf{u}</span><script type="math/tex">\nabla^2 \mathbf{u}</script></span>는 속도 벡터의 라플라스 연산자이다.</p>
<h3 id="_9">개선된 충돌 및 반발 모델</h3>
<p>기존의 충돌 모델 외에도 더욱 정교한 모델을 도입할 수 있다. 대표적인 두 가지 모델은 다음과 같다:</p>
<ul>
<li>
<p><strong>고전 충돌 모델</strong>: 물체 간 충돌을 단순히 속도의 반동으로 계산한다. 이를 통해 각 물체의 속도를 업데이트한다.</p>
</li>
<li>
<p><strong>신축-압축 모델</strong>: 물체의 변형을 고려한 모델이다. 신축(탄성) 및 압축(비탄성) 성분을 고려하여 물체의 변형과 힘을 계산한다.</p>
</li>
</ul>
<h3 id="_10">통합 프로세스</h3>
<p>새로운 시뮬레이션 기법을 기존 물리 엔진에 통합하는 프로세스는 다음과 같다:</p>
<ol>
<li><strong>개념 증명</strong>: 기법의 기본을 이해하고 작은 규모의 예제로 테스트한다.</li>
<li><strong>모듈화</strong>: 기법을 모듈화하여 엔진의 다른 부분과 독립적으로 작동하게 한다.</li>
<li><strong>통합</strong>: 모듈을 기존 엔진에 통합하고 상호 작용을 테스트한다.</li>
<li><strong>최적화</strong>: 성능을 최적화하고, 병목 현상을 해결한다.</li>
<li><strong>검증</strong>: 다양한 시나리오에서 기법의 안정성과 신뢰성을 검증한다.</li>
</ol>
<h3 id="_11">예제 코드</h3>
<p>마지막으로, 새로운 충돌 모델을 구현한 간단한 예제 코드를 살펴보겠다. 이 코드는 입자 간의 충돌을 처리한다:</p>
<pre><code class="language-cpp">struct Particle {
    Vector3 position;
    Vector3 velocity;
    float radius;
    float mass;

    void update(float deltaTime) {
        position += velocity * deltaTime;
    }
};

void resolveCollision(Particle&amp; p1, Particle&amp; p2) {
    Vector3 delta = p2.position - p1.position;
    float distance = delta.length();
    float penetration = p1.radius + p2.radius - distance;

    if (penetration &gt; 0) {
        Vector3 collisionNormal = delta.normalized();
        float relativeVelocity = (p2.velocity - p1.velocity).dot(collisionNormal);
        float e = 1.0f; // 탄성 계수

        float j = (-(1 + e) * relativeVelocity) / (1 / p1.mass + 1 / p2.mass);
        Vector3 impulse = j * collisionNormal;

        p1.velocity -= impulse / p1.mass;
        p2.velocity += impulse / p2.mass;

        // 침투 해결
        Vector3 correction = collisionNormal * (penetration / (p1.mass + p2.mass));
        p1.position -= correction * (p2.mass / (p1.mass + p2.mass));
        p2.position += correction * (p1.mass / (p1.mass + p2.mass));
    }
}
</code></pre>
<p>위 코드에서 <code>resolveCollision</code> 함수는 두 입자의 속도와 위치를 변경하여 충돌을 해결한다.</p>
<p>새로운 시뮬레이션 기법을 물리 엔진에 통합하는 데 있어 중요한 것은 정확성과 성능의 균형을 맞추는 것이다. 다양한 시뮬레이션 기법을 통합하고 테스트하여 엔진의 기능과 효과성을 극대화할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1805/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1805/" class="btn btn-xs btn-link">
        커스터마이징의 실제 적용 사례
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1803/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1803/" class="btn btn-xs btn-link">
        커스텀 제약 조건 구현
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>