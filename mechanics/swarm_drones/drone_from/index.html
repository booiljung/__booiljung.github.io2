<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/mechanics/swarm_drones/drone_from/" rel="canonical"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>Drone from - 실험 도서관</title>
<link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../css/base.css" rel="stylesheet"/>
<link href="../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "2.2.1 \ub4dc\ub860 \ud38c\uc6e8\uc5b4 (ArduPilot)", url: "#_top", children: [
          ]},
          {title: "3. \uad70\uc9d1 \uc0c1\ud0dc \uad00\ub9ac (\uc0c1\uc138)", url: "#3", children: [
              {title: "3.1 \uad70\uc9d1 \uc0c1\ud0dc \uc804\uc774 \ubaa8\ub378", url: "#31" },
              {title: "3.2 \uad70\uc9d1 \uc0c1\ud0dc\uc758 \uc218\ud559\uc801 \uc815\uc758", url: "#32" },
              {title: "3.3 \uad70\uc9d1 \uc0c1\ud0dc\uc5d0\uc11c\uc758 \uc0c1\ub300 \uc704\uce58 \ucd94\uc815", url: "#33" },
              {title: "3.4 \uac00\uc0c1 \ud3c9\uba74 \uc0dd\uc131", url: "#34" },
              {title: "3.5 \uad70\uc9d1 \uc0c1\ud0dc \uad00\ub9ac \uc54c\uace0\ub9ac\uc998", url: "#35" },
              {title: "\uad6c\uba74 \uc911\uac04 \uc704\uce58 \uacc4\uc0b0 (Haversine \uacf5\uc2dd \uc0ac\uc6a9)", url: "#haversine" },
              {title: "\ubc29\uc704\uac01 \uacc4\uc0b0 \uacf5\uc2dd", url: "#_1" },
              {title: "\ubc29\uc704\uac01\uc758 \uc758\ubbf8", url: "#_2" },
              {title: "Haversine \uacf5\uc2dd", url: "#haversine_1" },
              {title: "\uacc4\uc0b0 \uc608\uc2dc", url: "#_4" },
              {title: "\uc704\ub3c4 \ucc28\uc774\ub85c \uac70\ub9ac\ub97c \uacc4\uc0b0\ud558\ub294 \ubc29\ubc95", url: "#_5" },
              {title: "\uc608\uc2dc", url: "#_6" },
              {title: "\ud0c0\uc6d0\uccb4 \uacbd\ub3c4 \ucc28\uc774\uc5d0 \ub530\ub978 \uac70\ub9ac \uacc4\uc0b0 \uc218\uc2dd", url: "#_7" },
              {title: "\ub2e8\uacc4\ubcc4 \uc608\uc2dc", url: "#_8" },
              {title: "\uc8fc\uc5b4\uc9c4 \uc815\ubcf4:", url: "#_9" },
              {title: "\ubaa9\ud45c:", url: "#_10" },
              {title: "1\ub2e8\uacc4: GPS \uc88c\ud45c\ub97c ECEF \uc88c\ud45c\ub85c \ubcc0\ud658", url: "#1-gps-ecef" },
              {title: "2\ub2e8\uacc4: ECEF \uc88c\ud45c \ucc28 \ubca1\ud130 \uacc4\uc0b0", url: "#2-ecef" },
              {title: "3\ub2e8\uacc4: ECEF \uc88c\ud45c\ub97c ENU \uc88c\ud45c\ub85c \ubcc0\ud658", url: "#3-ecef-enu" },
              {title: "4\ub2e8\uacc4: \ubc29\uc704\uac01\uc744 \uace0\ub824\ud558\uc5ec ENU \uc88c\ud45c \ud68c\uc804", url: "#4-enu" },
              {title: "\ucd5c\uc885 \uc694\uc57d \uc218\uc2dd", url: "#_11" },
              {title: "\ubcc0\uc218 \uc124\uba85:", url: "#_12" },
              {title: "1. \ud3c9\uba74 \ubc29\uc815\uc2dd", url: "#1_1" },
              {title: "2. \uc120 \ubc29\uc815\uc2dd", url: "#2" },
              {title: "3. \uad50\uc810 \uad6c\ud558\uae30", url: "#3_2" },
              {title: "4. \uad50\uc810 \uc88c\ud45c", url: "#4" },
          ]},
          {title: "\ucd08\ub85d (Abstract)", url: "#abstract", children: [
          ]},
          {title: "1. \uc11c\ub860 (Background)", url: "#1-background", children: [
          ]},
          {title: "2. \uc2dc\uc2a4\ud15c \uac1c\uc694", url: "#2_1", children: [
              {title: "2.1 \ub4dc\ub860\uc758 \ud558\ub4dc\uc6e8\uc5b4 \uad6c\uc131", url: "#21" },
              {title: "2.2 MAVLink \ud1b5\uc2e0", url: "#22-mavlink" },
              {title: "2.2 \uc18c\ud504\ud2b8\uc6e8\uc5b4 \uad6c\uc131", url: "#22" },
              {title: "\ud3c9\uba74 \ubc29\uc815\uc2dd:", url: "#_13" },
              {title: "\uc120\ubd84 \ubc29\uc815\uc2dd:", url: "#_14" },
              {title: "\uad50\ucc28\uc810 \uad6c\ud558\uae30:", url: "#_15" },
              {title: "\uad50\ucc28\uc810 \\mathbf{x}\\mathbf{x}:", url: "#mathbfxmathbfx" },
              {title: "N_dN_d \uc815\uc758", url: "#n_dn_d" },
              {title: "\uace0\ub3c4 \uacc4\uc0b0\uc5d0\uc11c N_dN_d\uc758 \uc5ed\ud560", url: "#n_dn_d_1" },
              {title: "1. \uc77c\ubc18 \uc774\uc2ec\ub960 (ee)", url: "#1-ee" },
              {title: "2. \ubcf4\uc870 \uc774\uc2ec\ub960 (e\u0027e\u0027)", url: "#2-ee" },
              {title: "\uad00\uacc4 \ubd84\uc11d", url: "#_16" },
              {title: "1. \ud3c9\uba74 \ubc29\uc815\uc2dd", url: "#1_2" },
              {title: "2. \uc120 \ubc29\uc815\uc2dd", url: "#2_2" },
              {title: "3. \uad50\uc810 \uad6c\ud558\uae30", url: "#3_3" },
              {title: "4. \uad50\uc810\uc758 \uc870\uac74", url: "#4_1" },
              {title: "ODE\ub97c \ucc38\uc870\ud55c \uc5f0\uc0b0", url: "#ode" },
              {title: "zz\ucd95\uc744 \uae30\uc900\uc73c\ub85c \\psi\\psi\ub9cc\ud07c\uc758 \ud68c\uc804 \ud589\ub82c", url: "#zz-psipsi" },
              {title: "\uc124\uba85", url: "#_17" },
              {title: "3.3.4 \uac00\uc0c1 \ud3c9\uba74 \uc801\uc6a9", url: "#334" },
              {title: "3.3.5 \ud5a5\ud6c4 \uacfc\uc81c", url: "#335" },
              {title: "2.3 \uad70\uc9d1 \ube44\ud589 \uc81c\uc5b4", url: "#23" },
              {title: "2.4 \uac80\uc0ac \uc808\ucc28", url: "#24" },
          ]},
          {title: "3. \uad70\uc9d1 \uc81c\uc5b4 \uc2dc\uc2a4\ud15c", url: "#3_4", children: [
              {title: "3.1 \uad70\uc9d1 \uc0c1\ud0dc \uc804\uc774", url: "#31_1" },
              {title: "3.2 \uac1c\ubcc4 \ub4dc\ub860 \uc0c1\ud0dc \uc804\uc774", url: "#32_1" },
          ]},
          {title: "4. \uad00\uc81c \uc18c\ud504\ud2b8\uc6e8\uc5b4", url: "#4_2", children: [
              {title: "4.1 MAVLink \ud1b5\uc2e0", url: "#41-mavlink" },
              {title: "4.2 \uac00\uc0c1 \ud3c9\uba74 \uc0dd\uc131", url: "#42" },
          ]},
          {title: "5. \uacb0\ub860", url: "#5", children: [
          ]},
          {title: "\ucc38\uc870", url: "#_18", children: [
              {title: "1. \ucd08\uae30 \uc704\ub3c4 \uac12 \ucd94\uc815", url: "#1_3" },
              {title: "2. \ubc18\ubcf5\uc801\uc778 \uc704\ub3c4 \uacc4\uc0b0", url: "#2_3" },
              {title: "3. \uacbd\ub3c4\uc640 \uace0\ub3c4 \uacc4\uc0b0", url: "#3_5" },
              {title: "1. WGS84 \uc88c\ud45c\ub97c \uc9c1\uad50 \uc88c\ud45c\uacc4\ub85c \ubcc0\ud658 (ECEF \uc88c\ud45c\uacc4)", url: "#1-wgs84-ecef" },
              {title: "2. \ub450 \ub4dc\ub860 \uac04 \uc0c1\ub300 \ubca1\ud130 \uacc4\uc0b0", url: "#2_4" },
              {title: "3. \uc0c1\ub300 \ubc29\ud5a5\uc744 \ub4dc\ub860\uc758 \ub85c\uceec \uc88c\ud45c\uacc4\ub85c \ubcc0\ud658", url: "#3_6" },
              {title: "4. \ub85c\uceec \uc88c\ud45c\uacc4\uc5d0\uc11c \ubc29\ud5a5 \uacb0\uc815", url: "#4_3" },
          ]},
        ];

    </script>
<script src="../../../js/base.js"></script>
<script src="../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<p>ENU(동-북-천정) 좌표계에서 GPS 좌표(위도, 경도, 고도)를 사용하여 피사체를 기준으로 드론의 위치를 구하는 과정은 다음과 같다.</p>
<ol>
<li><strong>위도, 경도, 고도 정보를 이용한 ECEF 좌표 변환</strong>
   먼저, GPS 좌표계의 위도, 경도, 고도를 ECEF(지구 중심 직교 좌표계) 좌표계로 변환한다. 이를 위해서는 아래의 변환식을 사용한다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   X = (N(\phi) + h) \cdot \cos(\phi) \cdot \cos(\lambda)
</div>
<script type="math/tex; mode=display">
   X = (N(\phi) + h) \cdot \cos(\phi) \cdot \cos(\lambda)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   Y = (N(\phi) + h) \cdot \cos(\phi) \cdot \sin(\lambda)
</div>
<script type="math/tex; mode=display">
   Y = (N(\phi) + h) \cdot \cos(\phi) \cdot \sin(\lambda)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   Z = (N(\phi) \cdot (1 - e^2) + h) \cdot \sin(\phi)
</div>
<script type="math/tex; mode=display">
   Z = (N(\phi) \cdot (1 - e^2) + h) \cdot \sin(\phi)
</script>
</div>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>는 위도 (radians)
   - <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>는 경도 (radians)
   - <span class="arithmatex"><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span>는 고도 (meters)
   - <span class="arithmatex"><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>는 지구의 이심률 (0.0818191908426)
   - <span class="arithmatex"><span class="MathJax_Preview">N(\phi) = \frac{a}{\sqrt{1 - e^2 \cdot \sin^2(\phi)}}</span><script type="math/tex">N(\phi) = \frac{a}{\sqrt{1 - e^2 \cdot \sin^2(\phi)}}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>는 지구의 장반경 (6378137 m)</p>
<ol>
<li><strong>ENU 좌표 변환</strong>
   피사체의 ECEF 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r_o}</span><script type="math/tex">\mathbf{r_o}</script></span>와 드론의 ECEF 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r_d}</span><script type="math/tex">\mathbf{r_d}</script></span>를 구한 후, 피사체를 기준으로 한 상대적인 ECEF 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r_{rel}} = \mathbf{r_d} - \mathbf{r_o}</span><script type="math/tex">\mathbf{r_{rel}} = \mathbf{r_d} - \mathbf{r_o}</script></span>를 계산한다.</li>
</ol>
<p>이후, 상대적인 ECEF 좌표를 ENU 좌표로 변환하기 위해서는 회전 변환을 사용한다. ENU 변환을 위한 회전 행렬은 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{R} =
   \begin{bmatrix}
   -\sin(\lambda_o) &amp; \cos(\lambda_o) &amp; 0 \\
   -\sin(\phi_o) \cdot \cos(\lambda_o) &amp; -\sin(\phi_o) \cdot \sin(\lambda_o) &amp; \cos(\phi_o) \\
   \cos(\phi_o) \cdot \cos(\lambda_o) &amp; \cos(\phi_o) \cdot \sin(\lambda_o) &amp; \sin(\phi_o)
   \end{bmatrix}
</div>
<script type="math/tex; mode=display">
   \mathbf{R} =
   \begin{bmatrix}
   -\sin(\lambda_o) & \cos(\lambda_o) & 0 \\
   -\sin(\phi_o) \cdot \cos(\lambda_o) & -\sin(\phi_o) \cdot \sin(\lambda_o) & \cos(\phi_o) \\
   \cos(\phi_o) \cdot \cos(\lambda_o) & \cos(\phi_o) \cdot \sin(\lambda_o) & \sin(\phi_o)
   \end{bmatrix}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\phi_o</span><script type="math/tex">\phi_o</script></span>는 피사체의 위도, <span class="arithmatex"><span class="MathJax_Preview">\lambda_o</span><script type="math/tex">\lambda_o</script></span>는 피사체의 경도이다.</p>
<ol>
<li><strong>ENU 좌표 계산</strong>
   피사체를 원점으로 하는 ENU 좌표계에서 드론의 ENU 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r_{enu}}</span><script type="math/tex">\mathbf{r_{enu}}</script></span>는 다음과 같이 계산된다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{r_{enu}} = \mathbf{R} \cdot \mathbf{r_{rel}}
</div>
<script type="math/tex; mode=display">
\mathbf{r_{enu}} = \mathbf{R} \cdot \mathbf{r_{rel}}
</script>
</div>
<p>이 과정을 통해 피사체(원점) 기준으로 드론의 ENU 좌표를 계산할 수 있다.</p>
<p>이제 피사체의 위도, 경도, 고도 <span class="arithmatex"><span class="MathJax_Preview">(o_{\phi}, o_{\lambda}, o_h)</span><script type="math/tex">(o_{\phi}, o_{\lambda}, o_h)</script></span>와 드론의 위도, 경도, 고도 <span class="arithmatex"><span class="MathJax_Preview">(d_{\phi}, d_{\lambda}, d_h)</span><script type="math/tex">(d_{\phi}, d_{\lambda}, d_h)</script></span>를 통해 위와 같은 절차를 사용하여 ENU 좌표로 변환하면 된다.</p>
<p>3차원 제로 벡터는 보통 다음과 같이 표기된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{0} = 
</div>
<script type="math/tex; mode=display">
\mathbf{0} = 
</script>
</div>
<p>이 벡터는 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, <span class="arithmatex"><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>, <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span> 세 축 모두에서 성분이 0인 벡터를 의미한다.</p>
<h3 id="221-ardupilot">2.2.1 드론 펌웨어 (ArduPilot)</h3>
<p><strong>아두파일럿(ArduPilot)</strong>은 오픈 소스 기반의 자율 비행 소프트웨어로, 다양한 드론과 로봇의 자동 제어를 지원하는 플랫폼이다. 이 연구에서는 아두파일럿을 사용하여 드론의 자동 비행 및 상태 관리를 수행한다. 아두파일럿의 주요 역할은 다음과 같다.</p>
<ul>
<li>
<p><strong>자율 비행 제어</strong>: 아두파일럿은 드론의 자율 비행을 관리하는 소프트웨어로, GPS와 IMU 데이터를 실시간으로 처리하여 드론의 위치와 자세를 정확하게 제어한다. 이는 조종자의 개입 없이 드론이 사전에 설정된 비행 경로를 따라 이동할 수 있도록 한다. 비행 경로는 관제 소프트웨어에서 설정되며, 아두파일럿은 이 경로를 따라 비행 명령을 실행한다.</p>
</li>
<li>
<p><strong>센서 데이터 처리</strong>: 아두파일럿은 드론의 센서(GPS, IMU, 카메라 등) 데이터를 실시간으로 처리하여 드론의 비행 경로와 자세를 조정한다. 이러한 데이터는 드론의 안정성을 유지하고 피사체의 정확한 위치를 조준하는 데 사용된다.</p>
</li>
<li>
<p><strong>MAVLink 통신 프로토콜</strong>: 아두파일럿은 MAVLink 프로토콜을 통해 관제 소프트웨어와 통신한다. 이 프로토콜은 드론의 상태 정보(위치, 속도, 고도 등)를 관제 시스템에 전달하고, 관제 소프트웨어에서 내려오는 명령을 수신하여 드론의 비행 상태를 제어한다.</p>
</li>
<li>
<p><strong>안전 관리</strong>: 아두파일럿은 비행 중 드론의 안전을 확보하기 위해 다양한 기능을 제공한다. 예를 들어, 배터리가 부족하거나 GPS 신호가 약해질 경우 <strong>RTL</strong> 모드로 자동 전환하여 드론이 안전하게 출발 지점으로 복귀할 수 있도록 한다.</p>
</li>
</ul>
<p>아두파일럿은 본 연구에서 두 대의 드론이 자율적으로 비파괴 검사를 수행할 수 있도록 지원하는 핵심 소프트웨어로, 자동 비행 제어, 실시간 통신, 센서 데이터 처리, 안전 관리 등의 역할을 수행한다.</p>
<h2 id="3">3. 군집 상태 관리 (상세)</h2>
<p>본 시스템에서 두 대의 드론은 피사체를 중심으로 상호 간 거리를 유지하며 동시 비파괴 검사를 수행한다. 이를 위해 군집 상태 관리는 조종자의 명령에 따라 각 드론이 개별적으로 또는 군집으로 동작할 수 있도록 제어하는 중요한 역할을 한다. 본 장에서는 군집 상태 관리의 구체적인 동작 원리와 수학적 표현을 통해 군집 제어 방식을 설명한다.</p>
<h3 id="31">3.1 군집 상태 전이 모델</h3>
<p>군집 상태 관리는 상태 전이 다이어그램을 기반으로 설계되었다. 이 다이어그램은 드론의 상태를 정의하고, 각 상태 간의 전이를 수학적으로 표현한다. 군집 상태는 다음과 같은 상태로 정의된다:</p>
<ul>
<li><strong>Idle 상태</strong>: 시스템이 대기 중이며, 조종자의 명령을 기다리는 상태이다.</li>
<li><strong>Takeoff 상태</strong>: 두 대의 드론이 동시에 이륙하는 상태이다.</li>
<li><strong>Aim 상태</strong>: 두 대의 드론이 피사체를 중심으로 상호 간 위치를 조정하며 검사 장비를 피사체에 조준하는 상태이다.</li>
<li><strong>Brake 상태</strong>: 비행 중 비상 정지 명령이 내려졌을 때 드론의 비행이 멈추는 상태이다.</li>
<li><strong>Land 상태</strong>: 임무 완료 후 드론이 착륙하는 상태이다.</li>
<li><strong>Auto 상태</strong>: 조종자가 설정한 경로를 따라 드론이 자동으로 비파괴 검사를 수행하는 상태이다.</li>
<li><strong>RTL (Return to Launch) 상태</strong>: 임무가 중단되거나 종료될 때, 드론이 시작 지점으로 복귀하는 상태이다.</li>
</ul>
<p>군집 상태의 전이 조건을 수학적으로 표현하면 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S(t) = \left\{
\begin{array}{ll}
S_{\text{idle}} &amp; \text{if} \ t = 0 \\
S_{\text{takeoff}} &amp; \text{if} \ C_{\text{takeoff}}(t) \\
S_{\text{aim}} &amp; \text{if} \ C_{\text{aim}}(t) \\
S_{\text{auto}} &amp; \text{if} \ C_{\text{auto}}(t) \\
S_{\text{brake}} &amp; \text{if} \ C_{\text{brake}}(t) \\
S_{\text{land}} &amp; \text{if} \ C_{\text{land}}(t) \\
S_{\text{rtl}} &amp; \text{if} \ C_{\text{rtl}}(t)
\end{array}
\right.
</div>
<script type="math/tex; mode=display">
S(t) = \left\{
\begin{array}{ll}
S_{\text{idle}} & \text{if} \ t = 0 \\
S_{\text{takeoff}} & \text{if} \ C_{\text{takeoff}}(t) \\
S_{\text{aim}} & \text{if} \ C_{\text{aim}}(t) \\
S_{\text{auto}} & \text{if} \ C_{\text{auto}}(t) \\
S_{\text{brake}} & \text{if} \ C_{\text{brake}}(t) \\
S_{\text{land}} & \text{if} \ C_{\text{land}}(t) \\
S_{\text{rtl}} & \text{if} \ C_{\text{rtl}}(t)
\end{array}
\right.
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">S(t)</span><script type="math/tex">S(t)</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서의 군집 상태이며, 각 상태 전이 조건은 <span class="arithmatex"><span class="MathJax_Preview">C_x(t)</span><script type="math/tex">C_x(t)</script></span>로 정의된다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">C_{\text{takeoff}}(t)</span><script type="math/tex">C_{\text{takeoff}}(t)</script></span>는 조종자가 <strong>takeoff</strong> 명령을 내렸을 때 성립하는 조건을 의미하며, 이 조건이 만족되면 군집 상태는 <strong>takeoff</strong>로 전이된다.</p>
<h3 id="32">3.2 군집 상태의 수학적 정의</h3>
<p>각 군집 상태는 드론 간의 상호 위치를 계산하고 유지하기 위해 수학적으로 정의된다. 두 드론의 상대적 위치를 정의하기 위해 각 드론의 위치 벡터를 사용한다. 두 대의 드론 <span class="arithmatex"><span class="MathJax_Preview">D_1</span><script type="math/tex">D_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">D_2</span><script type="math/tex">D_2</script></span>의 위치를 각각 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1(t)</span><script type="math/tex">\mathbf{p}_1(t)</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2(t)</span><script type="math/tex">\mathbf{p}_2(t)</script></span>로 정의하면, 군집 상태에서 피사체로부터 일정한 거리를 유지하는 조건은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{d}(t) = \mathbf{p}_2(t) - \mathbf{p}_1(t)
</div>
<script type="math/tex; mode=display">
\mathbf{d}(t) = \mathbf{p}_2(t) - \mathbf{p}_1(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}(t)</span><script type="math/tex">\mathbf{d}(t)</script></span>는 두 드론 간의 거리 벡터이며, 이를 사용하여 두 드론이 피사체를 중심으로 일정한 거리를 유지하도록 제어한다. 이때, 군집 상태에서 유지해야 하는 거리를 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{target}}</span><script type="math/tex">d_{\text{target}}</script></span>이라 할 때, 거리 유지 조건은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{d}(t)\| = d_{\text{target}}
</div>
<script type="math/tex; mode=display">
\|\mathbf{d}(t)\| = d_{\text{target}}
</script>
</div>
<p>이 식은 두 드론이 항상 일정한 거리를 유지하며 비행해야 함을 의미한다. 군집 상태 관리 소프트웨어는 이 조건을 지속적으로 확인하고, 드론 간 상대 위치를 조정하여 피사체에 대한 일정 거리를 유지한다.</p>
<h3 id="33">3.3 군집 상태에서의 상대 위치 추정</h3>
<p>드론 간 상대적 위치를 추정하는 방법으로는 GPS 및 IMU 데이터를 결합한 센서 융합 방법을 사용한다. 각 드론의 위치 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1(t)</span><script type="math/tex">\mathbf{p}_1(t)</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2(t)</span><script type="math/tex">\mathbf{p}_2(t)</script></span>는 GPS 모듈로부터 얻을 수 있으며, IMU 데이터는 드론의 자세 및 상대 위치를 보정하는 데 사용된다. 이를 바탕으로 상대 위치 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}(t)</span><script type="math/tex">\mathbf{d}(t)</script></span>는 다음과 같이 추정된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{d}(t) = \hat{\mathbf{p}}_2(t) - \hat{\mathbf{p}}_1(t) + \Delta \mathbf{d}_{\text{IMU}}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{d}(t) = \hat{\mathbf{p}}_2(t) - \hat{\mathbf{p}}_1(t) + \Delta \mathbf{d}_{\text{IMU}}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{p}}_1(t)</span><script type="math/tex">\hat{\mathbf{p}}_1(t)</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{p}}_2(t)</span><script type="math/tex">\hat{\mathbf{p}}_2(t)</script></span>는 GPS로 측정한 각 드론의 위치이며, <span class="arithmatex"><span class="MathJax_Preview">\Delta \mathbf{d}_{\text{IMU}}(t)</span><script type="math/tex">\Delta \mathbf{d}_{\text{IMU}}(t)</script></span>는 IMU 데이터를 바탕으로 보정된 상대 위치 벡터이다. 이를 통해 두 드론은 상대적으로 정확한 위치 정보를 기반으로 군집 비행을 수행할 수 있다.</p>
<h3 id="34">3.4 가상 평면 생성</h3>
<p>군집 상태에서 두 대의 드론은 피사체를 중심으로 가상의 평면을 생성한다. 이 가상 평면은 두 드론의 위치를 기준으로 생성되며, 피사체와의 상대적인 거리를 유지하기 위해 사용된다. 두 드론의 위치를 이용하여 생성된 가상 평면의 수학적 정의는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{n}(t) = \frac{\mathbf{p}_2(t) - \mathbf{p}_1(t)}{\|\mathbf{p}_2(t) - \mathbf{p}_1(t)\|}
</div>
<script type="math/tex; mode=display">
\mathbf{n}(t) = \frac{\mathbf{p}_2(t) - \mathbf{p}_1(t)}{\|\mathbf{p}_2(t) - \mathbf{p}_1(t)\|}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}(t)</span><script type="math/tex">\mathbf{n}(t)</script></span>는 두 드론을 잇는 벡터의 단위 벡터이며, 이는 가상 평면의 법선 벡터로 사용된다. 이 가상 평면을 기준으로 드론은 피사체 주위를 비행하며, 일정 거리를 유지하고 상호 조준하여 비파괴 검사를 수행한다.</p>
<h3 id="35">3.5 군집 상태 관리 알고리즘</h3>
<p>군집 상태 관리 알고리즘은 조종자의 명령에 따라 군집 상태를 전이하고, 각 드론의 상태를 실시간으로 조정하는 역할을 한다. 군집 상태 관리의 알고리즘은 다음과 같은 절차로 구성된다:</p>
<ol>
<li>
<p><strong>조종자 명령 수신</strong>: 조종자는 관제 소프트웨어를 통해 군집 상태 전이 명령을 내린다. 예를 들어, <strong>takeoff</strong> 명령이 내려지면 군집 상태가 <strong>takeoff</strong>로 전이된다.</p>
</li>
<li>
<p><strong>상태 전이 조건 확인</strong>: 각 군집 상태의 전이 조건을 확인하여 해당 조건이 충족되면 군집 상태를 전이한다. 상태 전이 조건은 조종자 명령 또는 드론의 센서 데이터에 기반하여 결정된다.</p>
</li>
<li>
<p><strong>상대 위치 조정</strong>: 군집 상태가 전이된 후, 두 드론 간의 상대적 위치를 계산하고 피사체를 중심으로 지정된 거리를 유지하도록 제어한다. 이때, GPS 및 IMU 데이터를 이용하여 두 드론의 상대 위치를 실시간으로 추정하고 보정한다.</p>
</li>
<li>
<p><strong>임무 수행</strong>: 군집 상태가 <strong>aim</strong> 또는 <strong>auto</strong>로 전이되면, 드론은 피사체 주위를 비행하며 비파괴 검사를 수행한다. 이때, 관제 소프트웨어는 실시간으로 드론의 상태를 모니터링하고, 필요한 경우 군집 상태를 다시 전이한다.</p>
</li>
<li>
<p><strong>임무 완료 및 착륙</strong>: 임무가 완료되면, 군집 상태가 <strong>land</strong>로 전이되고 두 드론은 착륙한다.</p>
</li>
</ol>
<p>군집 상태 관리의 수학적 표현을 통해, 두 대의 드론이 피사체 주위를 정확하게 비행하며 비파괴 검사를 수행하는 과정을 명확히 설명할 수 있다. 이러한 군집 제어 방식은 두 드론 간의 상호 의존성을 기반으로 하며, 실시간 데이터 교환과 상태 전이를 통해 안정적인 비파괴 검사를 가능하게 한다.</p>
<p>맞습니다. GPS 좌표는 위도와 경도라는 각도로 표현되기 때문에, 단순한 더하기나 나누기로 중간 위치를 계산하는 것은 잘못된 접근이다. GPS 좌표는 지구의 곡면을 기반으로 하므로, 각도 계산에 적합한 방식이 필요하다. 중간 위치를 계산하려면 지구의 구형 모델을 사용한 <strong>구면 선형 보간</strong> 또는 <strong>구면 삼각법</strong>을 적용해야 한다.</p>
<p>GPS 좌표에서 두 지점 사이의 중간 위치를 계산하는 정확한 방법은 <strong>구면 보간</strong>을 사용하는 것이다. 이를 통해 각도 좌표계를 고려하여 정확한 중간 지점을 계산할 수 있다.</p>
<h3 id="haversine">구면 중간 위치 계산 (Haversine 공식 사용)</h3>
<ol>
<li></li>
</ol>
<p>이 과정은 두 GPS 좌표 사이의 중간 위치를 구하는 정확한 방법이다.</p>
<p>방위각(azimuth) 계산은 두 GPS 좌표 사이의 방향을 계산하는 방법이다. 두 점 간의 방위각은 드론이 상대 드론의 위치로부터 특정 방향으로 이동할 때 매우 중요한 정보이다. 방위각을 계산하기 위해서는 위도와 경도를 기반으로 한 구면 삼각법을 사용해야 한다.</p>
<p>다음은 두 GPS 좌표 <span class="arithmatex"><span class="MathJax_Preview">(φ_1, λ_1)</span><script type="math/tex">(φ_1, λ_1)</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">(φ_2, λ_2)</span><script type="math/tex">(φ_2, λ_2)</script></span> 사이의 방위각을 계산하는 과정이다:</p>
<h3 id="_1">방위각 계산 공식</h3>
<ol>
<li><strong>위도와 경도를 라디안으로 변환</strong><br/>
   방위각을 계산하기 위해서는 위도와 경도를 먼저 라디안으로 변환해야 한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   φ_1 = φ_1 \cdot \frac{\pi}{180}, \quad λ_1 = λ_1 \cdot \frac{\pi}{180}
</div>
<script type="math/tex; mode=display">
   φ_1 = φ_1 \cdot \frac{\pi}{180}, \quad λ_1 = λ_1 \cdot \frac{\pi}{180}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   φ_2 = φ_2 \cdot \frac{\pi}{180}, \quad λ_2 = λ_2 \cdot \frac{\pi}{180}
</div>
<script type="math/tex; mode=display">
   φ_2 = φ_2 \cdot \frac{\pi}{180}, \quad λ_2 = λ_2 \cdot \frac{\pi}{180}
</script>
</div>
<ol>
<li><strong>위도, 경도 차이 계산</strong><br/>
   두 지점 사이의 경도 차이를 계산한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
Δλ = λ_2 - λ_1
</div>
<script type="math/tex; mode=display">
Δλ = λ_2 - λ_1
</script>
</div>
<ol>
<li><strong>방위각 계산 공식</strong><br/>
   방위각(azimuth)은 다음과 같은 공식으로 계산된다:
$$
   θ = \tan^{-1} \left( \frac{\sin(Δλ) \cdot \cos(φ_2)}{\cos(φ_1) \cdot \sin(φ_2) - \sin(φ_1) \cdot \cos(φ_2) \cdot \cos(Δλ)} \right)
$$</li>
</ol>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">θ</span><script type="math/tex">θ</script></span>는 방위각(azimuth)을 의미하며, 라디안 단위로 계산된다.</p>
<ol>
<li><strong>결과 조정</strong><br/>
   방위각 <span class="arithmatex"><span class="MathJax_Preview">θ</span><script type="math/tex">θ</script></span>는 계산된 값에 따라 적절히 조정되어야 한다. 방위각은 0도에서 360도 사이의 값이어야 하므로 다음과 같이 조정한다:
$$
θ_{\text{deg}} = (θ \cdot \frac{180}{\pi} + 360) \, \mod \, 360
$$</li>
</ol>
<p>이 공식은 라디안으로 계산된 방위각을 도 단위로 변환하고, 결과를 0에서 360도 범위로 조정한다.</p>
<h3 id="_2">방위각의 의미</h3>
<ul>
<li><strong>0도</strong>는 북쪽을, <strong>90도</strong>는 동쪽을, <strong>180도</strong>는 남쪽을, <strong>270도</strong>는 서쪽을 나타낸다.</li>
<li>계산된 방위각은 첫 번째 드론에서 두 번째 드론으로 향하는 방향을 나타낸다.</li>
</ul>
<p>이 방식은 지구 곡률을 고려하여 GPS 좌표 간 방위각을 정확히 계산할 수 있으며, 드론 간 상대적 방향을 판단하는 데 중요한 역할을 한다.</p>
<p>두 개의 GPS 위치가 주어졌을 때, 두 지점 간의 <strong>지리적 경도 거리</strong>를 계산하는 방법은 <strong>Haversine 공식</strong>을 사용하는 것이다. 이 공식은 지구의 곡률을 고려하여 두 지점 사이의 대원거리를 계산한다. </p>
<h3 id="haversine_1">Haversine 공식</h3>
<p>주어진 두 GPS 좌표가 <span class="arithmatex"><span class="MathJax_Preview">(φ_1, λ_1)</span><script type="math/tex">(φ_1, λ_1)</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">(φ_2, λ_2)</span><script type="math/tex">(φ_2, λ_2)</script></span>일 때, 이 좌표는 각각 위도(φ)와 경도(λ)로 구성되며, 각도를 라디안으로 변환하여 계산한다. 이때 지구의 평균 반지름 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>은 약 6,371 km 또는 6,371,000 m이다.</p>
<h4 id="_3">공식:</h4>
<ol>
<li>먼저, 각도를 라디안으로 변환한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   φ_1 = φ_1 \cdot \frac{\pi}{180}, \quad λ_1 = λ_1 \cdot \frac{\pi}{180}
</div>
<script type="math/tex; mode=display">
   φ_1 = φ_1 \cdot \frac{\pi}{180}, \quad λ_1 = λ_1 \cdot \frac{\pi}{180}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   φ_2 = φ_2 \cdot \frac{\pi}{180}, \quad λ_2 = λ_2 \cdot \frac{\pi}{180}
</div>
<script type="math/tex; mode=display">
   φ_2 = φ_2 \cdot \frac{\pi}{180}, \quad λ_2 = λ_2 \cdot \frac{\pi}{180}
</script>
</div>
<ol>
<li>두 지점 간의 경도 차이 <span class="arithmatex"><span class="MathJax_Preview">Δλ</span><script type="math/tex">Δλ</script></span>와 위도 차이 <span class="arithmatex"><span class="MathJax_Preview">Δφ</span><script type="math/tex">Δφ</script></span>를 구한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   Δφ = φ_2 - φ_1
</div>
<script type="math/tex; mode=display">
   Δφ = φ_2 - φ_1
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   Δλ = λ_2 - λ_1
</div>
<script type="math/tex; mode=display">
   Δλ = λ_2 - λ_1
</script>
</div>
<ol>
<li>Haversine 공식을 이용하여 대원거리를 구한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   a = \sin^2\left(\frac{Δφ}{2}\right) + \cos(φ_1) \cdot \cos(φ_2) \cdot \sin^2\left(\frac{Δλ}{2}\right)
</div>
<script type="math/tex; mode=display">
   a = \sin^2\left(\frac{Δφ}{2}\right) + \cos(φ_1) \cdot \cos(φ_2) \cdot \sin^2\left(\frac{Δλ}{2}\right)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   c = 2 \cdot \tan^{-1}\left(\sqrt{a}, \sqrt{1 - a}\right)
</div>
<script type="math/tex; mode=display">
   c = 2 \cdot \tan^{-1}\left(\sqrt{a}, \sqrt{1 - a}\right)
</script>
</div>
<ol>
<li>두 지점 사이의 경도 거리는 다음과 같이 계산된다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   d = R \cdot c
</div>
<script type="math/tex; mode=display">
   d = R \cdot c
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>은 지구의 반지름(약 6,371,000m)이고, <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>는 두 지점 사이의 거리(미터 단위)이다.</p>
<h3 id="_4">계산 예시</h3>
<ul>
<li>GPS 좌표 1: <span class="arithmatex"><span class="MathJax_Preview">φ_1 = 37.7749^\circ N, λ_1 = 122.4194^\circ W</span><script type="math/tex">φ_1 = 37.7749^\circ N, λ_1 = 122.4194^\circ W</script></span></li>
<li>
<p>GPS 좌표 2: <span class="arithmatex"><span class="MathJax_Preview">φ_2 = 34.0522^\circ N, λ_2 = 118.2437^\circ W</span><script type="math/tex">φ_2 = 34.0522^\circ N, λ_2 = 118.2437^\circ W</script></span></p>
</li>
<li>
<p>각도를 라디안으로 변환:</p>
</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
   φ_1 = 37.7749 \cdot \frac{\pi}{180}, \quad λ_1 = -122.4194 \cdot \frac{\pi}{180}
</div>
<script type="math/tex; mode=display">
   φ_1 = 37.7749 \cdot \frac{\pi}{180}, \quad λ_1 = -122.4194 \cdot \frac{\pi}{180}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   φ_2 = 34.0522 \cdot \frac{\pi}{180}, \quad λ_2 = -118.2437 \cdot \frac{\pi}{180}
</div>
<script type="math/tex; mode=display">
   φ_2 = 34.0522 \cdot \frac{\pi}{180}, \quad λ_2 = -118.2437 \cdot \frac{\pi}{180}
</script>
</div>
<ol>
<li>위도 및 경도 차이:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   Δφ = φ_2 - φ_1, \quad Δλ = λ_2 - λ_1
</div>
<script type="math/tex; mode=display">
   Δφ = φ_2 - φ_1, \quad Δλ = λ_2 - λ_1
</script>
</div>
<ol>
<li>Haversine 값 계산:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   a = \sin^2\left(\frac{Δφ}{2}\right) + \cos(φ_1) \cdot \cos(φ_2) \cdot \sin^2\left(\frac{Δλ}{2}\right)
</div>
<script type="math/tex; mode=display">
   a = \sin^2\left(\frac{Δφ}{2}\right) + \cos(φ_1) \cdot \cos(φ_2) \cdot \sin^2\left(\frac{Δλ}{2}\right)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   c = 2 \cdot \tan^{-1}\left(\sqrt{a}, \sqrt{1 - a}\right)
</div>
<script type="math/tex; mode=display">
   c = 2 \cdot \tan^{-1}\left(\sqrt{a}, \sqrt{1 - a}\right)
</script>
</div>
<ol>
<li>최종 거리:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   d = R \cdot c
</div>
<script type="math/tex; mode=display">
   d = R \cdot c
</script>
</div>
<p>이 공식은 지구의 곡률을 고려한 대원거리를 계산하므로, 두 GPS 좌표 사이의 경도 거리를 정확히 구할 수 있다.</p>
<p>두 지점의 <strong>위도 차이에 따른 거리</strong>를 타원체 기준으로 계산하려면, 지구의 곡률을 고려한 타원체 모델을 사용해야 한다. 위도에 따른 거리는 경도에 관계없이 지구 반지름과 타원체의 형태에 따라 달라진다.</p>
<p>지구는 완전한 구가 아니라 <strong>타원체</strong>이므로, 특정 위도에서의 1도의 위도 차이에 따른 거리도 정확하게 계산할 필요가 있다. 이를 계산하기 위해, 지구 타원체의 반장축(적도 반경)과 반단축(극 반경)을 활용하여 미터로 변환할 수 있다.</p>
<h3 id="_5">위도 차이로 거리를 계산하는 방법</h3>
<p>타원체에서 위도에 따른 거리 계산은 다음과 같이 수행된다.</p>
<h4 id="1">1. 지구 타원체의 기본 파라미터</h4>
<ul>
<li><strong>반장축(a)</strong>: 타원체의 긴 반지름(적도 반경), 약 <span class="arithmatex"><span class="MathJax_Preview">a = 6,378,137 \, \text{m}</span><script type="math/tex">a = 6,378,137 \, \text{m}</script></span></li>
<li><strong>반단축(b)</strong>: 타원체의 짧은 반지름(극 반경), 약 <span class="arithmatex"><span class="MathJax_Preview">b = 6,356,752.3 \, \text{m}</span><script type="math/tex">b = 6,356,752.3 \, \text{m}</script></span></li>
</ul>
<h4 id="2-1">2. 위도에 따른 1도의 거리 계산</h4>
<p>위도에 따른 1도의 거리는 다음 공식으로 구할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
M(φ) = \frac{a \cdot (1 - e^2)}{(1 - e^2 \cdot \sin^2(φ))^{3/2}}
</div>
<script type="math/tex; mode=display">
M(φ) = \frac{a \cdot (1 - e^2)}{(1 - e^2 \cdot \sin^2(φ))^{3/2}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">φ</span><script type="math/tex">φ</script></span>는 위도(라디안 단위)
- <span class="arithmatex"><span class="MathJax_Preview">e^2 = \frac{a^2 - b^2}{a^2}</span><script type="math/tex">e^2 = \frac{a^2 - b^2}{a^2}</script></span>는 지구 타원체의 이심률 제곱</p>
<p>이 공식은 위도에 따른 <strong>자오선 반경(Meridional radius of curvature)</strong>을 구하는 공식으로, 타원체의 특정 위도에서 자오선(위도 방향)으로 1도의 거리(미터 단위)를 구할 수 있다.</p>
<h4 id="3_1">3. 두 지점의 위도 차이에 따른 거리 계산</h4>
<p>두 지점의 위도 차이 <span class="arithmatex"><span class="MathJax_Preview">Δφ</span><script type="math/tex">Δφ</script></span>를 미터로 변환하려면, 두 지점의 위도 차이를 <strong>라디안</strong>으로 변환하고 자오선 반경 <span class="arithmatex"><span class="MathJax_Preview">M(φ)</span><script type="math/tex">M(φ)</script></span>을 곱해주면 된다.</p>
<ul>
<li>두 지점의 위도 차이를 라디안으로 변환:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
Δφ = (φ_2 - φ_1) \cdot \frac{\pi}{180}
</div>
<script type="math/tex; mode=display">
Δφ = (φ_2 - φ_1) \cdot \frac{\pi}{180}
</script>
</div>
<ul>
<li>중간 위도(두 지점의 평균 위도)를 <span class="arithmatex"><span class="MathJax_Preview">φ_{\text{mid}}</span><script type="math/tex">φ_{\text{mid}}</script></span>라고 정의하고, 자오선 반경 <span class="arithmatex"><span class="MathJax_Preview">M(φ_{\text{mid}})</span><script type="math/tex">M(φ_{\text{mid}})</script></span>을 계산:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
φ_{\text{mid}} = \frac{φ_1 + φ_2}{2}
</div>
<script type="math/tex; mode=display">
φ_{\text{mid}} = \frac{φ_1 + φ_2}{2}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
M(φ_{\text{mid}}) = \frac{a \cdot (1 - e^2)}{(1 - e^2 \cdot \sin^2(φ_{\text{mid}}))^{3/2}}
</div>
<script type="math/tex; mode=display">
M(φ_{\text{mid}}) = \frac{a \cdot (1 - e^2)}{(1 - e^2 \cdot \sin^2(φ_{\text{mid}}))^{3/2}}
</script>
</div>
<ul>
<li>위도 차이에 따른 거리 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{lat}}</span><script type="math/tex">d_{\text{lat}}</script></span>는 다음과 같이 계산된다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
d_{\text{lat}} = M(φ_{\text{mid}}) \cdot Δφ
</div>
<script type="math/tex; mode=display">
d_{\text{lat}} = M(φ_{\text{mid}}) \cdot Δφ
</script>
</div>
<p>이 계산을 통해 타원체 모델에서 두 지점의 위도 차이에 따른 거리를 정확하게 구할 수 있다.</p>
<h3 id="_6">예시</h3>
<p>만약 두 지점의 위도가 각각 <span class="arithmatex"><span class="MathJax_Preview">φ_1 = 37.7749^\circ</span><script type="math/tex">φ_1 = 37.7749^\circ</script></span> (샌프란시스코), <span class="arithmatex"><span class="MathJax_Preview">φ_2 = 34.0522^\circ</span><script type="math/tex">φ_2 = 34.0522^\circ</script></span> (로스앤젤레스)라고 가정하면:</p>
<ol>
<li>두 지점의 위도 차이를 계산:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   Δφ = (37.7749 - 34.0522)^\circ = 3.7227^\circ
</div>
<script type="math/tex; mode=display">
   Δφ = (37.7749 - 34.0522)^\circ = 3.7227^\circ
</script>
</div>
<ol>
<li>중간 위도 <span class="arithmatex"><span class="MathJax_Preview">φ_{\text{mid}}</span><script type="math/tex">φ_{\text{mid}}</script></span>를 계산:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   φ_{\text{mid}} = \frac{37.7749 + 34.0522}{2} = 35.91355^\circ
</div>
<script type="math/tex; mode=display">
   φ_{\text{mid}} = \frac{37.7749 + 34.0522}{2} = 35.91355^\circ
</script>
</div>
<ol>
<li>자오선 반경 <span class="arithmatex"><span class="MathJax_Preview">M(φ_{\text{mid}})</span><script type="math/tex">M(φ_{\text{mid}})</script></span>를 계산:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   e^2 = \frac{(6,378,137)^2 - (6,356,752.3)^2}{(6,378,137)^2} = 0.00669437999014
</div>
<script type="math/tex; mode=display">
   e^2 = \frac{(6,378,137)^2 - (6,356,752.3)^2}{(6,378,137)^2} = 0.00669437999014
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   M(φ_{\text{mid}}) = \frac{6,378,137 \cdot (1 - 0.00669437999014)}{(1 - 0.00669437999014 \cdot \sin^2(35.91355^\circ))^{3/2}} = 6,367,191.14 \, \text{m}
</div>
<script type="math/tex; mode=display">
   M(φ_{\text{mid}}) = \frac{6,378,137 \cdot (1 - 0.00669437999014)}{(1 - 0.00669437999014 \cdot \sin^2(35.91355^\circ))^{3/2}} = 6,367,191.14 \, \text{m}
</script>
</div>
<ol>
<li>위도 차이에 따른 거리 <span class="arithmatex"><span class="MathJax_Preview">d_{\text{lat}}</span><script type="math/tex">d_{\text{lat}}</script></span> 계산:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   d_{\text{lat}} = 6,367,191.14 \cdot \left(\frac{3.7227 \cdot \pi}{180}\right) = 413,575.9 \, \text{m}
</div>
<script type="math/tex; mode=display">
   d_{\text{lat}} = 6,367,191.14 \cdot \left(\frac{3.7227 \cdot \pi}{180}\right) = 413,575.9 \, \text{m}
</script>
</div>
<p>결과적으로 두 지점의 위도 차이에 따른 거리는 약 <strong>413.6 km</strong>가 된다.</p>
<hr/>
<p>이 계산 방식은 타원체 모델을 기반으로 하여 위도 차이에 따른 거리를 정확하게 구하는 방법이다. 위도에 따라 자오선 반경이 변하므로, 두 지점 간의 중간 위도를 사용하여 해당 위도에서의 자오선 반경을 구한 후, 위도 차이를 곱해 거리를 미터로 변환한다.</p>
<p>타원체 지구 모델을 사용하는 경우, 지구가 완전한 구가 아니므로 정확한 경도 차이 계산을 위해 타원체의 형상을 고려해야 한다. 특히, 위도에 따라 지구의 곡률 반경이 달라지기 때문에 타원체를 기반으로 한 경도 차이 계산은 구형 지구 모델에서보다 복잡한다. </p>
<p>타원체 모델에서 경도 차이를 미터로 변환하는 수식은 다음과 같이 수정될 수 있다.</p>
<h3 id="_7">타원체 경도 차이에 따른 거리 계산 수식</h3>
<p>타원체 지구 모델에서 경도에 따른 거리를 계산하기 위해서는 <strong>위도에 따른 지구의 반경을 구하는 공식</strong>을 사용해야 한다. 이를 위해 두 가지 중요한 반경 값을 사용한다:
- <strong>주축 반경 (<span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>)</strong>: 지구 적도의 반경으로 약 6,378,137 m이다.
- <strong>부축 반경 (<span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>)</strong>: 극지방에서의 반경으로 약 6,356,752 m이다.</p>
<p>경도 차이에 따른 거리를 계산하기 위해서 <strong>위도에 따른 곡률 반경</strong>을 구하는 방법은 다음과 같다:</p>
<h4 id="1-rphirphi">1. 곡률 반경 <span class="arithmatex"><span class="MathJax_Preview">R(\phi)</span><script type="math/tex">R(\phi)</script></span></h4>
<p>위도 <span class="arithmatex"><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>에서의 타원체 곡률 반경 <span class="arithmatex"><span class="MathJax_Preview">R(\phi)</span><script type="math/tex">R(\phi)</script></span>는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
R(\phi) = \frac{a \cdot \cos(\phi)}{\sqrt{1 - e^2 \sin^2(\phi)}}
</div>
<script type="math/tex; mode=display">
R(\phi) = \frac{a \cdot \cos(\phi)}{\sqrt{1 - e^2 \sin^2(\phi)}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>는 주축 반경 (6,378,137 m).
- <span class="arithmatex"><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>는 타원체의 이심률로, <span class="arithmatex"><span class="MathJax_Preview">e = \sqrt{1 - \frac{b^2}{a^2}}</span><script type="math/tex">e = \sqrt{1 - \frac{b^2}{a^2}}</script></span>.
- <span class="arithmatex"><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>는 위도 (라디안).</p>
<p>이 식은 타원체 지구의 곡률 반경을 위도에 따라 계산하는 방법이다.</p>
<h4 id="2-d_lambdad_lambda">2. 경도 차이에 따른 거리 <span class="arithmatex"><span class="MathJax_Preview">d_{\lambda}</span><script type="math/tex">d_{\lambda}</script></span></h4>
<p>이제 타원체에서 경도 차이에 따른 거리를 계산할 수 있다. 주어진 위도 <span class="arithmatex"><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>에서의 경도 차이 <span class="arithmatex"><span class="MathJax_Preview">\Delta \lambda</span><script type="math/tex">\Delta \lambda</script></span>에 따른 거리는 다음과 같이 구할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
d_{\lambda} = \Delta \lambda \cdot R(\phi)
</div>
<script type="math/tex; mode=display">
d_{\lambda} = \Delta \lambda \cdot R(\phi)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">d_{\lambda}</span><script type="math/tex">d_{\lambda}</script></span>는 경도 차이에 따른 거리 (미터).
- <span class="arithmatex"><span class="MathJax_Preview">\Delta \lambda</span><script type="math/tex">\Delta \lambda</script></span>는 두 지점의 경도 차이 (라디안).
- <span class="arithmatex"><span class="MathJax_Preview">R(\phi)</span><script type="math/tex">R(\phi)</script></span>는 위도 <span class="arithmatex"><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>에서의 곡률 반경 (미터).</p>
<h3 id="_8">단계별 예시</h3>
<ul>
<li>두 GPS 위치의 위도: <span class="arithmatex"><span class="MathJax_Preview">\phi_1 = 35^\circ</span><script type="math/tex">\phi_1 = 35^\circ</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\phi_2 = 36^\circ</span><script type="math/tex">\phi_2 = 36^\circ</script></span></li>
<li>
<p>두 GPS 위치의 경도: <span class="arithmatex"><span class="MathJax_Preview">\lambda_1 = 127^\circ</span><script type="math/tex">\lambda_1 = 127^\circ</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\lambda_2 = 128^\circ</span><script type="math/tex">\lambda_2 = 128^\circ</script></span></p>
</li>
<li>
<p>경도 차이 <span class="arithmatex"><span class="MathJax_Preview">\Delta \lambda</span><script type="math/tex">\Delta \lambda</script></span>: <span class="arithmatex"><span class="MathJax_Preview">128^\circ - 127^\circ = 1^\circ</span><script type="math/tex">128^\circ - 127^\circ = 1^\circ</script></span>, 라디안으로 변환: <span class="arithmatex"><span class="MathJax_Preview">1^\circ \times \frac{\pi}{180} = 0.01745 \, \text{rad}</span><script type="math/tex">1^\circ \times \frac{\pi}{180} = 0.01745 \, \text{rad}</script></span>.</p>
</li>
<li>
<p>이심률 <span class="arithmatex"><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> 계산:</p>
</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
   e = \sqrt{1 - \frac{b^2}{a^2}} = \sqrt{1 - \frac{(6,356,752)^2}{(6,378,137)^2}} \approx 0.0818
</div>
<script type="math/tex; mode=display">
   e = \sqrt{1 - \frac{b^2}{a^2}} = \sqrt{1 - \frac{(6,356,752)^2}{(6,378,137)^2}} \approx 0.0818
</script>
</div>
<ol>
<li>두 지점의 위도의 평균 계산:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \phi = \frac{35^\circ + 36^\circ}{2} = 35.5^\circ = 0.6196 \, \text{rad}
</div>
<script type="math/tex; mode=display">
   \phi = \frac{35^\circ + 36^\circ}{2} = 35.5^\circ = 0.6196 \, \text{rad}
</script>
</div>
<ol>
<li>위도 <span class="arithmatex"><span class="MathJax_Preview">35.5^\circ</span><script type="math/tex">35.5^\circ</script></span>에서의 곡률 반경 <span class="arithmatex"><span class="MathJax_Preview">R(\phi)</span><script type="math/tex">R(\phi)</script></span> 계산:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   R(35.5^\circ) = \frac{6,378,137 \cdot \cos(0.6196)}{\sqrt{1 - 0.0818^2 \sin^2(0.6196)}} \approx 5,217,421 \, \text{m}
</div>
<script type="math/tex; mode=display">
   R(35.5^\circ) = \frac{6,378,137 \cdot \cos(0.6196)}{\sqrt{1 - 0.0818^2 \sin^2(0.6196)}} \approx 5,217,421 \, \text{m}
</script>
</div>
<ol>
<li>경도 차이에 따른 거리 계산:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   d_{\lambda} = 0.01745 \cdot 5,217,421 \approx 91,000 \, \text{m} 
</div>
<script type="math/tex; mode=display">
   d_{\lambda} = 0.01745 \cdot 5,217,421 \approx 91,000 \, \text{m} 
</script>
</div>
<p>결과적으로, 타원체 지구 모델을 사용한 경우 두 경도 차이에 따른 거리는 약 91 km이다.</p>
<p>이 수식은 지구의 타원체 형상을 반영하여 보다 정확한 경도 차이에 따른 거리를 구할 수 있는 방법이다.</p>
<p>드론의 좌표를 가상 평면의 원점을 기준으로 유클리드 좌표로 나타내기 위해, 타원구체로 모델링된 지구와 가상 평면의 방위각을 고려한 수학적 과정을 따를 수 있다. 다음은 단계별 설명이다.</p>
<h3 id="_9"><strong>주어진 정보:</strong></h3>
<ul>
<li>지구 모델은 타원구체(WGS84 기준 타원체).</li>
<li>가상 평면의 원점의 GPS 좌표: <span class="arithmatex"><span class="MathJax_Preview">(\phi_0, \lambda_0, h_0)</span><script type="math/tex">(\phi_0, \lambda_0, h_0)</script></span>.</li>
<li>드론의 GPS 좌표: <span class="arithmatex"><span class="MathJax_Preview">(\phi_1, \lambda_1, h_1)</span><script type="math/tex">(\phi_1, \lambda_1, h_1)</script></span>.</li>
<li>가상 평면의 방위각: <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> (북쪽으로부터 시계방향으로 측정).</li>
</ul>
<h3 id="_10"><strong>목표:</strong></h3>
<p>가상 평면의 원점을 기준으로 드론의 유클리드 좌표 <span class="arithmatex"><span class="MathJax_Preview">(x, y, z)</span><script type="math/tex">(x, y, z)</script></span>를 구하는 것.</p>
<hr/>
<h3 id="1-gps-ecef"><strong>1단계: GPS 좌표를 ECEF 좌표로 변환</strong></h3>
<p>가상 평면의 원점과 드론의 GPS 좌표를 각각 지구 중심 고정 좌표계(ECEF, Earth-Centered, Earth-Fixed)로 변환한다.</p>
<p><strong>ECEF 변환 공식:</strong></p>
<p>먼저 고정 상수들을 계산한다:
- 지구의 장축 반경 <span class="arithmatex"><span class="MathJax_Preview">a = 6378137</span><script type="math/tex">a = 6378137</script></span> 미터.
- 평평율 <span class="arithmatex"><span class="MathJax_Preview">f = 1/298.257223563</span><script type="math/tex">f = 1/298.257223563</script></span>.
- 단축 반경 <span class="arithmatex"><span class="MathJax_Preview">b = a(1 - f)</span><script type="math/tex">b = a(1 - f)</script></span>.
- 제1편평도 <span class="arithmatex"><span class="MathJax_Preview">e^2 = 1 - \left( \dfrac{b}{a} \right)^2</span><script type="math/tex">e^2 = 1 - \left( \dfrac{b}{a} \right)^2</script></span>.</p>
<p>GPS 좌표 (<span class="arithmatex"><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>: 위도, <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>: 경도, <span class="arithmatex"><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span>: 고도)로부터 ECEF 좌표를 구하는 공식은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{align*}
N &amp;= \dfrac{a}{\sqrt{1 - e^2 \sin^2 \phi}} \\
X &amp;= (N + h) \cos \phi \cos \lambda \\
Y &amp;= (N + h) \cos \phi \sin \lambda \\
Z &amp;= \left( N (1 - e^2) + h \right) \sin \phi
\end{align*}
</div>
<script type="math/tex; mode=display">
\begin{align*}
N &= \dfrac{a}{\sqrt{1 - e^2 \sin^2 \phi}} \\
X &= (N + h) \cos \phi \cos \lambda \\
Y &= (N + h) \cos \phi \sin \lambda \\
Z &= \left( N (1 - e^2) + h \right) \sin \phi
\end{align*}
</script>
</div>
<p>이를 이용해 가상 평면의 원점 <span class="arithmatex"><span class="MathJax_Preview">(X_0, Y_0, Z_0)</span><script type="math/tex">(X_0, Y_0, Z_0)</script></span>와 드론의 위치 <span class="arithmatex"><span class="MathJax_Preview">(X_1, Y_1, Z_1)</span><script type="math/tex">(X_1, Y_1, Z_1)</script></span>를 계산한다.</p>
<hr/>
<h3 id="2-ecef"><strong>2단계: ECEF 좌표 차 벡터 계산</strong></h3>
<p>두 점 사이의 ECEF 좌표 차를 구한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{align*}
\Delta X &amp;= X_1 - X_0 \\
\Delta Y &amp;= Y_1 - Y_0 \\
\Delta Z &amp;= Z_1 - Z_0
\end{align*}
</div>
<script type="math/tex; mode=display">
\begin{align*}
\Delta X &= X_1 - X_0 \\
\Delta Y &= Y_1 - Y_0 \\
\Delta Z &= Z_1 - Z_0
\end{align*}
</script>
</div>
<hr/>
<h3 id="3-ecef-enu"><strong>3단계: ECEF 좌표를 ENU 좌표로 변환</strong></h3>
<p>가상 평면의 원점을 기준으로 드론의 동-북-천(East-North-Up, ENU) 좌표를 계산한다.</p>
<p><strong>ENU 변환 공식:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{align*}
e &amp;= -\sin \lambda_0 \Delta X + \cos \lambda_0 \Delta Y \\
n &amp;= -\sin \phi_0 \cos \lambda_0 \Delta X - \sin \phi_0 \sin \lambda_0 \Delta Y + \cos \phi_0 \Delta Z \\
u &amp;= \cos \phi_0 \cos \lambda_0 \Delta X + \cos \phi_0 \sin \lambda_0 \Delta Y + \sin \phi_0 \Delta Z
\end{align*}
</div>
<script type="math/tex; mode=display">
\begin{align*}
e &= -\sin \lambda_0 \Delta X + \cos \lambda_0 \Delta Y \\
n &= -\sin \phi_0 \cos \lambda_0 \Delta X - \sin \phi_0 \sin \lambda_0 \Delta Y + \cos \phi_0 \Delta Z \\
u &= \cos \phi_0 \cos \lambda_0 \Delta X + \cos \phi_0 \sin \lambda_0 \Delta Y + \sin \phi_0 \Delta Z
\end{align*}
</script>
</div>
<hr/>
<h3 id="4-enu"><strong>4단계: 방위각을 고려하여 ENU 좌표 회전</strong></h3>
<p>가상 평면의 방위각을 고려하여 ENU 좌표를 회전시킨다.</p>
<p><strong>회전 변환 공식:</strong></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{align*}
x &amp;= e \sin \alpha + n \cos \alpha \\
y &amp;= -e \cos \alpha + n \sin \alpha \\
z &amp;= u
\end{align*}
</div>
<script type="math/tex; mode=display">
\begin{align*}
x &= e \sin \alpha + n \cos \alpha \\
y &= -e \cos \alpha + n \sin \alpha \\
z &= u
\end{align*}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 방위각으로, 이 각도에 따라 ENU 좌표가 회전한다. <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 라디안 단위여야 한다.</p>
<hr/>
<h3 id="_11"><strong>최종 요약 수식</strong></h3>
<p>모든 단계를 결합하여, 가상 평면의 원점을 기준으로 드론의 유클리드 좌표는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{align*}
x &amp;= \left( -\sin \lambda_0 \Delta X + \cos \lambda_0 \Delta Y \right) \sin \alpha + \left( -\sin \phi_0 \cos \lambda_0 \Delta X - \sin \phi_0 \sin \lambda_0 \Delta Y + \cos \phi_0 \Delta Z \right) \cos \alpha \\
y &amp;= -\left( -\sin \lambda_0 \Delta X + \cos \lambda_0 \Delta Y \right) \cos \alpha + \left( -\sin \phi_0 \cos \lambda_0 \Delta X - \sin \phi_0 \sin \lambda_0 \Delta Y + \cos \phi_0 \Delta Z \right) \sin \alpha \\
z &amp;= \cos \phi_0 \cos \lambda_0 \Delta X + \cos \phi_0 \sin \lambda_0 \Delta Y + \sin \phi_0 \Delta Z
\end{align*}
</div>
<script type="math/tex; mode=display">
\begin{align*}
x &= \left( -\sin \lambda_0 \Delta X + \cos \lambda_0 \Delta Y \right) \sin \alpha + \left( -\sin \phi_0 \cos \lambda_0 \Delta X - \sin \phi_0 \sin \lambda_0 \Delta Y + \cos \phi_0 \Delta Z \right) \cos \alpha \\
y &= -\left( -\sin \lambda_0 \Delta X + \cos \lambda_0 \Delta Y \right) \cos \alpha + \left( -\sin \phi_0 \cos \lambda_0 \Delta X - \sin \phi_0 \sin \lambda_0 \Delta Y + \cos \phi_0 \Delta Z \right) \sin \alpha \\
z &= \cos \phi_0 \cos \lambda_0 \Delta X + \cos \phi_0 \sin \lambda_0 \Delta Y + \sin \phi_0 \Delta Z
\end{align*}
</script>
</div>
<p>이 수식은 지구의 타원체 모델과 가상 평면의 방위각을 반영하여 드론의 위치를 가상 평면의 원점 기준으로 유클리드 좌표로 나타낸 것이다.</p>
<hr/>
<h3 id="_12"><strong>변수 설명:</strong></h3>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\phi_0, \lambda_0</span><script type="math/tex">\phi_0, \lambda_0</script></span>: 가상 평면 원점의 위도 및 경도 (라디안).</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\phi_1, \lambda_1</span><script type="math/tex">\phi_1, \lambda_1</script></span>: 드론의 위도 및 경도 (라디안).</li>
<li><span class="arithmatex"><span class="MathJax_Preview">h_0, h_1</span><script type="math/tex">h_0, h_1</script></span>: 가상 평면 원점과 드론의 고도 (미터).</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>: 가상 평면의 방위각 (라디안).</li>
<li><span class="arithmatex"><span class="MathJax_Preview">a, b</span><script type="math/tex">a, b</script></span>: 지구의 장축 반경 및 단축 반경.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">e^2</span><script type="math/tex">e^2</script></span>: 제1편평도.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>: 수직 곡률 반경.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\Delta X, \Delta Y, \Delta Z</span><script type="math/tex">\Delta X, \Delta Y, \Delta Z</script></span>: ECEF 좌표 차이.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">e, n, u</span><script type="math/tex">e, n, u</script></span>: ENU 좌표.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">x, y, z</span><script type="math/tex">x, y, z</script></span>: 드론의 가상 평면 원점 기준 유클리드 좌표.</li>
</ul>
<hr/>
<p>이 수식은 가상 평면의 방위각을 포함하여 드론의 위치를 수학적으로 정확하게 계산하는 방법을 나타낸다.</p>
<p>두 드론의 위치인 <span class="arithmatex"><span class="MathJax_Preview">\dot{\mathbf{p}}_1 = (\dot{x}_1, \dot{y}_1, \dot{z}_1)</span><script type="math/tex">\dot{\mathbf{p}}_1 = (\dot{x}_1, \dot{y}_1, \dot{z}_1)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\dot{\mathbf{p}}_2 = (\dot{x}_2, \dot{y}_2, \dot{z}_2)</span><script type="math/tex">\dot{\mathbf{p}}_2 = (\dot{x}_2, \dot{y}_2, \dot{z}_2)</script></span>, 그리고 평면의 위치인 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_o = (x_o, y_o, z_o)</span><script type="math/tex">\mathbf{p}_o = (x_o, y_o, z_o)</script></span>를 기반으로 평면과 두 드론을 이은 선의 교점을 구하기 위해서는, 먼저 평면 방정식과 선 방정식을 세우는 것이 필요하다.</p>
<h3 id="1_1">1. 평면 방정식</h3>
<p>가상 평면의 방위각이 <span class="arithmatex"><span class="MathJax_Preview">\dot{\alpha}</span><script type="math/tex">\dot{\alpha}</script></span>로 주어졌다면, 방위각을 사용해 평면의 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>을 구할 수 있다. 방위각 <span class="arithmatex"><span class="MathJax_Preview">\dot{\alpha}</span><script type="math/tex">\dot{\alpha}</script></span>가 주어졌다면, 법선 벡터는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{n} = (\cos(\dot{\alpha}), \sin(\dot{\alpha}), 0)
</div>
<script type="math/tex; mode=display">
\mathbf{n} = (\cos(\dot{\alpha}), \sin(\dot{\alpha}), 0)
</script>
</div>
<p>이 법선 벡터를 이용해, 평면의 방정식은 다음과 같이 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{n} \cdot (\mathbf{p} - \mathbf{p}_o) = 0
</div>
<script type="math/tex; mode=display">
\mathbf{n} \cdot (\mathbf{p} - \mathbf{p}_o) = 0
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\cos(\dot{\alpha})(x - x_o) + \sin(\dot{\alpha})(y - y_o) = 0
</div>
<script type="math/tex; mode=display">
\cos(\dot{\alpha})(x - x_o) + \sin(\dot{\alpha})(y - y_o) = 0
</script>
</div>
<p>이를 확장하면 평면 방정식은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\cos(\dot{\alpha}) x + \sin(\dot{\alpha}) y = \cos(\dot{\alpha}) x_o + \sin(\dot{\alpha}) y_o
</div>
<script type="math/tex; mode=display">
\cos(\dot{\alpha}) x + \sin(\dot{\alpha}) y = \cos(\dot{\alpha}) x_o + \sin(\dot{\alpha}) y_o
</script>
</div>
<h3 id="2">2. 선 방정식</h3>
<p>두 드론을 이은 선의 방정식을 구하려면, 매개변수 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에 따라 두 점을 연결하는 선을 정의할 수 있다. 선의 방정식은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}(t) = \dot{\mathbf{p}}_1 + t(\dot{\mathbf{p}}_2 - \dot{\mathbf{p}}_1)
</div>
<script type="math/tex; mode=display">
\mathbf{p}(t) = \dot{\mathbf{p}}_1 + t(\dot{\mathbf{p}}_2 - \dot{\mathbf{p}}_1)
</script>
</div>
<p>이것을 좌표 형태로 나타내면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}(t) = (\dot{x}_1 + t(\dot{x}_2 - \dot{x}_1), \dot{y}_1 + t(\dot{y}_2 - \dot{y}_1), \dot{z}_1 + t(\dot{z}_2 - \dot{z}_1))
</div>
<script type="math/tex; mode=display">
\mathbf{p}(t) = (\dot{x}_1 + t(\dot{x}_2 - \dot{x}_1), \dot{y}_1 + t(\dot{y}_2 - \dot{y}_1), \dot{z}_1 + t(\dot{z}_2 - \dot{z}_1))
</script>
</div>
<h3 id="3_2">3. 교점 구하기</h3>
<p>이제 평면 방정식과 선 방정식을 결합하여 교점을 구할 수 있다. 선 방정식에서 <span class="arithmatex"><span class="MathJax_Preview">x(t)</span><script type="math/tex">x(t)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">y(t)</span><script type="math/tex">y(t)</script></span>를 평면 방정식에 대입하면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\cos(\dot{\alpha})(\dot{x}_1 + t(\dot{x}_2 - \dot{x}_1)) + \sin(\dot{\alpha})(\dot{y}_1 + t(\dot{y}_2 - \dot{y}_1)) = \cos(\dot{\alpha}) x_o + \sin(\dot{\alpha}) y_o
</div>
<script type="math/tex; mode=display">
\cos(\dot{\alpha})(\dot{x}_1 + t(\dot{x}_2 - \dot{x}_1)) + \sin(\dot{\alpha})(\dot{y}_1 + t(\dot{y}_2 - \dot{y}_1)) = \cos(\dot{\alpha}) x_o + \sin(\dot{\alpha}) y_o
</script>
</div>
<p>위 식에서 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>를 풀면, 교점에서의 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 값을 구할 수 있다.</p>
<h4 id="tt"><span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 값 구하기:</h4>
<div class="arithmatex">
<div class="MathJax_Preview">
t = \frac{\cos(\dot{\alpha})(x_o - \dot{x}_1) + \sin(\dot{\alpha})(y_o - \dot{y}_1)}{\cos(\dot{\alpha})(\dot{x}_2 - \dot{x}_1) + \sin(\dot{\alpha})(\dot{y}_2 - \dot{y}_1)}
</div>
<script type="math/tex; mode=display">
t = \frac{\cos(\dot{\alpha})(x_o - \dot{x}_1) + \sin(\dot{\alpha})(y_o - \dot{y}_1)}{\cos(\dot{\alpha})(\dot{x}_2 - \dot{x}_1) + \sin(\dot{\alpha})(\dot{y}_2 - \dot{y}_1)}
</script>
</div>
<h3 id="4">4. 교점 좌표</h3>
<p>마지막으로, 구한 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 값을 선 방정식 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>에 대입하면 교점의 좌표가 나온다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_{\text{교점}} = (\dot{x}_1 + t(\dot{x}_2 - \dot{x}_1), \dot{y}_1 + t(\dot{y}_2 - \dot{y}_1), \dot{z}_1 + t(\dot{z}_2 - \dot{z}_1))
</div>
<script type="math/tex; mode=display">
\mathbf{p}_{\text{교점}} = (\dot{x}_1 + t(\dot{x}_2 - \dot{x}_1), \dot{y}_1 + t(\dot{y}_2 - \dot{y}_1), \dot{z}_1 + t(\dot{z}_2 - \dot{z}_1))
</script>
</div>
<p>이렇게 해서 두 드론을 연결하는 선과 가상 평면의 교점을 구할 수 있다.</p>
<p>두대의 군집 드론을 동시에 제어하여 비파괴 검사를 하는 연구 논문을 작성 하라. 대한민국의 로봇학계의 논문 형식으로 하라. 두대의 드론은 피사체를 사이에 두고, 조종자의 지시에 따라, 피사체로부터 지정한 거리를 유지하며, 지정한 간격만큼 이동하며 영상을 취득한다. 드론이 상호 상대 드론의 위치를 추정하여, 비파괴 검사 장비를 상호 조준하며, 영상을 획득 한다. 시스템 상태는 군집 상타와 개별 드론 상태로 나뉜다. 드론 자동 제어를 위한 펌웨어는 아두파일럿을 적용하였고, 두대의 드론으로 비파괴 검사를 수행하기 위한 관제 소프트웨어를 개발하였다. 관제 소프트웨어와 드론 FC 간에는 MAVLink로 통신을 한다. 관제를 위한 상태 관리는 개별 드론 관제 상태와 군집 관제 상태로 구분 된다. 조종자는 군집 상태 관리를 전이하여 임무를 수행하고, 군집 상태 관리는 임무 수행을 위해 절차에 따라 개별 드론 관제 상태를 전이 한다. 군집 관제 상태는 피사체 설정을 위해 두개의 드론 사이에 가상의 평면을 생성하고, 조종자의 명령에 따라 군집 관제는 가상 평면 위에서 지정한 거리를 유지하며 지정한 경로로 이동하고 비파괴 검사 장치를 작동 시켜 영상을 획득 한다.</p>
<h2 id="abstract">초록 (Abstract)</h2>
<p>본 연구에서는 두 대의 드론을 이용한 군집 비파괴 검사 시스템을 제안한다. 제안된 시스템은 피사체를 중심으로 드론이 일정한 거리를 유지하며 이동하면서 영상을 취득하는 방식으로, 비파괴 검사 장비를 이용해 피사체의 결함을 탐지한다. 두 드론은 서로의 위치를 실시간으로 추정하며 상호 조준하여 검사 정확도를 높이며, MAVLink 프로토콜을 사용하여 관제 소프트웨어와 통신한다. 시스템 상태는 개별 드론의 상태와 군집 상태로 나뉘며, 각 드론은 독립적으로 동작하는 상태와 군집으로 동작하는 상태에서 임무를 수행한다. 조종자의 명령에 따라 드론은 이륙 후 피사체를 중심으로 지정된 위치에 도달하며, 이후 자동 모드로 전환하여 설정된 경로를 따라 검사 작업을 수행한다. 이 시스템은 비파괴 검사를 위한 고정밀 자동화 기술을 제공하며, 상호 협력하는 드론 간의 효율적인 제어 및 관제를 통해 검사 장비의 효과적인 사용을 가능하게 한다. 향후 연구에서는 검사 장비의 정밀도 향상과 다양한 형태의 피사체에 대한 적용 가능성을 검토할 계획이다.</p>
<h2 id="1-background">1. 서론 (Background)</h2>
<p>비파괴 검사(Non-Destructive Testing, NDT)는 검사 대상 물체의 손상 없이 결함이나 이상을 탐지하는 중요한 기술로, 건설, 항공, 에너지 산업 등에서 폭넓게 활용되고 있다. 특히, 대형 구조물이나 접근이 어려운 장소에서는 작업자가 직접 접근하기 어려운 경우가 많아 비파괴 검사의 필요성이 더욱 커지고 있다. 이러한 요구에 대응하기 위해 최근에는 드론을 활용한 비파괴 검사 기술이 주목받고 있다. 드론을 활용하면 검사자의 물리적 접근이 어려운 고층 구조물이나 복잡한 환경에서도 효율적으로 검사를 수행할 수 있으며, 검사 시간을 단축하고 작업자의 안전을 보장할 수 있다.</p>
<p>하지만 기존의 단일 드론을 이용한 비파괴 검사는 여러 한계가 있다. 단일 드론으로는 넓은 범위를 효과적으로 커버하기 어려우며, 정밀한 위치 제어가 요구되는 비파괴 검사 장비를 운용하는 데에도 한계가 존재한다. 이러한 문제를 해결하기 위해 다수의 드론을 이용한 군집 비파괴 검사 시스템이 등장하였다. 군집 드론은 여러 대의 드론이 협력하여 검사 대상을 다양한 각도에서 동시에 촬영하거나, 서로의 위치를 보정하며 정밀한 검사를 가능하게 하는 장점이 있다.</p>
<p>본 논문에서는 두 대의 드론을 이용하여 군집 비파괴 검사를 수행하는 시스템을 제안한다. 이 시스템은 피사체를 중심으로 드론들이 지정된 거리를 유지하며, 조종자의 지시에 따라 비파괴 검사를 수행한다. 두 드론은 상호 위치를 실시간으로 추정하여 검사 장비를 정확히 조준하며, 지정된 간격으로 이동하면서 영상을 취득한다. 이러한 방식을 통해 검사 영역의 커버리지를 넓히고, 검사 정확도를 높일 수 있다. 또한, 군집 드론이 피사체와의 거리를 유지하면서 자동으로 검사 작업을 수행함으로써 작업자의 개입을 최소화하고, 검사 과정의 효율성을 극대화할 수 있다.</p>
<p>본 연구에서 제안하는 시스템은 아두파일럿(ArduPilot) 펌웨어를 기반으로 하여 비행 및 제어를 수행하며, 관제 소프트웨어는 MAVLink 프로토콜을 통해 드론과의 통신을 관리한다. 또한, 본 시스템에서는 군집 제어와 개별 드론 제어를 구분하여 조종자가 군집 상태를 전이시키면 개별 드론은 그에 맞춰 적절한 행동을 취하게 된다. 이를 통해 검사 작업을 보다 유연하고 효과적으로 수행할 수 있다.</p>
<p>따라서 본 논문에서는 제안된 시스템의 구조, 동작 원리, 관제 소프트웨어 및 군집 제어 알고리즘을 설명하고, 이를 바탕으로 두 대의 드론을 이용한 비파괴 검사 실험 결과를 제시한다. 제안된 시스템이 비파괴 검사 현장에서 어떻게 활용될 수 있는지에 대해 논의하고, 향후 연구 방향을 제시하고자 한다.</p>
<h2 id="2_1">2. 시스템 개요</h2>
<h3 id="21">2.1 드론의 하드웨어 구성</h3>
<p>비파괴 검사 시스템을 구성하는 드론들은 각각 동일한 하드웨어로 구성되어 있으며, 다음과 같은 주요 구성 요소를 포함한다.</p>
<ul>
<li>
<p><strong>비파괴 검사 장비</strong>: 두 대의 드론에는 비파괴 검사를 위한 장비가 탑재되어 있다. 이 장비는 구조물의 결함을 비접촉 방식으로 분석하며, 엑스레이나 초음파 센서, 열화상 카메라 등의 장비가 사용될 수 있다.</p>
</li>
<li>
<p><strong>카메라</strong>: 각 드론은 고해상도 카메라를 통해 피사체의 표면을 촬영한다. 이 카메라는 드론의 이동 경로에 따라 연속적으로 이미지를 획득하여 검사 데이터를 제공한다.</p>
</li>
<li>
<p><strong>GPS 모듈</strong>: 각 드론은 GPS 모듈을 탑재하여 실시간 위치 추적이 가능하며, 드론 간 상대적 위치와 피사체와의 거리를 계산하는 데 사용된다.</p>
</li>
<li>
<p><strong>9축 IMU (Inertial Measurement Unit)</strong>: 9축 IMU는 드론의 가속도와 각속도, 방위각을 측정하여 안정적인 비행과 위치 추정을 지원한다. IMU 데이터는 드론의 자세 제어에 사용되며, 상대 드론의 위치에 대응하여 자세를 결정하는 과정에 중요한 역할을 한다.</p>
</li>
<li>
<p><strong>FC (Flight Controller)</strong>: 드론의 비행을 제어하는 핵심 장치로, 아두파일럿(ArduPilot) 펌웨어가 설치된 비행 컨트롤러(Flight Controller)가 사용된다. 이 FC는 IMU, GPS, 카메라 등의 데이터를 통합하여 비행 경로를 계획하고, 액추에이터를 제어한다 [Ardupilot].</p>
</li>
</ul>
<h3 id="22-mavlink">2.2 MAVLink 통신</h3>
<p>MAVLink는 <strong>Micro Air Vehicle Link</strong>의 약자로, 무인 항공기(UAV) 및 로봇과 관제 소프트웨어 간의 경량 통신 프로토콜을 의미한다. 본 연구에서는 두 대의 드론과 관제 소프트웨어 간의 통신을 원활하게 하기 위해 MAVLink 프로토콜을 채택하였다. MAVLink는 특히 저전력 환경에서 효율적으로 동작하며, 실시간으로 드론의 상태 정보와 명령을 주고받을 수 있는 구조를 제공한다. 이를 통해 본 시스템에서 군집 드론 제어, 상태 전이, 비파괴 검사 데이터를 교환하는 데 중요한 역할을 한다[MAVLink].</p>
<h4 id="221-mavlink-2">2.2.1 MAVLink 2 선택 이유</h4>
<p>본 연구에서는 기존의 MAVLink 1 대신 <strong>MAVLink 2</strong> 프로토콜을 선택하여 드론 간 통신 및 관제 시스템을 구현하였다. MAVLink 2은 MAVLink 1의 단점을 보완하고, 더욱 향상된 기능을 제공하는 최신 버전의 통신 프로토콜로, 다음과 같은 이유로 선택되었다 [MAVLink2].</p>
<p><strong>확장된 메시지 용량</strong>: MAVLink 2은 MAVLink 1에 비해 <strong>확장된 메시지 용량</strong>을 지원한다. MAVLink 1에서는 페이로드 크기가 최대 255바이트로 제한되었지만, MAVLink 2에서는 메시지 크기를 확장하여 더 많은 데이터를 포함할 수 있게 되었다. 이는 비파괴 검사 시스템에서 대용량의 센서 데이터를 주고받는 경우에 특히 유리하다. 검사 장비에서 생성되는 초음파 데이터나 고해상도 카메라 데이터를 실시간으로 전송할 때, MAVLink 2의 확장된 페이로드는 더욱 효율적인 데이터 통신을 가능하게 한다.</p>
<p><strong>신뢰성 향상 및 오류 검출</strong>: MAVLink 2은 기존의 8비트 CRC(Cyclic Redundancy Check) 대신 <strong>64비트 서명(Signature)</strong>을 추가하여 통신 보안을 강화했다. 이는 통신 중 발생할 수 있는 데이터 손상이나 신호 간섭을 보다 효과적으로 검출하고 복구할 수 있게 해준다. 비파괴 검사 중에 드론이 고도로 정밀한 조작을 요구하는 경우가 많기 때문에, 통신 오류를 최소화하고 신뢰성을 확보하는 것이 매우 중요하다. MAVLink 2의 향상된 오류 검출 및 복구 메커니즘 덕분에, 드론 간 명령 전송 및 상태 보고의 신뢰성이 크게 향상되었다.</p>
<p><strong>프로토콜 확장성</strong>: MAVLink 2은 <strong>메시지 확장 필드</strong>를 지원하여, 새로운 메시지나 맞춤형 명령을 쉽게 추가할 수 있는 구조로 설계되었다. 본 시스템에서는 비파괴 검사를 위한 추가적인 데이터를 주고받아야 할 필요가 있었고, MAVLink 2의 확장성을 활용하여 사용자 정의 메시지를 추가로 정의할 수 있었다. 이러한 확장성 덕분에, 검사 장비의 상태 데이터나 비파괴 검사 장비의 고유한 명령을 효율적으로 전송할 수 있었다.</p>
<p><strong>신속한 모드 전환 지원</strong>: MAVLink 2은 <strong>프레임 단축</strong> 기능을 제공하여 메시지를 보다 신속하게 전송할 수 있다. 이는 드론 간 상호 위치를 추정하고, 비파괴 검사 중 피사체를 정확하게 조준하는 데 있어 필수적이다. 드론이 조종자의 명령에 따라 신속하게 모드를 전환해야 하는 경우, MAVLink 2의 향상된 메시지 전송 속도는 실시간 제어 성능을 크게 향상시켰다. 예를 들어, 드론이 <strong>aim</strong> 모드에서 <strong>auto</strong> 모드로 전환할 때, 모드 전환 지연을 최소화하여 검사 작업의 효율성을 높였다.</p>
<p><strong>보안 강화</strong>: MAVLink 2은 <strong>암호화</strong> 기능을 추가하여 통신의 보안을 한층 강화하였다. 드론은 중요한 임무를 수행하는 도중에 외부의 신호 간섭이나 해킹 시도로부터 안전해야 하므로, MAVLink 2의 암호화 기능은 중요한 보안 요소로 작용한다. 특히, 드론 간 통신이 빈번하게 이루어지는 본 연구에서, 상호 위치 정보 및 명령 데이터의 무결성을 보장하는 것은 매우 중요하다. MAVLink 2의 보안 기능을 통해 임무 수행 중 통신의 안전성을 확보할 수 있었다.</p>
<p><strong>상호 호환성</strong>: MAVLink 2은 기존의 MAVLink 1과도 <strong>상호 호환성</strong>을 유지하여, 시스템 구축 시에 유연성을 제공한다. 기존의 MAVLink 1 기반 장비나 소프트웨어를 사용하는 경우에도 MAVLink 2으로 쉽게 전환할 수 있기 때문에, 다양한 하드웨어와 통합하여 사용할 수 있었다. 본 시스템은 MAVLink 2을 기본 프로토콜로 사용하면서, 기존의 MAVLink 1 장비도 손쉽게 통합할 수 있었다.</p>
<h4 id="222-mavlink-2">2.2.2 MAVLink 2 프로토콜의 구조</h4>
<p>MAVLink 2은 기존 MAVLink 1의 확장 버전으로, 더 많은 기능과 향상된 보안을 제공한다. 특히 메시지 필드 확장, 인증을 위한 서명 기능, 더 작은 메시지 크기 등 여러 개선 사항이 포함되어 있다. 본 연구에서는 MAVLink 2 프로토콜을 적용하여 드론과 관제 소프트웨어 간의 통신을 구현하였다. MAVLink 2 메시지는 기존 버전과 비교해 더 많은 기능을 제공하기 위해 메시지 필드가 확장되었으며, 다음과 같은 요소로 구성된다 [MAVLink2]:</p>
<p><strong>STX (Start of Frame)</strong>: MAVLink 2.0 메시지의 시작을 나타내는 1바이트 필드로, 값은 <code>0xFD</code>로 설정된다. 이는 MAVLink 1.0에서 사용되는 <code>0xFE</code>와 구별되는 값이다.</p>
<p><strong>Payload Length (1 Byte)</strong>: 페이로드의 크기를 나타내는 1바이트 필드로, 최대 255바이트까지 확장할 수 있다. MAVLink 1.0에서는 최대 255바이트로 고정되었으나, MAVLink 2.0에서는 사용되지 않는 필드를 동적으로 줄임으로써 더 작은 패킷 크기를 사용할 수 있게 되었다.</p>
<p><strong>Incompatibility Flags (1 Byte)</strong>: MAVLink 2.0에서 추가된 필드로, 메시지를 처리할 수 없는 경우 이를 알리는 비호환성 플래그이다. 드론 또는 관제 소프트웨어가 이 메시지를 처리할 수 없는 경우 적절한 에러 처리를 할 수 있다.</p>
<p><strong>Compatibility Flags (1 Byte)</strong>: 이전 버전과의 호환성을 유지하기 위해 추가된 필드로, 비호환성을 일으키지 않는 메시지의 경우 이 플래그가 설정된다. 이를 통해 MAVLink 2.0은 MAVLink 1.0과의 상호 운용성을 제공한다.</p>
<p><strong>Sequence (1 Byte)</strong>: 송신 측에서 전송되는 메시지의 순서 번호를 나타내는 필드로, 패킷의 순서를 식별할 수 있다. 이를 통해 관제 소프트웨어는 패킷 손실 여부를 확인할 수 있으며, 재전송 메커니즘을 통해 통신의 신뢰성을 보장할 수 있다.</p>
<p><strong>System ID (1 Byte)</strong>: 메시지를 전송하는 시스템의 ID를 나타낸다. 각 드론이나 관제 소프트웨어는 고유한 시스템 ID를 가지며, 이를 통해 서로 다른 시스템 간의 메시지 충돌을 방지한다.</p>
<p><strong>Component ID (1 Byte)</strong>: 시스템 내의 특정 구성 요소를 식별하기 위한 필드로, 예를 들어 FC(Flight Controller)나 카메라 모듈 등 서로 다른 하드웨어 간에 통신을 구분할 수 있다.</p>
<p><strong>Message ID (3 Bytes)</strong>: 메시지의 유형을 나타내는 필드로, 메시지가 어떤 명령이나 상태 정보를 포함하는지를 정의한다. MAVLink 1.0에서는 1바이트였던 것과 달리, MAVLink 2.0에서는 3바이트로 확장되어 총 16,777,216개의 메시지 유형을 정의할 수 있다.</p>
<p><strong>Payload (최대 255 Bytes)</strong>: 실제 데이터를 포함하는 부분으로, 드론의 상태 정보, 명령, 센서 데이터 등을 전송한다. 이 필드는 메시지의 목적에 따라 가변적이며, 최대 255바이트의 데이터를 담을 수 있다.</p>
<p><strong>Checksum (2 Bytes)</strong>: 메시지의 무결성을 확인하기 위한 2바이트 필드로, 메시지 전송 과정에서 발생할 수 있는 오류를 감지하고 검증하는 역할을 한다. MAVLink 2.0에서는 페이로드에 따라 동적으로 생성되는 체크섬 값을 사용하여 데이터 손상을 방지한다.</p>
<p><strong>Signature (0–13 Bytes)</strong> (선택 사항): MAVLink 2.0에서 추가된 보안 기능으로, 메시지의 서명 값을 포함한다. 서명은 메시지의 무결성을 보장하며, 메시지가 외부에서 변조되지 않았음을 확인할 수 있다. 서명 필드는 13바이트까지 확장될 수 있으며, 보안을 강화하고자 할 때 사용된다.</p>
<h4 id="223">2.2.3 드론과 관제 소프트웨어 간 통신 흐름</h4>
<p>MAVLink는 본 시스템에서 드론과 관제 소프트웨어 사이의 실시간 통신을 담당하며, 다음과 같은 통신 흐름을 따른다:</p>
<h5 id="2231-telemetry">2.2.3.1 드론 상태 정보 전송 (Telemetry)</h5>
<p>각 드론은 상태 메시지를 주기적으로 전송하여 현재 상태를 관제 소프트웨어에 알린다. 이 메시지는 드론의 비행 모드, 배터리 상태, 센서 상태 등을 포함한다. 이러한 정보는 조종자가 실시간으로 드론의 상태를 모니터링할 수 있도록 하며, 비행 경로를 동적으로 조정하는 데 필요한 데이터를 제공한다. 주요 상태 정보는 다음과 같다:</p>
<p><strong>위치 정보</strong>: 드론의 실시간 GPS 데이터를 기반으로 드론의 좌표를 제공한다. 관제 소프트웨어는 두 드론 간의 상대 위치를 실시간으로 모니터링하며, 지정된 경로를 따르고 있는지 확인한다. 드론의 위치 정보는 일반적으로 두 가지 방식으로 제공 된다.</p>
<ul>
<li>GPS 좌표 기반 위치 정보:</li>
<li>드론의 절대적인 위치를 위도(latitude), 경도(longitude), 고도(altitude)로 나타낸다. 이는 <strong>지구 좌표계</strong>에서 드론이 어디에 있는지를 나타내는 정보로, GPS 모듈에서 제공된다.</li>
<li>본 시스템에서 GPS 좌표 기반 위치 정보는 드론이 정확한 위치를 파악하고 상대 드론의 위치를 계산하는데 사용 된다.</li>
<li>상대 좌표 기반 위치 정보:</li>
<li>이륙 기준점으로부터의 <strong>상대적인 위치</strong>를 나타낸다. 이는 드론의 센서(예: IMU, 거리 센서)와 상호 통신을 통해 계산된 데이터다.</li>
<li>상대 좌표 정보는 군집 비행 시 다른 드론이나 특정 목표물과의 상대적인 위치를 추적하는 데 유용하다.</li>
</ul>
<p>이 두 가지 정보를 결합하여 드론은 절대 위치와 상대적인 관계를 모두 파악할 수 있어, 특히 군집 비행과 같은 정밀한 작업에서 중요한 역할을 한다.</p>
<p><strong>배터리 상태</strong>: 드론의 배터리 수준이 안전한 비행을 유지할 수 있는지 모니터링하며, 필요 시 자동으로 <strong>RTL(Return to Launch)</strong>  명령을 수행 하도록 설정 할 수 있다.</p>
<p><strong>IMU 데이터</strong>: 본 연구에서는 IMU(Inertial Measurement Unit) 데이터를 실시간으로 활용하여 드론의 자세, 가속도, 각속도, 방위각을 모니터링하며, 이를 통해 드론의 포즈와 비행 안전성을 지속적으로 감시한다. 이러한 IMU 데이터는 비파괴 검사 장비의 활성화 여부를 결정하는 중요한 요소로 작용한다. 드론의 속도나 각속도가 미리 설정된 안전 한계를 초과하는 경우, 비파괴 검사 장비로부터 획득된 데이터는 과도한 측정 노이즈나 블러로 인해 정확한 분석이 불가능할 수 있다. 따라서, IMU 데이터는 드론의 안정성을 판단하고, 비파괴 검사 장비가 정확한 결과를 제공할 수 있는 최적의 조건에서만 작동하도록 제어하는 역할을 수행한다.</p>
<h5 id="2232-command-transmission">2.2.3.2 명령 전송 (Command Transmission)</h5>
<p>관제 소프트웨어는 드론에 대한 명령을 MAVLink 메시지를 통해 전송한다. 이 과정은 조종자의 명령에 따라 자동화되며, 주로 <strong>Command Long</strong> 메시지를 사용하여 다양한 비행 모드를 제어한다. 주요 명령 유형은 다음과 같다:</p>
<p><strong>이륙 및 착륙 명령</strong>: 관제 소프트웨어에서 <strong>Command Long 메시지</strong>를 전송하여 드론에게 <strong>takeoff</strong> 또는 <strong>land</strong> 명령을 내린다. 이 명령은 드론이 자동으로 고도와 위치를 조정하여 안전하게 이륙하거나 착륙할 수 있도록 한다.</p>
<p><strong>비행 경로 설정</strong>: <strong>Position Target 메시지</strong>를 통해 드론의 목표 위치를 지정한다. 이 메시지는 드론의 GPS 좌표와 목표 고도를 포함하며, 드론은 해당 목표에 맞춰 이동한다. 관제 소프트웨어는 이를 통해 두 드론이 피사체 주위를 일정한 거리로 이동하며 비파괴 검사를 수행할 수 있도록 한다.</p>
<p><strong>모드 전환 명령</strong>: 본 연구에서 드론의 비행 상태와 임무 수행을 관리하기 위해 아두파일럿(ArduPilot) 펌웨어를 사용하여 드론의 다양한 비행 모드를 제어한다. 드론의 상태 전환과 제어는 <strong>MAVLink</strong> 프로토콜을 통해 이루어지며, 관제 소프트웨어에서 명령을 전송하여 드론의 비행 모드를 전환한다. 주요 모드 전환 명령은 <strong>ARM</strong>, <strong>DISARM</strong>, <strong>TAKEOFF</strong>, <strong>LAND</strong>, <strong>RTL (Return to Launch)</strong>, <strong>GUIDED</strong>, <strong>BRAKE</strong> 모드를 사용한다. 각 명령의 동작은 아두파일럿의 기본 명령 집합을 따르며, 군집 비행 제어를 위한 중요한 요소로 작용한다.</p>
<h5 id="2233-inter-drone-communication">2.2.3.3. 드론 간 통신 (Inter-Drone Communication)</h5>
<p>본 시스템에서는 드론 간 직접적인 통신을 수행하지 않고, 관제 소프트웨어에서 두 드론의 상대적 위치를 계산한 후, 각 드론에 필요한 정보를 전송하는 방식을 채택하였다. 이는 무선 네트워크의 트래픽을 최소화하고, 통신 효율성을 극대화하기 위한 중요한 전략이다. 드론 간의 통신을 직접 수행하게 되면, 실시간 위치 정보와 명령 전송이 과도하게 발생하여 무선 네트워크의 대역폭이 불필요하게 소모될 수 있다. 이를 방지하기 위해 본 연구에서는 다음과 같은 통신 방식을 설계하였다.</p>
<p><strong>최소화된 메시지 전송</strong>: 관제 소프트웨어는 두 드론의 위치 데이터를 실시간으로 수집하고, 두 드론 간의 상대적 위치와 각도를 계산하여 필요한 정보만을 각각의 드론에 전송한다. 이 방식은 드론 간의 직접적인 데이터 전송을 줄여, 네트워크 트래픽을 최소화하는 효과를 제공한다. 특히, 드론이 비파괴 검사를 수행하는 동안에는 불필요한 통신을 제한하여 통신 지연이나 데이터 손실을 방지한다.</p>
<p><strong>Aim 모드에서의 통신</strong>: 군집 관제 상태에서 <strong>Aim 모드</strong>로 진입했을 때에만, 관제 소프트웨어는 두 드론의 상대 위치를 각 드론에 전송하여, 드론들이 상대편 드론을 조준할 수 있도록 한다. Aim 모드는 두 드론이 피사체에 대해 정밀하게 검사 장비를 조준하는 중요한 모드로, 이때만 드론 간 상호 위치 정보가 필요하다. 따라서 다른 비행 모드에서는 불필요한 위치 데이터 전송을 제한하고, Aim 모드에서만 최소한의 데이터가 전송되도록 설계하였다. 이로 인해 시스템은 무선 네트워크의 부담을 줄이면서, 필요한 시점에 정확한 데이터를 전송할 수 있게 된다.</p>
<h3 id="22">2.2 소프트웨어 구성</h3>
<p>비파괴 검사를 위한 두 대의 드론 제어 시스템에서 소프트웨어는 드론 제어, 상호 통신 등 다양한 기능을 담당한다. 이 소프트웨어 구성은 <strong>드론 펌웨어</strong>, <strong>군집 관제 소프트웨어</strong>로 나뉘며, 각각의 역할과 구성 요소는 다음과 같다.</p>
<h4 id="221">2.2.1 드론 펌웨어</h4>
<p><strong>아두파일럿(ArduPilot)</strong>은 오픈 소스 기반의 자율 비행 소프트웨어로, 다양한 드론, 비행기, 로봇 등의 제어를 지원하는 플랫폼이다. 아두파일럿은 다양한 하드웨어 플랫폼에서 실행 가능하며, 본 연구에서는 드론의 자동 비행과 상태 관리를 위해 아두파일럿을 사용한다. 이 시스템에서 아두파일럿이 담당하는 역할은 다음과 같다.</p>
<p><strong>비행 제어</strong>: 아두파일럿은 드론의 비행을 관리하는 주요 소프트웨어로, GPS 및 IMU(관성 측정 장치) 데이터를 활용하여 드론의 위치와 자세를 실시간으로 제어한다. 이를 통해 드론은 조종자의 개입 없이도 설정한 경로를 따라 정확히 이동할 수 있다. 경로는 관제 소프트웨어에서 설정되며, 아두파일럿은 이 경로를 따라 비행하도록 명령을 처리한다.</p>
<p><strong>비행 모드 관리</strong>: 아두파일럿은 다양한 비행 모드를 제공하여 드론이 상황에 맞게 동작할 수 있도록 한다. 본 연구에서 사용하는 비행 모드는 두 가지로 구분된다.</p>
<ol>
<li><strong>군집 관제 소프트웨어가 제어하는 경우</strong>:</li>
<li><strong>Guided 모드</strong>: 드론이 군집 관제 소프트웨어에서 지정한 경로에 따라 자동으로 비행하며, 실시간 명령에 따라 위치를 조정할 수 있다.</li>
<li><strong>Takeoff 모드</strong>: 드론이 군집 관제 소프트웨어 명령에 따라 자동으로 이륙하여 설정된 고도에 도달한다.</li>
<li><strong>Land 모드</strong>: 드론이 자동으로 착륙하여 안전하게 지면에 닿을 수 있도록 한다.</li>
<li><strong>RTL (Return to Launch) 모드</strong>: 드론이 자동으로 출발 지점으로 복귀하여 착륙하는 모드이다. 배터리 부족이나 긴급 상황 시 사용된다.</li>
<li>
<p><strong>Brake 모드</strong>: 드론을 즉시 정지시키는 모드로, 긴급 상황에서 사용된다.</p>
</li>
<li>
<p><strong>긴급 상황에서 인간 조종자가 제어하는 경우</strong>:</p>
</li>
<li><strong>Loiter 모드</strong>: 긴급 상황에서 조종자가 드론을 수동으로 제어해야 할 때 사용된다. 이 모드에서는 드론이 GPS 기반 위치를 유지하며, 조종자는 드론을 필요한 대로 이동시킬 수 있다. 그러나 이 모드는 긴급 상황에서만 사용되며, 대부분의 비행은 관제 소프트웨어에 의해 자동으로 제어된다.</li>
</ol>
<p><strong>센서 데이터 처리</strong>: 아두파일럿은 드론에 장착된 센서(GPS, IMU, 카메라 등)로부터 수집한 데이터를 실시간으로 처리한다. 이러한 데이터는 드론의 비행 경로와 자세를 제어하는 데 사용되며, 비행 중 드론의 안정성을 유지하고, 피사체를 정확히 조준하는 데 기여한다.</p>
<p><strong>MAVLink 프로토콜 통신</strong>: 아두파일럿은 MAVLink 프로토콜을 통해 관제 소프트웨어와 통신한다. MAVLink는 경량의 메시지 전송 프로토콜로, 드론의 상태 정보를 관제 시스템에 실시간으로 전송하고, 관제 소프트웨어로부터 명령을 수신하여 드론의 비행 경로, 자세, 모드 전환 등을 수행한다. 예를 들어, 관제 소프트웨어에서 특정 명령(예: <strong>takeoff</strong>)을 전달하면, 아두파일럿은 해당 명령을 받아 드론을 이륙시키고, 지정된 고도에 도달하도록 한다.</p>
<p><strong>안전 관리</strong>: 아두파일럿은 비행 중 드론의 안정성과 안전을 확보하기 위한 다양한 기능을 제공한다. 예를 들어, 배터리 부족 시 <strong>rtl</strong> 모드를 자동으로 활성화하여 드론이 안전하게 출발 지점으로 복귀하도록 한다. 또한, 실시간 비행 상태 모니터링을 통해 이상 상태 발생 시 자동으로 대처할 수 있다.</p>
<p>이와 같이, 아두파일럿은 본 연구에서 두 대의 드론이 자율적으로 비파괴 검사를 수행할 수 있도록 하는 핵심적인 소프트웨어 역할을 하며, 드론의 비행 경로 제어, 센서 데이터 처리, 실시간 통신 및 안전 관리 등을 통합적으로 수행한다.</p>
<h4 id="222">2.2.2 군집 관제 소프트웨어</h4>
<p>군집 관제 소프트웨어는 지상에서 두 대의 드론을 동시에 제어하고, 드론 간 상호 통신을 지원하며, 비파괴 검사를 수행하는 임무를 조율하는 핵심 요소이다. 이 소프트웨어는 <strong>MAVLink 프로토콜</strong>을 사용하여 드론과 실시간으로 데이터를 주고받으며, 드론의 상태를 모니터링하고 조종자의 명령을 드론에 전달하는 역할을 한다. 군집 관제 소프트웨어는 두 가지 주요 제어 체계를 가지고 있다: <strong>개별 드론 제어</strong>와 <strong>군집 드론 제어</strong>.</p>
<h4 id="223_1">2.2.3 군집 상태 관리</h4>
<p>군집 상태 관리는 상태 전이 다이어그램을 기반으로 설계되었다. 이 다이어그램은 군집의 상태를 정의한다. 군집 상태는 다음과 같은 상태로 정의된다:</p>
<ul>
<li><strong>Idle 상태</strong>: 군집이 대기 중이거나, 인간 조종자가 수동 관제하는 상태.</li>
<li><strong>Flightcheck</strong>: 개별 드론의 기능을 점검하는 상태.</li>
<li><strong>Takeoff 상태</strong>: 군집이 동시에 이륙하여 설정된 고도까지 상승하는 상태.</li>
<li><strong>Freeze 상태</strong>: 비행 중 비상 정지 명령이 내려졌을 때 군집의 비행이 멈추는 상태.</li>
<li><strong>Land 상태</strong>: 임무 완료 또는 조종자의 명령에 의해 군집이 착륙하는 상태.</li>
<li><strong>RTL (Return to Launch) 상태</strong>: 임무가 중단되거나 종료될 때, 군집이 시작 지점으로 복귀하는 상태.</li>
<li><strong>AutoAim</strong>: 피사체에 대해 군집이 위치를 조정하며 비파괴 검사 장비를 피사체에 정확하게 조준하는 상태.</li>
<li><strong>Auto</strong>: 드론들이 자동으로 시동하고 이륙하여 비파괴 검사 임무를 수행하는 상태.</li>
</ul>
<p>군집 상태는 조종자의 명령에 따라 절차적으로 전이되며, 한 드론의 상태 변화에 따라 다른 드론도 적절히 반응하여 동기화된다. 예를 들어, 군집이 <strong>Aim</strong> 상태에 진입하면 두 드론은 상호 위치를 파악하고 피사체에 대해 정확한 조준을 유지한다.</p>
<p>군집 상태 <span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span> 전이 조건은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S(t) = \left\{
\begin{array}{ll}
S_{\text{idle}} &amp; \text{if} \ t = 0 \\
S_{\text{flightcheck}} &amp; \text{if} \ C_{\text{flightcheck}}(t) \\
S_{\text{takeoff}} &amp; \text{if} \ C_{\text{takeoff}}(t) \\
S_{\text{freeze}} &amp; \text{if} \ C_{\text{freeze}}(t) \\
S_{\text{land}} &amp; \text{if} \ C_{\text{land}}(t) \\
S_{\text{rtl}} &amp; \text{if} \ C_{\text{rtl}}(t) \\
S_{\text{autoaim}} &amp; \text{if} \ C_{\text{autoaim}}(t) \\
S_{\text{auto}} &amp; \text{if} \ C_{\text{auto}}(t) \\
\end{array}
\right.
</div>
<script type="math/tex; mode=display">
S(t) = \left\{
\begin{array}{ll}
S_{\text{idle}} & \text{if} \ t = 0 \\
S_{\text{flightcheck}} & \text{if} \ C_{\text{flightcheck}}(t) \\
S_{\text{takeoff}} & \text{if} \ C_{\text{takeoff}}(t) \\
S_{\text{freeze}} & \text{if} \ C_{\text{freeze}}(t) \\
S_{\text{land}} & \text{if} \ C_{\text{land}}(t) \\
S_{\text{rtl}} & \text{if} \ C_{\text{rtl}}(t) \\
S_{\text{autoaim}} & \text{if} \ C_{\text{autoaim}}(t) \\
S_{\text{auto}} & \text{if} \ C_{\text{auto}}(t) \\
\end{array}
\right.
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">S(t)</span><script type="math/tex">S(t)</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서의 군집 상태이며, 각 상태 전이 조건은 <span class="arithmatex"><span class="MathJax_Preview">C_x(t)</span><script type="math/tex">C_x(t)</script></span>로 정의된다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">C_{\text{takeoff}}(t)</span><script type="math/tex">C_{\text{takeoff}}(t)</script></span>는 조종자가 <strong>takeoff</strong> 명령을 내렸을 때 성립하는 조건을 의미하며, 이 조건이 만족되면 군집 상태는 <strong>takeoff</strong>로 전이된다.</p>
<p>군집 상태 관리는 조종자의 명령에 따라 군집 상태를 전이하고, 각 드론의 상태를 실시간으로 조정하는 역할을 한다. 군집 상태 관리는 다음과 같은 절차로 구성된다:</p>
<ol>
<li>
<p><strong>조종자 명령 수신</strong>: 조종자는 관제 소프트웨어를 통해 군집 상태 전이 명령을 내린다. 예를 들어, <strong>takeoff</strong> 명령이 내려지면 군집 상태가 <strong>takeoff</strong>로 전이된다.</p>
</li>
<li>
<p><strong>상태 전이 조건 확인</strong>: 각 군집 상태의 전이 조건을 확인하여 해당 조건이 충족되면 군집 상태를 전이한다. 상태 전이 조건은 조종자 명령 또는 드론의 센서 데이터에 기반하여 결정된다. 예를 들여, <strong>takeoff</strong> 상태가 완료되면 <strong>idle</strong>상태로 전이 된다.</p>
</li>
<li>
<p><strong>상대 위치 조정</strong>: 군집 상태가 전이된 후, 두 드론 간의 상대적 위치를 계산하고 가상 평면을 중심으로 지정된 거리를 유지하도록 제어한다. 이때, GPS 및 IMU 데이터를 이용하여 두 드론의 상대 위치를 실시간으로 추정하고 보정한다.</p>
</li>
<li>
<p><strong>임무 수행</strong>: 군집 상태가 <strong>aim</strong> 또는 <strong>auto</strong>로 전이되면, 드론은 가상 평면을 기준으로 비행하며 비파괴 검사를 수행한다. 이때, 관제 소프트웨어는 실시간으로 드론의 상태를 모니터링하고, 필요한 경우 군집 상태를 다시 전이한다.</p>
</li>
<li>
<p><strong>임무 완료 및 착륙</strong>: 임무가 완료되거나, 조종자의 명령에 의해 군집 상태가 <strong>land</strong> 또는 <strong>RTL</strong> 전이되고 두 드론은 착륙한다.</p>
</li>
</ol>
<p>군집 상태 관리를 통해, 군집 드론이 피사체의 가상 평면을 정확하게 비행하며 비파괴 검사를 수행하는 과정을 명확히 관제 할 수 있다. 이러한 군집 제어 방식은 두 드론 간의 상호 의존성을 기반으로 하며, 실시간 데이터 교환과 상태 전이를 통해 안정적인 비파괴 검사를 가능하게 한다.</p>
<h4 id="224">2.2.4 개별 드론 상태</h4>
<p>관제 소프트웨어는 군집 상태뿐만 아니라 각 드론의 개별 상태도 관리한다. 개별 드론은 독립적으로 조종될 수 있으며, 특정 상황에서는 한 대의 드론만 상태를 전환하거나 동작을 수행할 수 있다. 주요 개별 드론 상태는 다음과 같다:</p>
<ul>
<li><strong>Idle</strong>: 개별 드론이 대기 중인 상태.</li>
<li><strong>Flightcheck</strong>: 개별 드론의 기능을 점검하는 상태.</li>
<li><strong>Arm</strong>: 드론이 이륙 준비가 완료된 상태.</li>
<li><strong>Takeoff</strong>: 드론이 이륙하여 설정된 고도까지 상승하는 상태.</li>
<li><strong>Brake</strong>: 비행 중인 드론이 정지하여 움직임을 멈춘 상태.</li>
<li><strong>Land</strong>: 드론이 착륙하는 상태.</li>
<li><strong>RTL (Return to Launch)</strong>: 드론이 출발 위치로 복귀하는 상태.</li>
<li><strong>Aim</strong>: 개별 드론이 피사체에 대해 조준을 맞추는 상태.</li>
</ul>
<p>이러한 개별 상태 전이는 군집 상태 관리 모듈이 조종자의 명령이나 드론의 비행 상태를 실시간으로 모니터링하고, 필요에 따라 명령을 전달함으로써 이루어진다.</p>
<p>개별 드론 <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>의 상태 <span class="arithmatex"><span class="MathJax_Preview">S_d</span><script type="math/tex">S_d</script></span> 전이 조건 <span class="arithmatex"><span class="MathJax_Preview">C_d</span><script type="math/tex">C_d</script></span>는 다음과 같다:
$$
S_n(t) = \left{
\begin{array}{ll}
S_{d,\text{idle}} &amp; \text{if} \ t = 0 \
S_{d,\text{flightcheck}} &amp; \text{if} \ C_{d,\text{flightcheck}}(t) \
S_{d,\text{arm}} &amp; \text{if} \ C_{d,\text{arm}}(t) \
S_{d,\text{takeoff}} &amp; \text{if} \ C_{d,\text{takeoff}}(t) \
S_{d,\text{brake}} &amp; \text{if} \ C_{d,\text{brake}}(t) \
S_{d,\text{land}} &amp; \text{if} \ C_{d,\text{land}}(t) \
S_{d,\text{rtl}} &amp; \text{if} \ C_{d,\text{rtl}}(t) \
S_{d,\text{aim}} &amp; \text{if} \ C_{d,\text{aim}}(t) \
\end{array}
\right.
$$</p>
<h4 id="225">2.2.5 군집과 개별 드론 상태</h4>
<p>조종자의 명령과 </p>
<div class="mermaid">stateDiagram-v2
    direction LR    
    classDef badBadEvent font-weight:bold,stroke-width:2px

    state "S_idle" as idle
    state "S_flightcheck" as flightcheck
    state "S_land" as land
    state "S_rtl" as rtl
    state "S_takeoff" as takeoff
    state "S_autoaim" as autoaim
    state "S_auto" as auto
    state "S_freeze" as freeze   

    [*] --&gt; idle

    idle --&gt; flightcheck: if user commands flightcheck
    flightcheck --&gt; idle: if completed
    flightcheck --&gt; freeze: if fail
    state flightcheck {
        direction LR
        state "S_d,flightcheck" as d_flightcheck*
        [*] --&gt; d_flightcheck*
        d_flightcheck* --&gt; [*]: if completed
    }

    idle --&gt; takeoff: if user commands takeoff
    takeoff --&gt; idle: if completed
    takeoff --&gt; freeze: if fail
    state takeoff {
        direction LR
        state "S_d,flightcheck" as d_flightcheck**
        state "S_d,arm" as d_arm**
        state "S_d,takeoff" as d_takeoff**
        [*] --&gt; d_flightcheck**
        d_flightcheck** --&gt; d_arm**: if completed
        d_arm** --&gt; d_arm**: trials
        d_arm** --&gt; d_takeoff**: if completed
        d_takeoff** --&gt; d_takeoff**: trials
        d_takeoff** --&gt; [*]: if completed
    }

    idle --&gt; land: if user commands land
    land --&gt; idle: if completed
    land --&gt; freeze: if fail
    state land {
        direction LR
        state "S_d_land" as d_land***
        [*] --&gt; d_land***
        d_land*** --&gt; d_land***: repeatly
        d_land*** --&gt; [*]: if completed
    }

    idle --&gt; rtl: if user commands RTL
    rtl --&gt; idle: completed
    rtl --&gt; freeze: if fail
    state rtl {
        direction LR
        state "S_d,rtl" as d_rtl****
        [*] --&gt; d_rtl****
        d_rtl**** --&gt; d_rtl****: repeatly
        d_rtl**** --&gt; [*]: if completed
    }

    idle --&gt; autoaim: User can command when in air
    autoaim --&gt; freeze: if fail
    autoaim --&gt; idle: if stop
    state autoaim {
        direction LR
        state "S_d,aim" as d_aim*****
        [*] --&gt; d_aim*****
        d_aim***** --&gt; d_aim*****: repeatly     
        d_aim***** --&gt; [*]: if stop
    }    

    idle --&gt; auto: if user commands automatic mission execution
    auto --&gt; freeze:::badBadEvent: if fail
    auto --&gt; idle: if stop
    state auto {
        direction LR
        state "S_d,flightcheck" as d_flightcheck!
        state "S_d,arm" as d_arm!
        state "S_d,takeoff" as d_takeoff!
        state "S_d,aim" as d_aim!

        [*] --&gt; d_flightcheck!
        d_flightcheck! --&gt; d_arm!: if completed
        d_arm! --&gt; d_arm!: trials
        d_arm! --&gt; d_takeoff!: if completed
        d_takeoff! --&gt; d_takeoff!: trials
        d_takeoff! --&gt; d_aim!: if completed
        d_aim! --&gt; d_aim!: repeatly
        d_aim! --&gt; [*]: if stop
    }   

    freeze --&gt; idle: if user commands to transit to idle
    state freeze {
        [*] --&gt; brake
        brake --&gt; brake: repeatly
    }
</div>
<h4 id="226">2.2.6 탐색 절차</h4>
<ul>
<li>피사체에 대한 가상 평면 생성 </li>
<li>가상 평면을 원점으로 드론의 국소 좌표 계산</li>
<li>드론의 위치를 가상 평면상으로 투영하고 가상 평면상에서 드론 이동, 주어진 거리만큼 간격 유지</li>
<li>계산된 위치로 드론 이동</li>
</ul>
<h4 id="227">2.2.7 피사체 가상 평면 생성</h4>
<p>본 연구에서 두 대의 드론은 피사체를 사이에 두고 비파괴 검사를 수행하기 위해, 피사체와 드론 간의 상대적 거리를 유지하면서 정확한 검사를 수행해야 한다. 이를 위해 드론 사이에  <strong>가상 평면</strong>이 생성한다. 이 평면은 드론의 GPS 위치로부터 중간 지점을 기준으로 하여 위치, 방위각을 계산하여 설정된다.</p>
<p>두 대의 드론은 각각 실시간으로 GPS 좌표를 측정한다. 각 드론 <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{g}_d</span><script type="math/tex">\mathbf{g}_d</script></span>는
$$
\mathbf{g}_d = (\phi_d, \lambda_d, h)
$$
로 정의되며, 여기서, <span class="arithmatex"><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>는 위도, <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>는 경도, <span class="arithmatex"><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span>는 상대 고도이다.</p>
<p><strong>군집 중심 위치 계산</strong>: 두 드론의 GPS좌표는 라디안 단위 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{g}_1=(\dot{\phi}_1, \dot{\lambda}_1, h_1)</span><script type="math/tex">\mathbf{g}_1=(\dot{\phi}_1, \dot{\lambda}_1, h_1)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{g}_2=(\dot{\phi}_2, \dot{\lambda}_2, h_2)</span><script type="math/tex">\mathbf{g}_2=(\dot{\phi}_2, \dot{\lambda}_2, h_2)</script></span>로 두 점 사이의 대원(지구 표면을 따라 그린 가장 짧은 경로)을 따라 중간 위치를 가상 평면의 원점으로 계산한다. 중간 위치의 위도와 경도 <span class="arithmatex"><span class="MathJax_Preview">(\dot{\phi}_o, \dot{\lambda}_o, h_o)</span><script type="math/tex">(\dot{\phi}_o, \dot{\lambda}_o, h_o)</script></span>는 다음과 같이 계산할 수 있다:
$$
\begin{align<em>}
\dot{x}_c &amp;= \cos(\dot{\phi}_2) \cdot \cos(\dot{\lambda}_2 - \dot{\lambda}_1)
\
\dot{y}_c &amp;= \cos(\dot{\phi}_2) \cdot \sin(\dot{\lambda}_2 - \dot{\lambda}_1)
\
\dot{\phi}_o &amp;= \tan^{-1}\left(\frac{\sin(\dot{\phi}_1) + \sin(\dot{\phi}_2)}{\sqrt{(\cos(\dot{\phi}_1) + {\dot{x}}_c)^2 + \dot{y}_c^2}}\right)
\
\dot{\lambda}_o &amp;= \dot{\lambda}_1 + \tan^{-1}\left(\frac{\dot{y}_c}{\cos(\dot{\phi}_1) + \dot{x}_c}\right)
\
h_o &amp;= \frac{h_2-h_1}{2}
\end{align</em>}
$$</p>
<p><strong>군집 방위각 계산</strong>:</p>
<p>지구 표면에서 특정 위치에서 지구의 타원체와 중력 방향으로 수직인 평면을 수평면이라고 한다. 수평면에 두대의 드론이 위치할때 두 드론의 중간 위치의 수평면 위에서 직교 벡터의 방향을 군집 드론의 방위각으로 정하였다. 군집 방위각은 가상 평면의 방위각에 해당 한다.</p>
<p>군집 방위각(azimuth) <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>를 계산한다:
$$
\begin{align<em>}
\Delta\dot{\lambda} &amp;= \dot{\lambda}_2 - \dot{\lambda}_1
\
\dot{\alpha} &amp;= \tan^{-1} \left( \frac{\sin(\Delta\dot{\lambda}) \cdot \cos(\dot{\phi}_2)}{\cos(\dot{\phi}_1) \cdot \sin(\dot{\phi}_2) - \sin(\dot{\phi}_1) \cdot \cos(\dot{\phi}_2) \cdot \cos(Δ\dot{\lambda})} \right)
\
\alpha &amp;= (\dot{\alpha} \cdot \frac{180}{\pi} + 360) \mod \, 360
\
\end{align</em>}
$$</p>
<h4 id="227_1">2.2.7 가상 평면을 중심으로 드론 관제</h4>
<p>반경 수백미터 이내의 제한된 영역에서 피사체를 기준으로 비행 경로를 다루기 위해서는 피사체를 원점으로 하는 데카르트 좌표계로 변환하여 국소 좌표계로 계산하면 간결해진다.</p>
<p>먼저, GPS 좌표계의 위치 라디안 단위 <span class="arithmatex"><span class="MathJax_Preview">\dot{\mathbf{g}} = (\dot{\phi}: \text{위도}, \dot{\lambda}: \text{경도}, \dot{h}: \text{고도})</span><script type="math/tex">\dot{\mathbf{g}} = (\dot{\phi}: \text{위도}, \dot{\lambda}: \text{경도}, \dot{h}: \text{고도})</script></span>를 ECEF 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p} = (x,y,z)</span><script type="math/tex">\mathbf{p} = (x,y,z)</script></span>로 변환하는 방법은 다음과 같다:
$$
\begin{align<em>}
n &amp;= \dfrac{a}{\sqrt{1 - e^2 \sin^2 \phi}} \
x &amp;= (n + h) \cos \dot{\phi} \cos \dot{\lambda} \
y &amp;= (n + h) \cos \dot{\phi} \sin \dot{\lambda} \
z &amp;= \left( n (1 - e^2) + h \right) \sin \dot{\phi}
\end{align</em>}
\tag{1}
$$
여기서 <span class="arithmatex"><span class="MathJax_Preview">e^2</span><script type="math/tex">e^2</script></span>는 제1편평도로 <span class="arithmatex"><span class="MathJax_Preview">1 - \left( \dfrac{b}{a} \right)^2</span><script type="math/tex">1 - \left( \dfrac{b}{a} \right)^2</script></span> 이며, <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>는 지구의 장축 반경으로 약 <span class="arithmatex"><span class="MathJax_Preview">6,378,137 \space m</span><script type="math/tex">6,378,137 \space m</script></span> 이고, <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>는 단축 반경으로 <span class="arithmatex"><span class="MathJax_Preview">a(1 - 1/298.257223563)</span><script type="math/tex">a(1 - 1/298.257223563)</script></span>이다.</p>
<p>식 <span class="arithmatex"><span class="MathJax_Preview">(1)</span><script type="math/tex">(1)</script></span>으로 가상 평면 원점의 GPS 좌표로부터 가상 평면의 원점 ECEF 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_o = (x_o, y_o, z_o)</span><script type="math/tex">\mathbf{p}_o = (x_o, y_o, z_o)</script></span>와 드론의 ECEF 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_d = (x_d, y_d, z_d)</span><script type="math/tex">\mathbf{p}_d = (x_d, y_d, z_d)</script></span>를 구하며, 가상평면 원점과 드론의 위치로부터 가상 평면을 원점으로 하는 드론의 위치 <span class="arithmatex"><span class="MathJax_Preview">\dot{\mathbf{p}}_d = (\dot{x}_d, \dot{y}_d, \dot{z}_d)</span><script type="math/tex">\dot{\mathbf{p}}_d = (\dot{x}_d, \dot{y}_d, \dot{z}_d)</script></span>를 계산 한다.
$$
\dot{x}_d = x_d - x_o \
\dot{y}_d = y_d - y_o \
\dot{z}_d = z_d - z_o \
$$
다음은 가상 평면 원점으로부터 드론의 위치 ECEF 좌표를 ENU 좌표로 변환 한다. 
$$
\begin{align<em>}
e_d &amp;= -\sin \dot{\lambda}_o \cdot \dot{x}_d + \cos \dot{\lambda}_o \cdot \dot{y}_d \
n_d &amp;= -\sin \dot{\phi}_o \cos \dot{\lambda}_o \cdot \dot{x}_d - \sin \dot{\phi}_o \sin \dot{\lambda}_o \dot{y} + \cos \dot{\phi}_o \cdot \dot{z}_d \
u_d &amp;= \cos \dot{\phi}_o \cos \dot{\lambda}_o \cdot \dot{x}_d + \cos \dot{\phi}_o \sin \dot{\lambda}_o \cdot \dot{y}_d + \sin \dot{\phi}_o \cdot \dot{z}_d
\end{align</em>}
$$
가상 평면을 기준으로 회전 변환한 드론의 국소 좌표 <span class="arithmatex"><span class="MathJax_Preview">(\hat{x}_d, \hat{y}_d, \hat{z}_d)</span><script type="math/tex">(\hat{x}_d, \hat{y}_d, \hat{z}_d)</script></span> 는 다음과 같다:
$$
\begin{align<em>}
\hat{x}_d &amp;= e_d \sin \dot{\alpha} + n_d \cos \dot{\alpha} \
\hat{y}_d &amp;= -e_d \cos \dot{\alpha} + n_d \sin \dot{\alpha} \
\hat{z}_d &amp;= u_d
\end{align</em>}
$$</p>
<h4 id="228">2.2.8 가상 평면상에서 드론의 위치와 이동</h4>
<p>두 드론의 국소 좌표인 <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{p}}_1 = (\hat{x}_1, \hat{y}_1, \hat{z}_1)</span><script type="math/tex">\hat{\mathbf{p}}_1 = (\hat{x}_1, \hat{y}_1, \hat{z}_1)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{p}}_2 = (\hat{x}_2, \hat{y}_2, \hat{z}_2)</span><script type="math/tex">\hat{\mathbf{p}}_2 = (\hat{x}_2, \hat{y}_2, \hat{z}_2)</script></span>, 그리고 평면의 위치인 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_o = (x_o, y_o, z_o)</span><script type="math/tex">\mathbf{p}_o = (x_o, y_o, z_o)</script></span>를 기반으로 평면과 두 드론을 이은 선의 교점을 구하기 위해서는, 먼저 평면 방정식과 선 방정식을 세우는 것이 필요하다.</p>
<p><strong>평면 방정식</strong>: 가상 평면의 방위각이 <span class="arithmatex"><span class="MathJax_Preview">\dot{\alpha}</span><script type="math/tex">\dot{\alpha}</script></span>로 주어졌다면, 방위각을 사용해 평면의 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>을 구할 수 있다. 방위각 <span class="arithmatex"><span class="MathJax_Preview">\dot{\alpha}</span><script type="math/tex">\dot{\alpha}</script></span>가 주어졌다면, 법선 벡터는 다음과 같이 정의된다:
$$
\mathbf{n} = (\cos(\dot{\alpha}), \sin(\dot{\alpha}), 0)
$$</p>
<p>이 법선 벡터를 이용해, 평면의 방정식은 다음과 같이 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{n} \cdot (\hat{\mathbf{p}}_d - \dot{\mathbf{p}}_o) = 0
</div>
<script type="math/tex; mode=display">
\mathbf{n} \cdot (\hat{\mathbf{p}}_d - \dot{\mathbf{p}}_o) = 0
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\cos(\dot{\alpha})(x - x_o) + \sin(\dot{\alpha})(y - y_o) = 0
</div>
<script type="math/tex; mode=display">
\cos(\dot{\alpha})(x - x_o) + \sin(\dot{\alpha})(y - y_o) = 0
</script>
</div>
<p>이를 확장하면 평면 방정식은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\cos(\dot{\alpha}) x + \sin(\dot{\alpha}) y = \cos(\dot{\alpha}) x_o + \sin(\dot{\alpha}) y_o
</div>
<script type="math/tex; mode=display">
\cos(\dot{\alpha}) x + \sin(\dot{\alpha}) y = \cos(\dot{\alpha}) x_o + \sin(\dot{\alpha}) y_o
</script>
</div>
<p><strong>선 방정식</strong>: 두 드론을 이은 선의 방정식을 구하려면, 매개변수 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에 따라 두 점을 연결하는 선을 정의할 수 있다. 선의 방정식은 다음과 같다:
$$
\mathbf{p}(t) = \dot{\mathbf{p}}_1 + t(\dot{\mathbf{p}}_2 - \dot{\mathbf{p}}_1)
$$</p>
<p>이것을 좌표 형태로 나타내면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}(t) = (\dot{x}_1 + t(\dot{x}_2 - \dot{x}_1), \dot{y}_1 + t(\dot{y}_2 - \dot{y}_1), \dot{z}_1 + t(\dot{z}_2 - \dot{z}_1))
</div>
<script type="math/tex; mode=display">
\mathbf{p}(t) = (\dot{x}_1 + t(\dot{x}_2 - \dot{x}_1), \dot{y}_1 + t(\dot{y}_2 - \dot{y}_1), \dot{z}_1 + t(\dot{z}_2 - \dot{z}_1))
</script>
</div>
<p><strong>교점 구하기</strong>: 이제 평면 방정식과 선 방정식을 결합하여 교점을 구할 수 있다. 선 방정식에서 <span class="arithmatex"><span class="MathJax_Preview">x(t)</span><script type="math/tex">x(t)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">y(t)</span><script type="math/tex">y(t)</script></span>를 평면 방정식에 대입하면:
$$
\cos(\dot{\alpha})(\dot{x}_1 + t(\dot{x}_2 - \dot{x}_1)) + \sin(\dot{\alpha})(\dot{y}_1 + t(\dot{y}_2 - \dot{y}_1)) = \cos(\dot{\alpha}) x_o + \sin(\dot{\alpha}) y_o
$$</p>
<p>위 식에서 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>를 풀면, 교점에서의 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 값을 구할 수 있다.</p>
<p><span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 값 구하기:
$$
t = \frac{\cos(\dot{\alpha})(x_o - \dot{x}_1) + \sin(\dot{\alpha})(y_o - \dot{y}_1)}{\cos(\dot{\alpha})(\dot{x}_2 - \dot{x}_1) + \sin(\dot{\alpha})(\dot{y}_2 - \dot{y}_1)}
$$</p>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">\cos(\dot{\alpha})(\dot{x}_2 - \dot{x}_1) + \sin(\dot{\alpha})(\dot{y}_2 - \dot{y}_1) \ne 0</span><script type="math/tex">\cos(\dot{\alpha})(\dot{x}_2 - \dot{x}_1) + \sin(\dot{\alpha})(\dot{y}_2 - \dot{y}_1) \ne 0</script></span>이다.</p>
<p>구한 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 값을 선 방정식 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>에 대입하면 교점의 좌표가 나온다:
$$
\mathbf{p}_\text{intersection} = (\dot{x}_1 + t(\dot{x}_2 - \dot{x}_1), \dot{y}_1 + t(\dot{y}_2 - \dot{y}_1), \dot{z}_1 + t(\dot{z}_2 - \dot{z}_1))
$$</p>
<p>이렇게 해서 두 드론을 연결하는 선과 가상 평면의 교점을 구할 수 있다.</p>
<p>3차원 공간에서 위치 <span class="arithmatex"><span class="MathJax_Preview">p_0</span><script type="math/tex">p_0</script></span>에 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>을 가진 평면과, 두 점 <span class="arithmatex"><span class="MathJax_Preview">p_1</span><script type="math/tex">p_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">p_2</span><script type="math/tex">p_2</script></span>를 연결하는 선분이 평면과 교차하는 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>를 구하는 방법은 다음과 같다.</p>
<h3 id="_13">평면 방정식:</h3>
<p>평면은 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>과 평면 위의 한 점 <span class="arithmatex"><span class="MathJax_Preview">p_0</span><script type="math/tex">p_0</script></span>으로 정의된다. 이 평면의 방정식은 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
(\mathbf{p} - \mathbf{p_0}) \cdot \mathbf{n} = 0
</div>
<script type="math/tex; mode=display">
(\mathbf{p} - \mathbf{p_0}) \cdot \mathbf{n} = 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 평면 위의 임의의 점을 의미한다. <span class="arithmatex"><span class="MathJax_Preview">\cdot</span><script type="math/tex">\cdot</script></span>는 벡터 내적이다.</p>
<h3 id="_14">선분 방정식:</h3>
<p>점 <span class="arithmatex"><span class="MathJax_Preview">p_1</span><script type="math/tex">p_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">p_2</span><script type="math/tex">p_2</script></span>를 연결하는 선분은 매개변수 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에 대해 다음과 같이 표현할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}(t) = (1 - t) \mathbf{p_1} + t \mathbf{p_2}, \quad t \in [0, 1]
</div>
<script type="math/tex; mode=display">
\mathbf{p}(t) = (1 - t) \mathbf{p_1} + t \mathbf{p_2}, \quad t \in [0, 1]
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t = 0</span><script type="math/tex">t = 0</script></span>일 때 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t) = \mathbf{p_1}</span><script type="math/tex">\mathbf{p}(t) = \mathbf{p_1}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">t = 1</span><script type="math/tex">t = 1</script></span>일 때 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t) = \mathbf{p_2}</span><script type="math/tex">\mathbf{p}(t) = \mathbf{p_2}</script></span>이다.</p>
<h3 id="_15">교차점 구하기:</h3>
<p>선분의 방정식을 평면 방정식에 대입하면 교차점에서의 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>를 구할 수 있다. 우선, 선분 방정식을 평면 방정식에 대입하면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
((1 - t) \mathbf{p_1} + t \mathbf{p_2} - \mathbf{p_0}) \cdot \mathbf{n} = 0
</div>
<script type="math/tex; mode=display">
((1 - t) \mathbf{p_1} + t \mathbf{p_2} - \mathbf{p_0}) \cdot \mathbf{n} = 0
</script>
</div>
<p>이를 전개하면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
(1 - t) (\mathbf{p_1} - \mathbf{p_0}) \cdot \mathbf{n} + t (\mathbf{p_2} - \mathbf{p_0}) \cdot \mathbf{n} = 0
</div>
<script type="math/tex; mode=display">
(1 - t) (\mathbf{p_1} - \mathbf{p_0}) \cdot \mathbf{n} + t (\mathbf{p_2} - \mathbf{p_0}) \cdot \mathbf{n} = 0
</script>
</div>
<p>이 식을 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에 대해 풀면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
t = \frac{(\mathbf{p_0} - \mathbf{p_1}) \cdot \mathbf{n}}{(\mathbf{p_2} - \mathbf{p_1}) \cdot \mathbf{n}}
</div>
<script type="math/tex; mode=display">
t = \frac{(\mathbf{p_0} - \mathbf{p_1}) \cdot \mathbf{n}}{(\mathbf{p_2} - \mathbf{p_1}) \cdot \mathbf{n}}
</script>
</div>
<h3 id="mathbfxmathbfx">교차점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>:</h3>
<p>구한 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 값을 선분 방정식 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>에 대입하면 교차점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>를 구할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x} = (1 - t) \mathbf{p_1} + t \mathbf{p_2}
</div>
<script type="math/tex; mode=display">
\mathbf{x} = (1 - t) \mathbf{p_1} + t \mathbf{p_2}
</script>
</div>
<p>---:
1. 먼저 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> 값을 구한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
   t = \frac{(\mathbf{p_0} - \mathbf{p_1}) \cdot \mathbf{n}}{(\mathbf{p_2} - \mathbf{p_1}) \cdot \mathbf{n}}
</div>
<script type="math/tex; mode=display">
   t = \frac{(\mathbf{p_0} - \mathbf{p_1}) \cdot \mathbf{n}}{(\mathbf{p_2} - \mathbf{p_1}) \cdot \mathbf{n}}
</script>
</div>
<ol>
<li>그 후, 교차점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>는:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x} = (1 - t) \mathbf{p_1} + t \mathbf{p_2}
</div>
<script type="math/tex; mode=display">
\mathbf{x} = (1 - t) \mathbf{p_1} + t \mathbf{p_2}
</script>
</div>
<p>이 방법으로 선분이 평면과 교차하는 점을 구할 수 있다.</p>
<p>먼저, 각 드론 <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>의 로컬 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}_d = (x_d, y_d, z_d)</span><script type="math/tex">\mathbf{q}_d = (x_d, y_d, z_d)</script></span>를 얻는다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
R(\dot{\phi}) = \frac{a (1 - e^2)}{(1 - e^2 \sin^2(\dot{\phi}))^{3/2}}
\\
x_d = (\dot{\lambda}_2 - \dot{\lambda}_1) \cdot \cos(\dot{\phi}) \cdot R(\dot{\phi})
\\
y_d = R_{\dot{\phi}} \cdot | \dot{\phi}_2 - \dot{\phi}_1|
\\
z_d = \text{각 드론의 상대 고도. 가상 평면은 군집 위치의 상대 고도 기준}
</div>
<script type="math/tex; mode=display">
R(\dot{\phi}) = \frac{a (1 - e^2)}{(1 - e^2 \sin^2(\dot{\phi}))^{3/2}}
\\
x_d = (\dot{\lambda}_2 - \dot{\lambda}_1) \cdot \cos(\dot{\phi}) \cdot R(\dot{\phi})
\\
y_d = R_{\dot{\phi}} \cdot | \dot{\phi}_2 - \dot{\phi}_1|
\\
z_d = \text{각 드론의 상대 고도. 가상 평면은 군집 위치의 상대 고도 기준}
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">R(\phi)</span><script type="math/tex">R(\phi)</script></span>은 위도에 따른 지구의 반경, <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>는 적도 반지름(지구의 반지름, 약 6,378,137m), <span class="arithmatex"><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>는 이심률(eccentricity, 약 0818191908426) 이다.</p>
<p>군집은 가상 평면의 현재 위치에서 지정한 방향으로 지정한 거리만큼 이동하며 비파괴 검사를 수행하므로 먼저 군집의 가상 평면상 위치를 구한다 [Vincenty1975].</p>
<p>가상평면은 로컬 좌표계에서 <span class="arithmatex"><span class="MathJax_Preview">(0, 0)</span><script type="math/tex">(0, 0)</script></span> 위치하고, 방위각 <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>만큼 회전되어 있는 상태이며 </p>
<p>두 드론의 로컬 위치와 가상 평면상 교점을 구한다.</p>
<p>방위각 <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>으로부터 가상평면의 노름 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{s}</span><script type="math/tex">\mathbf{s}</script></span>을 구한다: TODO 노름
$$
\mathbf{s} = \begin{bmatrix}
-\cos \dot{\alpha} &amp; \sin \dot{\alpha} &amp; 0 \
-\sin \dot{\alpha} &amp; -\cos \dot{\alpha} &amp; 0 \
0 &amp; 0 &amp; 1 \
\end{bmatrix}
\cdot
\begin{bmatrix}
0 \
0 \
-1
\end{bmatrix}
$$</p>
<p>ENU(동, 북, 상) 좌표계를 GPS(WGS84) 좌표계로 변환하는 과정은 일반적으로 다음과 같은 단계를 포함한다. ENU 좌표계는 지표면 위의 특정 기준점(예: 원점 <span class="arithmatex"><span class="MathJax_Preview">O</span><script type="math/tex">O</script></span>)을 기준으로 동(East), 북(North), 위(Up) 방향으로 정의된다. 변환하려면 먼저 그 기준점의 GPS 좌표(위도, 경도, 고도)를 알고 있어야 한다. 변환 과정은 다음과 같다:</p>
<ol>
<li><strong>원점 <span class="arithmatex"><span class="MathJax_Preview">O</span><script type="math/tex">O</script></span>의 GPS 좌표 확인 (위도, 경도, 고도)</strong>:<br/>
   원점 <span class="arithmatex"><span class="MathJax_Preview">O</span><script type="math/tex">O</script></span>의 GPS 좌표를 <span class="arithmatex"><span class="MathJax_Preview">(\phi_O, \lambda_O, h_O)</span><script type="math/tex">(\phi_O, \lambda_O, h_O)</script></span>로 설정한다. 여기서:</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\phi_O</span><script type="math/tex">\phi_O</script></span>는 원점의 위도</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\lambda_O</span><script type="math/tex">\lambda_O</script></span>는 원점의 경도</li>
<li>
<p><span class="arithmatex"><span class="MathJax_Preview">h_O</span><script type="math/tex">h_O</script></span>는 원점의 고도이다.</p>
</li>
<li>
<p><strong>ENU 좌표를 지구 중심 지구 고정(ECEF) 좌표로 변환</strong>:
   ENU 좌표계에서의 드론의 위치 <span class="arithmatex"><span class="MathJax_Preview">p_d = (e, n, u)</span><script type="math/tex">p_d = (e, n, u)</script></span>는 원점에서 동쪽으로 <span class="arithmatex"><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>, 북쪽으로 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>, 위쪽으로 <span class="arithmatex"><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>만큼 떨어져 있다. 이를 변환하려면 먼저 ENU 좌표를 ECEF 좌표로 변환해야 한다.</p>
</li>
</ol>
<p>ECEF 좌표로 변환하는 과정은 아래와 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{\text{ECEF}} = \mathbf{P}_O + \mathbf{R} \cdot \mathbf{P}_{\text{ENU}}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{\text{ECEF}} = \mathbf{P}_O + \mathbf{R} \cdot \mathbf{P}_{\text{ENU}}
</script>
</div>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{ECEF}}</span><script type="math/tex">\mathbf{P}_{\text{ECEF}}</script></span>는 변환된 드론의 ECEF 좌표
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_O</span><script type="math/tex">\mathbf{P}_O</script></span>는 원점 <span class="arithmatex"><span class="MathJax_Preview">O</span><script type="math/tex">O</script></span>의 ECEF 좌표
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{\text{ENU}} = (e, n, u)</span><script type="math/tex">\mathbf{P}_{\text{ENU}} = (e, n, u)</script></span>는 ENU 좌표에서의 드론의 위치
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 ENU 좌표계를 ECEF 좌표계로 변환하는 회전 행렬이다. 이 행렬은 원점의 위도와 경도를 사용하여 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
   \mathbf{R} =
   \begin{bmatrix}
   -\sin(\lambda_O) &amp; \cos(\lambda_O) &amp; 0 \\
   -\sin(\phi_O)\cos(\lambda_O) &amp; -\sin(\phi_O)\sin(\lambda_O) &amp; \cos(\phi_O) \\
   \cos(\phi_O)\cos(\lambda_O) &amp; \cos(\phi_O)\sin(\lambda_O) &amp; \sin(\phi_O)
   \end{bmatrix}
</div>
<script type="math/tex; mode=display">
   \mathbf{R} =
   \begin{bmatrix}
   -\sin(\lambda_O) & \cos(\lambda_O) & 0 \\
   -\sin(\phi_O)\cos(\lambda_O) & -\sin(\phi_O)\sin(\lambda_O) & \cos(\phi_O) \\
   \cos(\phi_O)\cos(\lambda_O) & \cos(\phi_O)\sin(\lambda_O) & \sin(\phi_O)
   \end{bmatrix}
</script>
</div>
<ol>
<li><strong>원점의 GPS 좌표를 ECEF 좌표로 변환</strong>:
   원점의 GPS 좌표 <span class="arithmatex"><span class="MathJax_Preview">(\phi_O, \lambda_O, h_O)</span><script type="math/tex">(\phi_O, \lambda_O, h_O)</script></span>를 사용하여 ECEF 좌표로 변환하는 방법은 다음과 같다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   X_O = (N_O + h_O) \cdot \cos(\phi_O) \cdot \cos(\lambda_O)
</div>
<script type="math/tex; mode=display">
   X_O = (N_O + h_O) \cdot \cos(\phi_O) \cdot \cos(\lambda_O)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   Y_O = (N_O + h_O) \cdot \cos(\phi_O) \cdot \sin(\lambda_O)
</div>
<script type="math/tex; mode=display">
   Y_O = (N_O + h_O) \cdot \cos(\phi_O) \cdot \sin(\lambda_O)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
   Z_O = \left[\frac{b^2}{a^2}N_O + h_O\right] \cdot \sin(\phi_O)
</div>
<script type="math/tex; mode=display">
   Z_O = \left[\frac{b^2}{a^2}N_O + h_O\right] \cdot \sin(\phi_O)
</script>
</div>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">N_O = \frac{a^2}{\sqrt{a^2 \cos^2(\phi_O) + b^2 \sin^2(\phi_O)}}</span><script type="math/tex">N_O = \frac{a^2}{\sqrt{a^2 \cos^2(\phi_O) + b^2 \sin^2(\phi_O)}}</script></span>는 원점의 곡률 반경
   - <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>는 WGS84 타원체의 장반경과 단반경이다.</p>
<ol>
<li><strong>드론의 ECEF 좌표에서 GPS 좌표로 변환</strong>:
   드론의 ECEF 좌표 <span class="arithmatex"><span class="MathJax_Preview">(X_d, Y_d, Z_d)</span><script type="math/tex">(X_d, Y_d, Z_d)</script></span>를 구한 후 이를 GPS 좌표로 변환하려면 반복적인 계산을 통해 위도 <span class="arithmatex"><span class="MathJax_Preview">\phi_d</span><script type="math/tex">\phi_d</script></span>, 경도 <span class="arithmatex"><span class="MathJax_Preview">\lambda_d</span><script type="math/tex">\lambda_d</script></span>, 고도 <span class="arithmatex"><span class="MathJax_Preview">h_d</span><script type="math/tex">h_d</script></span>를 얻는다. 일반적인 변환 과정은 다음과 같다:</li>
</ol>
<p>경도:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\lambda_d = \arctan2(Y_d, X_d)
</div>
<script type="math/tex; mode=display">
\lambda_d = \arctan2(Y_d, X_d)
</script>
</div>
<p>위도:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\phi_d = \arctan2\left(Z_d + e'^2 b \sin^3(\phi_d), \sqrt{X_d^2 + Y_d^2} - e^2 a \cos^3(\phi_d)\right)
</div>
<script type="math/tex; mode=display">
\phi_d = \arctan2\left(Z_d + e'^2 b \sin^3(\phi_d), \sqrt{X_d^2 + Y_d^2} - e^2 a \cos^3(\phi_d)\right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>는 이심률, <span class="arithmatex"><span class="MathJax_Preview">e'</span><script type="math/tex">e'</script></span>는 보조 이심률이다.</p>
<p>고도:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
h_d = \frac{\sqrt{X_d^2 + Y_d^2}}{\cos(\phi_d)} - N_d
</div>
<script type="math/tex; mode=display">
h_d = \frac{\sqrt{X_d^2 + Y_d^2}}{\cos(\phi_d)} - N_d
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>는 드론 위치에서의 곡률 반경이다.</p>
<p>이 과정을 통해 ENU 좌표계를 GPS(WGS84) 좌표계로 변환할 수 있다.</p>
<p>혹시 원점 <span class="arithmatex"><span class="MathJax_Preview">O</span><script type="math/tex">O</script></span>의 GPS 좌표를 제공해 주시면 더 구체적인 변환을 도와드릴 수 있다.</p>
<p>죄송한다, 설명이 조금 복잡하게 느껴졌을 수 있겠네요. <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>는 GPS 좌표계에서 곡률 반경을 나타내는 값으로, ECEF 좌표계에서 GPS 좌표로 변환할 때 필요하다. 그러므로 설명을 더 명확히 하기 위해 다시 설명드리겠다.</p>
<p>우선 <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>가 튀어나온 부분은 <strong>드론 위치에서의 곡률 반경</strong>을 의미하는데, 이 값은 위도를 계산할 때 필요한 지구의 곡률을 고려한 값이다. 일반적으로 WGS84 좌표계를 사용할 때, 지구는 타원체(정확히는 회전 타원체)로 근사되며, 이를 계산하기 위해 사용되는 값이 <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>이다.</p>
<h3 id="n_dn_d"><span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span> 정의</h3>
<p>곡률 반경 <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>는 주어진 위도에서 타원체의 곡률을 계산한 값으로 정의되며, 이는 타원체 표면에서 수직으로 측정한 반경이다. WGS84 타원체에서의 곡률 반경은 다음과 같이 주어진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
N_d = \frac{a^2}{\sqrt{a^2 \cos^2(\phi_d) + b^2 \sin^2(\phi_d)}}
</div>
<script type="math/tex; mode=display">
N_d = \frac{a^2}{\sqrt{a^2 \cos^2(\phi_d) + b^2 \sin^2(\phi_d)}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>는 지구 타원체의 장반경 (WGS84에서 약 6378137 m)
- <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>는 지구 타원체의 단반경 (WGS84에서 약 6356752.3142 m)
- <span class="arithmatex"><span class="MathJax_Preview">\phi_d</span><script type="math/tex">\phi_d</script></span>는 드론 위치에서의 위도이다.</p>
<h3 id="n_dn_d_1">고도 계산에서 <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>의 역할</h3>
<p>드론의 고도를 계산할 때 <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>는 드론이 위치한 GPS 좌표계에서의 타원체 반경을 구하기 위해 필요하다. 이를 통해 드론이 실제로 지표면으로부터 얼마나 떨어져 있는지를 계산할 수 있다.</p>
<p>고도는 드론의 ECEF 좌표 <span class="arithmatex"><span class="MathJax_Preview">(X_d, Y_d, Z_d)</span><script type="math/tex">(X_d, Y_d, Z_d)</script></span>에서 얻은 위도 <span class="arithmatex"><span class="MathJax_Preview">\phi_d</span><script type="math/tex">\phi_d</script></span>와 곡률 반경 <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>를 사용하여 계산되며, 다음과 같이 주어진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
h_d = \frac{\sqrt{X_d^2 + Y_d^2}}{\cos(\phi_d)} - N_d
</div>
<script type="math/tex; mode=display">
h_d = \frac{\sqrt{X_d^2 + Y_d^2}}{\cos(\phi_d)} - N_d
</script>
</div>
<p>즉, <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>는 드론 위치에서의 타원체 곡률 반경으로, 이를 통해 드론의 ECEF 좌표에서 GPS 좌표로 변환할 때 고도를 구하는 데 사용된다.</p>
<hr/>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>는 <strong>드론 위치에서의 곡률 반경</strong>으로, 타원체(지구)의 표면 곡률을 고려한 값이다.</li>
<li>이 값은 GPS 좌표계로 변환할 때 위도 및 고도를 계산하는 과정에서 사용된다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>는 드론이 위치한 지점의 위도 <span class="arithmatex"><span class="MathJax_Preview">\phi_d</span><script type="math/tex">\phi_d</script></span>에 따라 변하는 값이다.</li>
</ul>
<p>혹시 추가적으로 다른 부분에서 더 명확한 설명이 필요하시면 말씀해주세요!</p>
<p>보조 이심률(<span class="arithmatex"><span class="MathJax_Preview">e'</span><script type="math/tex">e'</script></span>)은 일반 이심률(<span class="arithmatex"><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>)의 <strong>역수</strong>는 아니다. 대신, 보조 이심률은 일반 이심률과 밀접한 관계를 가지고 있지만, 그 정의는 다르다. 보조 이심률은 타원체의 장반경과 단반경 사이의 비율을 다르게 반영한다. 두 값의 관계를 다시 한 번 정리해 보면:</p>
<h3 id="1-ee">1. <strong>일반 이심률 (<span class="arithmatex"><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>)</strong></h3>
<ul>
<li>타원체의 편평도를 나타내며, 장반경과 단반경의 비율을 기준으로 정의된다.</li>
<li>정의:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
     e = \sqrt{1 - \left(\frac{b}{a}\right)^2}
</div>
<script type="math/tex; mode=display">
     e = \sqrt{1 - \left(\frac{b}{a}\right)^2}
</script>
</div>
<pre><code> 여기서 $a$는 타원체의 장반경(적도 반경), $b$는 단반경(극 반경)이다.
</code></pre>
<h3 id="2-ee">2. <strong>보조 이심률 (<span class="arithmatex"><span class="MathJax_Preview">e'</span><script type="math/tex">e'</script></span>)</strong></h3>
<ul>
<li>보조 이심률은 타원체의 장반경과 단반경의 비율을 반대로 적용하여 정의된 값이다.</li>
<li>정의:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
     e' = \sqrt{\left(\frac{a}{b}\right)^2 - 1}
</div>
<script type="math/tex; mode=display">
     e' = \sqrt{\left(\frac{a}{b}\right)^2 - 1}
</script>
</div>
<pre><code> 또는:
</code></pre>
<div class="arithmatex">
<div class="MathJax_Preview">
e' = \frac{e}{\sqrt{1 - e^2}}
</div>
<script type="math/tex; mode=display">
e' = \frac{e}{\sqrt{1 - e^2}}
</script>
</div>
<h3 id="_16">관계 분석</h3>
<p>보조 이심률은 일반 이심률과의 관계식에서 알 수 있듯이, 단순한 역수가 아니다. 대신, 보조 이심률은 일반 이심률을 기반으로 한 값이며, 지구의 타원체 형상에 대한 다른 표현 방식이다. 이 두 값은 서로 변환 가능하지만, 하나가 다른 것의 역수로 정의되지 않는다.</p>
<p>정리하자면, <strong>보조 이심률은 일반 이심률의 역수는 아니며</strong>, 각각의 정의는 다르다. 보조 이심률은 일반 이심률을 더 복잡하게 변형한 값이다.</p>
<p>3차원 공간에서 두 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1</span><script type="math/tex">\mathbf{p}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2</span><script type="math/tex">\mathbf{p}_2</script></span>가 주어졌을 때, 이들 위치를 연결하는 선과 수평면에 수직인 평면 사이의 교점을 구하는 과정은 다음과 같다. 이때 평면의 위치는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>이고, 법선벡터는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>이라고 가정한다.</p>
<h3 id="1_2">1. 평면 방정식</h3>
<p>평면의 방정식은 법선 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span>과 평면 위의 한 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>을 사용하여 다음과 같이 표현할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
(\mathbf{x} - \mathbf{p}) \cdot \mathbf{n} = 0
</div>
<script type="math/tex; mode=display">
(\mathbf{x} - \mathbf{p}) \cdot \mathbf{n} = 0
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>는 평면 위의 임의의 점이다. 이 방정식은 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>가 평면에 있을 때 성립하는 방정식이다.</p>
<h3 id="2_2">2. 선 방정식</h3>
<p>선은 두 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1</span><script type="math/tex">\mathbf{p}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2</span><script type="math/tex">\mathbf{p}_2</script></span> 사이에 정의될 수 있으며, 매개변수 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>를 사용하여 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{r}(t) = \mathbf{p}_1 + t (\mathbf{p}_2 - \mathbf{p}_1)
</div>
<script type="math/tex; mode=display">
\mathbf{r}(t) = \mathbf{p}_1 + t (\mathbf{p}_2 - \mathbf{p}_1)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t \in [0, 1]</span><script type="math/tex">t \in [0, 1]</script></span>은 선분 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1</span><script type="math/tex">\mathbf{p}_1</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2</span><script type="math/tex">\mathbf{p}_2</script></span>로의 매개변수이다. <span class="arithmatex"><span class="MathJax_Preview">t = 0</span><script type="math/tex">t = 0</script></span>일 때 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}(t) = \mathbf{p}_1</span><script type="math/tex">\mathbf{r}(t) = \mathbf{p}_1</script></span>이고, <span class="arithmatex"><span class="MathJax_Preview">t = 1</span><script type="math/tex">t = 1</script></span>일 때 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}(t) = \mathbf{p}_2</span><script type="math/tex">\mathbf{r}(t) = \mathbf{p}_2</script></span>이다.</p>
<h3 id="3_3">3. 교점 구하기</h3>
<p>이제 선의 방정식을 평면의 방정식에 대입하여 교점을 찾는다. 즉, 선 위의 임의의 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}(t)</span><script type="math/tex">\mathbf{r}(t)</script></span>이 평면 방정식을 만족하는 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>를 구하는 과정이다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
(\mathbf{r}(t) - \mathbf{p}) \cdot \mathbf{n} = 0
</div>
<script type="math/tex; mode=display">
(\mathbf{r}(t) - \mathbf{p}) \cdot \mathbf{n} = 0
</script>
</div>
<p>위 식에 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}(t)</span><script type="math/tex">\mathbf{r}(t)</script></span>의 값을 대입하면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
((\mathbf{p}_1 + t (\mathbf{p}_2 - \mathbf{p}_1)) - \mathbf{p}) \cdot \mathbf{n} = 0
</div>
<script type="math/tex; mode=display">
((\mathbf{p}_1 + t (\mathbf{p}_2 - \mathbf{p}_1)) - \mathbf{p}) \cdot \mathbf{n} = 0
</script>
</div>
<p>이를 전개하면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
((\mathbf{p}_1 - \mathbf{p}) + t (\mathbf{p}_2 - \mathbf{p}_1)) \cdot \mathbf{n} = 0
</div>
<script type="math/tex; mode=display">
((\mathbf{p}_1 - \mathbf{p}) + t (\mathbf{p}_2 - \mathbf{p}_1)) \cdot \mathbf{n} = 0
</script>
</div>
<p>따라서, <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에 대한 식은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
(\mathbf{p}_1 - \mathbf{p}) \cdot \mathbf{n} + t (\mathbf{p}_2 - \mathbf{p}_1) \cdot \mathbf{n} = 0
</div>
<script type="math/tex; mode=display">
(\mathbf{p}_1 - \mathbf{p}) \cdot \mathbf{n} + t (\mathbf{p}_2 - \mathbf{p}_1) \cdot \mathbf{n} = 0
</script>
</div>
<p>이제 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에 대해 풀면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
t = -\frac{(\mathbf{p}_1 - \mathbf{p}) \cdot \mathbf{n}}{(\mathbf{p}_2 - \mathbf{p}_1) \cdot \mathbf{n}}
</div>
<script type="math/tex; mode=display">
t = -\frac{(\mathbf{p}_1 - \mathbf{p}) \cdot \mathbf{n}}{(\mathbf{p}_2 - \mathbf{p}_1) \cdot \mathbf{n}}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>는 선분 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1</span><script type="math/tex">\mathbf{p}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2</span><script type="math/tex">\mathbf{p}_2</script></span> 사이에서 평면과의 교점을 나타내는 매개변수이다.</p>
<h3 id="4_1">4. 교점의 조건</h3>
<ol>
<li>
<p><strong>교점이 있을 때</strong>: <span class="arithmatex"><span class="MathJax_Preview">0 \leq t \leq 1</span><script type="math/tex">0 \leq t \leq 1</script></span>일 때, 교점은 두 점 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_1</span><script type="math/tex">\mathbf{p}_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_2</span><script type="math/tex">\mathbf{p}_2</script></span> 사이에 존재한다. 교점의 좌표는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}(t)</span><script type="math/tex">\mathbf{r}(t)</script></span>를 사용하여 계산할 수 있다.</p>
</li>
<li>
<p><strong>교점이 없을 때</strong>: <span class="arithmatex"><span class="MathJax_Preview">t &lt; 0</span><script type="math/tex">t < 0</script></span> 또는 <span class="arithmatex"><span class="MathJax_Preview">t &gt; 1</span><script type="math/tex">t > 1</script></span>일 경우, 교점은 두 점 사이에 존재하지 않으므로 평면과 선분이 교차하지 않는다.</p>
</li>
<li>
<p><strong>분모가 0일 때</strong>: 만약 <span class="arithmatex"><span class="MathJax_Preview">(\mathbf{p}_2 - \mathbf{p}_1) \cdot \mathbf{n} = 0</span><script type="math/tex">(\mathbf{p}_2 - \mathbf{p}_1) \cdot \mathbf{n} = 0</script></span>이라면, 선이 평면과 평행하다는 것을 의미하며, 교점이 없거나 선이 평면 위에 완전히 놓일 수 있다.</p>
</li>
</ol>
<h3 id="ode">ODE를 참조한 연산</h3>
<p>위 과정을 ODE 문제로 해석할 수 있다. 선의 매개변수화는 일종의 미분 방정식의 형태를 가지며, 이를 통해 평면과 선의 교점을 구하는 과정은 ODE 해법의 한 예로 볼 수 있다. <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>는 시간 매개변수와 유사한 역할을 하며, 이를 통해 특정 시점에서의 교차점을 찾는 것이다.</p>
<p>3차원 공간에서 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>축을 기준으로 <span class="arithmatex"><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span>만큼 회전하는 회전 행렬은 다음과 같이 주어진다. 이 행렬은 시계 방향과 반시계 방향을 기준으로 각각 정의될 수 있다. 여기서는 일반적으로 반시계 방향을 기준으로 한다.</p>
<h3 id="zz-psipsi"><span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>축을 기준으로 <span class="arithmatex"><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span>만큼의 회전 행렬</h3>
<p>회전 행렬 <span class="arithmatex"><span class="MathJax_Preview">R_z(\psi)</span><script type="math/tex">R_z(\psi)</script></span>는 다음과 같은 형태를 갖는다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
R_z(\psi) =
</div>
<script type="math/tex; mode=display">
R_z(\psi) =
</script>
</div>
<p>이 행렬은 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>축을 기준으로 <span class="arithmatex"><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span>만큼의 회전을 표현하며, 이를 적용한 벡터는 <span class="arithmatex"><span class="MathJax_Preview">xy</span><script type="math/tex">xy</script></span>평면에서만 회전하고, <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>축 방향 성분은 변하지 않는다.</p>
<h3 id="_17">설명</h3>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\cos \psi</span><script type="math/tex">\cos \psi</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\sin \psi</span><script type="math/tex">\sin \psi</script></span>는 회전 각도 <span class="arithmatex"><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span>에 따른 삼각 함수 값이다.</li>
<li>이 회전은 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>축을 중심으로 <span class="arithmatex"><span class="MathJax_Preview">xy</span><script type="math/tex">xy</script></span>평면 상에서만 영향을 미치므로, <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>축 성분은 그대로 유지된다.</li>
</ul>
<h3 id="334">3.3.4 가상 평면 적용</h3>
<p>가상 평면은 피사체를 중심으로 설정되며, 두 드론은 이 평면을 기준으로 일정한 거리와 각도를 유지하면서 검사 작업을 수행한다. 관제 소프트웨어는 피사체의 위치와 방위각, 기울기를 실시간으로 계산하고, 이를 바탕으로 드론의 비행 경로를 조정하여 피사체에 대한 정확한 비파괴 검사를 가능하게 한다. 이 가상 평면을 통해 드론 간 상호 조준이 이루어지며, 피사체에 대한 검사는 일정한 거리를 유지하며 효율적으로 진행된다.</p>
<h3 id="335">3.3.5 향후 과제</h3>
<p>본 연구에서 제안한 가상 평면 생성 방법은 두 드론 간의 상대적인 위치와 자세를 정확하게 조정할 수 있는 기반을 제공한다. 향후 연구에서는 더 정밀한 센서 데이터를 활용하여 피사체의 3차원 형상을 보다 정확하게 추정하고, 더욱 복잡한 검사 경로 계획을 수립하는 방법에 대해 연구할 예정이다.</p>
<p>[끝]</p>
<ol>
<li><strong>경로 계획 및 가상 평면 생성</strong></li>
</ol>
<p>관제 소프트웨어는 두 대의 드론이 비파괴 검사를 수행할 피사체를 기준으로 경로를 설정하고, 이 경로를 따라 군집 비행을 수행하도록 한다. 이때, 소프트웨어는 두 드론 사이에 <strong>가상의 평면</strong>을 생성하여 피사체를 중심으로 대칭적인 위치를 유지하도록 조정한다.</p>
<ul>
<li><strong>가상 평면</strong>은 두 드론이 피사체를 기준으로 일정 거리를 유지하며, 동기화된 경로를 따라 이동할 수 있도록 가이드라인 역할을 한다.</li>
<li>
<p><strong>경로 계획</strong>은 조종자의 설정에 따라 이루어지며, 검사 구역의 크기와 드론 간의 이동 속도 등을 고려하여 설정한다. 드론은 이 경로를 따라 이동하면서, 비파괴 검사 장비를 통해 영상 데이터를 취득한다.</p>
</li>
<li>
<p><strong>실시간 상태 모니터링 및 데이터 처리</strong></p>
</li>
</ul>
<p>관제 소프트웨어는 MAVLink 프로토콜을 통해 드론으로부터 실시간 상태 데이터를 수신한다. 이러한 데이터는 드론의 위치, 고도, 속도, 배터리 상태, 각종 센서 데이터(IMU, GPS 등) 등을 포함하며, 실시간으로 조종자에게 피드백을 제공한다. 또한, 조종자는 이를 통해 즉각적인 제어 명령을 내릴 수 있다.</p>
<ul>
<li><strong>드론 상태 시각화</strong>: 소프트웨어는 드론의 실시간 위치 및 상태를 시각적으로 모니터링할 수 있도록 화면에 표시한다. 이를 통해 조종자는 각 드론이 정확하게 임무를 수행하고 있는지 확인할 수 있다.</li>
<li><strong>임무 중 데이터 분석</strong>: 임무 수행 중 관제 소프트웨어는 드론이 획득한 데이터를 실시간으로 처리하여 비파괴 검사 결과를 분석한다. 만약 결함이 감지될 경우, 조종자는 즉시 해당 구역을 재검사할 수 있도록 드론을 제어할 수 있다.</li>
</ul>
<p>관제 소프트웨어는 이러한 다양한 기능을 통해 두 대의 드론이 비파괴 검사를 효과적으로 수행할 수 있도록 지원하며, 군집 비행과 개별 제어를 모두 가능하게 한다.</p>
<h3 id="23">2.3 군집 비행 제어</h3>
<p>두 대의 드론이 동시에 비파괴 검사를 수행하기 위해서는 군집 비행 제어가 필요하다. 군집 비행 제어는 두 대의 드론이 상호 위치를 조정하면서 피사체로부터 일정한 거리를 유지하는 것을 목표로 한다. 이를 위해 다음과 같은 절차가 진행된다.</p>
<ol>
<li>
<p><strong>피사체 위치 설정</strong>: 관제 소프트웨어는 피사체의 위치를 설정하고, 두 대의 드론이 피사체를 중심으로 대칭적인 위치에 위치하도록 명령을 내린다.</p>
</li>
<li>
<p><strong>가상 평면 생성</strong>: 두 대의 드론 사이에 가상의 평면을 생성하여 피사체와의 거리를 유지하며, 이 평면을 기준으로 드론 간 상대 위치를 조정한다.</p>
</li>
<li>
<p><strong>경로 계획</strong>: 조종자는 두 드론이 검사할 경로를 설정하며, 드론들은 이 경로를 따라 이동하며 지정된 간격으로 영상을 취득한다. 드론이 경로를 따라 이동하는 동안, 두 드론의 상대적 위치가 계속 조정되며 피사체를 중심으로 대칭적인 비행을 유지한다.</p>
</li>
</ol>
<h3 id="24">2.4 검사 절차</h3>
<p>드론이 피사체 주위를 비행하며 비파괴 검사를 수행하는 절차는 다음과 같다.</p>
<ol>
<li>
<p><strong>이륙 및 초기 위치 설정</strong>: 두 대의 드론은 동시에 이륙하여 피사체로부터 일정 거리에 도달한다. 이 과정에서 GPS 및 IMU 데이터를 사용하여 드론 간 상대적 위치와 피사체로부터의 거리를 정확히 측정한다.</p>
</li>
<li>
<p><strong>검사 장비 조준</strong>: 두 대의 드론은 상호 위치를 추정하여 비파괴 검사 장비를 피사체에 정확히 조준한다. 이 과정에서 드론 간 통신을 통해 상대 드론의 위치를 실시간으로 추적하며, 검사 장비가 피사체의 동일한 부분을 검사하도록 조정한다.</p>
</li>
<li>
<p><strong>영상 취득</strong>: 두 대의 드론이 지정된 경로를 따라 이동하면서, 비파괴 검사 장비를 이용해 연속적으로 영상을 취득한다. 관제 소프트웨어는 실시간으로 영상을 모니터링하며 결함 여부를 분석한다.</p>
</li>
<li>
<p><strong>착륙 및 데이터 분석</strong>: 임무가 완료되면 드론은 안전하게 착륙하며, 취득한 데이터를 분석하여 최종적인 결함 여부를 판단한다.</p>
</li>
</ol>
<p>본 시스템 개요는 두 대의 드론을 이용한 비파괴 검사의 원리를 상세히 설명하며, 시스템의 하드웨어 및 소프트웨어 구성을 포함한 전체적인 동작 방식을 기술한다.</p>
<h2 id="3_4">3. 군집 제어 시스템</h2>
<h3 id="31_1">3.1 군집 상태 전이</h3>
<p>군집 관제는 조종자의 명령에 따라 절차적으로 전이된다. 군집 상태는 <strong>idle</strong>에서 시작하며, 조종자의 지시에 따라 <strong>takeoff</strong> 상태로 전이된다. 군집이 상승한 후에는 <strong>aim</strong> 모드로 진입하여 피사체를 중심으로 지정된 위치를 유지하며 상호 조준한다. 이후 <strong>auto</strong> 모드로 전이하여 지정된 경로를 따라 이동하면서 비파괴 검사를 수행한다.</p>
<h3 id="32_1">3.2 개별 드론 상태 전이</h3>
<p>각 드론은 개별적으로 <strong>idle</strong> 상태에서 출발하며, 조종자의 명령에 따라 <strong>arm</strong>하여 준비 상태에 진입한다. 이후 <strong>takeoff</strong> 명령이 내려지면 이륙하여 지정된 고도로 상승하며, <strong>aim</strong> 상태에서 상대 드론과 피사체의 위치를 추정하여 정확히 조준한다. 임무가 완료되면 <strong>land</strong> 상태로 전이하여 착륙한다.</p>
<h2 id="4_2">4. 관제 소프트웨어</h2>
<h3 id="41-mavlink">4.1 MAVLink 통신</h3>
<p>드론과 관제 소프트웨어는 MAVLink 프로토콜을 사용하여 통신한다. 관제 소프트웨어는 두 대의 드론에 대해 개별적으로 명령을 전달할 수 있으며, 드론 간 상호 위치 정보를 수집하여 군집 제어를 수행한다.</p>
<h3 id="42">4.2 가상 평면 생성</h3>
<p>비파괴 검사를 위해 두 대의 드론은 피사체를 사이에 두고 가상의 평면을 생성한다. 이 평면을 기준으로 드론은 지정된 거리를 유지하며, 조종자의 명령에 따라 일정 간격으로 이동한다.</p>
<h2 id="5">5. 결론</h2>
<p>본 논문에서는 두 대의 드론을 이용한 군집 비파괴 검사 시스템을 제안하였다. 각 드론은 서로의 위치를 실시간으로 추정하며 피사체를 조준하고, 지정된 경로를 따라 검사 영상을 취득한다. 제안된 시스템은 MAVLink 기반 통신을 통해 효율적으로 작동하며, 향후 연구에서는 검사 장비의 정밀도를 향상시키고, 다양한 피사체에 대한 적용 가능성을 검토할 예정이다.</p>
<h2 id="_18">참조</h2>
<p>[Ardupilot] https://ardupilot.org/</p>
<p>[MAVLink] https://mavlink.io/en/</p>
<p>[MAVLink2] https://mavlink.io/en/guide/mavlink_2.html</p>
<hr/>
<p>[Vincenty1975]</p>
<p><strong>Thaddeus Vincenty</strong>가 1975년에 발표한 타원체 거리 계산법은 논문으로 다음과 같은 제목으로 출판되었다:</p>
<p><strong>"Direct and Inverse Solutions of Geodesics on the Ellipsoid with Application of Nested Equations"</strong></p>
<p>이 논문은 <strong>Survey Review</strong> 저널의 1975년판에 게재되었으며, 타원체 상에서의 두 지점 간의 거리를 계산하는 방법을 제시한 매우 중요한 연구이다. 논문에서는 두 주요 문제를 다룬다:</p>
<ol>
<li><strong>직접 문제 (Direct problem)</strong>: 한 지점에서 특정 방위각과 거리를 주어졌을 때, 목표 지점의 좌표를 계산하는 방법.</li>
<li><strong>역문제 (Inverse problem)</strong>: 두 지점의 좌표가 주어졌을 때, 그 사이의 대지 거리와 방위각을 계산하는 방법.</li>
</ol>
<p>Vincenty의 계산법은 매우 정확하며, GPS나 지리 정보 시스템(GIS)에서 타원체 모델을 사용할 때 거리 계산에 자주 사용된다.</p>
<p>참고로, 이 논문은 타원체 모델을 사용한 지리적 계산에서 여전히 중요한 기여를 하고 있으며, 타원체의 편평도와 이심률을 고려한 매우 정밀한 계산을 가능하게 한다.</p>
<p>맞습니다! 위에서 설명한 <span class="arithmatex"><span class="MathJax_Preview">\phi_d</span><script type="math/tex">\phi_d</script></span>를 구하는 과정은 재귀적인 형태로 되어 있었는데, 실제로는 수렴하는 방식으로 계산을 해야 한다. 따라서 그 식은 수정되어야 한다. <span class="arithmatex"><span class="MathJax_Preview">\phi_d</span><script type="math/tex">\phi_d</script></span> (위도)를 구하는 보다 정확한 방식은 반복적인 방법을 사용하는 것이다. </p>
<p>정확한 변환 과정을 살펴보면, 드론의 ECEF 좌표 <span class="arithmatex"><span class="MathJax_Preview">(X_d, Y_d, Z_d)</span><script type="math/tex">(X_d, Y_d, Z_d)</script></span>에서 GPS 좌표로 변환할 때 위도 <span class="arithmatex"><span class="MathJax_Preview">\phi_d</span><script type="math/tex">\phi_d</script></span>는 다음과 같은 방식으로 구해진다:</p>
<h3 id="1_3">1. 초기 위도 값 추정</h3>
<p>우선 초기 위도 값을 대략적으로 추정할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\phi_d^{(0)} = \arctan\left(\frac{Z_d}{\sqrt{X_d^2 + Y_d^2}}\right)
</div>
<script type="math/tex; mode=display">
\phi_d^{(0)} = \arctan\left(\frac{Z_d}{\sqrt{X_d^2 + Y_d^2}}\right)
</script>
</div>
<p>이는 고도 <span class="arithmatex"><span class="MathJax_Preview">h_d</span><script type="math/tex">h_d</script></span>를 무시한 상태에서의 초기 추정값이다.</p>
<h3 id="2_3">2. 반복적인 위도 계산</h3>
<p>초기 위도 값 <span class="arithmatex"><span class="MathJax_Preview">\phi_d^{(0)}</span><script type="math/tex">\phi_d^{(0)}</script></span>를 사용하여 드론 위치에서의 곡률 반경 <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>를 계산한 후, 이를 이용해 위도를 반복적으로 업데이트한다. 이 방법은 다음과 같다:</p>
<ol>
<li>초기 위도 <span class="arithmatex"><span class="MathJax_Preview">\phi_d^{(0)}</span><script type="math/tex">\phi_d^{(0)}</script></span>로 시작한다.</li>
<li>위도의 업데이트는 다음과 같은 식을 사용한다:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\phi_d^{(n+1)} = \arctan\left(\frac{Z_d + e'^2 N_d \sin(\phi_d^{(n)})}{\sqrt{X_d^2 + Y_d^2}}\right)
</div>
<script type="math/tex; mode=display">
\phi_d^{(n+1)} = \arctan\left(\frac{Z_d + e'^2 N_d \sin(\phi_d^{(n)})}{\sqrt{X_d^2 + Y_d^2}}\right)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">e'</span><script type="math/tex">e'</script></span>는 보조 이심률 (<span class="arithmatex"><span class="MathJax_Preview">e' = \frac{b}{a}</span><script type="math/tex">e' = \frac{b}{a}</script></span>)이며, <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>는 WGS84 타원체의 장반경과 단반경이다.
- <span class="arithmatex"><span class="MathJax_Preview">N_d</span><script type="math/tex">N_d</script></span>는 현재 위도에서의 곡률 반경으로 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
N_d = \frac{a}{\sqrt{1 - e^2 \sin^2(\phi_d^{(n)})}}
</div>
<script type="math/tex; mode=display">
N_d = \frac{a}{\sqrt{1 - e^2 \sin^2(\phi_d^{(n)})}}
</script>
</div>
<p>반복 과정은 위도 값이 수렴할 때까지 진행된다. 일반적으로, 이 과정은 매우 빠르게 수렴한다.</p>
<h3 id="3_5">3. 경도와 고도 계산</h3>
<ul>
<li>경도 <span class="arithmatex"><span class="MathJax_Preview">\lambda_d</span><script type="math/tex">\lambda_d</script></span>는 위도와 고도가 구해지면 아래와 같이 단순 계산으로 구할 수 있다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
\lambda_d = \arctan2(Y_d, X_d)
</div>
<script type="math/tex; mode=display">
\lambda_d = \arctan2(Y_d, X_d)
</script>
</div>
<ul>
<li>고도 <span class="arithmatex"><span class="MathJax_Preview">h_d</span><script type="math/tex">h_d</script></span>는 다음과 같이 계산된다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
h_d = \frac{\sqrt{X_d^2 + Y_d^2}}{\cos(\phi_d)} - N_d
</div>
<script type="math/tex; mode=display">
h_d = \frac{\sqrt{X_d^2 + Y_d^2}}{\cos(\phi_d)} - N_d
</script>
</div>
<p>---:
이와 같은 방식으로 <span class="arithmatex"><span class="MathJax_Preview">\phi_d</span><script type="math/tex">\phi_d</script></span>를 반복적으로 계산해야 하며, 초기 값으로부터 시작하여 정확한 위도 값을 수렴시키는 방식이다. 위에서 제시된 재귀적인 형태는 실제로 반복적인 계산 방식으로 처리된다.</p>
<p>따라서 재귀적인 형태는 틀린 방식이 아니며, 적절히 반복적인 방식으로 변환되어야 한다.</p>
<p>고도가 동일한 두 대의 드론이 WGS84 좌표로 서로의 위치를 공유하고 있고, 상대 위치를 향하도록 하려면, 두 드론이 각각 상대방을 가리키는 벡터 방향을 계산해야 한다. 이를 위해 각 드론의 WGS84 좌표(g_1, g_2)를 활용하여 상대 방향을 계산할 수 있다. WGS84 좌표는 경도(Longitude), 위도(Latitude), 고도(Altitude) 정보를 포함하며, 이를 기초로 하여 각 드론이 상대 드론을 향하게 하는 방법은 다음과 같다.</p>
<h3 id="1-wgs84-ecef">1. WGS84 좌표를 직교 좌표계로 변환 (ECEF 좌표계)</h3>
<p>WGS84는 구면 좌표계이므로, 드론 간의 벡터 계산을 쉽게 하기 위해 ECEF 좌표계(지구 중심 좌표계)로 변환한다. ECEF 좌표계에서 X, Y, Z 좌표로 변환하는 공식은 아래와 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
X = (N + h) \cdot \cos(\phi) \cdot \cos(\lambda)
</div>
<script type="math/tex; mode=display">
X = (N + h) \cdot \cos(\phi) \cdot \cos(\lambda)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
Y = (N + h) \cdot \cos(\phi) \cdot \sin(\lambda)
</div>
<script type="math/tex; mode=display">
Y = (N + h) \cdot \cos(\phi) \cdot \sin(\lambda)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
Z = \left(\left(1 - e^2\right) \cdot N + h\right) \cdot \sin(\phi)
</div>
<script type="math/tex; mode=display">
Z = \left(\left(1 - e^2\right) \cdot N + h\right) \cdot \sin(\phi)
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>: 위도(Latitude, 단위: 라디안)</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>: 경도(Longitude, 단위: 라디안)</li>
<li><span class="arithmatex"><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span>: 고도(Altitude, 단위: 미터)</li>
<li><span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>: WGS84 타원체의 반경</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
  N = \frac{a}{\sqrt{1 - e^2 \cdot \sin^2(\phi)}}
</div>
<script type="math/tex; mode=display">
  N = \frac{a}{\sqrt{1 - e^2 \cdot \sin^2(\phi)}}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>: 지구 적도 반경 (6378137.0 m)</li>
<li><span class="arithmatex"><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>: 타원체 이심률 (0.081819190842622)</li>
</ul>
<h3 id="2_4">2. 두 드론 간 상대 벡터 계산</h3>
<p>ECEF 좌표계로 변환된 드론 1의 좌표를 <span class="arithmatex"><span class="MathJax_Preview">P_1 = (X_1, Y_1, Z_1)</span><script type="math/tex">P_1 = (X_1, Y_1, Z_1)</script></span>, 드론 2의 좌표를 <span class="arithmatex"><span class="MathJax_Preview">P_2 = (X_2, Y_2, Z_2)</span><script type="math/tex">P_2 = (X_2, Y_2, Z_2)</script></span>라고 하면, 드론 1에서 드론 2를 향하는 상대 벡터는 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\vec{r_{12}} = P_2 - P_1 = (X_2 - X_1, Y_2 - Y_1, Z_2 - Z_1)
</div>
<script type="math/tex; mode=display">
\vec{r_{12}} = P_2 - P_1 = (X_2 - X_1, Y_2 - Y_1, Z_2 - Z_1)
</script>
</div>
<p>이 벡터는 드론 1에서 드론 2를 향하는 방향을 나타낸다. 마찬가지로, 드론 2에서 드론 1을 향하는 벡터는 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\vec{r_{21}} = P_1 - P_2 = (X_1 - X_2, Y_1 - Y_2, Z_1 - Z_2)
</div>
<script type="math/tex; mode=display">
\vec{r_{21}} = P_1 - P_2 = (X_1 - X_2, Y_1 - Y_2, Z_1 - Z_2)
</script>
</div>
<h3 id="3_6">3. 상대 방향을 드론의 로컬 좌표계로 변환</h3>
<p>각 드론의 상대 벡터를 구한 후, 해당 벡터를 드론의 로컬 좌표계 (ENU: 동쪽, 북쪽, 위쪽)로 변환해야 한다. 이를 위해 ECEF 좌표를 ENU 좌표로 변환한다.</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">E = -\sin(\lambda) \cdot \Delta X + \cos(\lambda) \cdot \Delta Y</span><script type="math/tex">E = -\sin(\lambda) \cdot \Delta X + \cos(\lambda) \cdot \Delta Y</script></span></li>
<li><span class="arithmatex"><span class="MathJax_Preview">N = -\sin(\phi) \cdot \cos(\lambda) \cdot \Delta X - \sin(\phi) \cdot \sin(\lambda) \cdot \Delta Y + \cos(\phi) \cdot \Delta Z</span><script type="math/tex">N = -\sin(\phi) \cdot \cos(\lambda) \cdot \Delta X - \sin(\phi) \cdot \sin(\lambda) \cdot \Delta Y + \cos(\phi) \cdot \Delta Z</script></span></li>
<li><span class="arithmatex"><span class="MathJax_Preview">U = \cos(\phi) \cdot \cos(\lambda) \cdot \Delta X + \cos(\phi) \cdot \sin(\lambda) \cdot \Delta Y + \sin(\phi) \cdot \Delta Z</span><script type="math/tex">U = \cos(\phi) \cdot \cos(\lambda) \cdot \Delta X + \cos(\phi) \cdot \sin(\lambda) \cdot \Delta Y + \sin(\phi) \cdot \Delta Z</script></span></li>
</ul>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\Delta X, \Delta Y, \Delta Z</span><script type="math/tex">\Delta X, \Delta Y, \Delta Z</script></span>는 두 드론 간 상대 ECEF 벡터이다.</p>
<h3 id="4_3">4. 로컬 좌표계에서 방향 결정</h3>
<p>ENU 좌표계에서 드론의 yaw (heading, 방위각)를 계산하여 드론이 상대를 향하도록 회전시킬 수 있다. yaw 각도는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{yaw} = \text{atan2}(E, N)
</div>
<script type="math/tex; mode=display">
\text{yaw} = \text{atan2}(E, N)
</script>
</div>
<p>이 각도를 이용해 드론이 서로를 향하도록 yaw 방향을 조정하면 된다.</p>
<hr/>
<ol>
<li>WGS84 좌표를 ECEF 좌표로 변환.</li>
<li>두 드론 간의 상대 벡터를 계산.</li>
<li>ECEF 좌표를 드론의 로컬 좌표계인 ENU로 변환.</li>
<li>로컬 좌표계에서 yaw 각도를 계산하여 드론을 서로 향하도록 함.</li>
</ol>
<p>이 절차를 통해 두 드론은 서로의 위치를 기반으로 상대적인 방향을 알 수 있다.</p>
<br/>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>