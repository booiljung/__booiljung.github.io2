<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot%20simulation%20with%20unity/chapter%2002/0203/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>물리 엔진 및 스크립팅 환경 설정 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Unity \ubb3c\ub9ac \uc5d4\uc9c4 \uc18c\uac1c", url: "#_top", children: [
              {title: "PhysX\uc758 \uc8fc\uc694 \uae30\ub2a5", url: "#physx" },
          ]},
          {title: "Rigidbody \uc124\uc815", url: "#rigidbody", children: [
              {title: "Rigidbody\uc758 \uc8fc\uc694 \uc18d\uc131", url: "#rigidbody_1" },
              {title: "Rigidbody \ucd94\uac00 \ubc29\ubc95", url: "#rigidbody_2" },
          ]},
          {title: "Collider \uc124\uc815", url: "#collider", children: [
              {title: "\uc8fc\uc694 Collider \uc720\ud615", url: "#collider_1" },
              {title: "Collider \ucd94\uac00 \ubc0f \uc124\uc815", url: "#collider_2" },
          ]},
          {title: "Physics Material \uc124\uc815", url: "#physics-material", children: [
              {title: "\uc8fc\uc694 Physics Material \uc18d\uc131", url: "#physics-material_1" },
              {title: "Physics Material \uc0dd\uc131 \ubc0f \uc801\uc6a9", url: "#physics-material_2" },
          ]},
          {title: "\uc2a4\ud06c\ub9bd\ud305\uc744 \ud1b5\ud55c \ubb3c\ub9ac \uc5d4\uc9c4 \uc81c\uc5b4", url: "#_1", children: [
              {title: "Rigidbody \uc81c\uc5b4", url: "#rigidbody_3" },
              {title: "\ubb3c\ub9ac\uc801 \ud798\uacfc \ud1a0\ud06c \uc801\uc6a9", url: "#_2" },
          ]},
          {title: "\ubb3c\ub9ac \uc5c5\ub370\uc774\ud2b8\uc640 FixedUpdate", url: "#fixedupdate", children: [
          ]},
          {title: "\ucda9\ub3cc \uac10\uc9c0 \ubc0f \ucc98\ub9ac", url: "#_3", children: [
          ]},
          {title: "\ubb3c\ub9ac \uc5d4\uc9c4 \uace0\uae09 \uc124\uc815", url: "#_4", children: [
              {title: "\ubb3c\ub9ac \uc124\uc815(Global Physics Settings)", url: "#global-physics-settings" },
              {title: "\ubb3c\ub9ac \uc7ac\uc9c8\uc758 \uace0\uae09 \uc124\uc815", url: "#_5" },
              {title: "\ub808\uc774\uc5b4 \uae30\ubc18 \ucda9\ub3cc \uc124\uc815", url: "#_6" },
              {title: "\ubb3c\ub9ac \uc2dc\uac04 \uc124\uc815(Time Settings)", url: "#time-settings" },
              {title: "\ubb3c\ub9ac \ub514\ubc84\uae45 \ub3c4\uad6c", url: "#_7" },
          ]},
          {title: "\uc2a4\ud06c\ub9bd\ud305 \ud658\uacbd \uc124\uc815", url: "#_8", children: [
              {title: "\uac1c\ubc1c \ub3c4\uad6c \ud1b5\ud569", url: "#_9" },
              {title: "\uc2a4\ud06c\ub9bd\ud2b8 \ud15c\ud50c\ub9bf \ubc0f \uad6c\uc870", url: "#_10" },
              {title: "\uc2a4\ud06c\ub9bd\ud2b8 \ucef4\ud30c\uc77c \uc124\uc815", url: "#_11" },
              {title: "\ub514\ubc84\uae45 \ubc0f \ub85c\uae45", url: "#_12" },
          ]},
          {title: "\uc2a4\ud06c\ub9bd\ud305\uc744 \ud1b5\ud55c \ubb3c\ub9ac \uc5d4\uc9c4 \uc81c\uc5b4", url: "#_13", children: [
              {title: "\ubb3c\ub9ac \uc18d\uc131 \uc811\uadfc", url: "#_14" },
              {title: "\ubb3c\ub9ac \uc774\ubca4\ud2b8 \ud65c\uc6a9", url: "#_15" },
              {title: "\ubb3c\ub9ac \uae30\ubc18 \uc560\ub2c8\uba54\uc774\uc158 \uc81c\uc5b4", url: "#_16" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter%2003/0301/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter%2003/0301/" class="btn btn-xs btn-link">
        URDF 파일을 이용한 로봇 모델링
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0202/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0202/" class="btn btn-xs btn-link">
        기본 프로젝트 구성
      </a>
    </div>
    
  </div>

    

    <p>로봇 시뮬레이션에서 물리 엔진과 스크립팅 환경은 로봇의 동작과 상호작용을 현실적으로 구현하는 데 필수적인 요소이다. 이 장에서는 Unity의 물리 엔진을 이해하고, 이를 효과적으로 설정 및 활용하기 위한 방법을 상세히 다룬다.</p>
<h3 id="unity">Unity 물리 엔진 소개</h3>
<p>Unity는 강력한 물리 엔진을 내장하고 있어, 물리 기반 시뮬레이션을 손쉽게 구현할 수 있다. 주로 사용되는 물리 엔진은 NVIDIA의 PhysX로, 실시간 물리 계산을 지원하여 로봇의 움직임과 상호작용을 현실적으로 시뮬레이션할 수 있다.</p>
<h4 id="physx">PhysX의 주요 기능</h4>
<ul>
<li><strong>충돌 감지</strong>: 객체 간의 충돌을 실시간으로 감지하고 처리한다.</li>
<li><strong>강체 역학</strong>: 물체의 질량, 관성, 마찰 등을 기반으로 움직임을 계산한다.</li>
<li><strong>조인트 시스템</strong>: 여러 물체를 연결하여 복잡한 구조와 움직임을 구현할 수 있다.</li>
<li><strong>유연성</strong>: 다양한 물리적 현상을 시뮬레이션할 수 있는 높은 유연성을 제공한다.</li>
</ul>
<h3 id="rigidbody">Rigidbody 설정</h3>
<p>Rigidbody는 Unity에서 물리 기반 객체를 생성하는 데 사용되는 핵심 컴포넌트이다. Rigidbody를 통해 객체는 중력의 영향을 받고, 충돌 시 반응하며, 물리적 힘을 적용받을 수 있다.</p>
<h4 id="rigidbody_1">Rigidbody의 주요 속성</h4>
<ul>
<li><strong>Mass (질량)</strong>: 객체의 질량을 설정한다. 질량이 클수록 더 많은 힘이 필요하다.</li>
<li><strong>Drag (공기 저항)</strong>: 객체가 이동할 때 받는 저항을 설정한다.</li>
<li><strong>Angular Drag (회전 저항)</strong>: 객체의 회전에 대한 저항을 설정한다.</li>
<li><strong>Use Gravity (중력 사용 여부)</strong>: 객체가 중력의 영향을 받을지 여부를 결정한다.</li>
<li><strong>Is Kinematic (키네마틱 여부)</strong>: 키네마틱 Rigidbody는 물리 엔진의 영향을 받지 않고, 스크립트로 직접 제어할 수 있다.</li>
</ul>
<h4 id="rigidbody_2">Rigidbody 추가 방법</h4>
<ol>
<li><strong>객체 선택</strong>: Hierarchy 창에서 물리 엔진을 적용할 객체를 선택한다.</li>
<li><strong>컴포넌트 추가</strong>: Inspector 창에서 "Add Component" 버튼을 클릭하고 "Rigidbody"를 검색하여 추가한다.</li>
<li><strong>속성 설정</strong>: 필요한 Rigidbody 속성을 설정한다.</li>
</ol>
<pre><code class="language-csharp">// Rigidbody에 힘을 적용하는 예제 스크립트
using UnityEngine;

public class ApplyForceExample : MonoBehaviour
{
    public Vector3 forceDirection = new Vector3(0, 10, 0);
    public float forceMagnitude = 5f;

    void Start()
    {
        Rigidbody rb = GetComponent&lt;Rigidbody&gt;();
        rb.AddForce(forceDirection.normalized * forceMagnitude, ForceMode.Impulse);
    }
}
</code></pre>
<h3 id="collider">Collider 설정</h3>
<p>Collider는 객체의 물리적 경계를 정의하여 충돌 감지를 가능하게 한다. 다양한 형태의 Collider가 있으며, 객체의 형태에 맞는 Collider를 선택하여 적용하는 것이 중요하다.</p>
<h4 id="collider_1">주요 Collider 유형</h4>
<ul>
<li><strong>Box Collider</strong>: 직육면체 형태의 Collider이다. 간단한 구조에 적합한다.</li>
<li><strong>Sphere Collider</strong>: 구 형태의 Collider로, 대칭적인 물체에 적합한다.</li>
<li><strong>Capsule Collider</strong>: 캡슐 형태의 Collider로, 사람이나 동물 같은 형태에 적합한다.</li>
<li><strong>Mesh Collider</strong>: 복잡한 형태의 Collider로, 정확한 충돌 감지가 필요할 때 사용한다.</li>
<li><strong>Wheel Collider</strong>: 자동차 휠과 같은 회전 가능한 물체에 특화된 Collider이다.</li>
</ul>
<h4 id="collider_2">Collider 추가 및 설정</h4>
<ol>
<li><strong>객체 선택</strong>: Collider를 추가할 객체를 선택한다.</li>
<li><strong>컴포넌트 추가</strong>: Inspector 창에서 "Add Component" 버튼을 클릭하고 원하는 Collider를 검색하여 추가한다.</li>
<li><strong>속성 설정</strong>: Collider의 크기, 위치, 회전 등을 설정하여 객체와 일치하도록 조정한다.</li>
</ol>
<pre><code class="language-csharp">// Collider 충돌 이벤트 처리 예제
using UnityEngine;

public class CollisionExample : MonoBehaviour
{
    void OnCollisionEnter(Collision collision)
    {
        Debug.Log(&quot;충돌한 객체: &quot; + collision.gameObject.name);
    }
}
</code></pre>
<h3 id="physics-material">Physics Material 설정</h3>
<p>Physics Material은 Collider의 표면 특성을 정의하여 마찰력과 탄성력을 설정할 수 있다. 이를 통해 객체 간의 상호작용을 더욱 현실적으로 만들 수 있다.</p>
<h4 id="physics-material_1">주요 Physics Material 속성</h4>
<ul>
<li><strong>Dynamic Friction (동적 마찰력)</strong>: 객체가 움직일 때 발생하는 마찰력을 설정한다.</li>
<li><strong>Static Friction (정적 마찰력)</strong>: 객체가 정지해 있을 때의 마찰력을 설정한다.</li>
<li><strong>Bounciness (탄성력)</strong>: 충돌 시 객체가 튕겨 나가는 정도를 설정한다.</li>
<li><strong>Friction Combine (마찰력 결합 방식)</strong>: 두 물체의 마찰력을 결합하는 방식을 설정한다.</li>
<li><strong>Bounce Combine (탄성력 결합 방식)</strong>: 두 물체의 탄성력을 결합하는 방식을 설정한다.</li>
</ul>
<h4 id="physics-material_2">Physics Material 생성 및 적용</h4>
<ol>
<li><strong>Material 생성</strong>: Project 창에서 마우스 오른쪽 버튼을 클릭하고 <strong>Create &gt; Physics Material</strong>을 선택한다.</li>
<li><strong>속성 설정</strong>: 생성된 Physics Material의 속성을 원하는 대로 설정한다.</li>
<li><strong>Collider에 적용</strong>: Collider 컴포넌트의 <strong>Material</strong> 필드에 생성한 Physics Material을 드래그 앤 드롭하여 적용한다.</li>
</ol>
<pre><code class="language-csharp">// Physics Material을 동적으로 변경하는 예제 스크립트
using UnityEngine;

public class ChangePhysicsMaterial : MonoBehaviour
{
    public PhysicsMaterial material1;
    public PhysicsMaterial material2;

    void OnMouseDown()
    {
        Collider col = GetComponent&lt;Collider&gt;();
        if (col.material == material1)
        {
            col.material = material2;
        }
        else
        {
            col.material = material1;
        }
    }
}
</code></pre>
<h3 id="_1">스크립팅을 통한 물리 엔진 제어</h3>
<p>Unity에서는 C# 스크립트를 사용하여 물리 엔진을 제어할 수 있다. 이를 통해 로봇의 움직임, 힘의 적용, 충돌 반응 등을 프로그래밍적으로 관리할 수 있다.</p>
<h4 id="rigidbody_3">Rigidbody 제어</h4>
<p>Rigidbody 컴포넌트를 통해 물리적 힘을 적용하거나 객체의 속도를 직접 설정할 수 있다.</p>
<pre><code class="language-csharp">// Rigidbody의 속도를 직접 설정하는 예제
using UnityEngine;

public class SetVelocityExample : MonoBehaviour
{
    public Vector3 initialVelocity = new Vector3(0, 5, 0);

    void Start()
    {
        Rigidbody rb = GetComponent&lt;Rigidbody&gt;();
        rb.velocity = initialVelocity;
    }
}
</code></pre>
<h4 id="_2">물리적 힘과 토크 적용</h4>
<p>힘과 토크는 객체에 물리적 영향을 주어 자연스러운 움직임을 생성하는 데 사용된다.</p>
<ul>
<li><strong>AddForce</strong>: 객체에 일정한 힘을 적용한다.</li>
<li><strong>AddTorque</strong>: 객체에 회전력을 적용한다.</li>
</ul>
<pre><code class="language-csharp">// 지속적으로 힘을 적용하여 객체를 이동시키는 예제
using UnityEngine;

public class ContinuousForce : MonoBehaviour
{
    public Vector3 force = new Vector3(0, 0, 10);
    public ForceMode forceMode = ForceMode.Force;

    void FixedUpdate()
    {
        Rigidbody rb = GetComponent&lt;Rigidbody&gt;();
        rb.AddForce(force, forceMode);
    }
}
</code></pre>
<h3 id="fixedupdate">물리 업데이트와 FixedUpdate</h3>
<p>Unity의 물리 계산은 <strong>FixedUpdate</strong> 메서드 내에서 처리된다. 이는 물리 연산이 일정한 시간 간격으로 업데이트되어 안정적인 시뮬레이션을 보장하기 위함이다. 따라서 물리 관련 코드는 <strong>FixedUpdate</strong>에서 작성하는 것이 권장된다.</p>
<pre><code class="language-csharp">// FixedUpdate를 사용한 물리적 힘 적용 예제
using UnityEngine;

public class FixedForceExample : MonoBehaviour
{
    public Vector3 force = new Vector3(0, 10, 0);

    void FixedUpdate()
    {
        Rigidbody rb = GetComponent&lt;Rigidbody&gt;();
        rb.AddForce(force);
    }
}
</code></pre>
<h3 id="_3">충돌 감지 및 처리</h3>
<p>충돌 이벤트는 <strong>OnCollisionEnter</strong>, <strong>OnCollisionStay</strong>, <strong>OnCollisionExit</strong> 등의 메서드를 통해 감지할 수 있다. 이를 활용하여 충돌 시 로봇의 행동을 제어하거나, 환경과의 상호작용을 구현할 수 있다.</p>
<pre><code class="language-csharp">// 충돌 시 소리 재생 예제
using UnityEngine;

public class CollisionSound : MonoBehaviour
{
    public AudioClip collisionClip;
    private AudioSource audioSource;

    void Start()
    {
        audioSource = GetComponent&lt;AudioSource&gt;();
    }

    void OnCollisionEnter(Collision collision)
    {
        audioSource.PlayOneShot(collisionClip);
    }
}
</code></pre>
<h3 id="_4">물리 엔진 고급 설정</h3>
<p>Unity의 물리 엔진은 기본 설정 외에도 다양한 고급 설정을 통해 시뮬레이션의 정확성과 성능을 최적화할 수 있다. 이 절에서는 물리 엔진의 고급 설정 방법과 이를 활용한 시뮬레이션 개선 방법에 대해 설명한다.</p>
<h4 id="global-physics-settings">물리 설정(Global Physics Settings)</h4>
<p>Unity는 프로젝트 전반에 걸쳐 적용되는 글로벌 물리 설정을 제공한다. 이러한 설정은 모든 물리 객체에 영향을 미치므로 신중하게 조정해야 한다.</p>
<ul>
<li><strong>Gravity (중력)</strong>: 중력 벡터를 설정하여 시뮬레이션 내의 모든 객체에 영향을 미치는 중력의 방향과 크기를 정의한다.</li>
</ul>
<p>$$
\mathbf{Gravity} = (0, -9.81, 0)</p>
<p>$$</p>
<p>기본값은 지구의 중력 가속도인 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Gravity} = (0, -9.81, 0)</span><script type="math/tex">\mathbf{Gravity} = (0, -9.81, 0)</script></span>이다. 필요에 따라 중력의 크기나 방향을 변경할 수 있다.</p>
<ul>
<li>
<p><strong>Default Solver Iterations (기본 솔버 반복 횟수)</strong>: 물리 엔진이 충돌과 접촉을 계산할 때 사용하는 반복 횟수를 설정한다. 값이 클수록 충돌 계산이 정확해지지만 성능에 영향을 미친다.</p>
</li>
<li>
<p><strong>Default Solver Velocity Iterations (기본 솔버 속도 반복 횟수)</strong>: 물체의 속도 계산에 사용되는 솔버 반복 횟수를 설정한다. 이 값 역시 정확도와 성능 간의 균형을 맞추는 데 중요하다.</p>
</li>
</ul>
<h4 id="_5">물리 재질의 고급 설정</h4>
<p>Physics Material을 통해 물체의 마찰력과 탄성력을 세부적으로 조정할 수 있다. 고급 설정을 통해 더욱 현실적인 상호작용을 구현할 수 있다.</p>
<ul>
<li>
<p><strong>Dynamic Friction Curve (동적 마찰 곡선)</strong>: 마찰력이 속도에 따라 어떻게 변화하는지 정의한다. 이를 통해 다양한 속도 범위에서의 마찰 특성을 세밀하게 조정할 수 있다.</p>
</li>
<li>
<p><strong>Static Friction Curve (정적 마찰 곡선)</strong>: 물체가 정지해 있을 때의 마찰력 변화를 정의한다. 마찰 곡선을 사용하면 특정 조건에서의 마찰 특성을 더 정밀하게 설정할 수 있다.</p>
</li>
<li>
<p><strong>Bounciness Curve (탄성 곡선)</strong>: 충돌 시 탄성력이 속도에 따라 어떻게 변화하는지 정의한다. 이를 통해 충돌 시의 반발력을 더욱 세밀하게 조정할 수 있다.</p>
</li>
</ul>
<h4 id="_6">레이어 기반 충돌 설정</h4>
<p>Unity는 레이어를 사용하여 객체 간의 충돌을 제어할 수 있다. 이를 통해 특정 레이어에 속한 객체들 간의 충돌 여부를 설정할 수 있어, 복잡한 시뮬레이션에서도 효율적으로 충돌을 관리할 수 있다.</p>
<ol>
<li>
<p><strong>레이어 정의</strong>: <code>Edit &gt; Project Settings &gt; Tags and Layers</code>에서 새로운 레이어를 추가한다.</p>
</li>
<li>
<p><strong>레이어 할당</strong>: 객체의 <code>Inspector</code> 창에서 원하는 레이어를 할당한다.</p>
</li>
<li>
<p><strong>충돌 매트릭스 설정</strong>: <code>Edit &gt; Project Settings &gt; Physics</code>에서 <code>Layer Collision Matrix</code>를 사용하여 특정 레이어 간의 충돌 여부를 설정한다.
$$
   \text{Layer Collision Matrix} = 
   \begin{bmatrix}
   \text{Layer 1} &amp; \text{Layer 2} &amp; \cdots &amp; \text{Layer N} \
   \end{bmatrix}</p>
</li>
</ol>
<p>$$</p>
<p>예를 들어, 로봇과 환경 객체가 충돌하지 않도록 설정할 수 있다.</p>
<h4 id="time-settings">물리 시간 설정(Time Settings)</h4>
<p>물리 시뮬레이션의 정확성과 성능은 시간 설정에 크게 의존한다. Unity는 고정된 시간 간격으로 물리 연산을 수행하며, 이를 통해 일관된 시뮬레이션을 보장한다.</p>
<ul>
<li><strong>Fixed Timestep (고정된 시간 간격)</strong>: 물리 업데이트가 호출되는 시간 간격을 설정한다. 기본값은 0.02초(50 FPS)로, 필요에 따라 조정할 수 있다.</li>
</ul>
<p>$$
\text{Fixed Timestep} = 0.02 \, \text{초}</p>
<p>$$</p>
<p>시간 간격을 줄이면 물리 시뮬레이션의 정확도가 증가하지만 성능 부담이 커진다. 반대로 시간을 늘리면 성능은 향상되지만 시뮬레이션의 정확도가 떨어질 수 있다.</p>
<ul>
<li><strong>Maximum Allowed Timestep (허용 최대 시간 간격)</strong>: 한 프레임에서 처리할 수 있는 최대 물리 시간 간격을 설정한다. 이 값을 초과하면 시뮬레이션이 보간된다.</li>
</ul>
<h4 id="_7">물리 디버깅 도구</h4>
<p>Unity는 물리 시뮬레이션을 디버깅하기 위한 다양한 도구를 제공한다. 이러한 도구를 활용하면 시뮬레이션의 문제를 효과적으로 식별하고 수정할 수 있다.</p>
<ul>
<li>
<p><strong>Physics Debug Visualization (물리 디버깅 시각화)</strong>: <code>Scene</code> 뷰에서 <code>Gizmos</code>를 활성화하면 Collider, Rigidbody, Joint 등의 물리 컴포넌트를 시각적으로 확인할 수 있다.</p>
</li>
<li>
<p><strong>Profiler (프로파일러)</strong>: Unity의 <code>Profiler</code> 창을 사용하여 물리 연산의 성능을 모니터링할 수 있다. 이를 통해 병목 현상을 식별하고 최적화할 수 있다.</p>
</li>
</ul>
<p>```csharp
  // 프로파일러를 사용하여 물리 연산 시간을 측정하는 예제
  using UnityEngine;
  using UnityEngine.Profiling;</p>
<p>public class PhysicsProfiler : MonoBehaviour
  {
      void FixedUpdate()
      {
          Profiler.BeginSample("Physics Update");</p>
<pre><code>      // 물리 관련 코드 실행

      Profiler.EndSample();
  }
</code></pre>
<p>}
  ```</p>
<h3 id="_8">스크립팅 환경 설정</h3>
<p>물리 엔진과의 효과적인 상호작용을 위해서는 Unity의 스크립팅 환경을 적절히 설정하고 활용하는 것이 중요하다. 이 절에서는 C# 스크립팅 환경의 기본 설정과 효율적인 스크립트 관리를 위한 방법을 다룬다.</p>
<h4 id="_9">개발 도구 통합</h4>
<p>Unity는 주로 C#을 사용하여 스크립트를 작성하며, Visual Studio 또는 다른 코드 편집기와의 통합을 지원한다.</p>
<ul>
<li>
<p><strong>Visual Studio 설치 및 설정</strong>: Unity를 설치할 때 Visual Studio가 함께 설치되도록 설정할 수 있다. Visual Studio는 강력한 디버깅 도구와 코드 완성 기능을 제공하여 개발 생산성을 향상시킨다.</p>
</li>
<li>
<p><strong>외부 편집기 설정</strong>: <code>Edit &gt; Preferences &gt; External Tools</code>에서 선호하는 코드 편집기를 선택할 수 있다. 예를 들어, Visual Studio Code나 Rider와 같은 다른 편집기를 사용할 수 있다.</p>
</li>
</ul>
<h4 id="_10">스크립트 템플릿 및 구조</h4>
<p>효율적인 스크립트 작성을 위해 일관된 템플릿과 구조를 사용하는 것이 중요하다.</p>
<ul>
<li><strong>MonoBehaviour 상속</strong>: 모든 스크립트는 <code>MonoBehaviour</code>를 상속받아야 하며, 이를 통해 Unity의 생명주기 메서드(<code>Start()</code>, <code>Update()</code>, <code>FixedUpdate()</code> 등)를 활용할 수 있다.</li>
</ul>
<p>```csharp
  using UnityEngine;</p>
<p>public class RobotController : MonoBehaviour
  {
      void Start()
      {
          // 초기화 코드
      }</p>
<pre><code>  void Update()
  {
      // 매 프레임 실행되는 코드
  }

  void FixedUpdate()
  {
      // 물리 연산 관련 코드
  }
</code></pre>
<p>}
  ```</p>
<ul>
<li><strong>네이밍 컨벤션</strong>: 변수와 메서드의 이름은 명확하고 일관되게 지정하여 코드의 가독성을 높인다. 예를 들어, <code>camelCase</code>는 로컬 변수와 메서드에, <code>PascalCase</code>는 클래스와 속성에 사용한다.</li>
</ul>
<h4 id="_11">스크립트 컴파일 설정</h4>
<p>Unity는 프로젝트 내의 모든 C# 스크립트를 자동으로 컴파일한다. 효율적인 컴파일 설정을 통해 개발 속도를 향상시킬 수 있다.</p>
<ul>
<li><strong>Assembly Definition Files (어셈블리 정의 파일)</strong>: 큰 프로젝트에서는 어셈블리 정의 파일을 사용하여 스크립트를 모듈화하고, 필요한 부분만 재컴파일하도록 설정할 수 있다. 이를 통해 컴파일 시간을 단축하고, 코드 관리가 용이해진다.</li>
</ul>
<p><code>plaintext
  // Example: Creating an Assembly Definition File
  1. Create a new folder, e.g., "Scripts/Robot"
  2. Right-click in the folder and select Create &gt; Assembly Definition
  3. Name it "RobotAssembly"
  4. Assign relevant scripts to this assembly</code></p>
<h4 id="_12">디버깅 및 로깅</h4>
<p>효과적인 디버깅과 로깅은 스크립트 개발에서 중요한 부분이다. Unity는 다양한 디버깅 도구와 로깅 기능을 제공한다.</p>
<ul>
<li><strong>Debug.Log 사용</strong>: <code>Debug.Log</code>, <code>Debug.Warning</code>, <code>Debug.Error</code>를 사용하여 콘솔에 메시지를 출력할 수 있다. 이는 코드의 흐름을 추적하거나 변수의 값을 확인하는 데 유용하다.</li>
</ul>
<p>```csharp
  using UnityEngine;</p>
<p>public class DebugExample : MonoBehaviour
  {
      void Start()
      {
          Debug.Log("시뮬레이션 시작");
      }</p>
<pre><code>  void Update()
  {
      if (Input.GetKeyDown(KeyCode.Space))
      {
          Debug.Log("스페이스 키가 눌렸다.");
      }
  }
</code></pre>
<p>}
  ```</p>
<ul>
<li>
<p><strong>브레이크포인트 설정</strong>: Visual Studio와 같은 IDE에서 브레이크포인트를 설정하여 코드의 특정 지점에서 실행을 일시 중지하고 변수의 상태를 확인할 수 있다.</p>
</li>
<li>
<p><strong>Profiler 활용</strong>: Unity Profiler를 사용하여 스크립트의 성능을 분석하고 최적화할 수 있다. 이는 특히 물리 연산과 관련된 성능 문제를 해결하는 데 유용하다.</p>
</li>
</ul>
<h3 id="_13">스크립팅을 통한 물리 엔진 제어</h3>
<p>물리 엔진과의 상호작용은 주로 C# 스크립트를 통해 이루어진다. 이를 통해 로봇의 동작을 정밀하게 제어하고, 시뮬레이션의 다양한 측면을 프로그래밍적으로 관리할 수 있다.</p>
<h4 id="_14">물리 속성 접근</h4>
<p>Rigidbody와 Collider 등의 물리 컴포넌트는 스크립트에서 직접 접근하고 수정할 수 있다. 이를 통해 실시간으로 물리 속성을 변경하거나, 특정 조건에 따라 물리 동작을 제어할 수 있다.</p>
<ul>
<li><strong>Rigidbody 속성 변경</strong>: 질량, 드래그, 속도 등의 속성을 실시간으로 변경할 수 있다.</li>
</ul>
<p>```csharp
  using UnityEngine;</p>
<p>public class RigidbodyController : MonoBehaviour
  {
      private Rigidbody rb;</p>
<pre><code>  void Start()
  {
      rb = GetComponent&lt;Rigidbody&gt;();
      rb.mass = 10f;
      rb.drag = 1f;
  }

  void Update()
  {
      if (Input.GetKeyDown(KeyCode.UpArrow))
      {
          rb.mass += 1f;
          Debug.Log("현재 질량: " + rb.mass);
      }
  }
</code></pre>
<p>}
  ```</p>
<ul>
<li><strong>Collider 속성 변경</strong>: Collider의 크기나 모양을 동적으로 변경할 수 있다.</li>
</ul>
<p>```csharp
  using UnityEngine;</p>
<p>public class ColliderController : MonoBehaviour
  {
      private BoxCollider boxCollider;</p>
<pre><code>  void Start()
  {
      boxCollider = GetComponent&lt;BoxCollider&gt;();
  }

  void Update()
  {
      if (Input.GetKeyDown(KeyCode.C))
      {
          boxCollider.size += new Vector3(1, 1, 1);
          Debug.Log("Collider 크기 변경: " + boxCollider.size);
      }
  }
</code></pre>
<p>}
  ```</p>
<h4 id="_15">물리 이벤트 활용</h4>
<p>Unity는 다양한 물리 이벤트를 제공하여 충돌이나 트리거와 같은 물리적 상호작용을 감지하고 처리할 수 있다.</p>
<ul>
<li><strong>OnCollisionEnter</strong>: 두 물체가 충돌했을 때 호출된다.</li>
</ul>
<p>```csharp
  using UnityEngine;</p>
<p>public class CollisionHandler : MonoBehaviour
  {
      void OnCollisionEnter(Collision collision)
      {
          Debug.Log(gameObject.name + "이(가) " + collision.gameObject.name + "과(와) 충돌하였다.");
      }
  }
  ```</p>
<ul>
<li><strong>OnTriggerEnter</strong>: 트리거 영역에 다른 물체가 들어왔을 때 호출된다.</li>
</ul>
<p>```csharp
  using UnityEngine;</p>
<p>public class TriggerHandler : MonoBehaviour
  {
      void OnTriggerEnter(Collider other)
      {
          Debug.Log(other.gameObject.name + "이(가) 트리거에 진입하였다.");
      }
  }
  ```</p>
<h4 id="_16">물리 기반 애니메이션 제어</h4>
<p>물리 엔진을 활용하여 로봇의 애니메이션을 자연스럽게 제어할 수 있다. 예를 들어, 힘과 토크를 적용하여 로봇의 조인트를 움직이거나, 외부 힘에 반응하는 애니메이션을 구현할 수 있다.</p>
<ul>
<li><strong>힘과 토크 적용을 통한 애니메이션</strong>:</li>
</ul>
<p>```csharp
  using UnityEngine;</p>
<p>public class JointController : MonoBehaviour
  {
      public Rigidbody jointRigidbody;
      public Vector3 forceDirection = new Vector3(0, 100, 0);
      public Vector3 torqueDirection = new Vector3(10, 0, 0);</p>
<pre><code>  void Update()
  {
      if (Input.GetKey(KeyCode.F))
      {
          jointRigidbody.AddForce(forceDirection * Time.deltaTime);
      }

      if (Input.GetKey(KeyCode.T))
      {
          jointRigidbody.AddTorque(torqueDirection * Time.deltaTime);
      }
  }
</code></pre>
<p>}
  ```</p>
<ul>
<li><strong>외부 힘에 반응하는 애니메이션</strong>:</li>
</ul>
<p>```csharp
  using UnityEngine;</p>
<p>public class ReactionAnimation : MonoBehaviour
  {
      private Animator animator;
      private Rigidbody rb;</p>
<pre><code>  void Start()
  {
      animator = GetComponent&lt;Animator&gt;();
      rb = GetComponent&lt;Rigidbody&gt;();
  }

  void OnCollisionEnter(Collision collision)
  {
      if (collision.relativeVelocity.magnitude &gt; 2f)
      {
          animator.SetTrigger("Hit");
      }
  }
</code></pre>
<p>}
  ```</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter%2003/0301/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter%2003/0301/" class="btn btn-xs btn-link">
        URDF 파일을 이용한 로봇 모델링
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0202/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0202/" class="btn btn-xs btn-link">
        기본 프로젝트 구성
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>