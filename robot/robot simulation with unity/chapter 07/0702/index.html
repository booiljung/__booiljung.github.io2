<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot%20simulation%20with%20unity/chapter%2007/0702/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>ROS 메시지 구조 및 Unity에서의 사용 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "ROS \uba54\uc2dc\uc9c0\uc758 \uae30\ubcf8 \uad6c\uc870", url: "#_top", children: [
          ]},
          {title: "\uba54\uc2dc\uc9c0 \ud0c0\uc785", url: "#_1", children: [
          ]},
          {title: "\uba54\uc2dc\uc9c0 \uc9c1\ub82c\ud654 \ubc0f \uc5ed\uc9c1\ub82c\ud654", url: "#_2", children: [
          ]},
          {title: "Unity\uc5d0\uc11c ROS \uba54\uc2dc\uc9c0 \uc0ac\uc6a9\ud558\uae30", url: "#unity-ros", children: [
              {title: "ROS# \ud328\ud0a4\uc9c0 \uc124\uce58", url: "#ros_1" },
              {title: "\uba54\uc2dc\uc9c0 \uc815\uc758 \ubc0f \ub9e4\ud551", url: "#_3" },
              {title: "\ud37c\ube14\ub9ac\uc154\uc640 \uc11c\ube0c\uc2a4\ud06c\ub77c\uc774\ubc84 \uad6c\ud604", url: "#_4" },
          ]},
          {title: "\uba54\uc2dc\uc9c0 \ub3d9\uae30\ud654 \ubc0f \uc2dc\uac04 \uad00\ub9ac", url: "#_5", children: [
          ]},
          {title: "\uc5d0\ub7ec \ucc98\ub9ac \ubc0f \ub514\ubc84\uae45", url: "#_6", children: [
          ]},
          {title: "\uba54\uc2dc\uc9c0 \ud544\ud130\ub9c1 \ubc0f \uc870\uac74\ubd80 \ucc98\ub9ac", url: "#_7", children: [
              {title: "\uba54\uc2dc\uc9c0 \ud544\ud130\ub9c1", url: "#_8" },
              {title: "\uc870\uac74\ubd80 \ucc98\ub9ac", url: "#_9" },
          ]},
          {title: "\uba54\uc2dc\uc9c0 \ubcc0\ud658 \ubc0f \ub370\uc774\ud130 \ub9e4\ud551", url: "#_10", children: [
              {title: "\uc704\uce58 \ubc0f \uc790\uc138 \ub370\uc774\ud130 \ub9e4\ud551", url: "#_11" },
              {title: "\uc13c\uc11c \ub370\uc774\ud130 \ub9e4\ud551", url: "#_12" },
          ]},
          {title: "\uace0\uae09 \uba54\uc2dc\uc9c0 \ucc98\ub9ac \uae30\ubc95", url: "#_13", children: [
              {title: "\uba54\uc2dc\uc9c0 \ud050 \uad00\ub9ac", url: "#_14" },
              {title: "\ube44\ub3d9\uae30 \uba54\uc2dc\uc9c0 \ucc98\ub9ac", url: "#_15" },
          ]},
          {title: "\uba54\uc2dc\uc9c0 \ud0c0\uc785 \ud655\uc7a5 \ubc0f \uc0ac\uc6a9\uc790 \uc815\uc758 \uba54\uc2dc\uc9c0", url: "#_16", children: [
              {title: "\uc0ac\uc6a9\uc790 \uc815\uc758 \uba54\uc2dc\uc9c0 \uc815\uc758", url: "#_17" },
              {title: "\uc0ac\uc6a9\uc790 \uc815\uc758 \uba54\uc2dc\uc9c0 \ube4c\ub4dc \ubc0f Unity \uc5f0\ub3d9", url: "#unity" },
          ]},
          {title: "\uba54\uc2dc\uc9c0 \ubcf4\uc548 \ubc0f \uc778\uc99d", url: "#_18", children: [
              {title: "\ubcf4\uc548 \ud504\ub85c\ud1a0\ucf5c \uc0ac\uc6a9", url: "#_19" },
              {title: "\uc778\uc99d \uba54\ucee4\ub2c8\uc998 \uad6c\ud604", url: "#_20" },
          ]},
          {title: "\uc131\ub2a5 \ucd5c\uc801\ud654 \ud301", url: "#_21", children: [
              {title: "\uba54\uc2dc\uc9c0 \ube48\ub3c4 \uc870\uc808", url: "#_22" },
              {title: "\uba54\uc2dc\uc9c0 \uc555\ucd95 \uc0ac\uc6a9", url: "#_23" },
              {title: "\ubd88\ud544\uc694\ud55c \ub370\uc774\ud130 \uc81c\uac70", url: "#_24" },
          ]},
          {title: "\uc720\ub2db \ud14c\uc2a4\ud2b8 \ubc0f \uac80\uc99d", url: "#_25", children: [
              {title: "Unity\uc5d0\uc11c\uc758 \uc720\ub2db \ud14c\uc2a4\ud2b8 \uc791\uc131", url: "#unity_1" },
              {title: "\ud1b5\ud569 \ud14c\uc2a4\ud2b8", url: "#_26" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0703/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0703/" class="btn btn-xs btn-link">
        ROS-Unity 통합 시뮬레이션 환경 구성
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0701/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0701/" class="btn btn-xs btn-link">
        ROS와 Unity의 통신 방법
      </a>
    </div>
    
  </div>

    

    <p>로봇 운영 체제(ROS)는 로봇 애플리케이션 개발을 위한 강력한 프레임워크로, 다양한 메시지 타입을 통해 로봇의 센서 데이터, 제어 명령 등을 주고받는다. Unity와의 연동에서는 이러한 ROS 메시지를 효과적으로 처리하고 활용하는 것이 중요하다. 이 절에서는 ROS 메시지의 구조와 Unity에서의 사용 방법에 대해 상세히 설명한다.</p>
<h3 id="ros">ROS 메시지의 기본 구조</h3>
<p>ROS 메시지는 데이터를 주고받기 위한 기본 단위로, 다양한 타입의 필드를 포함할 수 있다. 각 메시지는 <code>.msg</code> 파일로 정의되며, 다음과 같은 형식을 갖는다.</p>
<pre><code class="language-plaintext">타입 필드이름
타입 필드이름
...
</code></pre>
<p>예를 들어, <code>geometry_msgs/Point</code> 메시지는 다음과 같이 정의된다.</p>
<pre><code class="language-plaintext">float64 x
float64 y
float64 z
</code></pre>
<p>이 메시지는 3차원 공간에서의 한 점을 나타내는 <code>x</code>, <code>y</code>, <code>z</code> 좌표를 포함한다.</p>
<h3 id="_1">메시지 타입</h3>
<p>ROS는 다양한 기본 메시지 타입을 제공하며, 사용자 정의 메시지도 가능한다. 주요 메시지 타입은 다음과 같다.</p>
<ul>
<li><strong>기본 타입</strong>: <code>int32</code>, <code>float64</code>, <code>string</code> 등</li>
<li><strong>복합 타입</strong>: <code>geometry_msgs/Point</code>, <code>sensor_msgs/Image</code> 등</li>
<li><strong>배열 타입</strong>: <code>float64[]</code>, <code>geometry_msgs/Point[]</code> 등</li>
</ul>
<p>복합 타입 메시지는 다른 메시지를 포함할 수 있어, 복잡한 데이터 구조를 표현할 수 있다.</p>
<h3 id="_2">메시지 직렬화 및 역직렬화</h3>
<p>ROS 메시지는 네트워크를 통해 전송되기 전에 직렬화(serialization)되어야 한다. 직렬화는 메시지를 바이트 스트림으로 변환하는 과정이며, 역직렬화는 이를 다시 원래의 메시지 구조로 복원하는 과정이다. Unity에서는 ROS와의 통신을 위해 이러한 직렬화 및 역직렬화를 처리해야 한다.</p>
<h3 id="unity-ros">Unity에서 ROS 메시지 사용하기</h3>
<p>Unity에서 ROS 메시지를 사용하기 위해서는 ROS와의 통신을 설정하고, 메시지를 송수신하는 방법을 구현해야 한다. 이를 위해 일반적으로 다음과 같은 단계를 거친다.</p>
<h4 id="ros_1">ROS# 패키지 설치</h4>
<p>ROS#는 Unity와 ROS 간의 통신을 지원하는 오픈 소스 프로젝트이다. ROS#를 사용하면 WebSocket을 통해 ROS 노드와 Unity 간에 메시지를 주고받을 수 있다. ROS# 설치 방법은 다음과 같다.</p>
<ol>
<li>ROS# GitHub 저장소에서 최신 버전을 다운로드한다.</li>
<li>Unity 프로젝트에 ROS# 패키지를 임포트한다.</li>
<li>필요한 ROS 노드와의 통신 설정을 구성한다.</li>
</ol>
<h4 id="_3">메시지 정의 및 매핑</h4>
<p>Unity에서 ROS 메시지를 사용하려면, ROS 메시지 타입과 Unity 스크립트 간의 매핑이 필요하다. 예를 들어, <code>geometry_msgs/Point</code> 메시지를 Unity의 <code>Vector3</code> 타입으로 매핑할 수 있다.</p>
<pre><code class="language-csharp">using UnityEngine;
using RosMessageTypes.Geometry;

public class PointSubscriber : MonoBehaviour
{
    void Start()
    {
        RosConnector ros = GetComponent&lt;RosConnector&gt;();
        ros.Subscribe&lt;PointMsg&gt;(&quot;point_topic&quot;, OnPointReceived);
    }

    void OnPointReceived(PointMsg msg)
    {
        Vector3 point = new Vector3((float)msg.x, (float)msg.y, (float)msg.z);
        // Unity 오브젝트에 적용
    }
}
</code></pre>
<h4 id="_4">퍼블리셔와 서브스크라이버 구현</h4>
<p>Unity에서 ROS 메시지를 퍼블리시(publish)하거나 서브스크라이브(subscribe)하려면, 각각의 역할에 맞는 스크립트를 작성해야 한다.</p>
<p><strong>퍼블리셔 예제:</strong></p>
<pre><code class="language-csharp">using UnityEngine;
using RosMessageTypes.Geometry;

public class PointPublisher : MonoBehaviour
{
    private RosConnector ros;
    private Publisher&lt;PointMsg&gt; publisher;

    void Start()
    {
        ros = GetComponent&lt;RosConnector&gt;();
        publisher = ros.Advertise&lt;PointMsg&gt;(&quot;point_topic&quot;);
    }

    void Update()
    {
        PointMsg msg = new PointMsg
        {
            x = transform.position.x,
            y = transform.position.y,
            z = transform.position.z
        };
        publisher.Publish(msg);
    }
}
</code></pre>
<p><strong>서브스크라이버 예제:</strong></p>
<pre><code class="language-csharp">using UnityEngine;
using RosMessageTypes.Geometry;

public class PointSubscriber : MonoBehaviour
{
    private RosConnector ros;

    void Start()
    {
        ros = GetComponent&lt;RosConnector&gt;();
        ros.Subscribe&lt;PointMsg&gt;(&quot;point_topic&quot;, OnPointReceived);
    }

    void OnPointReceived(PointMsg msg)
    {
        Vector3 position = new Vector3((float)msg.x, (float)msg.y, (float)msg.z);
        transform.position = position;
    }
}
</code></pre>
<h3 id="_5">메시지 동기화 및 시간 관리</h3>
<p>ROS 메시지는 시간 동기화가 중요하다. 메시지의 헤더(Header)에는 타임스탬프가 포함되어 있어, Unity와 ROS 간의 시간 차이를 관리할 수 있다. 이를 통해 시뮬레이션의 정확성을 높일 수 있다.</p>
<pre><code class="language-plaintext">std_msgs/Header header
</code></pre>
<p>헤더 정보는 메시지의 출처, 시퀀스 번호, 타임스탬프 등을 포함한다.</p>
<h3 id="_6">에러 처리 및 디버깅</h3>
<p>ROS와 Unity 간의 통신에서 발생할 수 있는 에러를 처리하고 디버깅하는 것은 안정적인 시스템 구축에 필수적이다. ROS#에서는 로그 메시지를 통해 통신 상태를 모니터링할 수 있으며, Unity의 디버그 도구를 활용하여 문제를 신속하게 해결할 수 있다.</p>
<h3 id="_7">메시지 필터링 및 조건부 처리</h3>
<p>복잡한 로봇 시뮬레이션 환경에서는 다양한 종류의 메시지가 빈번하게 송수신된다. 이때, 필요한 메시지만을 필터링하여 처리하는 것은 성능 최적화와 효율적인 데이터 관리에 중요하다. Unity에서 메시지를 필터링하고 조건부로 처리하는 방법은 다음과 같다.</p>
<h4 id="_8">메시지 필터링</h4>
<p>ROS에서는 특정 조건을 만족하는 메시지에만 반응하도록 설정할 수 있다. 예를 들어, 특정 범위 내의 센서 데이터만 처리하거나, 특정 이벤트가 발생했을 때만 메시지를 처리할 수 있다. 이를 구현하기 위해서는 메시지를 수신한 후 조건을 검사하는 로직을 추가하면 된다.</p>
<pre><code class="language-csharp">using UnityEngine;
using RosMessageTypes.Sensor;

public class LidarSubscriber : MonoBehaviour
{
    private RosConnector ros;

    void Start()
    {
        ros = GetComponent&lt;RosConnector&gt;();
        ros.Subscribe&lt;LaserScanMsg&gt;(&quot;lidar_topic&quot;, OnLidarReceived);
    }

    void OnLidarReceived(LaserScanMsg msg)
    {
        // 특정 거리 범위 내의 데이터만 처리
        foreach (var range in msg.ranges)
        {
            if (range &lt; 10.0)
            {
                // 처리 로직
            }
        }
    }
}
</code></pre>
<h4 id="_9">조건부 처리</h4>
<p>메시지를 조건부로 처리함으로써 불필요한 연산을 줄이고, 시스템의 효율성을 높일 수 있다. 예를 들어, 특정 로봇의 상태가 활성화된 경우에만 메시지를 처리하도록 설정할 수 있다.</p>
<pre><code class="language-csharp">using UnityEngine;
using RosMessageTypes.Std;

public class ConditionalSubscriber : MonoBehaviour
{
    private RosConnector ros;
    public bool isActive = true;

    void Start()
    {
        ros = GetComponent&lt;RosConnector&gt;();
        ros.Subscribe&lt;BoolMsg&gt;(&quot;control_topic&quot;, OnControlReceived);
    }

    void OnControlReceived(BoolMsg msg)
    {
        if (msg.data &amp;&amp; isActive)
        {
            // 활성화된 상태에서만 처리
        }
    }
}
</code></pre>
<h3 id="_10">메시지 변환 및 데이터 매핑</h3>
<p>ROS 메시지와 Unity 데이터 타입 간의 변환은 시뮬레이션의 정확성을 유지하는 데 필수적이다. 다양한 메시지 타입을 Unity에서 적절히 활용하기 위해서는 데이터 매핑이 정확하게 이루어져야 한다.</p>
<h4 id="_11">위치 및 자세 데이터 매핑</h4>
<p>로봇의 위치와 자세를 나타내는 메시지는 <code>geometry_msgs/Pose</code>와 같은 타입을 사용한다. Unity에서는 이를 <code>Transform</code> 컴포넌트와 매핑하여 로봇 모델의 위치와 회전을 업데이트할 수 있다.</p>
<pre><code class="language-csharp">using UnityEngine;
using RosMessageTypes.Geometry;

public class PoseSubscriber : MonoBehaviour
{
    private RosConnector ros;

    void Start()
    {
        ros = GetComponent&lt;RosConnector&gt;();
        ros.Subscribe&lt;PoseMsg&gt;(&quot;pose_topic&quot;, OnPoseReceived);
    }

    void OnPoseReceived(PoseMsg msg)
    {
        Vector3 position = new Vector3((float)msg.position.x, (float)msg.position.y, (float)msg.position.z);
        Quaternion rotation = new Quaternion((float)msg.orientation.x, (float)msg.orientation.y, (float)msg.orientation.z, (float)msg.orientation.w);
        transform.position = position;
        transform.rotation = rotation;
    }
}
</code></pre>
<h4 id="_12">센서 데이터 매핑</h4>
<p>센서 데이터는 다양한 형태로 제공되며, Unity에서 이를 시각화하거나 추가 처리하기 위해 적절한 데이터 타입으로 변환해야 한다. 예를 들어, 카메라 이미지 데이터를 처리하는 경우 <code>sensor_msgs/Image</code> 메시지를 Unity의 텍스처로 변환할 수 있다.</p>
<pre><code class="language-csharp">using UnityEngine;
using RosMessageTypes.Sensor;

public class ImageSubscriber : MonoBehaviour
{
    private RosConnector ros;
    public Renderer cameraRenderer;

    void Start()
    {
        ros = GetComponent&lt;RosConnector&gt;();
        ros.Subscribe&lt;ImageMsg&gt;(&quot;camera_topic&quot;, OnImageReceived);
    }

    void OnImageReceived(ImageMsg msg)
    {
        Texture2D texture = new Texture2D(msg.width, msg.height, TextureFormat.RGB24, false);
        texture.LoadRawTextureData(msg.data);
        texture.Apply();
        cameraRenderer.material.mainTexture = texture;
    }
}
</code></pre>
<h3 id="_13">고급 메시지 처리 기법</h3>
<p>복잡한 시뮬레이션에서는 단순한 메시지 송수신 외에도 다양한 고급 메시지 처리 기법이 필요하다. 이러한 기법을 통해 시뮬레이션의 정밀도와 효율성을 높일 수 있다.</p>
<h4 id="_14">메시지 큐 관리</h4>
<p>메시지 큐는 수신된 메시지를 일시적으로 저장하고 순차적으로 처리하는 역할을 한다. Unity의 메인 스레드에서 메시지를 처리할 때, 메시지 큐를 활용하면 스레드 안전성을 유지하면서 효율적으로 메시지를 처리할 수 있다.</p>
<pre><code class="language-csharp">using UnityEngine;
using RosMessageTypes.Geometry;
using System.Collections.Concurrent;

public class ThreadSafeSubscriber : MonoBehaviour
{
    private RosConnector ros;
    private ConcurrentQueue&lt;PoseMsg&gt; messageQueue = new ConcurrentQueue&lt;PoseMsg&gt;();

    void Start()
    {
        ros = GetComponent&lt;RosConnector&gt;();
        ros.Subscribe&lt;PoseMsg&gt;(&quot;pose_topic&quot;, EnqueueMessage);
    }

    void EnqueueMessage(PoseMsg msg)
    {
        messageQueue.Enqueue(msg);
    }

    void Update()
    {
        while (messageQueue.TryDequeue(out PoseMsg msg))
        {
            // 메인 스레드에서 메시지 처리
            Vector3 position = new Vector3((float)msg.position.x, (float)msg.position.y, (float)msg.position.z);
            Quaternion rotation = new Quaternion((float)msg.orientation.x, (float)msg.orientation.y, (float)msg.orientation.z, (float)msg.orientation.w);
            transform.position = position;
            transform.rotation = rotation;
        }
    }
}
</code></pre>
<h4 id="_15">비동기 메시지 처리</h4>
<p>비동기 메시지 처리를 통해 Unity의 메인 스레드가 블로킹되지 않도록 할 수 있다. 이는 특히 대량의 데이터를 처리할 때 유용하며, 시뮬레이션의 부드러움을 유지하는 데 도움이 된다.</p>
<pre><code class="language-csharp">using UnityEngine;
using RosMessageTypes.Geometry;
using System.Threading.Tasks;

public class AsyncSubscriber : MonoBehaviour
{
    private RosConnector ros;

    void Start()
    {
        ros = GetComponent&lt;RosConnector&gt;();
        ros.Subscribe&lt;PoseMsg&gt;(&quot;pose_topic&quot;, OnPoseReceivedAsync);
    }

    async void OnPoseReceivedAsync(PoseMsg msg)
    {
        await Task.Run(() =&gt;
        {
            Vector3 position = new Vector3((float)msg.position.x, (float)msg.position.y, (float)msg.position.z);
            Quaternion rotation = new Quaternion((float)msg.orientation.x, (float)msg.orientation.y, (float)msg.orientation.z, (float)msg.orientation.w);
            // 추가적인 비동기 처리 로직
        });

        // 메인 스레드에서의 후처리
        Vector3 mainPosition = new Vector3((float)msg.position.x, (float)msg.position.y, (float)msg.position.z);
        Quaternion mainRotation = new Quaternion((float)msg.orientation.x, (float)msg.orientation.y, (float)msg.orientation.z, (float)msg.orientation.w);
        transform.position = mainPosition;
        transform.rotation = mainRotation;
    }
}
</code></pre>
<h3 id="_16">메시지 타입 확장 및 사용자 정의 메시지</h3>
<p>ROS의 강력한 기능 중 하나는 사용자 정의 메시지를 정의할 수 있다는 점이다. 이를 통해 특정 시뮬레이션 요구사항에 맞는 메시지 타입을 생성하고, Unity에서 이를 활용할 수 있다.</p>
<h4 id="_17">사용자 정의 메시지 정의</h4>
<p>사용자 정의 메시지는 <code>.msg</code> 파일을 생성하여 정의할 수 있다. 예를 들어, 로봇의 상태 정보를 포함하는 <code>RobotStatus.msg</code>를 정의할 수 있다.</p>
<pre><code class="language-plaintext">Header header
string state
float64 battery_level
geometry_msgs/Pose current_pose
</code></pre>
<h4 id="unity">사용자 정의 메시지 빌드 및 Unity 연동</h4>
<p>사용자 정의 메시지를 사용하려면, ROS 패키지를 빌드하여 메시지 타입을 생성한 후, ROS#를 통해 Unity에 연동해야 한다.</p>
<ol>
<li>
<p><strong>ROS 패키지 빌드</strong>: 사용자 정의 메시지가 포함된 ROS 패키지를 빌드한다.
    <code>bash
    cd ~/catkin_ws
    catkin_make
    source devel/setup.bash</code></p>
</li>
<li>
<p><strong>ROS#에서 메시지 가져오기</strong>: ROS#의 <code>RosBridgeClient</code>에서 사용자 정의 메시지를 인식할 수 있도록 설정한다. <code>RosBridgeClient</code>의 설정 파일에 메시지 타입을 추가한다.</p>
</li>
<li>
<p><strong>Unity 스크립트에서 메시지 사용</strong>:
    ```csharp
    using UnityEngine;
    using RosMessageTypes.RobotStatus;</p>
<p>public class RobotStatusSubscriber : MonoBehaviour
{
    private RosConnector ros;</p>
<pre><code>void Start()
{
    ros = GetComponent&lt;RosConnector&gt;();
    ros.Subscribe&lt;RobotStatusMsg&gt;("robot_status_topic", OnRobotStatusReceived);
}

void OnRobotStatusReceived(RobotStatusMsg msg)
{
    // 로봇 상태 정보 처리
    string state = msg.state;
    float battery = (float)msg.battery_level;
    Vector3 position = new Vector3((float)msg.current_pose.position.x, (float)msg.current_pose.position.y, (float)msg.current_pose.position.z);
    Quaternion rotation = new Quaternion((float)msg.current_pose.orientation.x, (float)msg.current_pose.orientation.y, (float)msg.current_pose.orientation.z, (float)msg.current_pose.orientation.w);

    // 예: UI 업데이트 또는 로봇 모델 상태 변경
}
</code></pre>
<p>}
```</p>
</li>
</ol>
<h3 id="_18">메시지 보안 및 인증</h3>
<p>ROS와 Unity 간의 통신에서 보안과 인증은 중요한 요소이다. 특히, 네트워크를 통해 데이터를 주고받을 때는 데이터의 무결성과 기밀성을 보장하는 것이 필요하다.</p>
<h4 id="_19">보안 프로토콜 사용</h4>
<p>ROS는 기본적으로 보안 기능을 제공하지 않으므로, 보안 프로토콜을 추가로 설정해야 한다. WebSocket Secure (WSS)를 사용하여 데이터 전송 시 암호화를 적용할 수 있다.</p>
<pre><code class="language-csharp">// ROS# 설정에서 WebSocket을 WSS로 변경
RosSocket = new RosSocket(new RosSharp.RosBridgeClient.Protocols.WebSocketSharpProtocol(&quot;wss://your_ros_bridge_server:9090&quot;));
</code></pre>
<h4 id="_20">인증 메커니즘 구현</h4>
<p>인증을 통해 신뢰할 수 있는 클라이언트와 서버만 통신할 수 있도록 설정한다. 이는 OAuth, JWT(Json Web Token) 등 다양한 인증 방식을 통해 구현할 수 있다.</p>
<pre><code class="language-csharp">// 예: JWT를 사용한 인증
string jwtToken = &quot;your_jwt_token&quot;;
RosSocket = new RosSocket(new RosSharp.RosBridgeClient.Protocols.WebSocketSharpProtocol(&quot;wss://your_ros_bridge_server:9090&quot;, jwtToken));
</code></pre>
<h3 id="_21">성능 최적화 팁</h3>
<p>Unity와 ROS 간의 통신은 실시간 시뮬레이션의 핵심 요소이므로, 성능 최적화가 중요하다. 다음은 메시지 처리 성능을 향상시키기 위한 몇 가지 팁이다.</p>
<h4 id="_22">메시지 빈도 조절</h4>
<p>필요 이상의 메시지를 송수신하지 않도록 메시지 빈도를 조절한다. 예를 들어, 센서 데이터의 경우, 실제 필요에 맞는 빈도로 메시지를 발행하도록 설정한다.</p>
<pre><code class="language-csharp">public class SensorPublisher : MonoBehaviour
{
    private RosConnector ros;
    private Publisher&lt;SensorMsg&gt; publisher;
    public float publishRate = 10.0f; // 초당 10회

    void Start()
    {
        ros = GetComponent&lt;RosConnector&gt;();
        publisher = ros.Advertise&lt;SensorMsg&gt;(&quot;sensor_topic&quot;);
        InvokeRepeating(&quot;PublishSensorData&quot;, 0, 1.0f / publishRate);
    }

    void PublishSensorData()
    {
        SensorMsg msg = new SensorMsg
        {
            // 센서 데이터 설정
        };
        publisher.Publish(msg);
    }
}
</code></pre>
<h4 id="_23">메시지 압축 사용</h4>
<p>메시지 데이터를 압축하여 네트워크 대역폭을 절약하고 전송 속도를 향상시킬 수 있다. ROS#에서는 메시지 압축을 지원하는 플러그인을 활용할 수 있다.</p>
<pre><code class="language-csharp">// 메시지 압축을 위한 설정 예제
RosSocket = new RosSocket(new RosSharp.RosBridgeClient.Protocols.WebSocketSharpProtocol(&quot;ws://your_ros_bridge_server:9090&quot;, compress: true));
</code></pre>
<h4 id="_24">불필요한 데이터 제거</h4>
<p>필요하지 않은 데이터는 메시지에서 제외하여 데이터 전송량을 줄이다. 예를 들어, 로봇의 특정 상태 정보만 필요하다면, 다른 상태 정보는 메시지에서 제거한다.</p>
<pre><code class="language-plaintext">Header header
string state
float64 battery_level
</code></pre>
<h3 id="_25">유닛 테스트 및 검증</h3>
<p>ROS 메시지 구조와 Unity에서의 사용을 올바르게 구현했는지 검증하기 위해 유닛 테스트를 작성하는 것이 중요하다. 이는 코드의 신뢰성을 높이고, 잠재적인 버그를 사전에 발견하는 데 도움을 준다.</p>
<h4 id="unity_1">Unity에서의 유닛 테스트 작성</h4>
<p>Unity는 자체적으로 유닛 테스트 프레임워크를 제공하므로, 이를 활용하여 메시지 처리 로직을 테스트할 수 있다.</p>
<pre><code class="language-csharp">using NUnit.Framework;
using UnityEngine;
using RosMessageTypes.Geometry;

public class PoseSubscriberTests
{
    [Test]
    public void TestOnPoseReceived()
    {
        // Arrange
        GameObject testObject = new GameObject();
        PoseSubscriber subscriber = testObject.AddComponent&lt;PoseSubscriber&gt;();
        PoseMsg testMsg = new PoseMsg
        {
            position = new PointMsg { x = 1.0, y = 2.0, z = 3.0 },
            orientation = new QuaternionMsg { x = 0.0, y = 0.0, z = 0.0, w = 1.0 }
        };

        // Act
        subscriber.OnPoseReceived(testMsg);

        // Assert
        Assert.AreEqual(new Vector3(1.0f, 2.0f, 3.0f), testObject.transform.position);
        Assert.AreEqual(new Quaternion(0.0f, 0.0f, 0.0f, 1.0f), testObject.transform.rotation);
    }
}
</code></pre>
<h4 id="_26">통합 테스트</h4>
<p>Unity와 ROS 간의 통합을 테스트하기 위해, 실제 ROS 노드와 Unity 간의 통신을 시뮬레이션하는 통합 테스트를 수행할 수 있다. 이를 통해 전체 시스템의 동작을 검증하고, 통신 과정에서 발생할 수 있는 문제를 사전에 발견할 수 있다.</p>
<pre><code class="language-csharp">using NUnit.Framework;
using UnityEngine;
using RosMessageTypes.Geometry;
using RosSharp.RosBridgeClient;

public class IntegrationTests
{
    [Test]
    public void TestPoseCommunication()
    {
        // ROS 노드 시뮬레이션
        RosConnector rosConnector = new GameObject().AddComponent&lt;RosConnector&gt;();
        rosConnector.RosSocket = new RosSocket(new RosSharp.RosBridgeClient.Protocols.WebSocketSharpProtocol(&quot;ws://localhost:9090&quot;));

        // Unity 구독자 설정
        PoseSubscriber subscriber = new GameObject().AddComponent&lt;PoseSubscriber&gt;();
        subscriber.Start();

        // ROS 퍼블리셔 설정
        Publisher&lt;PoseMsg&gt; publisher = rosConnector.Advertise&lt;PoseMsg&gt;(&quot;pose_topic&quot;);

        // 메시지 퍼블리시
        PoseMsg msg = new PoseMsg
        {
            position = new PointMsg { x = 4.0, y = 5.0, z = 6.0 },
            orientation = new QuaternionMsg { x = 0.0, y = 0.0, z = 0.0, w = 1.0 }
        };
        publisher.Publish(msg);

        // Unity 오브젝트의 위치 확인
        Assert.AreEqual(new Vector3(4.0f, 5.0f, 6.0f), subscriber.transform.position);
    }
}
</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0703/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0703/" class="btn btn-xs btn-link">
        ROS-Unity 통합 시뮬레이션 환경 구성
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0701/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0701/" class="btn btn-xs btn-link">
        ROS와 Unity의 통신 방법
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>