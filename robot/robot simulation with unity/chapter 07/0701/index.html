<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot%20simulation%20with%20unity/chapter%2007/0701/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>ROS와 Unity의 통신 방법 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "ROS \ube0c\ub9ac\uc9c0 \uac1c\uc694", url: "#_top", children: [
          ]},
          {title: "rosbridge_suite\ub97c \uc774\uc6a9\ud55c \ud1b5\uc2e0", url: "#rosbridge_suite", children: [
              {title: "rosbridge \uc124\uce58 \ubc0f \uc124\uc815", url: "#rosbridge" },
              {title: "Unity\uc5d0\uc11c rosbridge\uc640 \uc5f0\uacb0", url: "#unity-rosbridge" },
          ]},
          {title: "ROS#\uc744 \uc774\uc6a9\ud55c \ud1b5\uc2e0", url: "#ros_1", children: [
              {title: "ROS# \uc124\uce58 \ubc0f \uc124\uc815", url: "#ros_2" },
              {title: "ROSConnector \uc124\uc815", url: "#rosconnector" },
          ]},
          {title: "\uba54\uc2dc\uc9c0 \ud0c0\uc785 \ubc0f \uc9c1\ub82c\ud654", url: "#_1", children: [
              {title: "\uba54\uc2dc\uc9c0 \uc9c1\ub82c\ud654 \uc608\uc81c", url: "#_2" },
          ]},
          {title: "\uc11c\ube44\uc2a4\uc640 \uc561\uc158\uc758 \ud1b5\uc2e0", url: "#_3", children: [
              {title: "\uc11c\ube44\uc2a4 \ud638\ucd9c \uc608\uc81c", url: "#_4" },
          ]},
          {title: "\uc561\uc158(Action) \ud1b5\uc2e0", url: "#action", children: [
              {title: "\uc561\uc158 \ud074\ub77c\uc774\uc5b8\ud2b8 \uc124\uc815 \uc608\uc81c", url: "#_5" },
          ]},
          {title: "\uc5f0\uacb0 \uc0c1\ud0dc \uad00\ub9ac", url: "#_6", children: [
              {title: "\uc5f0\uacb0 \uc0c1\ud0dc \ubaa8\ub2c8\ud130\ub9c1 \uc608\uc81c", url: "#_7" },
          ]},
          {title: "\ub370\uc774\ud130 \ub3d9\uae30\ud654", url: "#_8", children: [
              {title: "\ud0c0\uc784\uc2a4\ud0ec\ud504 \uc0ac\uc6a9", url: "#_9" },
          ]},
          {title: "\ubcf4\uc548 \uace0\ub824\uc0ac\ud56d", url: "#_10", children: [
              {title: "SSL/TLS\ub97c \ud1b5\ud55c \uc554\ud638\ud654", url: "#ssltls" },
          ]},
          {title: "\ucd5c\uc801\ud654 \uae30\ubc95", url: "#_11", children: [
              {title: "\uba54\uc2dc\uc9c0 \uc804\uc1a1 \ube48\ub3c4 \uc870\uc808", url: "#_12" },
          ]},
          {title: "\uc624\ub958 \ucc98\ub9ac \ubc0f \uc7ac\uc2dc\ub3c4 \uba54\ucee4\ub2c8\uc998", url: "#_13", children: [
              {title: "\uc624\ub958 \ucc98\ub9ac \uc608\uc81c", url: "#_14" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0702/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0702/" class="btn btn-xs btn-link">
        ROS 메시지 구조 및 Unity에서의 사용
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter%2006/0603/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter%2006/0603/" class="btn btn-xs btn-link">
        실시간 로봇 컨트롤 구현
      </a>
    </div>
    
  </div>

    

    <p>로봇 시뮬레이션에서 ROS(Robot Operating System)와 Unity 간의 원활한 통신은 필수적이다. 이를 위해 다양한 통신 방법과 브리지를 활용할 수 있으며, 이 절에서는 주요 통신 방법과 그 구현 방식을 상세히 다룬다.</p>
<h3 id="ros">ROS 브리지 개요</h3>
<p>ROS 브리지는 ROS 네트워크와 Unity 사이의 통신을 중개하는 역할을 한다. 이를 통해 두 시스템 간에 메시지를 주고받을 수 있으며, 로봇의 상태 정보, 센서 데이터, 명령 등을 실시간으로 교환할 수 있다. 주요 ROS 브리지로는 <code>rosbridge_suite</code>와 <code>ROS#</code> 등이 있다.</p>
<h3 id="rosbridge_suite">rosbridge_suite를 이용한 통신</h3>
<p><code>rosbridge_suite</code>는 ROS 메시지를 JSON 형식으로 변환하여 웹 소켓을 통해 전송할 수 있게 해주는 도구이다. 이를 통해 Unity는 웹 소켓 클라이언트를 사용하여 ROS와 통신할 수 있다.</p>
<h4 id="rosbridge">rosbridge 설치 및 설정</h4>
<ol>
<li><strong>rosbridge_suite 설치</strong></li>
</ol>
<p><code>bash
   sudo apt-get install ros-&lt;distro&gt;-rosbridge-suite</code></p>
<ol>
<li><strong>rosbridge 실행</strong></li>
</ol>
<p><code>bash
   roslaunch rosbridge_server rosbridge_websocket.launch</code></p>
<p>기본적으로 <code>rosbridge_websocket</code>은 포트 9090에서 웹 소켓 서버를 실행한다.</p>
<h4 id="unity-rosbridge">Unity에서 rosbridge와 연결</h4>
<p>Unity에서는 웹 소켓 클라이언트를 사용하여 <code>rosbridge_websocket</code> 서버에 연결할 수 있다. 이를 위해 <code>WebSocketSharp</code>과 같은 라이브러리를 활용할 수 있다.</p>
<pre><code class="language-csharp">using WebSocketSharp;
using Newtonsoft.Json.Linq;

public class RosBridgeConnector : MonoBehaviour
{
    private WebSocket ws;

    void Start()
    {
        ws = new WebSocket(&quot;ws://localhost:9090&quot;);
        ws.OnMessage += (sender, e) =&gt;
        {
            JObject message = JObject.Parse(e.Data);
            // 메시지 처리 로직
        };
        ws.Connect();
    }

    void Publish(string topic, JObject msg)
    {
        var publishMsg = new JObject
        {
            { &quot;op&quot;, &quot;publish&quot; },
            { &quot;topic&quot;, topic },
            { &quot;msg&quot;, msg }
        };
        ws.Send(publishMsg.ToString());
    }

    void OnDestroy()
    {
        ws.Close();
    }
}
</code></pre>
<p>위의 예제에서는 Unity가 <code>rosbridge_websocket</code> 서버에 연결하고, 메시지를 발행하는 기본적인 구조를 보여준다.</p>
<h3 id="ros_1">ROS#을 이용한 통신</h3>
<p><code>ROS#</code>은 Unity와 ROS 간의 통신을 보다 쉽게 구현할 수 있도록 도와주는 오픈 소스 라이브러리이다. <code>ROS#</code>은 C#으로 작성되었으며, ROS 메시지와 서비스와의 상호작용을 간편하게 처리할 수 있는 다양한 기능을 제공한다.</p>
<h4 id="ros_2">ROS# 설치 및 설정</h4>
<ol>
<li><strong>ROS# 클론</strong></li>
</ol>
<p><code>bash
   git clone https://github.com/siemens/ros-sharp.git</code></p>
<ol>
<li><strong>Unity 프로젝트에 ROS# 추가</strong></li>
</ol>
<p>Unity 프로젝트의 <code>Assets</code> 폴더에 <code>ros-sharp</code> 폴더를 복사한다.</p>
<ol>
<li><strong>ROS# 빌드</strong></li>
</ol>
<p>Unity 내에서 <code>ros-sharp</code>의 <code>Build</code> 스크립트를 실행하여 필요한 DLL 파일을 생성한다.</p>
<h4 id="rosconnector">ROSConnector 설정</h4>
<p>Unity에서 ROS와의 연결을 관리하는 주요 컴포넌트는 <code>ROSConnector</code>이다. 이를 통해 ROS 네트워크와의 통신을 설정할 수 있다.</p>
<pre><code class="language-csharp">using RosSharp.RosBridgeClient;

public class RosConnectorSetup : MonoBehaviour
{
    public string RosBridgeServerUrl = &quot;ws://localhost:9090&quot;;

    void Start()
    {
        ROSConnector rosConnector = GetComponent&lt;ROSConnector&gt;();
        rosConnector.RosBridgeServerUrl = RosBridgeServerUrl;
        rosConnector.Connect();
    }
}
</code></pre>
<p><code>ROSConnector</code> 컴포넌트를 Unity 오브젝트에 추가하고, ROS 브리지 서버의 URL을 설정한 후 연결을 시작한다.</p>
<h3 id="_1">메시지 타입 및 직렬화</h3>
<p>ROS와 Unity 간의 통신에서 중요한 부분은 메시지 타입과 그 직렬화 방식이다. ROS 메시지는 <code>std_msgs</code>, <code>sensor_msgs</code> 등 다양한 타입이 있으며, Unity에서는 이들을 C# 객체로 변환하여 사용한다.</p>
<h4 id="_2">메시지 직렬화 예제</h4>
<pre><code class="language-csharp">using RosSharp.RosBridgeClient.MessageTypes.Std;

public class StringPublisher : Publisher&lt;std_msgs.String&gt;
{
    protected override void Start()
    {
        base.Start();
    }

    public void PublishMessage(string message)
    {
        std_msgs.String rosMessage = new std_msgs.String
        {
            data = message
        };
        Publish(rosMessage);
    }
}
</code></pre>
<p>위의 예제는 ROS의 <code>std_msgs/String</code> 메시지를 Unity에서 발행하는 방법을 보여준다. <code>Publisher</code> 클래스를 상속받아 특정 메시지 타입을 처리할 수 있다.</p>
<h3 id="_3">서비스와 액션의 통신</h3>
<p>ROS에서는 서비스와 액션을 통해 요청-응답 및 비동기 작업을 처리할 수 있다. Unity에서도 이를 지원하여 보다 복잡한 상호작용을 구현할 수 있다.</p>
<h4 id="_4">서비스 호출 예제</h4>
<pre><code class="language-csharp">using RosSharp.RosBridgeClient;
using RosSharp.RosBridgeClient.MessageTypes.Std;

public class AddTwoIntsClient : MonoBehaviour
{
    private ServiceProvider serviceProvider;

    void Start()
    {
        serviceProvider = GetComponent&lt;ServiceProvider&gt;();
    }

    public void CallAddService(int a, int b)
    {
        AddTwoIntsRequest request = new AddTwoIntsRequest
        {
            a = a,
            b = b
        };
        serviceProvider.CallService&lt;AddTwoIntsResponse&gt;(&quot;add_two_ints&quot;, request, OnServiceResponse);
    }

    private void OnServiceResponse(AddTwoIntsResponse response)
    {
        Debug.Log(&quot;Sum: &quot; + response.sum);
    }
}
</code></pre>
<p>이 예제에서는 ROS의 <code>add_two_ints</code> 서비스를 호출하고, 응답을 처리하는 방법을 보여준다.</p>
<h3 id="action">액션(Action) 통신</h3>
<p>ROS에서는 액션을 사용하여 장시간 실행되는 작업을 처리할 수 있다. 액션은 목표(goal)을 설정하고, 진행 중인 상태(status)를 확인하며, 결과(result)를 수신할 수 있는 비동기적인 통신 방식이다. Unity에서도 ROS 액션과 상호작용할 수 있다.</p>
<h4 id="_5">액션 클라이언트 설정 예제</h4>
<pre><code class="language-csharp">using RosSharp.RosBridgeClient;
using RosSharp.RosBridgeClient.MessageTypes.Actionlib;
using RosSharp.RosBridgeClient.MessageTypes.MoveBase;

public class MoveBaseActionClient : MonoBehaviour
{
    private ActionClient actionClient;

    void Start()
    {
        actionClient = GetComponent&lt;ActionClient&gt;();
        actionClient.Connect();
    }

    public void SendMoveBaseGoal(float x, float y, float theta)
    {
        MoveBaseGoal goal = new MoveBaseGoal
        {
            target_pose = new geometry_msgs.PoseStamped
            {
                header = new std_msgs.Header { frame_id = &quot;map&quot; },
                pose = new geometry_msgs.Pose
                {
                    position = new geometry_msgs.Point { x = x, y = y, z = 0 },
                    orientation = new geometry_msgs.Quaternion { z = Mathf.Sin(theta / 2), w = Mathf.Cos(theta / 2) }
                }
            }
        };
        actionClient.SendGoal(goal, OnGoalFeedback, OnGoalResult);
    }

    private void OnGoalFeedback(ActionlibFeedback&lt;MoveBaseFeedback&gt; feedback)
    {
        // 피드백 처리 로직
    }

    private void OnGoalResult(ActionlibResult&lt;MoveBaseResult&gt; result)
    {
        Debug.Log(&quot;MoveBase Action Result: &quot; + result.result);
    }
}
</code></pre>
<p>이 예제에서는 <code>MoveBase</code> 액션을 사용하여 목표 위치를 설정하고, 피드백과 결과를 처리하는 방법을 보여준다.</p>
<h3 id="_6">연결 상태 관리</h3>
<p>ROS와 Unity 간의 통신에서 안정적인 연결 상태를 유지하는 것은 중요하다. 연결이 끊어졌을 때 자동으로 재연결을 시도하거나, 연결 상태를 지속적으로 모니터링하여 필요한 조치를 취할 수 있어야 한다.</p>
<h4 id="_7">연결 상태 모니터링 예제</h4>
<pre><code class="language-csharp">using RosSharp.RosBridgeClient;

public class ConnectionMonitor : MonoBehaviour
{
    private ROSConnector rosConnector;

    void Start()
    {
        rosConnector = GetComponent&lt;ROSConnector&gt;();
    }

    void Update()
    {
        if (!rosConnector.IsConnected)
        {
            Debug.LogWarning(&quot;ROS Connector is not connected. Attempting to reconnect...&quot;);
            rosConnector.Connect();
        }
    }
}
</code></pre>
<p>위의 스크립트는 연결 상태를 지속적으로 확인하고, 연결이 끊어진 경우 재연결을 시도한다.</p>
<h3 id="_8">데이터 동기화</h3>
<p>ROS와 Unity 간에 데이터를 동기화하는 것은 시뮬레이션의 정확성과 실시간성에 영향을 미친다. 데이터의 일관성을 유지하기 위해 동기화 메커니즘을 구현하는 것이 중요하다.</p>
<h4 id="_9">타임스탬프 사용</h4>
<p>메시지의 타임스탬프를 사용하여 데이터 동기화를 관리할 수 있다.</p>
<pre><code class="language-csharp">public void HandleSensorData(SensorData msg)
{
    float timestamp = msg.header.stamp.sec + msg.header.stamp.nsec * 1e-9f;
    // 현재 시간과 메시지 타임스탬프를 비교하여 동기화
}
</code></pre>
<h3 id="_10">보안 고려사항</h3>
<p>ROS와 Unity 간의 통신에서 보안을 고려하는 것도 중요하다. 데이터 전송 시 암호화를 적용하거나, 인증 메커니즘을 구현하여 보안을 강화할 수 있다.</p>
<h4 id="ssltls">SSL/TLS를 통한 암호화</h4>
<p>웹 소켓 연결을 SSL/TLS로 설정하여 데이터를 암호화할 수 있다.</p>
<pre><code class="language-csharp">ws = new WebSocket(&quot;wss://localhost:9090&quot;);
</code></pre>
<p>이렇게 하면 데이터 전송 시 암호화가 적용된다.</p>
<h3 id="_11">최적화 기법</h3>
<p>통신의 효율성을 높이기 위해 메시지 전송 빈도를 조절하거나, 필요한 데이터만 전송하도록 최적화할 수 있다.</p>
<h4 id="_12">메시지 전송 빈도 조절</h4>
<pre><code class="language-csharp">void Update()
{
    if (Time.time &gt; nextPublishTime)
    {
        PublishSensorData();
        nextPublishTime += publishInterval;
    }
}
</code></pre>
<p>이 예제에서는 일정 간격으로만 메시지를 전송하여 네트워크 부하를 줄이다.</p>
<h3 id="_13">오류 처리 및 재시도 메커니즘</h3>
<p>통신 과정에서 발생할 수 있는 오류를 효과적으로 처리하고, 필요 시 재시도하는 메커니즘을 구현하는 것이 중요하다.</p>
<h4 id="_14">오류 처리 예제</h4>
<pre><code class="language-csharp">void Start()
{
    try
    {
        ws.Connect();
    }
    catch (Exception ex)
    {
        Debug.LogError(&quot;WebSocket connection failed: &quot; + ex.Message);
        RetryConnection();
    }
}

void RetryConnection()
{
    Invoke(&quot;Start&quot;, 5.0f); // 5초 후 재시도
}
</code></pre>
<p>이 예제에서는 WebSocket 연결 시 오류가 발생하면 일정 시간 후 재연결을 시도한다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0702/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0702/" class="btn btn-xs btn-link">
        ROS 메시지 구조 및 Unity에서의 사용
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter%2006/0603/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter%2006/0603/" class="btn btn-xs btn-link">
        실시간 로봇 컨트롤 구현
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>