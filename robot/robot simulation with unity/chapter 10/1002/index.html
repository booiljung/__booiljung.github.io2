<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot%20simulation%20with%20unity/chapter%2010/1002/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>매니퓰레이터 시뮬레이션 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ub9e4\ub2c8\ud4f0\ub808\uc774\ud130 \uc2dc\ubbac\ub808\uc774\uc158", url: "#_top", children: [
              {title: "\ub9e4\ub2c8\ud4f0\ub808\uc774\ud130\uc758 \uae30\ubcf8 \uad6c\uc131 \uc694\uc18c", url: "#_2" },
              {title: "\ub9e4\ub2c8\ud4f0\ub808\uc774\ud130\uc758 \ubaa8\ub378\ub9c1", url: "#_3" },
              {title: "\ub9e4\ub2c8\ud4f0\ub808\uc774\ud130\uc758 \uc6c0\uc9c1\uc784 \uc124\uc815", url: "#_4" },
          ]},
          {title: "\ub9e4\ub2c8\ud4f0\ub808\uc774\ud130 \uc2dc\ubbac\ub808\uc774\uc158 (\uacc4\uc18d)", url: "#_8", children: [
              {title: "\ub3d9\uc5ed\ud559 \uc2dc\ubbac\ub808\uc774\uc158", url: "#_9" },
              {title: "\ucda9\ub3cc \uac10\uc9c0 \ubc0f \ubc18\uc751", url: "#_13" },
              {title: "\uc13c\uc11c \ub370\uc774\ud130 \ud1b5\ud569", url: "#_16" },
              {title: "\ub9e4\ub2c8\ud4f0\ub808\uc774\ud130\uc758 \uacbd\ub85c \uacc4\ud68d", url: "#_18" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1003/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1003/" class="btn btn-xs btn-link">
        자율 주행 자동차 시뮬레이션
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1001/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1001/" class="btn btn-xs btn-link">
        모바일 로봇 시뮬레이션
      </a>
    </div>
    
  </div>

    

    <h1 id="_1">매니퓰레이터 시뮬레이션</h1>
<p>매니퓰레이터 시뮬레이션은 로봇 공학에서 중요한 분야로, 로봇의 팔이나 손과 같은 조작 장치를 가상 환경에서 정확하게 모델링하고 제어하는 과정을 포함한다. Unity를 사용하여 매니퓰레이터를 시뮬레이션하는 방법을 단계별로 살펴보겠다.</p>
<h3 id="_2">매니퓰레이터의 기본 구성 요소</h3>
<p>매니퓰레이터는 일반적으로 여러 개의 조인트와 링크로 구성된다. 각 조인트는 특정 축을 중심으로 회전하거나 이동할 수 있으며, 링크는 이러한 조인트를 연결하는 구조물이다.</p>
<ul>
<li><strong>조인트 (Joint):</strong> 매니퓰레이터의 각 연결 부위로, 회전 조인트와 이동 조인트가 있다.</li>
<li><strong>링크 (Link):</strong> 조인트를 연결하는 강체로, 매니퓰레이터의 각 부분을 형성한다.</li>
<li><strong>엔드 이펙터 (End Effector):</strong> 매니퓰레이터의 최종 부분으로, 물체를 잡거나 도구를 사용할 수 있다.</li>
</ul>
<h3 id="_3">매니퓰레이터의 모델링</h3>
<p>Unity에서 매니퓰레이터를 모델링하기 위해서는 URDF(Unified Robot Description Format) 파일을 사용하여 로봇의 구조를 정의할 수 있다. URDF 파일에는 링크와 조인트의 정보가 포함되어 있으며, 이를 Unity로 변환하여 시뮬레이션에 사용할 수 있다.</p>
<h4 id="urdf">URDF 파일의 기본 구조</h4>
<p>URDF 파일은 XML 형식으로 작성되며, 다음과 같은 기본 요소를 포함한다:</p>
<pre><code class="language-xml">&lt;robot name=&quot;manipulator&quot;&gt;
  &lt;link name=&quot;base_link&quot;&gt;
    &lt;!-- 링크의 시각적 요소와 물리적 속성 정의 --&gt;
  &lt;/link&gt;
  &lt;joint name=&quot;shoulder_joint&quot; type=&quot;revolute&quot;&gt;
    &lt;parent link=&quot;base_link&quot;/&gt;
    &lt;child link=&quot;upper_arm&quot;/&gt;
    &lt;origin xyz=&quot;0 0 0.1&quot; rpy=&quot;0 0 0&quot;/&gt;
    &lt;axis xyz=&quot;0 0 1&quot;/&gt;
    &lt;limit lower=&quot;-1.57&quot; upper=&quot;1.57&quot; effort=&quot;10&quot; velocity=&quot;1.0&quot;/&gt;
  &lt;/joint&gt;
  &lt;!-- 추가 링크와 조인트 정의 --&gt;
&lt;/robot&gt;
</code></pre>
<h4 id="unity">Unity로의 변환 과정</h4>
<ol>
<li><strong>URDF Importer 사용:</strong> Unity에는 URDF 파일을 불러와 로봇 모델을 생성할 수 있는 다양한 플러그인이 존재한다. 예를 들어, ROS#와 같은 플러그인을 사용하여 URDF 파일을 Unity 프로젝트에 임포트할 수 있다.</li>
<li><strong>링크와 조인트 설정:</strong> 임포트된 로봇 모델의 각 링크와 조인트를 Unity의 계층 구조에 맞게 조정한다. 각 조인트의 회전 축과 제한을 Unity의 조인트 컴포넌트에 설정한다.</li>
<li><strong>물리 속성 적용:</strong> 각 링크에 Rigidbody와 Collider 컴포넌트를 추가하여 물리 기반 시뮬레이션이 가능하도록 설정한다.</li>
</ol>
<h3 id="_4">매니퓰레이터의 움직임 설정</h3>
<p>매니퓰레이터의 움직임을 정확하게 시뮬레이션하기 위해서는 각 조인트의 회전 각도와 위치를 제어해야 한다. 이를 위해 Unity의 스크립팅 기능을 활용하여 C#으로 제어 로직을 작성할 수 있다.</p>
<h4 id="_5">조인트 제어를 위한 수학적 모델</h4>
<p>매니퓰레이터의 각 조인트는 특정 각도 θ로 회전할 수 있으며, 이를 통해 엔드 이펙터의 위치를 결정한다. 매니퓰레이터의 역운동학(Inverse Kinematics)을 사용하여 엔드 이펙터의 목표 위치에 도달하기 위한 각 조인트의 각도를 계산할 수 있다.</p>
<p>역운동학 방정식은 다음과 같이 표현된다:</p>
<p>$$</p>
<p>\mathbf{p}<em>{end} = \mathbf{T}_1(\theta_1) \mathbf{T}_2(\theta_2) \dots \mathbf{T}_n(\theta_n) \mathbf{p}</em>{local}</p>
<p>$$</p>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{end}</span><script type="math/tex">\mathbf{p}_{end}</script></span>는 엔드 이펙터의 전역 위치 벡터
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_i(\theta_i)</span><script type="math/tex">\mathbf{T}_i(\theta_i)</script></span>는 각 조인트의 변환 행렬
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{local}</span><script type="math/tex">\mathbf{p}_{local}</script></span>는 로컬 좌표계에서의 엔드 이펙터 위치</p>
<h4 id="_6">역운동학 알고리즘 구현</h4>
<p>Unity에서 역운동학을 구현하기 위해 다음과 같은 단계를 따른다:</p>
<ol>
<li><strong>목표 위치 설정:</strong> 엔드 이펙터가 도달해야 할 목표 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{target}</span><script type="math/tex">\mathbf{p}_{target}</script></span>을 설정한다.</li>
<li><strong>초기 추정:</strong> 각 조인트의 초기 각도 <span class="arithmatex"><span class="MathJax_Preview">\theta_i</span><script type="math/tex">\theta_i</script></span>를 추정한다.</li>
<li><strong>반복 계산:</strong> 목표 위치와 현재 엔드 이펙터 위치의 오차를 줄이기 위해 각 조인트의 각도를 조정한다.</li>
<li><strong>수렴 확인:</strong> 오차가 허용 범위 내에 들어오면 알고리즘을 종료한다.</li>
</ol>
<h4 id="_7">예제 코드: 간단한 역운동학 구현</h4>
<pre><code class="language-csharp">using UnityEngine;

public class InverseKinematics : MonoBehaviour
{
    public Transform endEffector;
    public Transform target;
    public int maxIterations = 10;
    public float threshold = 0.01f;

    void Update()
    {
        for(int i = 0; i &lt; maxIterations; i++)
        {
            Vector3 toEnd = endEffector.position - transform.position;
            Vector3 toTarget = target.position - transform.position;

            float angle = Vector3.SignedAngle(toEnd, toTarget, Vector3.up);
            transform.Rotate(Vector3.up, angle);

            if(Vector3.Distance(endEffector.position, target.position) &lt; threshold)
                break;
        }
    }
}
</code></pre>
<p>이 코드는 매우 간단한 역운동학 예제로, 실제 매니퓰레이터의 복잡한 움직임을 구현하려면 더 정교한 알고리즘이 필요하다. 그러나 기본 개념을 이해하는 데 도움이 된다.</p>
<p>[계속]</p>
<h1 id="_8">매니퓰레이터 시뮬레이션 (계속)</h1>
<h3 id="_9">동역학 시뮬레이션</h3>
<p>매니퓰레이터의 동적 거동을 정확하게 시뮬레이션하기 위해서는 물리 기반의 동역학 모델을 구현해야 한다. 이는 매니퓰레이터의 조인트에 작용하는 힘과 토크를 계산하고, 각 링크의 가속도와 속도를 결정하는 과정을 포함한다.</p>
<h4 id="_10">라그랑지안 역학</h4>
<p>라그랑지안 역학은 매니퓰레이터의 동역학을 모델링하는 데 널리 사용되는 방법이다. 라그랑지안 <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span>은 운동 에너지 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>와 위치 에너지 <span class="arithmatex"><span class="MathJax_Preview">V</span><script type="math/tex">V</script></span>의 차이로 정의된다:</p>
<p>$$</p>
<p>L = T - V</p>
<p>$$</p>
<p>라그랑지안 역학의 기본 방정식은 다음과 같다:</p>
<p>$$</p>
<p>\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{\theta}_i} \right ) - \frac{\partial L}{\partial \theta_i} = \tau_i</p>
<p>$$</p>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\theta_i</span><script type="math/tex">\theta_i</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>번째 조인트의 각도
- <span class="arithmatex"><span class="MathJax_Preview">\dot{\theta}_i</span><script type="math/tex">\dot{\theta}_i</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>번째 조인트의 각속도
- <span class="arithmatex"><span class="MathJax_Preview">\tau_i</span><script type="math/tex">\tau_i</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>번째 조인트에 작용하는 토크</p>
<h4 id="_11">동역학 방정식의 적용</h4>
<p>매니퓰레이터의 각 링크에 대해 운동 에너지와 위치 에너지를 계산하고, 이를 라그랑지안에 대입하여 각 조인트에 대한 동역학 방정식을 도출한다. Unity에서는 이러한 방정식을 스크립트로 구현하여 조인트의 움직임을 제어할 수 있다.</p>
<h4 id="_12">예제 코드: 동역학 기반 조인트 제어</h4>
<pre><code class="language-csharp">using UnityEngine;

public class DynamicsController : MonoBehaviour
{
    public Transform joint;
    public float desiredAngle;
    public float kp = 100.0f;
    public float kd = 20.0f;
    private float currentAngle;
    private float angularVelocity;

    void Update()
    {
        currentAngle = joint.localEulerAngles.y;
        if(currentAngle &gt; 180) currentAngle -= 360;

        float error = desiredAngle - currentAngle;
        float torque = kp * error - kd * angularVelocity;

        joint.GetComponent&lt;Rigidbody&gt;().AddTorque(Vector3.up * torque);
        angularVelocity = joint.GetComponent&lt;Rigidbody&gt;().angularVelocity.y;
    }
}
</code></pre>
<p>이 코드는 비례-미분(PD) 제어기를 사용하여 조인트의 각도를 원하는 값으로 제어한다. 실제 동역학을 구현하려면 힘과 토크의 정확한 계산이 필요하다.</p>
<h3 id="_13">충돌 감지 및 반응</h3>
<p>매니퓰레이터 시뮬레이션에서 충돌 감지는 중요한 요소이다. Unity의 물리 엔진을 활용하여 매니퓰레이터의 링크 간, 링크와 환경 간의 충돌을 감지하고 적절히 반응할 수 있다.</p>
<h4 id="_14">충돌 감지 설정</h4>
<ol>
<li><strong>Collider 추가:</strong> 매니퓰레이터의 각 링크에 Collider 컴포넌트를 추가하여 충돌을 감지할 수 있도록 한다. 일반적으로 BoxCollider, SphereCollider, CapsuleCollider 등이 사용된다.</li>
<li><strong>Rigidbody 설정:</strong> 물리적 상호작용을 위해 각 링크에 Rigidbody 컴포넌트를 추가하고, 필요한 경우 Kinematic 옵션을 설정한다.</li>
<li><strong>충돌 반응:</strong> 충돌이 발생했을 때의 반응을 정의한다. 예를 들어, 충돌 시 로봇의 움직임을 멈추거나, 충돌 지점에 힘을 가하는 등의 처리를 할 수 있다.</li>
</ol>
<h4 id="_15">예제 코드: 충돌 이벤트 처리</h4>
<pre><code class="language-csharp">using UnityEngine;

public class CollisionHandler : MonoBehaviour
{
    void OnCollisionEnter(Collision collision)
    {
        Debug.Log($&quot;{gameObject.name} collided with {collision.gameObject.name}&quot;);
        // 충돌 시 추가적인 로직 구현
    }
}
</code></pre>
<p>이 코드는 충돌이 발생했을 때 콘솔에 로그를 출력하는 간단한 예제이다. 실제 응용에서는 충돌에 따른 로봇의 반응을 정의할 수 있다.</p>
<h3 id="_16">센서 데이터 통합</h3>
<p>매니퓰레이터 시뮬레이션에서 센서 데이터를 통합하여 로봇의 상태를 모니터링하고 제어하는 것이 중요하다. 예를 들어, 근접 센서, 힘 토크 센서 등을 사용하여 로봇의 상호작용을 보다 정밀하게 제어할 수 있다.</p>
<h4 id="_17">근접 센서 시뮬레이션</h4>
<p>근접 센서는 매니퓰레이터가 물체에 접근할 때 거리를 측정하는 데 사용된다. Unity에서는 Raycast를 사용하여 근접 센서를 시뮬레이션할 수 있다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class ProximitySensor : MonoBehaviour
{
    public float detectionRange = 1.0f;

    void Update()
    {
        RaycastHit hit;
        if(Physics.Raycast(transform.position, transform.forward, out hit, detectionRange))
        {
            Debug.Log($&quot;Detected object: {hit.collider.gameObject.name} at distance {hit.distance}&quot;);
            // 센서 데이터에 따른 로직 구현
        }
    }
}
</code></pre>
<p>이 코드는 매니퓰레이터의 전방에 Ray를 쏴서 일정 범위 내의 물체를 감지한다. 감지된 물체의 이름과 거리를 로그로 출력한다.</p>
<h3 id="_18">매니퓰레이터의 경로 계획</h3>
<p>매니퓰레이터가 특정 작업을 수행하기 위해 경로를 계획하는 과정은 시뮬레이션에서 중요한 부분이다. 경로 계획 알고리즘을 구현하여 로봇이 충돌 없이 목표 지점으로 이동할 수 있도록 한다.</p>
<h4 id="_19">경로 계획 알고리즘</h4>
<p>대표적인 경로 계획 알고리즘으로는 다음과 같은 것들이 있다:</p>
<ul>
<li><strong>직선 경로 계획:</strong> 간단한 직선 경로를 따라 이동하는 방법이다.</li>
<li><strong>자유 공간 탐색:</strong> 장애물이 있는 환경에서 자유롭게 이동할 수 있는 경로를 탐색한다.</li>
<li><strong>최적 경로 계획:</strong> 최소 시간, 최소 에너지 등 최적의 조건을 만족하는 경로를 찾는다.</li>
</ul>
<h4 id="_20">예제 코드: 직선 경로 계획</h4>
<pre><code class="language-csharp">using UnityEngine;

public class PathPlanner : MonoBehaviour
{
    public Transform target;
    public float speed = 1.0f;

    void Update()
    {
        Vector3 direction = (target.position - transform.position).normalized;
        transform.position += direction * speed * Time.deltaTime;
    }
}
</code></pre>
<p>이 코드는 매니퓰레이터가 목표 지점을 향해 직선 경로로 이동하도록 한다. 보다 복잡한 경로 계획을 위해서는 추가적인 알고리즘이 필요하다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1003/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1003/" class="btn btn-xs btn-link">
        자율 주행 자동차 시뮬레이션
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1001/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1001/" class="btn btn-xs btn-link">
        모바일 로봇 시뮬레이션
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>