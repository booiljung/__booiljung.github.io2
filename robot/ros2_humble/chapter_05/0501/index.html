<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/robot/ros2_humble/chapter_05/0501/" rel="canonical"/>
<link href="../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>노드(Node) 생성과 관리 - 실험 도서관</title>
<link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ub178\ub4dc\uc758 \uc815\uc758", url: "#_top", children: [
          ]},
          {title: "\ub178\ub4dc\uc758 \uad6c\uc870", url: "#_2", children: [
              {title: "\ub178\ub4dc \uc774\ub984\uacfc \ub124\uc784\uc2a4\ud398\uc774\uc2a4 \uc608\uc2dc", url: "#_3" },
          ]},
          {title: "\ub178\ub4dc \uc0dd\uc131", url: "#_4", children: [
              {title: "C++\uc5d0\uc11c\uc758 \ub178\ub4dc \uc0dd\uc131", url: "#c" },
              {title: "Python\uc5d0\uc11c\uc758 \ub178\ub4dc \uc0dd\uc131", url: "#python" },
          ]},
          {title: "\ub178\ub4dc\uc758 \uad00\ub9ac", url: "#_5", children: [
          ]},
          {title: "\ub178\ub4dc\uc758 \uc0c1\ud0dc \uad00\ub9ac", url: "#_6", children: [
          ]},
          {title: "\ud37c\ube14\ub9ac\uc154\uc640 \uc11c\ube0c\uc2a4\ud06c\ub77c\uc774\ubc84 \uc124\uc815", url: "#_7", children: [
              {title: "\ud37c\ube14\ub9ac\uc154(Publisher) \uc0dd\uc131", url: "#publisher" },
              {title: "\uc11c\ube0c\uc2a4\ud06c\ub77c\uc774\ubc84(Subscriber) \uc0dd\uc131", url: "#subscriber" },
          ]},
          {title: "\ud37c\ube14\ub9ac\uc154\uc640 \uc11c\ube0c\uc2a4\ud06c\ub77c\uc774\ubc84\uc758 \ud1b5\uc2e0 \ud750\ub984", url: "#_8", children: [
          ]},
          {title: "\ud1b5\uc2e0 \uc124\uc815\uacfc QoS \uc815\ucc45", url: "#qos", children: [
              {title: "QoS \uc124\uc815 \uc608\uc2dc (C++)", url: "#qos-c" },
              {title: "QoS \uc124\uc815 \uc608\uc2dc (Python)", url: "#qos-python" },
          ]},
          {title: "\ub178\ub4dc\uc758 \uc2e4\ud589 \ubc0f \uc8fc\uae30\uc801 \uc791\uc5c5 \uad00\ub9ac", url: "#_9", children: [
              {title: "\ud0c0\uc774\uba38(Timer) \uc0dd\uc131", url: "#timer" },
          ]},
          {title: "\ub178\ub4dc \uac04 \ud1b5\uc2e0 \ud750\ub984 \uc608\uc2dc", url: "#_10", children: [
          ]},
          {title: "\ub178\ub4dc\uc758 \uc0c1\ud0dc \ubaa8\ub2c8\ud130\ub9c1", url: "#_11", children: [
              {title: "\ub178\ub4dc \uc0c1\ud0dc \ud655\uc778 \uba85\ub839\uc5b4", url: "#_12" },
          ]},
          {title: "\uba40\ud2f0 \ub178\ub4dc \uc2dc\uc2a4\ud15c\uc5d0\uc11c\uc758 \uad00\ub9ac", url: "#_13", children: [
              {title: "\uba40\ud2f0 \ub178\ub4dc \uad00\ub9ac \uc608\uc2dc", url: "#_14" },
          ]},
          {title: "\uc608\uc678 \ucc98\ub9ac\uc640 \uc5d0\ub7ec \ud578\ub4e4\ub9c1", url: "#_15", children: [
              {title: "C++\uc5d0\uc11c\uc758 \uc608\uc678 \ucc98\ub9ac", url: "#c_4" },
              {title: "Python\uc5d0\uc11c\uc758 \uc608\uc678 \ucc98\ub9ac", url: "#python_4" },
          ]},
        ];

    </script>
<script src="../../../../js/base.js"></script>
<script src="../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0502/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0502/">
        싱글 노드와 멀티 노드 차이점
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../../chapter_04/0404/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../../chapter_04/0404/">
        네임스페이스와 리매핑 실습
      </a>
</div>
</div>
<h3 id="_1">노드의 정의</h3>
<p>ROS2에서 <strong>노드(Node)</strong>는 시스템에서 실행되는 기본 단위로, 노드는 여러 프로세스에 걸쳐 분산될 수 있으며, 각 노드는 서로 통신을 통해 데이터를 주고받는다. 노드는 일반적으로 특정 기능을 수행하는 작은 단위의 프로그램이며, 노드 간의 통신을 통해 전체 시스템의 작업을 분배하고 협력하여 큰 작업을 수행한다.</p>
<h3 id="_2">노드의 구조</h3>
<p>ROS2 노드는 <strong>rclcpp</strong>(C++) 또는 <strong>rclpy</strong>(Python) 라이브러리를 사용하여 구현된다. 각각의 노드는 다음과 같은 구조적 요소로 구성된다.</p>
<ul>
<li><strong>이름(Name)</strong>: 각 노드는 고유한 이름을 갖는다. 노드의 이름은 네트워크 상에서 노드를 구분하는 데 사용되며, 시스템 내에서 노드 간의 충돌을 피하기 위해 고유해야 한다.</li>
<li><strong>네임스페이스(Namespace)</strong>: 여러 노드를 그룹화하여 동일한 이름의 노드가 다른 네임스페이스 내에 있을 수 있다. 네임스페이스를 통해 논리적 그룹을 만들어 관리하기 쉬워진다.</li>
</ul>
<h4 id="_3">노드 이름과 네임스페이스 예시</h4>
<p>예를 들어, 두 개의 로봇이 각각 동일한 노드를 가지고 있지만, 네임스페이스로 구분된다면 다음과 같이 관리할 수 있다.</p>
<ul>
<li><code>/robot1/camera_node</code></li>
<li><code>/robot2/camera_node</code></li>
</ul>
<h3 id="_4">노드 생성</h3>
<p>ROS2에서 노드를 생성하는 방법은 프로그래밍 언어에 따라 다르며, 다음과 같은 방법으로 노드를 만들 수 있다.</p>
<h4 id="c">C++에서의 노드 생성</h4>
<p><strong>C++</strong>에서 노드를 생성할 때는 <strong>rclcpp</strong> 라이브러리를 사용한다. 간단한 노드를 생성하는 코드는 아래와 같다.</p>
<pre><code class="language-cpp">#include "rclcpp/rclcpp.hpp"

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv); // ROS2 초기화
    auto node = std::make_shared&lt;rclcpp::Node&gt;("my_node"); // 노드 생성
    rclcpp::spin(node); // 노드 실행
    rclcpp::shutdown(); // ROS2 종료
    return 0;
}
</code></pre>
<h4 id="python">Python에서의 노드 생성</h4>
<p><strong>Python</strong>에서 노드를 생성할 때는 <strong>rclpy</strong> 라이브러리를 사용한다. 아래는 Python으로 노드를 생성하는 예제이다.</p>
<pre><code class="language-python">import rclpy
from rclpy.node import Node

def main(args=None):
    rclpy.init(args=args) # ROS2 초기화
    node = Node("my_node") # 노드 생성
    rclpy.spin(node) # 노드 실행
    node.destroy_node() # 노드 종료
    rclpy.shutdown() # ROS2 종료

if __name__ == '__main__':
    main()
</code></pre>
<h3 id="_5">노드의 관리</h3>
<p>노드 관리에는 다음과 같은 작업이 포함된다.</p>
<ul>
<li><strong>노드 실행</strong>: 노드를 생성하고 실행하는 것은 ROS2 시스템에서 기본적으로 수행하는 작업이다. C++에서는 <code>rclcpp::spin()</code>, Python에서는 <code>rclpy.spin()</code>을 사용하여 노드를 실행한다.</li>
<li><strong>노드 종료</strong>: 노드를 종료할 때는 <code>rclcpp::shutdown()</code> 또는 <code>rclpy.shutdown()</code> 함수를 호출하여 ROS2 시스템을 정상적으로 종료한다. 이는 시스템 내에서 사용하던 자원을 해제하고, 더 이상 통신하지 않음을 알린다.</li>
</ul>
<h3 id="_6">노드의 상태 관리</h3>
<p>ROS2 노드는 상태를 관리할 수 있는 생명주기(Lifecycle) 노드로 확장할 수 있다. 그러나 기본적인 노드는 상태 관리가 필요하지 않으며, 다음과 같은 간단한 상태 전환이 이루어진다.</p>
<ol>
<li><strong>생성 상태</strong>: 노드가 처음 생성되고, 필요한 초기화 작업이 완료되는 상태이다.</li>
<li><strong>실행 상태</strong>: 노드가 동작하면서 통신을 주고받는 상태이다.</li>
<li><strong>종료 상태</strong>: 노드가 종료되고, 메모리 자원과 통신이 해제되는 상태이다.</li>
</ol>
<p>다음으로는 <strong>퍼블리셔</strong>와 <strong>서브스크라이버</strong>를 통해 통신을 설정하는 과정이 이어진다.</p>
<h3 id="_7">퍼블리셔와 서브스크라이버 설정</h3>
<p>ROS2 노드 간의 통신은 기본적으로 <strong>퍼블리셔(Publisher)</strong>와 <strong>서브스크라이버(Subscriber)</strong> 개념을 통해 이루어진다. 퍼블리셔는 데이터를 송신하고, 서브스크라이버는 해당 데이터를 수신하는 방식으로 동작한다. 퍼블리셔와 서브스크라이버는 <strong>토픽(Topic)</strong>이라는 채널을 통해 데이터를 교환한다.</p>
<h4 id="publisher">퍼블리셔(Publisher) 생성</h4>
<p>퍼블리셔는 ROS2 노드가 다른 노드에게 정보를 전송할 수 있도록 설정된 객체이다. 퍼블리셔는 특정한 <strong>토픽</strong>을 통해 데이터를 송신하며, 이 토픽에 등록된 서브스크라이버들은 그 데이터를 수신한다.</p>
<h5 id="c_1">C++에서 퍼블리셔 생성</h5>
<p>C++에서 퍼블리셔를 생성하는 방법은 다음과 같다.</p>
<pre><code class="language-cpp">auto publisher = node-&gt;create_publisher&lt;std_msgs::msg::String&gt;("topic_name", 10);
</code></pre>
<p>위 코드에서 퍼블리셔는 <code>std_msgs::msg::String</code> 타입의 메시지를 발행하며, <strong>"topic_name"</strong>이라는 토픽으로 데이터를 전송한다. 마지막 인자는 <strong>큐 사이즈(queue size)</strong>로, 송신 대기열의 크기를 지정한다.</p>
<h5 id="python_1">Python에서 퍼블리셔 생성</h5>
<p>Python에서는 다음과 같이 퍼블리셔를 생성한다.</p>
<pre><code class="language-python">publisher = node.create_publisher(String, "topic_name", 10)
</code></pre>
<p>여기서 <code>String</code>은 발행할 메시지 타입이며, <code>"topic_name"</code>은 퍼블리싱할 토픽 이름이다.</p>
<h4 id="subscriber">서브스크라이버(Subscriber) 생성</h4>
<p>서브스크라이버는 특정 토픽에서 데이터를 수신하기 위해 노드에 설정된 객체이다. 서브스크라이버는 퍼블리셔가 송신하는 데이터를 받아서 처리할 수 있다.</p>
<h5 id="c_2">C++에서 서브스크라이버 생성</h5>
<p>C++에서 서브스크라이버를 생성하는 방법은 다음과 같다.</p>
<pre><code class="language-cpp">auto subscription = node-&gt;create_subscription&lt;std_msgs::msg::String&gt;(
    "topic_name", 10, [](const std_msgs::msg::String::SharedPtr msg) {
        RCLCPP_INFO(node-&gt;get_logger(), "I heard: '%s'", msg-&gt;data.c_str());
    });
</code></pre>
<p>위 코드는 <strong>"topic_name"</strong>이라는 토픽에서 데이터를 수신하는 서브스크라이버를 생성하며, 수신된 메시지를 처리하는 콜백 함수를 등록한다.</p>
<h5 id="python_2">Python에서 서브스크라이버 생성</h5>
<p>Python에서는 서브스크라이버를 다음과 같이 생성할 수 있다.</p>
<pre><code class="language-python">subscription = node.create_subscription(
    String,
    "topic_name",
    lambda msg: node.get_logger().info('I heard: "%s"' % msg.data),
    10)
</code></pre>
<p>이 코드에서는 <code>"topic_name"</code>이라는 토픽에서 데이터를 받아 처리하며, 콜백 함수는 수신된 메시지를 출력하는 방식으로 동작한다.</p>
<h3 id="_8">퍼블리셔와 서브스크라이버의 통신 흐름</h3>
<p>퍼블리셔와 서브스크라이버는 <strong>토픽(Topic)</strong>을 통해 통신하며, 토픽을 기준으로 데이터를 주고받는다. 이를 시각적으로 설명하면 다음과 같다.</p>
<div class="mermaid">graph LR
    A[퍼블리셔] --&gt; |데이터 전송| B[토픽]
    B --&gt; |데이터 수신| C[서브스크라이버1]
    B --&gt; |데이터 수신| D[서브스크라이버2]
</div>
<p>위 다이어그램은 퍼블리셔가 데이터를 송신하고, 여러 서브스크라이버가 동일한 토픽에서 데이터를 수신하는 과정을 보여준다.</p>
<h3 id="qos">통신 설정과 QoS 정책</h3>
<p>퍼블리셔와 서브스크라이버는 <strong>QoS(Quality of Service)</strong> 정책을 통해 통신 품질을 관리할 수 있다. QoS는 네트워크 상태와 응용 프로그램의 요구 사항에 따라 데이터를 어떻게 처리할지를 정의한다.</p>
<h4 id="qos-c">QoS 설정 예시 (C++)</h4>
<pre><code class="language-cpp">rclcpp::QoS qos(rclcpp::KeepLast(10)); // 최신 10개의 메시지만 유지
auto publisher = node-&gt;create_publisher&lt;std_msgs::msg::String&gt;("topic_name", qos);
</code></pre>
<h4 id="qos-python">QoS 설정 예시 (Python)</h4>
<pre><code class="language-python">qos = QoSProfile(depth=10) # 최신 10개의 메시지만 유지
publisher = node.create_publisher(String, "topic_name", qos)
</code></pre>
<p><strong>QoS 프로파일</strong>은 다양한 통신 시나리오에 맞추어 네트워크 성능을 최적화할 수 있다.</p>
<h3 id="_9">노드의 실행 및 주기적 작업 관리</h3>
<p>노드는 다양한 방식으로 실행될 수 있으며, 특히 주기적인 작업(예: 주기적으로 센서 데이터를 수집하거나, 주기적으로 데이터를 퍼블리싱하는 작업)을 관리하기 위해 ROS2의 <strong>타이머(Timer)</strong> 기능을 활용할 수 있다.</p>
<h4 id="timer">타이머(Timer) 생성</h4>
<p><strong>타이머</strong>는 노드가 일정한 시간 간격으로 작업을 수행할 수 있게 한다. 타이머는 주어진 주기마다 콜백 함수를 실행하여 노드가 특정 작업을 반복적으로 수행할 수 있게 해준다.</p>
<h5 id="c_3">C++에서 타이머 생성</h5>
<p>C++에서 타이머를 생성하는 방법은 다음과 같다.</p>
<pre><code class="language-cpp">auto timer = node-&gt;create_wall_timer(
    std::chrono::milliseconds(500),
    []() {
        RCLCPP_INFO(node-&gt;get_logger(), "Timer callback executed.");
    });
</code></pre>
<p>위 코드는 500 밀리초마다 콜백 함수가 실행되는 타이머를 설정하는 예시이다. <strong><code>create_wall_timer()</code></strong>는 시스템의 벽 시계 시간을 기준으로 타이머를 실행한다.</p>
<h5 id="python_3">Python에서 타이머 생성</h5>
<p>Python에서는 다음과 같이 타이머를 생성할 수 있다.</p>
<pre><code class="language-python">timer = node.create_timer(0.5, lambda: node.get_logger().info('Timer callback executed.'))
</code></pre>
<p>여기서 <strong><code>0.5</code></strong>는 0.5초마다 타이머가 콜백 함수를 실행한다는 의미이다.</p>
<h3 id="_10">노드 간 통신 흐름 예시</h3>
<p>주기적으로 데이터를 퍼블리시하는 노드와 이를 구독하는 노드 간의 상호작용은 아래와 같이 정리될 수 있다.</p>
<div class="mermaid">graph TD
    P[퍼블리셔 노드] --&gt; |주기적 퍼블리싱| T[토픽]
    S1[서브스크라이버 노드1] --&gt; |데이터 수신| T
    S2[서브스크라이버 노드2] --&gt; |데이터 수신| T
</div>
<p>이 다이어그램은 퍼블리셔 노드가 정기적으로 데이터를 퍼블리시하고, 여러 서브스크라이버 노드가 이를 수신하는 통신 흐름을 나타낸다.</p>
<h3 id="_11">노드의 상태 모니터링</h3>
<p>ROS2 시스템 내에서 노드의 상태를 모니터링하는 것은 매우 중요하다. 이를 위해 ROS2는 다양한 도구와 명령어를 제공하며, 노드의 현재 상태, 토픽, 서비스 등의 상태를 실시간으로 확인할 수 있다.</p>
<h4 id="_12">노드 상태 확인 명령어</h4>
<ul>
<li><strong>노드 목록 확인</strong>: 현재 실행 중인 모든 노드를 확인하는 명령어는 다음과 같다.</li>
</ul>
<p><code>bash
  ros2 node list</code></p>
<ul>
<li><strong>노드 정보 확인</strong>: 특정 노드에 대한 정보를 확인하는 명령어는 다음과 같다.</li>
</ul>
<p><code>bash
  ros2 node info &lt;node_name&gt;</code></p>
<h3 id="_13">멀티 노드 시스템에서의 관리</h3>
<p>ROS2 시스템은 분산된 노드들로 구성될 수 있으며, 멀티 노드 시스템에서의 관리가 필요하다. 각 노드는 독립적인 프로세스로 실행되며, 이를 효율적으로 관리하기 위한 다양한 기능이 제공된다.</p>
<h4 id="_14">멀티 노드 관리 예시</h4>
<p>멀티 노드 시스템에서 중요한 요소는 노드 간의 네임스페이스를 잘 관리하는 것과, 노드가 적절한 리소스를 사용할 수 있도록 통신의 우선순위나 QoS를 잘 설정하는 것이다.</p>
<p>예를 들어, 하나의 로봇 시스템에서 두 개의 센서 노드가 독립적으로 데이터 수집을 수행하고, 이를 하나의 중앙 노드가 처리한다고 가정해 봅시다.</p>
<div class="mermaid">graph TD
    SensorNode1[센서 노드1] --&gt; |데이터 전송| CentralNode[중앙 노드]
    SensorNode2[센서 노드2] --&gt; |데이터 전송| CentralNode
</div>
<h3 id="_15">예외 처리와 에러 핸들링</h3>
<p>ROS2 노드를 생성하고 관리하는 과정에서 발생할 수 있는 예외와 오류를 처리하는 것은 안정적인 시스템 운영을 위해 매우 중요하다. 예를 들어, 노드가 특정 리소스에 접근하지 못할 경우나, 네트워크 상의 통신 문제가 발생할 때 적절한 대처가 필요하다.</p>
<h4 id="c_4">C++에서의 예외 처리</h4>
<p>C++에서는 <code>try-catch</code> 구문을 사용하여 예외를 처리할 수 있다.</p>
<pre><code class="language-cpp">try {
    // 노드 실행 코드
} catch (const std::exception &amp;e) {
    RCLCPP_ERROR(node-&gt;get_logger(), "Exception: %s", e.what());
}
</code></pre>
<h4 id="python_4">Python에서의 예외 처리</h4>
<p>Python에서도 <code>try-except</code> 구문을 통해 예외 처리를 할 수 있다.</p>
<pre><code class="language-python">try:
    # 노드 실행 코드
except Exception as e:
    node.get_logger().error(f"Exception: {str(e)}")
</code></pre>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../0502/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../0502/">
        싱글 노드와 멀티 노드 차이점
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../../chapter_04/0404/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../../chapter_04/0404/">
        네임스페이스와 리매핑 실습
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>