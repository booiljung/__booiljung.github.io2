<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="https://booiljung.github.io/robot/ros2_humble/chapter_05/0505/" rel="canonical"/>
<link href="../../../../img/favicon.ico" rel="shortcut icon"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>서비스와 액션의 활용 사례 - 소프트웨어 융합</title>
<link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet"/>
<link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet"/>
<link href="../../../../css/base.css" rel="stylesheet"/>
<link href="../../../../css/highlight.css" rel="stylesheet"/>
<link href="../../../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script src="../../../../js/jquery-3.2.1.min.js"></script>
<script src="../../../../js/bootstrap-3.3.7.min.js"></script>
<script src="../../../../js/highlight.pack.js"></script>
<base target="_top"/>
<script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc11c\ube44\uc2a4\uc758 \uac1c\ub150 \ubc0f \uae30\ubcf8 \uad6c\uc870", url: "#_top", children: [
              {title: "\uc11c\ubc84 \uad6c\ud604 \uc608\uc81c", url: "#_2" },
          ]},
          {title: "\uc561\uc158\uc758 \uac1c\ub150 \ubc0f \uae30\ubcf8 \uad6c\uc870", url: "#_3", children: [
              {title: "\uc561\uc158 \uc11c\ubc84\uc640 \ud074\ub77c\uc774\uc5b8\ud2b8\uc758 \uc0c1\ud638\uc791\uc6a9", url: "#_4" },
          ]},
          {title: "\uc11c\ube44\uc2a4\uc640 \uc561\uc158\uc758 \ud65c\uc6a9 \ucc28\uc774\uc810", url: "#_5", children: [
              {title: "\uc11c\ube44\uc2a4\uc640 \uc561\uc158\uc758 \uacb0\ud569", url: "#_6" },
          ]},
          {title: "\uc11c\ube44\uc2a4 \ud65c\uc6a9 \uc0ac\ub840", url: "#_7", children: [
              {title: "\ub85c\ubd07 \uc81c\uc5b4\uc5d0\uc11c\uc758 \uc11c\ube44\uc2a4 \ud638\ucd9c", url: "#_8" },
              {title: "\uc13c\uc11c \ub370\uc774\ud130 \uc694\uccad \uc11c\ube44\uc2a4", url: "#_10" },
          ]},
          {title: "\uc561\uc158 \ud65c\uc6a9 \uc0ac\ub840", url: "#_12", children: [
              {title: "\ub85c\ubd07 \uc774\ub3d9 \uacbd\ub85c \ucd94\uc885\uc5d0\uc11c\uc758 \uc561\uc158 \uc0ac\uc6a9", url: "#_13" },
              {title: "\ub4dc\ub860\uc758 \ucc29\ub959 \ub3d9\uc791\uc5d0\uc11c \uc561\uc158 \uc0ac\uc6a9", url: "#_15" },
              {title: "\ub85c\ubd07\uc758 \ube44\uc804 \uae30\ubc18 \uac1d\uccb4 \uc778\uc2dd\uc5d0\uc11c\uc758 \uc561\uc158 \uc0ac\uc6a9", url: "#_17" },
              {title: "\ub85c\ubd07 \uc554\uc758 \uc870\ub9bd \uc791\uc5c5\uc5d0\uc11c \uc561\uc158 \uc0ac\uc6a9", url: "#_19" },
              {title: "\uc11c\ube44\uc2a4\uc640 \uc561\uc158\uc758 \uc2e4\uc81c \uc0ac\ub840", url: "#_21" },
              {title: "\uc0ac\ub840 3: \uc0b0\uc5c5 \uc790\ub3d9\ud654 \uc2dc\uc2a4\ud15c\uc5d0\uc11c\uc758 \ud65c\uc6a9", url: "#3" },
              {title: "\uc0ac\ub840 4: \uc790\uc728 \uc8fc\ud589 \ucc28\ub7c9\uc758 \uc791\uc5c5 \ubd84\ud560", url: "#4" },
          ]},
        ];

    </script>
<script src="../../../../js/base.js"></script>
<script src="../../../../js/google_analytics.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script>
</meta></head>
<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>
<div class="container-fluid wm-page-content">
<a name="_top"></a>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../../chapter_06/0601/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../../chapter_06/0601/">
        생명주기 노드의 개념 및 상태
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0504/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0504/">
        서비스와 액션의 개념 및 차이점
      </a>
</div>
</div>
<h3 id="_1">서비스의 개념 및 기본 구조</h3>
<p>ROS2에서 서비스(Service)는 요청(request)과 응답(response) 방식으로 동작하는 통신 개념이다. 이는 클라이언트-서버 모델을 기반으로 하며, 클라이언트가 요청을 보내고 서버가 해당 요청에 대한 응답을 보내는 형태로 이루어진다. 서비스는 일회성 통신에 적합하며, 특정한 작업을 완료하는 데 자주 사용된다.</p>
<p>다음은 ROS2에서 서비스 서버와 클라이언트를 설정하고, 이를 활용한 간단한 예제 코드이다.</p>
<h4 id="_2">서버 구현 예제</h4>
<pre><code class="language-cpp">#include "rclcpp/rclcpp.hpp"
#include "example_interfaces/srv/add_two_ints.hpp"

class AddTwoIntsServer : public rclcpp::Node
{
public:
  AddTwoIntsServer() : Node("add_two_ints_server")
  {
    service_ = this-&gt;create_service&lt;example_interfaces::srv::AddTwoInts&gt;(
        "add_two_ints", std::bind(&amp;AddTwoIntsServer::handle_add_two_ints, this, _1, _2));
  }

private:
  void handle_add_two_ints(const std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Request&gt; request,
                           std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Response&gt; response)
  {
    response-&gt;sum = request-&gt;a + request-&gt;b;
    RCLCPP_INFO(this-&gt;get_logger(), "Incoming request\na: %ld b: %ld", request-&gt;a, request-&gt;b);
  }

  rclcpp::Service&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr service_;
};

int main(int argc, char **argv)
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared&lt;AddTwoIntsServer&gt;());
  rclcpp::shutdown();
  return 0;
}
</code></pre>
<p>위 코드는 두 개의 정수를 더하는 간단한 서비스 서버이다. 클라이언트가 두 개의 정수를 요청으로 보내면 서버가 해당 요청을 처리하고 결과를 반환한다.</p>
<h3 id="_3">액션의 개념 및 기본 구조</h3>
<p>액션(Action)은 서비스와 달리 장시간 걸리는 비동기 작업을 처리하는 데 적합한 구조이다. 액션 서버는 클라이언트로부터 목표(goal)를 수신한 후, 이를 처리하면서 중간 결과(feedback)를 제공하고, 최종적으로 완료되었을 때 결과(result)를 반환한다. 액션은 장시간 작업을 잘 지원하며, 작업 도중 피드백을 받을 수 있는 구조적 장점이 있다.</p>
<p>액션의 구조는 크게 세 부분으로 나뉜다:</p>
<ul>
<li><strong>Goal</strong>: 작업의 목표를 설정하는 부분</li>
<li><strong>Feedback</strong>: 작업이 진행 중일 때 클라이언트에 보내는 중간 결과</li>
<li><strong>Result</strong>: 작업이 완료되었을 때 반환되는 최종 결과</li>
</ul>
<h4 id="_4">액션 서버와 클라이언트의 상호작용</h4>
<p>액션은 다양한 실용적인 예시에서 활용된다. 예를 들어, 로봇이 지정된 목표 지점으로 이동할 때 액션 서버는 로봇이 목표 지점에 도달할 때까지 주기적으로 피드백을 클라이언트로 전송할 수 있다.</p>
<p>다음은 이동 관련 액션 서버 예시이다.</p>
<pre><code class="language-cpp">#include "rclcpp/rclcpp.hpp"
#include "example_interfaces/action/move_to_goal.hpp"
#include "rclcpp_action/rclcpp_action.hpp"

class MoveToGoalActionServer : public rclcpp::Node
{
public:
  using MoveToGoal = example_interfaces::action::MoveToGoal;
  using GoalHandleMoveToGoal = rclcpp_action::ServerGoalHandle&lt;MoveToGoal&gt;;

  MoveToGoalActionServer() : Node("move_to_goal_action_server")
  {
    action_server_ = rclcpp_action::create_server&lt;MoveToGoal&gt;(
        this,
        "move_to_goal",
        std::bind(&amp;MoveToGoalActionServer::handle_goal, this, _1, _2),
        std::bind(&amp;MoveToGoalActionServer::handle_cancel, this, _1),
        std::bind(&amp;MoveToGoalActionServer::handle_accepted, this, _1));
  }

private:
  rclcpp_action::GoalResponse handle_goal(const rclcpp_action::GoalUUID &amp;uuid,
                                          std::shared_ptr&lt;const MoveToGoal::Goal&gt; goal)
  {
    RCLCPP_INFO(this-&gt;get_logger(), "Received goal request with distance %f", goal-&gt;distance);
    return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
  }

  rclcpp_action::CancelResponse handle_cancel(const std::shared_ptr&lt;GoalHandleMoveToGoal&gt; goal_handle)
  {
    RCLCPP_INFO(this-&gt;get_logger(), "Received request to cancel goal");
    return rclcpp_action::CancelResponse::ACCEPT;
  }

  void handle_accepted(const std::shared_ptr&lt;GoalHandleMoveToGoal&gt; goal_handle)
  {
    using namespace std::placeholders;
    std::thread{std::bind(&amp;MoveToGoalActionServer::execute, this, _1), goal_handle}.detach();
  }

  void execute(const std::shared_ptr&lt;GoalHandleMoveToGoal&gt; goal_handle)
  {
    const auto goal = goal_handle-&gt;get_goal();
    auto feedback = std::make_shared&lt;MoveToGoal::Feedback&gt;();
    auto result = std::make_shared&lt;MoveToGoal::Result&gt;();

    for (int i = 0; i &lt;= 100; ++i)
    {
      if (goal_handle-&gt;is_canceling())
      {
        result-&gt;success = false;
        goal_handle-&gt;canceled(result);
        RCLCPP_INFO(this-&gt;get_logger(), "Goal canceled");
        return;
      }
      feedback-&gt;progress = i;
      goal_handle-&gt;publish_feedback(feedback);
      RCLCPP_INFO(this-&gt;get_logger(), "Progress: %d%%", i);
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    result-&gt;success = true;
    goal_handle-&gt;succeed(result);
    RCLCPP_INFO(this-&gt;get_logger(), "Goal succeeded");
  }

  rclcpp_action::Server&lt;MoveToGoal&gt;::SharedPtr action_server_;
};

int main(int argc, char **argv)
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared&lt;MoveToGoalActionServer&gt;());
  rclcpp::shutdown();
  return 0;
}
</code></pre>
<p>이 코드에서는 액션 서버가 목표 지점까지 이동하는 작업을 수행하며, 진행 중에 피드백을 클라이언트로 전송한다.</p>
<h3 id="_5">서비스와 액션의 활용 차이점</h3>
<p>서비스와 액션은 서로 다른 통신 요구에 적합하게 설계되었다. 서비스는 짧은 작업에 적합하며, 비동기적 요구는 액션을 통해 해결할 수 있다. 예를 들어, 로봇이 특정 위치에 이동하거나, 이미지를 처리하는 등의 장기 작업에서는 액션이 더 유리한다.</p>
<h4 id="_6">서비스와 액션의 결합</h4>
<p>다음은 서비스와 액션을 결합하여 더 복잡한 로봇 시스템을 구현하는 방법에 대한 예이다. 예를 들어, 특정 작업(예: 로봇 팔 움직임)의 성공 여부를 서비스로 처리하고, 장기 작업(예: 로봇의 이동)은 액션을 통해 처리할 수 있다.</p>
<h2 id="_7">서비스 활용 사례</h2>
<h3 id="_8">로봇 제어에서의 서비스 호출</h3>
<p>로봇 제어 시스템에서 서비스를 이용하여 특정한 작업을 요청하거나 명령을 전달하는 경우가 빈번한다. 예를 들어, 로봇 팔이 특정 위치로 이동해야 하는 상황을 생각해 봅시다. 이때 사용자는 서비스 서버로 목표 위치를 전달하고, 서버는 이 요청을 받아들여 로봇 팔이 해당 위치로 이동할 수 있도록 명령을 실행하게 된다.</p>
<h4 id="_9">서비스 요청 예제</h4>
<p>로봇 팔 제어에서, 목표 좌표를 전달하고 이동 명령을 실행하는 서비스의 인터페이스는 다음과 같이 구성될 수 있다.</p>
<ul>
<li><strong>입력:</strong> 목표 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p} = [x, y, z]</span><script type="math/tex">\mathbf{p} = [x, y, z]</script></span></li>
<li><strong>출력:</strong> 성공 여부와 완료 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span></li>
</ul>
<p>사용자는 서비스 요청을 통해 로봇 팔이 특정 좌표로 이동할 것을 요구할 수 있다. 이때, 목표 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 3차원 벡터로 표현되며, 서비스 호출 시 이를 매개변수로 전달한다.</p>
<pre><code class="language-python">class MoveRobotArmService:
    def __init__(self):
        self.service = create_service(MoveRobot, 'move_robot_arm', self.handle_move_robot_arm)

    def handle_move_robot_arm(self, request, response):
        target_position = request.position  # 목표 좌표 [x, y, z]
        # 로봇 팔 이동 로직 수행
        response.success = move_to_position(target_position)
        response.completion_time = get_current_time()
        return response
</code></pre>
<p>여기서 중요한 점은 서비스가 비동기적으로 동작할 수 있다는 점이다. 즉, 클라이언트는 서비스 요청을 보낸 후 즉시 결과를 기다리는 것이 아니라, 서비스 서버가 응답을 완료할 때까지 다른 작업을 수행할 수 있다.</p>
<h3 id="_10">센서 데이터 요청 서비스</h3>
<p>ROS2 시스템에서는 여러 종류의 센서를 통해 데이터를 수집할 수 있다. 센서 데이터는 일반적으로 토픽을 통해 실시간으로 전달되지만, 특정 시점의 데이터를 요청하고자 할 때 서비스가 유용하게 사용될 수 있다.</p>
<h4 id="_11">센서 서비스 요청 예제</h4>
<p>특정 센서 데이터, 예를 들어 로봇의 주변 온도를 조회하는 서비스를 고려해 보자. 서비스 요청 시, 현재 온도 <span class="arithmatex"><span class="MathJax_Preview">T(t)</span><script type="math/tex">T(t)</script></span>를 제공하는 서버는 다음과 같은 방식으로 구성된다.</p>
<ul>
<li><strong>입력:</strong> 요청 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span></li>
<li><strong>출력:</strong> 해당 시점의 온도 <span class="arithmatex"><span class="MathJax_Preview">T(t)</span><script type="math/tex">T(t)</script></span></li>
</ul>
<pre><code class="language-python">class TemperatureService:
    def __init__(self):
        self.service = create_service(GetTemperature, 'get_temperature', self.handle_get_temperature)

    def handle_get_temperature(self, request, response):
        current_temperature = read_temperature_sensor()
        response.temperature = current_temperature
        return response
</code></pre>
<p>이와 같은 방식으로, 서비스 호출을 통해 특정 시점의 센서 데이터를 손쉽게 요청할 수 있으며, 이러한 접근 방식은 특히 실시간 데이터가 필요하지 않은 경우에 유용하다.</p>
<h2 id="_12">액션 활용 사례</h2>
<h3 id="_13">로봇 이동 경로 추종에서의 액션 사용</h3>
<p>액션 서버는 긴 시간이 소요되는 작업을 처리할 때 매우 유용하다. 예를 들어, 로봇이 지정된 경로를 따라 이동하는 작업을 생각해 봅시다. 경로를 추종하는 동안 주기적으로 현재 상태를 피드백으로 받아보아야 하며, 경로 이동이 완료되었을 때 완료 신호를 받아야 한다.</p>
<h4 id="_14">경로 추종 액션 예제</h4>
<p>로봇의 경로 추종을 위한 액션 서버의 인터페이스는 다음과 같이 구성될 수 있다.</p>
<ul>
<li><strong>목표:</strong> 경로 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P} = [\mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n]</span><script type="math/tex">\mathbf{P} = [\mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n]</script></span></li>
<li><strong>피드백:</strong> 현재 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span></li>
<li><strong>결과:</strong> 경로 완료 여부</li>
</ul>
<p>경로 추종 중 로봇의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>는 피드백으로 클라이언트에게 주기적으로 전달된다.</p>
<pre><code class="language-python">class FollowPathActionServer:
    def __init__(self):
        self.action_server = create_action_server(FollowPath, 'follow_path', self.execute_path)

    def execute_path(self, goal_handle):
        path = goal_handle.request.path  # 경로 [p1, p2, ..., pn]
        for waypoint in path:
            # 경로 추종 로직 수행
            move_to_waypoint(waypoint)
            feedback = FollowPath.Feedback()
            feedback.current_position = get_robot_position()
            goal_handle.publish_feedback(feedback)

        goal_handle.succeed()
        result = FollowPath.Result()
        result.success = True
        return result
</code></pre>
<p>액션 서버는 목표 경로를 따라 로봇이 이동하는 동안 지속적으로 현재 위치를 피드백으로 제공하며, 경로를 모두 따라간 후 성공 여부를 클라이언트에 알린다.</p>
<h3 id="_15">드론의 착륙 동작에서 액션 사용</h3>
<p>드론이나 무인항공기(UAV)의 착륙 과정은 즉시 완료되는 작업이 아니기 때문에, 착륙 동작을 관리하는 액션 서버를 사용하는 것이 효과적이다. 드론이 착륙할 위치에 도달하고 실제로 착륙을 완료하는 과정 동안 실시간 상태 피드백이 필요하다.</p>
<h4 id="_16">착륙 동작 액션 예제</h4>
<p>착륙을 위한 액션 서버의 인터페이스는 다음과 같이 구성될 수 있다.</p>
<ul>
<li><strong>목표:</strong> 착륙 좌표 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_l = [x_l, y_l, z_l]</span><script type="math/tex">\mathbf{p}_l = [x_l, y_l, z_l]</script></span></li>
<li><strong>피드백:</strong> 현재 고도 <span class="arithmatex"><span class="MathJax_Preview">z(t)</span><script type="math/tex">z(t)</script></span></li>
<li><strong>결과:</strong> 착륙 완료 여부</li>
</ul>
<p>드론이 착륙 과정에서 고도 <span class="arithmatex"><span class="MathJax_Preview">z(t)</span><script type="math/tex">z(t)</script></span>를 주기적으로 피드백으로 제공하며, 안전하게 착륙했을 때 착륙 완료 신호를 전송한다.</p>
<pre><code class="language-python">class LandDroneActionServer:
    def __init__(self):
        self.action_server = create_action_server(LandDrone, 'land_drone', self.execute_landing)

    def execute_landing(self, goal_handle):
        landing_position = goal_handle.request.position  # 착륙 좌표 [x_l, y_l, z_l]
        current_altitude = get_current_altitude()

        while current_altitude &gt; landing_position[2]:
            # 착륙 로직 수행
            decrease_altitude()
            feedback = LandDrone.Feedback()
            feedback.current_altitude = get_current_altitude()
            goal_handle.publish_feedback(feedback)
            current_altitude = get_current_altitude()

        goal_handle.succeed()
        result = LandDrone.Result()
        result.success = True
        return result
</code></pre>
<p>이 예제에서 액션 서버는 착륙 중에 드론의 현재 고도를 클라이언트에게 피드백으로 제공하며, 최종적으로 드론이 착륙 완료 상태에 도달했을 때 성공 신호를 보낸다.</p>
<h3 id="_17">로봇의 비전 기반 객체 인식에서의 액션 사용</h3>
<p>로봇이 카메라를 통해 객체를 인식하는 작업은 상당히 시간이 걸리며, 지속적인 피드백이 필요한 경우가 많다. 이때 액션 서버를 사용하면, 객체를 찾는 동안 피드백을 받을 수 있고, 객체 인식이 완료되면 결과를 받을 수 있다.</p>
<h4 id="_18">객체 인식 액션 예제</h4>
<p>로봇이 특정 객체를 인식하는 작업을 위한 액션 서버는 다음과 같이 설계될 수 있다.</p>
<ul>
<li><strong>목표:</strong> 인식할 객체의 ID <span class="arithmatex"><span class="MathJax_Preview">\mathbf{id}</span><script type="math/tex">\mathbf{id}</script></span></li>
<li><strong>피드백:</strong> 현재 인식 중인 객체의 상태</li>
<li><strong>결과:</strong> 인식 성공 여부 및 객체 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_o = [x_o, y_o, z_o]</span><script type="math/tex">\mathbf{p}_o = [x_o, y_o, z_o]</script></span></li>
</ul>
<pre><code class="language-python">class ObjectRecognitionActionServer:
    def __init__(self):
        self.action_server = create_action_server(ObjectRecognition, 'recognize_object', self.execute_recognition)

    def execute_recognition(self, goal_handle):
        object_id = goal_handle.request.object_id  # 인식할 객체 ID
        while not object_recognized(object_id):
            # 객체 인식 로직 수행
            feedback = ObjectRecognition.Feedback()
            feedback.recognition_progress = get_recognition_progress()
            goal_handle.publish_feedback(feedback)

        goal_handle.succeed()
        result = ObjectRecognition.Result()
        result.object_position = get_object_position()
        return result
</code></pre>
<p>액션 서버는 객체 인식이 진행되는 동안 인식 상태를 피드백으로 제공하며, 객체 인식이 완료되면 객체의 위치와 함께 성공 여부를 클라이언트에 전달한다.</p>
<h3 id="_19">로봇 암의 조립 작업에서 액션 사용</h3>
<p>로봇 암이 여러 부품을 조립하는 작업에서는 각 단계별로 부품을 정확한 위치에 놓아야 하는 경우가 많다. 이러한 작업은 장시간에 걸쳐 수행되며, 각 부품을 놓을 때마다 피드백을 통해 현재 상태를 확인할 수 있다.</p>
<h4 id="_20">조립 작업 액션 예제</h4>
<p>조립 작업의 액션 서버는 다음과 같이 구성될 수 있다.</p>
<ul>
<li><strong>목표:</strong> 조립할 부품들의 위치 리스트 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_a = [\mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n]</span><script type="math/tex">\mathbf{P}_a = [\mathbf{p}_1, \mathbf{p}_2, \dots, \mathbf{p}_n]</script></span></li>
<li><strong>피드백:</strong> 현재 조립 단계 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span></li>
<li><strong>결과:</strong> 조립 완료 여부</li>
</ul>
<pre><code class="language-python">class AssemblyActionServer:
    def __init__(self):
        self.action_server = create_action_server(Assembly, 'assembly_robot_arm', self.execute_assembly)

    def execute_assembly(self, goal_handle):
        assembly_positions = goal_handle.request.assembly_positions  # 조립할 위치 리스트
        for i, position in enumerate(assembly_positions):
            move_to_position(position)
            feedback = Assembly.Feedback()
            feedback.current_step = i
            goal_handle.publish_feedback(feedback)

        goal_handle.succeed()
        result = Assembly.Result()
        result.success = True
        return result
</code></pre>
<p>이 액션 서버는 로봇이 각 부품을 지정된 위치에 놓는 동안 현재 조립 단계에 대한 피드백을 제공하며, 모든 부품이 조립되었을 때 성공 여부를 클라이언트에 알린다.</p>
<h3 id="_21">서비스와 액션의 실제 사례</h3>
<h4 id="1">사례 1: 로봇의 이동과 목표 지점 도달</h4>
<p>로봇의 네비게이션에서 자주 사용되는 예는 특정 목표 지점으로 로봇을 이동시키는 작업이다. 이러한 작업에서는 액션 서버가 로봇이 이동할 목표 좌표를 목표(goal)로 받아, 이동하는 동안 피드백을 클라이언트에 제공하며, 도착 시 결과를 반환한다. 이와 동시에 서비스는 더 작은 단위의 작업, 예를 들어 특정 장애물을 우회하기 위한 순간적인 회전이나 직진 같은 작업을 처리하는 데 사용될 수 있다.</p>
<p>액션은 클라이언트에서 비동기적으로 실행되며, 도중에 취소 요청을 보내거나 진행 중인 피드백을 받으면서도 자유롭게 다른 작업을 처리할 수 있다.</p>
<h4 id="2">사례 2: 로봇 팔의 제어</h4>
<p>로봇 팔을 제어할 때, 서비스와 액션은 매우 유용하다. 간단한 작업, 예를 들어 로봇 팔의 조인트를 특정 각도로 회전시키는 작업은 서비스로 쉽게 처리할 수 있다. 그러나 로봇 팔이 복잡한 동작을 수행하거나 연속적인 움직임을 필요로 할 때, 예를 들어 특정 위치에서 물체를 집고 다른 위치로 이동하는 작업에는 액션을 사용하여 장기적인 동작을 비동기적으로 처리하고, 중간에 피드백을 통해 동작 상태를 파악할 수 있다.</p>
<p>이 예에서, 서비스는 주로 개별적이고 짧은 동작을 실행하는 데 적합하며, 액션은 장기적이고 연속적인 작업에 더 적합한다. 서비스와 액션을 동시에 활용함으로써, 로봇 팔의 정교한 동작과 유연한 제어를 실현할 수 있다.</p>
<h3 id="3">사례 3: 산업 자동화 시스템에서의 활용</h3>
<p>산업 자동화 시스템에서는 액션과 서비스가 다양한 방식으로 결합되어 사용된다. 예를 들어, 공장에서 컨베이어 벨트를 제어하는 시스템에서는 다음과 같은 시나리오를 생각할 수 있다:</p>
<ul>
<li>컨베이어 벨트를 특정 위치로 이동시키는 작업은 <strong>액션</strong>으로 처리된다. 이때 이동 중에 발생하는 상태 정보(예: 현재 위치, 목표 위치에 대한 진행률)는 클라이언트로 피드백되어 시스템이 동작 상태를 실시간으로 모니터링할 수 있다.</li>
<li>컨베이어 벨트가 멈추거나, 특정한 간격으로 동작하는 작은 작업들은 <strong>서비스</strong>를 통해 처리된다. 이러한 서비스는 단일 요청-응답 모델로 설계되어, 즉시 처리되고 응답을 반환한다.</li>
</ul>
<p>이러한 복잡한 시스템에서는 서비스와 액션을 적절히 결합하여 시스템의 유연성과 반응성을 높이는 것이 중요하다. 다음은 이를 구현하기 위한 통합된 시스템 예이다:</p>
<div class="mermaid">graph LR
  Client --&gt;|서비스 요청| Service_Server
  Client --&gt;|액션 목표 설정| Action_Server
  Service_Server --&gt;|즉각 응답| Client
  Action_Server --&gt;|피드백 전송| Client
  Action_Server --&gt;|결과 전송| Client
</div>
<p>위의 다이어그램은 클라이언트가 서비스 서버와 액션 서버에 각각 요청을 보내는 과정을 보여준다. 서비스는 즉각적으로 응답을 반환하고, 액션은 목표에 도달할 때까지 주기적으로 피드백을 보낸다.</p>
<h3 id="4">사례 4: 자율 주행 차량의 작업 분할</h3>
<p>자율 주행 차량에서도 서비스와 액션의 활용이 매우 중요하다. 예를 들어, 차량이 특정 목적지까지 주행하는 동안에는 액션을 사용하여 이동 상태를 지속적으로 모니터링하고 피드백을 받을 수 있다. 또한, 차량이 주행 중 만나는 짧은 작업들(예: 차선 변경, 장애물 회피 등)은 서비스로 처리된다. 이 과정에서 액션과 서비스는 상호 보완적인 역할을 한다.</p>
<h4 id="_22">액션 피드백과 결과 처리</h4>
<p>액션을 통해 피드백을 제공하는 과정에서 클라이언트는 중간에 작업을 취소할 수 있다. 예를 들어, 자율 주행 차량이 주행 중에 목적지 변경 요청을 받았을 경우, 액션을 취소하고 새로운 목표를 설정할 수 있다. 반면, 서비스는 이미 진행 중인 작업을 취소하거나 변경할 수 없으므로, 작업이 완료된 후 새로운 작업을 요청해야 한다.</p>
<hr/>
<p>서비스와 액션은 각각 짧은 일회성 작업과 장시간에 걸친 비동기 작업을 효과적으로 처리하는 데 최적화되어 있다. 이를 통해 다양한 로봇 및 자율 시스템에서 유연한 통신을 구현할 수 있다. 실제 로봇 제어나 복잡한 자동화 시스템에서는 이 두 가지 방법을 적절히 결합하여 사용할 수 있으며, 이러한 통합은 시스템의 성능과 반응성을 높이는 데 중요한 역할을 한다.</p>
<br/>
<div aria-label="navigation" class="row wm-article-nav-buttons" role="navigation">
<div class="wm-article-nav pull-right">
<a class="btn btn-xs btn-default pull-right" href="../../chapter_06/0601/">
        Next
        <i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
<a class="btn btn-xs btn-link" href="../../chapter_06/0601/">
        생명주기 노드의 개념 및 상태
      </a>
</div>
<div class="wm-article-nav">
<a class="btn btn-xs btn-default pull-left" href="../0504/">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
        Previous</a><a class="btn btn-xs btn-link" href="../0504/">
        서비스와 액션의 개념 및 차이점
      </a>
</div>
</div>
<br/>
</div>
<footer class="container-fluid wm-page-content">
<p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>