<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/ros2_humble/chapter_01/0102/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>ROS2의 ROS1과의 차이점 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ud1b5\uc2e0 \ud504\ub85c\ud1a0\ucf5c \ubcc0\ud654: DDS\uc640 RTPS \uae30\ubc18", url: "#_top", children: [
          ]},
          {title: "\ub124\uc774\ud2f0\ube0c \uba40\ud2f0\uc2a4\ub808\ub529 \uc9c0\uc6d0", url: "#_1", children: [
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ucc98\ub9ac \uc9c0\uc6d0", url: "#_2", children: [
          ]},
          {title: "\ud06c\ub85c\uc2a4 \ud50c\ub7ab\ud3fc \uc9c0\uc6d0", url: "#_3", children: [
          ]},
          {title: "\ub178\ub4dc \uc0dd\uba85\uc8fc\uae30(Lifecycle)", url: "#lifecycle", children: [
          ]},
          {title: "ROS2\uc758 QoS(\ud488\uc9c8 \uc11c\ube44\uc2a4) \uc815\ucc45", url: "#ros2-qos", children: [
          ]},
          {title: "\ube4c\ub4dc \uc2dc\uc2a4\ud15c\uc758 \ubcc0\ud654", url: "#_4", children: [
          ]},
          {title: "\ubcf4\uc548 \uae30\ub2a5\uc758 \ud5a5\uc0c1", url: "#_5", children: [
          ]},
          {title: "\ud30c\ub77c\ubbf8\ud130 \uc11c\ubc84 \ubc0f \ub3d9\uc801 \ud30c\ub77c\ubbf8\ud130", url: "#_6", children: [
          ]},
          {title: "\ubd84\uc0b0 \uc2dc\uc2a4\ud15c \uc9c0\uc6d0", url: "#_7", children: [
          ]},
          {title: "Node-to-Node \ud1b5\uc2e0 \ubc29\uc2dd\uc758 \ubcc0\ud654", url: "#node-to-node", children: [
          ]},
          {title: "\uc561\uc158(Action) \uae30\ubc18 \ube44\ub3d9\uae30 \uc791\uc5c5 \uc9c0\uc6d0", url: "#action", children: [
          ]},
          {title: "\ub7f0\ud0c0\uc784 \uad6c\uc131 \uad00\ub9ac", url: "#_8", children: [
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0103/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0103/" class="btn btn-xs btn-link">
        ROS2 릴리즈 사이클 및 버전 관리
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0101/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0101/" class="btn btn-xs btn-link">
        ROS의 역사와 배경
      </a>
    </div>
    
  </div>

    

    <h3 id="dds-rtps">통신 프로토콜 변화: DDS와 RTPS 기반</h3>
<p>ROS1에서는 자체 개발한 <code>ROS_MASTER_URI</code>를 통해 노드 간 통신을 관리했지만, ROS2는 데이터 분산 서비스(DDS)와 실시간 퍼블리싱 구독(RTPS) 프로토콜을 표준으로 채택하였다. 이를 통해 ROS2는 기본적으로 분산 아키텍처를 제공하여 더욱 안정적이고 유연한 네트워크 통신을 가능하게 한다. ROS2에서의 DDS는 퍼블리셔와 서브스크라이버 간의 연결을 직접 처리하며, <code>ROS_MASTER_URI</code>와 같은 중앙 관리 서버가 필요하지 않는다.</p>
<h3 id="_1">네이티브 멀티스레딩 지원</h3>
<p>ROS1은 멀티스레딩 처리를 위한 별도의 설정이 필요하며, 멀티스레딩 성능이 제한적이다. 반면에 ROS2는 처음부터 멀티스레딩을 지원하도록 설계되었다. ROS2는 각 노드의 콜백 그룹을 통해 여러 개의 실행자를 활용하여 병렬 처리를 가능하게 한다. 실행자(executor)를 사용하면 각 노드가 다양한 콜백 함수를 별도로 처리할 수 있으며, 이를 통해 병렬 처리가 가능한다. 이를 수식으로 표현하면, 각 콜백 그룹 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}_i</span><script type="math/tex">\mathbf{C}_i</script></span>에 대해 실행자는 다음과 같은 방정식을 따른다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{E} = \sum_{i=1}^{n} f(\mathbf{C}_i)
</div>
<script type="math/tex; mode=display">
\mathbf{E} = \sum_{i=1}^{n} f(\mathbf{C}_i)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{E}</span><script type="math/tex">\mathbf{E}</script></span>는 실행자의 총 처리량을, <span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{C}_i)</span><script type="math/tex">f(\mathbf{C}_i)</script></span>는 콜백 그룹 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}_i</span><script type="math/tex">\mathbf{C}_i</script></span>의 처리 시간을 의미한다.</p>
<h3 id="_2">실시간 처리 지원</h3>
<p>ROS1에서는 실시간 시스템을 구현하기 위한 지원이 제한적이었다. 그러나 ROS2는 실시간 시스템을 염두에 두고 개발되었다. ROS2는 우선순위 스케줄링 및 메모리 관리 등 실시간 기능을 향상시키기 위한 메커니즘을 제공한다. 실시간 시스템에서 중요한 요소 중 하나는 지연 시간(latency)을 줄이는 것이며, ROS2는 이를 위해 실시간 안전 큐와 메모리 할당을 제공한다.</p>
<p>실시간 시스템에서의 지연 시간은 다음과 같은 수식으로 모델링할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
L = \frac{T_{max} - T_{min}}{2}
</div>
<script type="math/tex; mode=display">
L = \frac{T_{max} - T_{min}}{2}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span>은 지연 시간을, <span class="arithmatex"><span class="MathJax_Preview">T_{max}</span><script type="math/tex">T_{max}</script></span>는 최대 응답 시간을, <span class="arithmatex"><span class="MathJax_Preview">T_{min}</span><script type="math/tex">T_{min}</script></span>은 최소 응답 시간을 의미한다.</p>
<h3 id="_3">크로스 플랫폼 지원</h3>
<p>ROS1은 주로 Ubuntu에서만 실행 가능했지만, ROS2는 Windows, macOS, Linux 등 다양한 운영 체제를 공식적으로 지원한다. 이로 인해 더욱 폭넓은 개발 환경에서 ROS2를 활용할 수 있게 되었으며, 산업용 및 상업용 로봇 개발에 더욱 적합하게 되었다. 크로스 플랫폼 지원을 위한 빌드 시스템은 각 플랫폼에 맞는 CMake 파일을 사용하여 유연성을 보장한다. </p>
<h3 id="lifecycle">노드 생명주기(Lifecycle)</h3>
<p>ROS1에서는 노드가 시작되면 일반적으로 종료될 때까지 활성 상태로 유지되며, 명시적인 상태 관리를 지원하지 않았다. 반면에 ROS2는 노드의 생명주기(Lifecycle)를 관리하는 기능을 제공한다. 이를 통해 노드는 활성화, 비활성화 등의 상태를 가질 수 있으며, 특정 상태에 따라 노드의 동작을 제어할 수 있다. </p>
<p>노드의 생명주기는 크게 다음과 같은 상태들로 구성된다:
- <code>unconfigured</code>: 노드가 설정되지 않은 초기 상태
- <code>inactive</code>: 설정은 되었으나 활성화되지 않은 상태
- <code>active</code>: 완전히 활성화된 상태로, 퍼블리셔나 서브스크라이버 등을 처리하는 상태
- <code>finalized</code>: 노드가 종료된 상태</p>
<p>각 상태 전환은 다음과 같은 전이 함수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}(s_i, s_j)</span><script type="math/tex">\mathbf{T}(s_i, s_j)</script></span>로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{T}(s_i, s_j) = \begin{cases} 
1 &amp; \text{상태 } s_i \text{에서 } s_j \text{로 전이 가능할 때} \\
0 &amp; \text{전이 불가능할 때}
\end{cases}
</div>
<script type="math/tex; mode=display">
\mathbf{T}(s_i, s_j) = \begin{cases} 
1 & \text{상태 } s_i \text{에서 } s_j \text{로 전이 가능할 때} \\
0 & \text{전이 불가능할 때}
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">s_i</span><script type="math/tex">s_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">s_j</span><script type="math/tex">s_j</script></span>는 각각 현재 상태와 전이 후 상태를 나타낸다.</p>
<h3 id="ros2-qos">ROS2의 QoS(품질 서비스) 정책</h3>
<p>ROS1에서는 토픽 간의 통신 품질에 대해 세밀하게 제어할 수 있는 기능이 없었다. 그러나 ROS2에서는 DDS를 사용함으로써 QoS(품질 서비스) 정책을 통해 통신의 신뢰성, 지연 시간, 지속성 등을 세부적으로 설정할 수 있다. QoS 정책은 주로 퍼블리셔와 서브스크라이버 사이의 메시지 송수신 방식을 결정하며, 이를 통해 다양한 네트워크 환경에서 통신 성능을 최적화할 수 있다.</p>
<p>QoS 정책은 다음과 같은 매개변수들을 포함한다:
- <code>Reliability</code>: 통신의 신뢰성을 보장할지 여부 (예: <code>Reliable</code> vs <code>Best effort</code>)
- <code>Durability</code>: 메시지의 지속성 (예: <code>Transient local</code> vs <code>Volatile</code>)
- <code>History</code>: 버퍼링되는 메시지의 개수
- <code>Deadline</code>: 메시지 도착 시간을 보장하는 제한 시간</p>
<p>QoS 설정에 따라 퍼블리셔와 서브스크라이버 간의 메시지 송수신을 수식으로 나타내면 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{Q}(p, s) = \text{QoS}(p) \cap \text{QoS}(s)
</div>
<script type="math/tex; mode=display">
\mathbf{Q}(p, s) = \text{QoS}(p) \cap \text{QoS}(s)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>는 퍼블리셔, <span class="arithmatex"><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>는 서브스크라이버를 나타내며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}(p, s)</span><script type="math/tex">\mathbf{Q}(p, s)</script></span>는 퍼블리셔와 서브스크라이버 간의 QoS 정책을 반영한 통신 성능을 의미한다.</p>
<h3 id="_4">빌드 시스템의 변화</h3>
<p>ROS1은 <code>catkin</code>이라는 빌드 시스템을 사용했으나, ROS2는 <code>colcon</code>이라는 새로운 빌드 도구로 전환되었다. <code>colcon</code>은 멀티패키지 빌드 환경을 제공하며, ROS2는 여러 패키지를 병렬로 빌드할 수 있는 기능을 갖추고 있다. 이는 특히 대규모 프로젝트에서 빌드 시간을 크게 단축시킨다.</p>
<p>각 패키지의 의존성을 관리하고 빌드하는 과정은 다음과 같은 의존성 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>로 표현할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{D}_{i,j} = \begin{cases} 
1 &amp; \text{패키지 } P_i \text{가 } P_j \text{에 의존할 때} \\
0 &amp; \text{의존하지 않을 때}
\end{cases}
</div>
<script type="math/tex; mode=display">
\mathbf{D}_{i,j} = \begin{cases} 
1 & \text{패키지 } P_i \text{가 } P_j \text{에 의존할 때} \\
0 & \text{의존하지 않을 때}
\end{cases}
</script>
</div>
<p>이 의존성 행렬을 통해 <code>colcon</code>은 패키지 간의 의존성을 분석하여 빌드 순서를 최적화한다.</p>
<h3 id="_5">보안 기능의 향상</h3>
<p>ROS1에서는 기본적으로 보안 기능을 제공하지 않았으며, 보안 통신을 구현하기 위해서는 별도의 네트워크 설정 및 보안 도구가 필요하였다. 반면에 ROS2는 보안성을 강화하여 SROS2라는 보안 확장 기능을 제공한다. SROS2는 DDS의 보안 표준을 기반으로 하여 노드 간 통신을 암호화하고, 인증서를 통한 인증 절차를 지원한다. 이를 통해 민감한 데이터를 처리하거나 보안이 중요한 환경에서 ROS2를 안전하게 사용할 수 있다.</p>
<p>보안 설정을 위한 주요 요소는 다음과 같다:
- <strong>암호화(Encryption)</strong>: 노드 간의 모든 메시지 데이터를 암호화하여 제3자가 중간에서 데이터에 접근하는 것을 방지한다.
- <strong>인증(Authentication)</strong>: 노드들이 상호 통신하기 전에 서로를 인증하는 과정을 통해, 허가된 노드들만 네트워크에서 통신할 수 있도록 한다.
- <strong>권한 관리(Authorization)</strong>: 각 노드에 대해 권한을 설정하여, 특정 노드가 접근 가능한 데이터와 실행 가능한 작업을 제한할 수 있다.</p>
<p>보안 모델은 다음과 같은 관계식으로 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{S}(n_i, n_j) = \begin{cases} 
1 &amp; \text{노드 } n_i \text{와 } n_j \text{가 보안 인증을 통과하고 통신할 수 있을 때} \\
0 &amp; \text{통신이 불가능할 때}
\end{cases}
</div>
<script type="math/tex; mode=display">
\mathbf{S}(n_i, n_j) = \begin{cases} 
1 & \text{노드 } n_i \text{와 } n_j \text{가 보안 인증을 통과하고 통신할 수 있을 때} \\
0 & \text{통신이 불가능할 때}
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">n_i</span><script type="math/tex">n_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">n_j</span><script type="math/tex">n_j</script></span>는 각각 통신하는 두 노드를 의미하며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{S}(n_i, n_j)</span><script type="math/tex">\mathbf{S}(n_i, n_j)</script></span>는 두 노드 간의 보안 통신 여부를 나타낸다.</p>
<h3 id="_6">파라미터 서버 및 동적 파라미터</h3>
<p>ROS1에서도 파라미터 서버를 제공하였지만, ROS2는 더욱 강화된 파라미터 관리 기능을 제공한다. 특히, ROS2의 파라미터 서버는 각 노드가 개별적으로 파라미터를 관리하며, 동적으로 파라미터를 변경할 수 있는 기능을 지원한다. 이를 통해 실시간으로 노드의 동작을 변경하거나 파라미터를 조정할 수 있어, 시스템의 유연성이 크게 향상되었다.</p>
<p>파라미터 서버의 기본 구조는 다음과 같이 나타낼 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}(n_i) = \{ p_1, p_2, \dots, p_k \}
</div>
<script type="math/tex; mode=display">
\mathbf{P}(n_i) = \{ p_1, p_2, \dots, p_k \}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}(n_i)</span><script type="math/tex">\mathbf{P}(n_i)</script></span>는 노드 <span class="arithmatex"><span class="MathJax_Preview">n_i</span><script type="math/tex">n_i</script></span>가 보유한 파라미터 집합을 의미하며, 각 파라미터 <span class="arithmatex"><span class="MathJax_Preview">p_1, p_2, \dots, p_k</span><script type="math/tex">p_1, p_2, \dots, p_k</script></span>는 해당 노드에서 조정 가능한 변수들이다. 또한, 파라미터는 다음과 같이 실시간으로 변경될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}(n_i) \longrightarrow \mathbf{P}'(n_i) = \{ p_1', p_2', \dots, p_k' \}
</div>
<script type="math/tex; mode=display">
\mathbf{P}(n_i) \longrightarrow \mathbf{P}'(n_i) = \{ p_1', p_2', \dots, p_k' \}
</script>
</div>
<p>변경된 파라미터 값들이 시스템에 반영되어 노드의 동작을 즉시 수정할 수 있다.</p>
<h3 id="_7">분산 시스템 지원</h3>
<p>ROS2는 ROS1과 달리 본질적으로 분산 시스템을 지원한다. ROS1에서는 모든 노드가 <code>ROS_MASTER_URI</code>라는 중앙 노드를 통해 통신을 중계받아야 했기 때문에, 분산 환경에서 사용하기에 어려움이 있었다. 그러나 ROS2에서는 노드들이 DDS 프로토콜을 사용하여 직접 통신하므로, 중앙 집중식 네트워크 구성을 필요로 하지 않으며, 대규모 분산 시스템에서 더욱 효율적으로 동작할 수 있다.</p>
<p>분산 시스템에서의 노드 간 통신은 다음과 같은 메시지 전달 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span>로 표현할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{M}_{i,j} = \begin{cases} 
1 &amp; \text{노드 } n_i \text{와 } n_j \text{가 직접 통신할 수 있을 때} \\
0 &amp; \text{통신할 수 없을 때}
\end{cases}
</div>
<script type="math/tex; mode=display">
\mathbf{M}_{i,j} = \begin{cases} 
1 & \text{노드 } n_i \text{와 } n_j \text{가 직접 통신할 수 있을 때} \\
0 & \text{통신할 수 없을 때}
\end{cases}
</script>
</div>
<p>이 행렬을 통해 각 노드 간의 직접적인 통신 가능 여부를 평가할 수 있으며, 분산 시스템의 성능을 최적화할 수 있다.</p>
<h3 id="node-to-node">Node-to-Node 통신 방식의 변화</h3>
<p>ROS1에서는 노드 간의 통신이 주로 메시지 패싱을 통해 이루어졌으며, 이러한 통신 방식은 매우 단순한 구조였다. 그러나 ROS2에서는 보다 복잡하고 유연한 통신 구조를 지원하며, 노드 간의 데이터 전송 방식이 DDS 프로토콜을 기반으로 한다. 이는 퍼블리셔와 서브스크라이버 간의 통신뿐만 아니라 서비스와 액션을 통해 비동기 통신 및 상태 관리가 용이하도록 설계되었다.</p>
<p>특히, ROS2에서는 노드 간 통신의 QoS(품질 서비스) 설정을 통해 네트워크 상황에 맞춘 최적화가 가능한다. 통신의 신뢰성을 높이기 위해 퍼블리셔와 서브스크라이버 간에 설정할 수 있는 다양한 QoS 옵션들이 있으며, 이를 수식으로 나타내면 다음과 같다.</p>
<p>퍼블리셔 <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>와 서브스크라이버 <span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span> 간의 통신을 위한 QoS 최적화는 다음과 같은 함수로 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{Q}(P, S) = \max \left( \text{Reliability}, \text{Durability}, \text{History}, \text{Deadline} \right)
</div>
<script type="math/tex; mode=display">
\mathbf{Q}(P, S) = \max \left( \text{Reliability}, \text{Durability}, \text{History}, \text{Deadline} \right)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}(P, S)</span><script type="math/tex">\mathbf{Q}(P, S)</script></span>는 두 노드 간의 최적 QoS 값을 나타내며, 각 QoS 옵션(신뢰성, 내구성, 버퍼링 내역, 제한 시간)의 최대치를 선택하여 통신 성능을 조절한다.</p>
<h3 id="action">액션(Action) 기반 비동기 작업 지원</h3>
<p>ROS1에서는 퍼블리셔-서브스크라이버 패턴이나 서비스 호출 방식으로 노드 간 통신을 했지만, 비동기 작업에 대한 지원은 제한적이었다. ROS2에서는 액션(Action)이라는 새로운 개념을 도입하여 비동기 작업을 쉽게 처리할 수 있다. 액션은 퍼블리셔와 서브스크라이버보다 복잡한 상호작용을 지원하며, 액션 서버와 클라이언트를 통해 긴 시간 동안 진행되는 작업의 상태를 모니터링하고 제어할 수 있다.</p>
<p>액션은 다음과 같은 상태 전환 모델로 표현할 수 있다:</p>
<ul>
<li><strong>Pending</strong>: 액션이 시작되지 않은 상태</li>
<li><strong>Active</strong>: 액션이 실행 중인 상태</li>
<li><strong>Succeeded</strong>: 액션이 성공적으로 완료된 상태</li>
<li><strong>Canceled</strong>: 액션이 취소된 상태</li>
<li><strong>Aborted</strong>: 오류로 인해 액션이 중단된 상태</li>
</ul>
<p>액션의 상태 전이는 다음과 같은 함수로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}(s_i, s_j) = \begin{cases} 
1 &amp; \text{액션이 } s_i \text{에서 } s_j \text{로 전이 가능할 때} \\
0 &amp; \text{전이 불가능할 때}
\end{cases}
</div>
<script type="math/tex; mode=display">
\mathbf{A}(s_i, s_j) = \begin{cases} 
1 & \text{액션이 } s_i \text{에서 } s_j \text{로 전이 가능할 때} \\
0 & \text{전이 불가능할 때}
\end{cases}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">s_i</span><script type="math/tex">s_i</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">s_j</span><script type="math/tex">s_j</script></span>는 각각 액션의 현재 상태와 전이 후 상태를 나타낸다. 이러한 상태 관리 구조 덕분에 ROS2에서는 액션을 이용하여 비동기 작업을 더 쉽게 구현할 수 있다.</p>
<h3 id="_8">런타임 구성 관리</h3>
<p>ROS1에서는 런타임 중에 파라미터나 설정을 동적으로 변경하는 기능이 제한적이었다. 반면에 ROS2는 동적 파라미터 설정 및 구성 변경을 보다 쉽게 관리할 수 있다. 파라미터 서버를 통해 노드 간의 파라미터 공유와 설정을 실시간으로 변경할 수 있으며, 이를 통해 실행 중인 노드의 동작을 즉시 제어할 수 있다.</p>
<p>파라미터 업데이트는 다음과 같은 수식으로 모델링할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}(t) = \mathbf{P}_0 + \Delta \mathbf{P}(t)
</div>
<script type="math/tex; mode=display">
\mathbf{P}(t) = \mathbf{P}_0 + \Delta \mathbf{P}(t)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_0</span><script type="math/tex">\mathbf{P}_0</script></span>는 초기 파라미터 값, <span class="arithmatex"><span class="MathJax_Preview">\Delta \mathbf{P}(t)</span><script type="math/tex">\Delta \mathbf{P}(t)</script></span>는 시간에 따라 변경되는 파라미터 변화량이다. 이를 통해 ROS2 노드는 실시간으로 런타임 중에 변경된 파라미터 값을 반영하여 동작을 조정할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0103/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0103/" class="btn btn-xs btn-link">
        ROS2 릴리즈 사이클 및 버전 관리
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0101/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0101/" class="btn btn-xs btn-link">
        ROS의 역사와 배경
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>