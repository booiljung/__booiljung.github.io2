<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot%20simulation%20with%20urdf%20sdf/chapter%2028/2801/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>시뮬레이션 데이터 기록 및 분석 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "1. \uc2dc\ubbac\ub808\uc774\uc158 \ub370\uc774\ud130 \uae30\ub85d", url: "#_top", children: [
              {title: "1.1 \uae30\ub85d\ud560 \ub370\uc774\ud130\uc758 \uc885\ub958", url: "#11" },
              {title: "1.2 \ub370\uc774\ud130 \uae30\ub85d \ubc29\ubc95", url: "#12" },
              {title: "1.3 \ucf54\ub4dc \uc608\uc2dc: Gazebo\uc5d0\uc11c \ub370\uc774\ud130 \uae30\ub85d", url: "#13-gazebo" },
          ]},
          {title: "2. \uc2dc\ubbac\ub808\uc774\uc158 \ub370\uc774\ud130 \ubd84\uc11d", url: "#2", children: [
              {title: "2.1 \ub85c\ubd07 \uc0c1\ud0dc \ub370\uc774\ud130 \ubd84\uc11d", url: "#21" },
              {title: "2.2 \uc13c\uc11c \ub370\uc774\ud130 \ubd84\uc11d", url: "#22" },
              {title: "2.3 \uc0c1\ud638\uc791\uc6a9 \ub370\uc774\ud130 \ubd84\uc11d", url: "#23" },
              {title: "2.4 \ucf54\ub4dc \uc608\uc2dc: Python\uc744 \uc774\uc6a9\ud55c \ub370\uc774\ud130 \ubd84\uc11d", url: "#24-python" },
          ]},
          {title: "2.5 \ud1b5\uacc4\uc801 \ubd84\uc11d", url: "#25", children: [
              {title: "2.5.1 \ud3c9\uade0\uac12 \uacc4\uc0b0", url: "#251" },
              {title: "2.5.2 \ubd84\uc0b0\uacfc \ud45c\uc900 \ud3b8\ucc28", url: "#252" },
              {title: "2.5.3 \uc0c1\uad00\uad00\uacc4 \ubd84\uc11d", url: "#253" },
              {title: "2.5.4 \ub370\uc774\ud130 \ud074\ub7ec\uc2a4\ud130\ub9c1", url: "#254" },
              {title: "2.6 \ucf54\ub4dc \uc608\uc2dc: Python\uc744 \uc774\uc6a9\ud55c \ud1b5\uacc4\uc801 \ubd84\uc11d", url: "#26-python" },
          ]},
          {title: "2.6 \uc2dc\ubbac\ub808\uc774\uc158 \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#26", children: [
              {title: "2.6.1 \ub85c\ubd07 \uada4\uc801 \uc2dc\uac01\ud654", url: "#261" },
              {title: "2.6.2 \uc18d\ub3c4 \ubc0f \uac00\uc18d\ub3c4 \uc2dc\uac01\ud654", url: "#262" },
              {title: "2.6.3 \uc13c\uc11c \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#263" },
              {title: "2.6.4 \ub370\uc774\ud130 \uc2dc\uac01\ud654 \ub3c4\uad6c", url: "#264" },
              {title: "2.7 \ucf54\ub4dc \uc608\uc2dc: \uc18d\ub3c4 \ubc0f \uac00\uc18d\ub3c4 \uc2dc\uac01\ud654", url: "#27" },
          ]},
          {title: "2.8 \uc2dc\ubbac\ub808\uc774\uc158 \ub370\uc774\ud130\uc758 \ud6c4\ucc98\ub9ac", url: "#28", children: [
              {title: "2.8.1 \ub370\uc774\ud130 \ud544\ud130\ub9c1", url: "#281" },
              {title: "2.8.2 \ub370\uc774\ud130 \ubcf4\uac04 (Interpolation)", url: "#282-interpolation" },
              {title: "2.8.3 \ub370\uc774\ud130 \uc815\uaddc\ud654", url: "#283" },
              {title: "2.9 \ucf54\ub4dc \uc608\uc2dc: \ub370\uc774\ud130 \ud544\ud130\ub9c1 \ubc0f \ubcf4\uac04", url: "#29" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2802/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2802/" class="btn btn-xs btn-link">
        센서 데이터 분석 및 처리
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter%2027/2703/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter%2027/2703/" class="btn btn-xs btn-link">
        Gazebo 로그 및 분석 도구 활용
      </a>
    </div>
    
  </div>

    

    <h3 id="1">1. 시뮬레이션 데이터 기록</h3>
<p>시뮬레이션 중 생성되는 데이터는 로봇의 상태, 센서의 출력, 그리고 환경과의 상호작용 정보를 포함한다. 이러한 데이터를 기록하는 방식은 시뮬레이션의 정확성을 평가하고, 로봇의 성능을 개선하는 데 중요한 역할을 한다.</p>
<h4 id="11">1.1 기록할 데이터의 종류</h4>
<ul>
<li><strong>로봇 상태 데이터</strong>: 위치, 속도, 가속도, 관성 등 로봇의 물리적 상태와 관련된 데이터.</li>
<li>위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>는 시간에 따른 위치 벡터로 나타낼 수 있다:</li>
</ul>
<p>$$</p>
<p>\mathbf{p}(t) = \begin{bmatrix} x(t) \ y(t) \ z(t) \end{bmatrix}</p>
<p>$$</p>
<ul>
<li>속도 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}(t)</span><script type="math/tex">\mathbf{v}(t)</script></span>는 시간에 따른 속도 벡터로 나타낼 수 있다:</li>
</ul>
<p>$$</p>
<p>\mathbf{v}(t) = \frac{d\mathbf{p}(t)}{dt} = \begin{bmatrix} \dot{x}(t) \ \dot{y}(t) \ \dot{z}(t) \end{bmatrix}</p>
<p>$$</p>
<ul>
<li>가속도 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}(t)</span><script type="math/tex">\mathbf{a}(t)</script></span>는 속도의 변화율로 나타낼 수 있다:</li>
</ul>
<p>$$</p>
<p>\mathbf{a}(t) = \frac{d\mathbf{v}(t)}{dt} = \begin{bmatrix} \ddot{x}(t) \ \ddot{y}(t) \ \ddot{z}(t) \end{bmatrix}</p>
<p>$$</p>
<ul>
<li><strong>센서 데이터</strong>: 카메라, LIDAR, IMU 등 로봇에 장착된 다양한 센서의 출력 값.</li>
<li>예를 들어, LIDAR 데이터는 특정 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서의 거리 측정 값 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}(t)</span><script type="math/tex">\mathbf{d}(t)</script></span>으로 나타낼 수 있다:</li>
</ul>
<p>$$</p>
<p>\mathbf{d}(t) = \begin{bmatrix} d_1(t) \ d_2(t) \ \vdots \ d_n(t) \end{bmatrix}</p>
<p>$$</p>
<ul>
<li><strong>환경과의 상호작용 데이터</strong>: 로봇과 환경 간의 충돌, 힘, 마찰력 등 환경 요소와의 상호작용 정보.</li>
</ul>
<h4 id="12">1.2 데이터 기록 방법</h4>
<p>Gazebo와 같은 시뮬레이션 소프트웨어는 데이터를 기록하기 위한 다양한 인터페이스를 제공한다. 데이터를 효율적으로 기록하기 위해서는 다음과 같은 고려 사항이 필요하다.</p>
<ul>
<li><strong>주기적 기록</strong>: 시뮬레이션의 시간 주기를 고려하여 데이터를 주기적으로 기록해야 한다. 주기 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 데이터의 해상도와 시뮬레이션의 정확성에 큰 영향을 미친다. 만약 로봇이 매우 빠르게 움직이는 상황이라면, 짧은 주기로 데이터를 기록하는 것이 필요하다.</li>
<li><strong>데이터 형식</strong>: 기록된 데이터는 CSV, JSON, HDF5 등 다양한 형식으로 저장할 수 있으며, 각 형식의 장단점을 고려하여 선택해야 한다.</li>
<li>CSV: 가독성이 좋고 다루기 쉽지만 대용량 데이터에 비효율적.</li>
<li>HDF5: 대용량 데이터를 효율적으로 저장하고 빠르게 읽어들일 수 있지만, 추가적인 라이브러리 의존성이 있음.</li>
</ul>
<h4 id="13-gazebo">1.3 코드 예시: Gazebo에서 데이터 기록</h4>
<pre><code class="language-cpp">#include &lt;gazebo/transport/transport.hh&gt;
#include &lt;gazebo/msgs/msgs.hh&gt;
#include &lt;fstream&gt;

void LogData(const std::string &amp;topicName, const std::string &amp;logFileName)
{
    gazebo::transport::NodePtr node(new gazebo::transport::Node());
    node-&gt;Init();

    gazebo::transport::SubscriberPtr sub = node-&gt;Subscribe(topicName, [](const gazebo::msgs::Any &amp;msg)
    {
        std::ofstream logFile;
        logFile.open(logFileName, std::ios::app);
        logFile &lt;&lt; msg.DebugString() &lt;&lt; std::endl;
        logFile.close();
    });
}
</code></pre>
<p>위 코드는 Gazebo 시뮬레이션에서 특정 주제에 대해 데이터를 기록하는 간단한 예시이다. 주제 이름을 <code>topicName</code>으로 지정하고, 데이터를 파일에 기록할 때 파일 이름을 <code>logFileName</code>으로 지정할 수 있다.</p>
<h3 id="2">2. 시뮬레이션 데이터 분석</h3>
<p>시뮬레이션 중 기록된 데이터를 분석하는 것은 로봇의 성능을 평가하고 개선하는 데 필수적이다. 이 과정에서 데이터를 시각화하고 통계적 분석 기법을 사용하여 유의미한 정보를 도출할 수 있다.</p>
<h4 id="21">2.1 로봇 상태 데이터 분석</h4>
<ul>
<li><strong>위치 분석</strong>: 로봇의 궤적을 분석하기 위해 시간에 따른 위치 변화를 시각화한다. 이때 로봇의 이동 경로를 2D 또는 3D 공간에서 그래프로 표현할 수 있다.</li>
<li>로봇의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>에 대한 시간 함수는 다음과 같이 나타낼 수 있다:</li>
</ul>
<p>$$</p>
<p>\mathbf{p}(t) = \begin{bmatrix} x(t) \ y(t) \ z(t) \end{bmatrix}</p>
<p>$$</p>
<p>이를 시각화하면, 로봇의 경로를 직관적으로 확인할 수 있으며 경로 계획 또는 장애물 회피 성능을 평가할 수 있다.</p>
<ul>
<li><strong>속도 및 가속도 분석</strong>: 로봇의 속도와 가속도를 분석함으로써 로봇의 동작이 원활하게 이루어지고 있는지 평가할 수 있다. 예를 들어, 로봇이 급격한 가속도를 보이는 구간은 충돌 위험이 높거나 제어가 불안정할 가능성이 있다.</li>
<li>속도 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}(t)</span><script type="math/tex">\mathbf{v}(t)</script></span>는 다음과 같이 표현된다:</li>
</ul>
<p>$$</p>
<p>\mathbf{v}(t) = \frac{d\mathbf{p}(t)}{dt} = \begin{bmatrix} \dot{x}(t) \ \dot{y}(t) \ \dot{z}(t) \end{bmatrix}</p>
<p>$$</p>
<ul>
<li>가속도 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}(t)</span><script type="math/tex">\mathbf{a}(t)</script></span>는 다음과 같다:</li>
</ul>
<p>$$</p>
<p>\mathbf{a}(t) = \frac{d\mathbf{v}(t)}{dt} = \begin{bmatrix} \ddot{x}(t) \ \ddot{y}(t) \ \ddot{z}(t) \end{bmatrix}</p>
<p>$$</p>
<h4 id="22">2.2 센서 데이터 분석</h4>
<p>센서의 정확성을 평가하기 위해 센서 데이터와 실제 환경 데이터 간의 비교가 필요하다. 이를 통해 센서 노이즈를 제거하거나 보정할 수 있다.</p>
<ul>
<li><strong>IMU 데이터 분석</strong>: IMU(Inertial Measurement Unit)의 가속도와 자이로스코프 데이터를 이용하여 로봇의 움직임을 분석한다. 가속도 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}(t)</span><script type="math/tex">\mathbf{a}(t)</script></span>는 로봇의 가속도를 나타내며, 이를 적분하여 로봇의 속도와 위치를 추정할 수 있다. 그러나 센서 노이즈가 포함되기 때문에 필터링 기법을 적용해야 한다.</li>
<li>예를 들어, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}(t)</span><script type="math/tex">\mathbf{a}(t)</script></span>를 적분하여 속도를 추정할 수 있다:</li>
</ul>
<p>$$</p>
<p>\mathbf{v}(t) = \int \mathbf{a}(t) \, dt</p>
<p>$$</p>
<ul>
<li><strong>카메라 및 LIDAR 데이터 분석</strong>: 카메라 또는 LIDAR 데이터를 기반으로 주변 환경을 3D로 재구성하여 로봇이 인식한 환경을 분석할 수 있다. 이러한 데이터는 객체 인식, 장애물 회피, 경로 계획 등에 사용될 수 있으며, 시각적 분석을 통해 로봇의 환경 인식 능력을 평가할 수 있다.</li>
<li>예를 들어, LIDAR로부터 얻은 거리 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}(t)</span><script type="math/tex">\mathbf{d}(t)</script></span>는 3D 좌표로 변환될 수 있으며, 이는 다음과 같이 표현된다:</li>
</ul>
<p>$$</p>
<p>\mathbf{P}(t) = f(\mathbf{d}(t))</p>
<p>$$</p>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>는 LIDAR 거리 데이터를 3D 공간 좌표로 변환하는 함수이다.</p>
<h4 id="23">2.3 상호작용 데이터 분석</h4>
<p>로봇과 환경 간의 충돌 또는 상호작용을 기록하고 분석하여 로봇의 물리적 성능을 평가할 수 있다. 충돌 빈도, 충돌 강도, 마찰력 등을 분석하여 로봇의 안정성 또는 설계상의 문제를 확인할 수 있다.</p>
<ul>
<li><strong>충돌 분석</strong>: 충돌 발생 위치와 강도를 기록하여 로봇의 설계나 제어 알고리즘을 개선할 수 있다. 충돌 강도는 충돌 시 가속도의 변화로 측정할 수 있으며, 이를 수학적으로 표현하면 다음과 같다:</li>
</ul>
<p>$$</p>
<p>F_{\text{충돌}} = m \cdot \mathbf{a}(t)</p>
<p>$$</p>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">F_{\text{충돌}}</span><script type="math/tex">F_{\text{충돌}}</script></span>은 충돌 시 발생하는 힘, <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 로봇의 질량, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}(t)</span><script type="math/tex">\mathbf{a}(t)</script></span>는 충돌 시의 가속도 변화이다.</p>
<h4 id="24-python">2.4 코드 예시: Python을 이용한 데이터 분석</h4>
<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np

time = np.linspace(0, 10, 100)
x = np.sin(time)
y = np.cos(time)
z = time * 0.1

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot(x, y, z, label='Robot Trajectory')
ax.set_xlabel('X Position')
ax.set_ylabel('Y Position')
ax.set_zlabel('Z Position')
plt.legend()
plt.show()
</code></pre>
<p>위 코드는 Python을 이용해 로봇의 3D 궤적을 시각화하는 간단한 예시이다. 기록된 위치 데이터를 기반으로 로봇의 이동 경로를 그래프로 그릴 수 있다.</p>
<h3 id="25">2.5 통계적 분석</h3>
<p>기록된 데이터를 수치적으로 분석하여 로봇의 성능을 평가할 수 있다. 시뮬레이션 결과가 안정적이고 신뢰할 수 있는지를 확인하기 위해 평균, 분산, 표준 편차 등의 통계적 분석이 필요하다.</p>
<h4 id="251">2.5.1 평균값 계산</h4>
<p>로봇의 상태나 센서 데이터의 평균값을 계산하여 전반적인 성능을 평가할 수 있다. 예를 들어, 로봇의 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>의 평균값은 다음과 같이 구할 수 있다:</p>
<p>$$</p>
<p>\bar{\mathbf{p}} = \frac{1}{T} \int_0^T \mathbf{p}(t) \, dt</p>
<p>$$</p>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>는 전체 시뮬레이션 시간이다. 이를 통해 로봇이 특정 구역에서 얼마나 오래 머물렀는지를 평가할 수 있다.</p>
<h4 id="252">2.5.2 분산과 표준 편차</h4>
<p>로봇의 상태나 센서 데이터의 변동성을 평가하기 위해 분산과 표준 편차를 계산할 수 있다. 예를 들어, 위치 데이터의 분산은 다음과 같이 계산된다:</p>
<p>$$</p>
<p>\sigma^2_{\mathbf{p}} = \frac{1}{T} \int_0^T \left( \mathbf{p}(t) - \bar{\mathbf{p}} \right)^2 dt</p>
<p>$$</p>
<p>표준 편차는 분산의 제곱근으로 구할 수 있다:</p>
<p>$$</p>
<p>\sigma_{\mathbf{p}} = \sqrt{\sigma^2_{\mathbf{p}}}</p>
<p>$$</p>
<p>표준 편차는 로봇의 위치 변동성을 평가하는 데 사용되며, 값이 크면 로봇의 이동 경로가 불안정함을 의미할 수 있다.</p>
<h4 id="253">2.5.3 상관관계 분석</h4>
<p>센서 간 데이터의 상관관계를 분석하여 센서 데이터가 일관되게 작동하는지 확인할 수 있다. 예를 들어, IMU의 가속도 데이터와 LIDAR 데이터 간의 상관관계를 분석할 수 있다. 상관계수 <span class="arithmatex"><span class="MathJax_Preview">\rho</span><script type="math/tex">\rho</script></span>는 다음과 같이 계산된다:</p>
<p>$$</p>
<p>\rho(\mathbf{a}, \mathbf{d}) = \frac{\mathbb{E}[(\mathbf{a}(t) - \mathbb{E}[\mathbf{a}(t)])(\mathbf{d}(t) - \mathbb{E}[\mathbf{d}(t)])]}{\sigma_{\mathbf{a}}\sigma_{\mathbf{d}}}</p>
<p>$$</p>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbb{E}[\mathbf{a}(t)]</span><script type="math/tex">\mathbb{E}[\mathbf{a}(t)]</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbb{E}[\mathbf{d}(t)]</span><script type="math/tex">\mathbb{E}[\mathbf{d}(t)]</script></span>는 각각 가속도와 거리 데이터의 기대값을 나타내며, <span class="arithmatex"><span class="MathJax_Preview">\sigma_{\mathbf{a}}</span><script type="math/tex">\sigma_{\mathbf{a}}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\sigma_{\mathbf{d}}</span><script type="math/tex">\sigma_{\mathbf{d}}</script></span>는 각각의 표준 편차이다. 상관계수가 1에 가까울수록 두 데이터 간의 상관관계가 높음을 의미한다.</p>
<h4 id="254">2.5.4 데이터 클러스터링</h4>
<p>시뮬레이션 중 기록된 데이터를 클러스터링하여 로봇의 동작 패턴을 분석할 수 있다. K-평균 알고리즘을 사용하여 로봇의 이동 경로를 여러 군집으로 나눌 수 있다. 예를 들어, 로봇의 위치 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>를 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>개의 클러스터로 나눈다면, 각 클러스터의 중심 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}_i</span><script type="math/tex">\mathbf{c}_i</script></span>는 다음과 같이 구할 수 있다:</p>
<p>$$</p>
<p>\mathbf{c}<em>i = \frac{1}{n_i} \sum</em>{j=1}^{n_i} \mathbf{p}_j</p>
<p>$$</p>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">n_i</span><script type="math/tex">n_i</script></span>는 클러스터 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>에 속하는 데이터 포인트의 개수이다. 클러스터링을 통해 로봇이 특정 구역에서 반복적인 동작을 수행하는지 분석할 수 있다.</p>
<h4 id="26-python">2.6 코드 예시: Python을 이용한 통계적 분석</h4>
<pre><code class="language-python">import numpy as np

position_data = np.array([np.sin(t) for t in np.linspace(0, 10, 100)])

mean_position = np.mean(position_data)
print(&quot;Mean Position:&quot;, mean_position)

std_position = np.std(position_data)
print(&quot;Standard Deviation of Position:&quot;, std_position)
</code></pre>
<p>위 코드는 시뮬레이션 중 기록된 위치 데이터를 기반으로 평균과 표준 편차를 계산하는 간단한 예시이다.</p>
<h3 id="26">2.6 시뮬레이션 데이터 시각화</h3>
<p>시뮬레이션 데이터를 효과적으로 분석하기 위해서는 시각화가 매우 중요한 역할을 한다. 데이터를 시각적으로 표현함으로써 로봇의 궤적, 속도 변화, 센서 데이터 등을 직관적으로 이해할 수 있다. 다양한 시각화 도구를 활용하여 데이터를 그래프, 차트 또는 3D 모델로 표현할 수 있다.</p>
<h4 id="261">2.6.1 로봇 궤적 시각화</h4>
<p>로봇의 이동 경로를 시각화함으로써 로봇이 특정 환경에서 어떻게 이동하고 상호작용했는지를 확인할 수 있다. 이를 위해 위치 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}(t)</span><script type="math/tex">\mathbf{p}(t)</script></span>를 시간에 따라 2D 또는 3D 공간에서 그래프로 그릴 수 있다.</p>
<ul>
<li>2D 시각화:</li>
</ul>
<p>$$</p>
<p>\mathbf{p}(t) = \begin{bmatrix} x(t) \ y(t) \end{bmatrix}</p>
<p>$$</p>
<p>2D 그래프로 그리면 로봇의 평면 상에서의 경로를 시각화할 수 있다.</p>
<ul>
<li>3D 시각화:</li>
</ul>
<p>$$</p>
<p>\mathbf{p}(t) = \begin{bmatrix} x(t) \ y(t) \ z(t) \end{bmatrix}</p>
<p>$$</p>
<p>3D 그래프는 더 복잡한 환경에서의 로봇 이동 경로를 직관적으로 표현하는 데 유용하다.</p>
<h4 id="262">2.6.2 속도 및 가속도 시각화</h4>
<p>시간에 따른 속도 및 가속도의 변화를 시각화함으로써 로봇의 움직임이 얼마나 원활하게 이루어지고 있는지 평가할 수 있다. 속도 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}(t)</span><script type="math/tex">\mathbf{v}(t)</script></span>와 가속도 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}(t)</span><script type="math/tex">\mathbf{a}(t)</script></span>는 각각 시간에 따른 변화를 그래프로 나타낼 수 있다.</p>
<ul>
<li>속도 그래프:</li>
</ul>
<p>$$</p>
<p>\mathbf{v}(t) = \begin{bmatrix} \dot{x}(t) \ \dot{y}(t) \ \dot{z}(t) \end{bmatrix}</p>
<p>$$</p>
<p>시간에 따른 속도의 크기 <span class="arithmatex"><span class="MathJax_Preview">|\mathbf{v}(t)|</span><script type="math/tex">|\mathbf{v}(t)|</script></span>를 그래프로 표현할 수 있다.</p>
<ul>
<li>가속도 그래프:</li>
</ul>
<p>$$</p>
<p>\mathbf{a}(t) = \begin{bmatrix} \ddot{x}(t) \ \ddot{y}(t) \ \ddot{z}(t) \end{bmatrix}</p>
<p>$$</p>
<p>시간에 따른 가속도의 변화를 그래프로 그리면, 급격한 가속도가 발생한 구간을 쉽게 확인할 수 있다.</p>
<h4 id="263">2.6.3 센서 데이터 시각화</h4>
<p>센서로부터 수집된 데이터를 시각화하여 로봇이 인식한 환경을 확인할 수 있다. 예를 들어, LIDAR 데이터를 시각화하면 로봇 주변의 물체와 거리를 확인할 수 있으며, 카메라 데이터를 시각화하면 로봇이 촬영한 영상 정보를 확인할 수 있다.</p>
<ul>
<li>LIDAR 시각화:
  LIDAR로 측정된 거리 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}(t)</span><script type="math/tex">\mathbf{d}(t)</script></span>는 2D 또는 3D 좌표로 변환되어 시각화된다.</li>
</ul>
<p>$$</p>
<p>\mathbf{P}(t) = f(\mathbf{d}(t))</p>
<p>$$</p>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>는 거리 데이터를 좌표로 변환하는 함수이다.</p>
<h4 id="264">2.6.4 데이터 시각화 도구</h4>
<p>데이터를 시각화하기 위해 다양한 도구를 사용할 수 있다. 대표적인 도구로는 다음과 같다.</p>
<ul>
<li><strong>Matplotlib</strong>: Python에서 널리 사용되는 시각화 도구로, 2D 그래프와 차트를 그리는 데 유용하다.</li>
<li><strong>Plotly</strong>: 상호작용이 가능한 그래프를 그릴 수 있는 도구로, 3D 그래프에도 적합하다.</li>
<li><strong>Gazebo</strong>: 시뮬레이션 환경 자체에서 3D 데이터를 시각화할 수 있는 기능을 제공한다.</li>
</ul>
<h4 id="27">2.7 코드 예시: 속도 및 가속도 시각화</h4>
<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np

time = np.linspace(0, 10, 100)
velocity = np.sin(time)

acceleration = np.cos(time)

plt.figure()
plt.plot(time, velocity, label='Velocity')
plt.xlabel('Time (s)')
plt.ylabel('Velocity (m/s)')
plt.title('Velocity over Time')
plt.legend()
plt.show()

plt.figure()
plt.plot(time, acceleration, label='Acceleration', color='red')
plt.xlabel('Time (s)')
plt.ylabel('Acceleration (m/s²)')
plt.title('Acceleration over Time')
plt.legend()
plt.show()
</code></pre>
<p>위 코드는 시간에 따른 속도 및 가속도 데이터를 시각화하는 예시이다. 이를 통해 로봇의 움직임을 시각적으로 분석할 수 있다.</p>
<h3 id="28">2.8 시뮬레이션 데이터의 후처리</h3>
<p>시뮬레이션 데이터는 기록 후에 다양한 후처리 과정을 거쳐 분석에 적합한 형태로 가공될 수 있다. 후처리 과정은 데이터를 필터링하고 노이즈를 제거하며, 필요한 경우 보간(interpolation)을 통해 데이터의 해상도를 높일 수 있다.</p>
<h4 id="281">2.8.1 데이터 필터링</h4>
<p>시뮬레이션 데이터에는 다양한 노이즈가 포함될 수 있으며, 이러한 노이즈는 분석 과정에서 오류를 발생시킬 수 있다. 데이터를 필터링하여 노이즈를 제거하는 것은 매우 중요한 과정이다. 대표적인 필터링 방법은 다음과 같다.</p>
<ul>
<li><strong>저역 통과 필터 (Low-pass filter)</strong>: 고주파 노이즈를 제거하고 저주파 성분만 남기는 필터로, 로봇의 움직임이나 센서 데이터의 부드러운 변화를 얻는 데 유용하다.</li>
<li>저역 통과 필터의 수학적 표현은 다음과 같다:</li>
</ul>
<p>$$</p>
<p>y(t) = \alpha x(t) + (1 - \alpha) y(t-1)</p>
<p>$$</p>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">x(t)</span><script type="math/tex">x(t)</script></span>는 입력 데이터, <span class="arithmatex"><span class="MathJax_Preview">y(t)</span><script type="math/tex">y(t)</script></span>는 필터링된 출력 데이터, <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 필터 계수로 0과 1 사이의 값이다.</p>
<ul>
<li><strong>칼만 필터 (Kalman filter)</strong>: 센서 데이터의 노이즈를 줄이기 위해 자주 사용되는 필터로, 예측과 관측을 결합하여 보다 정확한 데이터를 추정한다.</li>
</ul>
<h4 id="282-interpolation">2.8.2 데이터 보간 (Interpolation)</h4>
<p>시뮬레이션 중 기록된 데이터는 종종 불규칙한 시간 간격으로 기록될 수 있다. 이러한 경우, 보간(interpolation) 기법을 사용하여 데이터를 균일한 시간 간격으로 변환할 수 있다. 대표적인 보간 방법으로는 선형 보간(linear interpolation)과 스플라인 보간(spline interpolation)이 있다.</p>
<ul>
<li><strong>선형 보간</strong>: 두 데이터 포인트 사이의 값을 선형으로 추정하는 방식이다.</li>
<li>선형 보간은 다음과 같이 표현된다:</li>
</ul>
<p>$$</p>
<p>y(t) = y_1 + \frac{(t - t_1)}{(t_2 - t_1)} (y_2 - y_1)</p>
<p>$$</p>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">y_1</span><script type="math/tex">y_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">y_2</span><script type="math/tex">y_2</script></span>는 각각 시간 <span class="arithmatex"><span class="MathJax_Preview">t_1</span><script type="math/tex">t_1</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">t_2</span><script type="math/tex">t_2</script></span>에서의 데이터 값이다.</p>
<ul>
<li><strong>스플라인 보간</strong>: 곡선을 사용하여 여러 데이터 포인트 사이의 값을 추정하는 방법으로, 선형 보간보다 부드러운 결과를 제공한다.</li>
</ul>
<h4 id="283">2.8.3 데이터 정규화</h4>
<p>시뮬레이션 데이터는 서로 다른 범위나 단위를 가질 수 있다. 분석을 용이하게 하기 위해 데이터를 정규화(normalization)하여 동일한 범위로 변환할 수 있다. 대표적인 정규화 방법은 최소-최대 정규화와 Z-점수 정규화가 있다.</p>
<ul>
<li><strong>최소-최대 정규화</strong>: 데이터를 0과 1 사이의 값으로 변환한다.</li>
<li>최소-최대 정규화는 다음과 같이 표현된다:</li>
</ul>
<p>$$</p>
<p>y = \frac{x - \min(x)}{\max(x) - \min(x)}</p>
<p>$$</p>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>는 원본 데이터, <span class="arithmatex"><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>는 정규화된 데이터이다.</p>
<ul>
<li><strong>Z-점수 정규화</strong>: 데이터를 평균이 0, 표준 편차가 1이 되도록 변환한다.</li>
<li>Z-점수 정규화는 다음과 같다:</li>
</ul>
<p>$$</p>
<p>z = \frac{x - \mu}{\sigma}</p>
<p>$$</p>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span>는 데이터의 평균, <span class="arithmatex"><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>는 표준 편차이다.</p>
<h4 id="29">2.9 코드 예시: 데이터 필터링 및 보간</h4>
<pre><code class="language-python">import numpy as np
from scipy import interpolate
import matplotlib.pyplot as plt

time = np.linspace(0, 10, 100)
velocity = np.sin(time) + np.random.normal(0, 0.1, size=time.shape)

alpha = 0.1
filtered_velocity = [velocity[0]]  # 초기 값 설정
for i in range(1, len(velocity)):
    filtered_velocity.append(alpha * velocity[i] + (1 - alpha) * filtered_velocity[i - 1])

interp_func = interpolate.interp1d(time, velocity, kind='linear')
interpolated_time = np.linspace(0, 10, 200)
interpolated_velocity = interp_func(interpolated_time)

plt.plot(time, velocity, label='Original Data', alpha=0.5)
plt.plot(time, filtered_velocity, label='Filtered Data', color='red')
plt.xlabel('Time (s)')
plt.ylabel('Velocity (m/s)')
plt.legend()
plt.show()

plt.plot(time, velocity, label='Original Data', alpha=0.5)
plt.plot(interpolated_time, interpolated_velocity, label='Interpolated Data', color='green')
plt.xlabel('Time (s)')
plt.ylabel('Velocity (m/s)')
plt.legend()
plt.show()
</code></pre>
<p>위 코드는 노이즈가 포함된 데이터를 필터링하고 보간하는 방법을 보여주는 예시이다. 필터링된 데이터는 보다 부드럽고 노이즈가 줄어든 형태로 나타나며, 보간된 데이터는 해상도가 높아진 데이터를 제공한다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2802/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2802/" class="btn btn-xs btn-link">
        센서 데이터 분석 및 처리
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter%2027/2703/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter%2027/2703/" class="btn btn-xs btn-link">
        Gazebo 로그 및 분석 도구 활용
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>