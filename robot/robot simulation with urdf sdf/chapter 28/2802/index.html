<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot%20simulation%20with%20urdf%20sdf/chapter%2028/2802/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>센서 데이터 분석 및 처리 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "1. \uc13c\uc11c \ub370\uc774\ud130 \ud544\ud130\ub9c1", url: "#_top", children: [
          ]},
          {title: "2. \uc13c\uc11c \ub370\uc774\ud130 \ub3d9\uae30\ud654", url: "#2", children: [
          ]},
          {title: "3. \uc13c\uc11c \uc735\ud569", url: "#3", children: [
          ]},
          {title: "4. \uc13c\uc11c \ub370\uc774\ud130\uc758 \uc774\uc0c1\uac12 \ucc98\ub9ac", url: "#4", children: [
          ]},
          {title: "5. \uc13c\uc11c \ub370\uc774\ud130\uc758 \uc7a1\uc74c \ubaa8\ub378\ub9c1", url: "#5", children: [
          ]},
          {title: "6. \uc2e4\uc2dc\uac04 \uc13c\uc11c \ub370\uc774\ud130 \ucc98\ub9ac", url: "#6", children: [
          ]},
          {title: "7. \uc13c\uc11c \ub370\uc774\ud130\uc758 \uc804\ucc98\ub9ac", url: "#7", children: [
              {title: "a. \ub370\uc774\ud130 \uc815\uaddc\ud654(Normalization)", url: "#a-normalization" },
              {title: "b. \ub370\uc774\ud130 \uc2a4\ubb34\ub529(Smoothing)", url: "#b-smoothing" },
              {title: "c. \uace0\uae09 \ud544\ud130\ub9c1 \uae30\ubc95", url: "#c" },
          ]},
          {title: "8. \ub370\uc774\ud130 \uc735\ud569 \uc54c\uace0\ub9ac\uc998 \uc801\uc6a9", url: "#8", children: [
          ]},
          {title: "9. \ud655\uc7a5 \uce7c\ub9cc \ud544\ud130\uc758 \uc801\uc6a9 \ub2e8\uacc4", url: "#9", children: [
              {title: "a. \uc608\uce21 \ub2e8\uacc4", url: "#a" },
              {title: "b. \uc5c5\ub370\uc774\ud2b8 \ub2e8\uacc4", url: "#b" },
          ]},
          {title: "10. \uc2e4\uc2dc\uac04 \uc13c\uc11c \ub370\uc774\ud130 \uc735\ud569\uc744 \uc704\ud55c \uace0\ub824\uc0ac\ud56d", url: "#10", children: [
              {title: "a. \uc13c\uc11c \ub370\uc774\ud130\uc758 \uc2dc\uac04 \ub3d9\uae30\ud654", url: "#a_1" },
              {title: "b. \uc8fc\uae30 \ucc28\uc774\uc5d0 \ub530\ub978 \uc0c1\ud0dc \uc608\uce21", url: "#b_1" },
              {title: "c. \uc735\ud569\ub41c \uc13c\uc11c \ub370\uc774\ud130\uc758 \uc7a1\uc74c \ubaa8\ub378\ub9c1", url: "#c_1" },
          ]},
          {title: "11. \uc13c\uc11c \ub370\uc774\ud130 \uc735\ud569 \uacb0\uacfc\uc758 \uac80\uc99d \ubc0f \ubd84\uc11d", url: "#11", children: [
              {title: "a. \ub8e8\ud2b8 \ud3c9\uade0 \uc81c\uacf1 \uc624\ucc28(Root Mean Square Error, RMSE)", url: "#a-root-mean-square-error-rmse" },
              {title: "b. \uc624\ucc28 \uacf5\ubd84\uc0b0 \ubd84\uc11d", url: "#b_2" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2803/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2803/" class="btn btn-xs btn-link">
        시뮬레이션 결과 시각화 도구
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2801/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2801/" class="btn btn-xs btn-link">
        시뮬레이션 데이터 기록 및 분석
      </a>
    </div>
    
  </div>

    

    <p>센서 데이터 분석 및 처리는 로봇 시뮬레이션 결과의 정확성과 효율성을 평가하고, 센서가 제공하는 데이터를 기반으로 로봇의 상태를 추정하는 중요한 과정이다. 센서 데이터는 일반적으로 잡음(noise)을 포함하고 있어, 이를 필터링하고 유용한 정보를 추출하는 것이 필요하다.</p>
<h3 id="1">1. 센서 데이터 필터링</h3>
<p>센서로부터 얻은 데이터는 필연적으로 잡음이 포함되어 있다. 이 잡음을 줄이기 위한 방법 중 하나는 필터링이다. 필터링 방법은 크게 저주파 필터(low-pass filter), 고주파 필터(high-pass filter), 대역 통과 필터(band-pass filter) 등이 있으며, 로봇 시뮬레이션에서는 주로 저주파 필터가 사용된다.</p>
<p>가장 널리 사용되는 필터는 칼만 필터(Kalman filter)와 확장 칼만 필터(Extended Kalman Filter, EKF)이다. 이 필터들은 시간에 따라 변화하는 상태를 예측하고, 실제 측정값과 비교하여 상태를 보정한다.</p>
<p>칼만 필터의 기본 원리는 다음과 같다. 시스템 상태를 나타내는 벡터를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_k</span><script type="math/tex">\mathbf{x}_k</script></span>라 할 때, 상태는 다음과 같은 상태 방정식으로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_k = \mathbf{A} \mathbf{x}_{k-1} + \mathbf{B} \mathbf{u}_k + \mathbf{w}_k
</div>
<script type="math/tex; mode=display">
\mathbf{x}_k = \mathbf{A} \mathbf{x}_{k-1} + \mathbf{B} \mathbf{u}_k + \mathbf{w}_k
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 상태 전이 행렬 (state transition matrix),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>는 제어 입력 행렬 (control input matrix),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_k</span><script type="math/tex">\mathbf{u}_k</script></span>는 제어 입력 (control input),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{w}_k</span><script type="math/tex">\mathbf{w}_k</script></span>는 시스템 노이즈 (process noise)이다.</p>
<p>측정된 센서 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_k</span><script type="math/tex">\mathbf{z}_k</script></span>는 측정 방정식으로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{z}_k = \mathbf{H} \mathbf{x}_k + \mathbf{v}_k
</div>
<script type="math/tex; mode=display">
\mathbf{z}_k = \mathbf{H} \mathbf{x}_k + \mathbf{v}_k
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}</span><script type="math/tex">\mathbf{H}</script></span>는 측정 행렬 (measurement matrix),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}_k</span><script type="math/tex">\mathbf{v}_k</script></span>는 측정 잡음 (measurement noise)이다.</p>
<h3 id="2">2. 센서 데이터 동기화</h3>
<p>센서 데이터는 각각 다른 주기로 측정되며, 이를 효과적으로 처리하기 위해서는 센서 데이터를 동기화하는 과정이 필요하다. 예를 들어, IMU(관성 측정 장치)는 매우 높은 주기로 데이터를 제공하는 반면, GPS는 상대적으로 낮은 주기로 데이터를 제공한다. 이러한 이질적인 데이터를 동기화하고 하나의 상태로 융합하는 것이 중요하다.</p>
<p>센서 데이터를 시간 축으로 보간하는 방법으로는 선형 보간법 (linear interpolation)과 상호 보간법 (spline interpolation)이 있다. 이를 통해 서로 다른 주기의 센서 데이터를 동기화하여 분석할 수 있다.</p>
<h3 id="3">3. 센서 융합</h3>
<p>센서 데이터 융합은 여러 센서로부터 얻은 데이터를 결합하여 보다 정확한 로봇 상태를 추정하는 방법이다. 센서 융합에는 여러 기법이 존재하지만, 가장 대표적인 방법은 칼만 필터를 이용한 융합이다. 두 개 이상의 센서로부터 얻은 데이터를 결합하기 위해서는 다음과 같은 과정이 필요하다.</p>
<p>각 센서로부터 얻은 측정값을 기반으로 상태를 예측하고, 각 센서의 신뢰도에 따라 가중치를 부여하여 상태를 업데이트한다. 이는 칼만 필터의 이득(gain) <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}_k</span><script type="math/tex">\mathbf{K}_k</script></span>을 통해 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}^T \left( \mathbf{H} \mathbf{P}_{k|k-1} \mathbf{H}^T + \mathbf{R} \right)^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}^T \left( \mathbf{H} \mathbf{P}_{k|k-1} \mathbf{H}^T + \mathbf{R} \right)^{-1}
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_{k|k-1}</span><script type="math/tex">\mathbf{P}_{k|k-1}</script></span>은 예측 공분산 행렬 (predicted covariance matrix),
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>은 측정 잡음 공분산 행렬 (measurement noise covariance matrix)이다.</p>
<p>상태 업데이트는 다음과 같이 이루어진다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_k = \mathbf{x}_{k|k-1} + \mathbf{K}_k \left( \mathbf{z}_k - \mathbf{H} \mathbf{x}_{k|k-1} \right)
</div>
<script type="math/tex; mode=display">
\mathbf{x}_k = \mathbf{x}_{k|k-1} + \mathbf{K}_k \left( \mathbf{z}_k - \mathbf{H} \mathbf{x}_{k|k-1} \right)
</script>
</div>
<p>공분산 행렬은 다음과 같이 업데이트된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_k = \left( \mathbf{I} - \mathbf{K}_k \mathbf{H} \right) \mathbf{P}_{k|k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_k = \left( \mathbf{I} - \mathbf{K}_k \mathbf{H} \right) \mathbf{P}_{k|k-1}
</script>
</div>
<p>이 과정을 통해 센서 데이터의 잡음을 줄이고, 더 정확한 상태 추정이 가능한다.</p>
<h3 id="4">4. 센서 데이터의 이상값 처리</h3>
<p>센서 데이터는 종종 이상값(outliers)을 포함할 수 있다. 이상값은 잘못된 측정이나 일시적인 센서 오류로 인해 발생하며, 이러한 데이터는 필터링되거나 제거되어야 한다. 이를 위해 흔히 사용하는 방법 중 하나는 <em>이상값 탐지(outlier detection)</em> 기법이다.</p>
<p>대표적인 이상값 탐지 방법으로는 <em>통계적 방법</em>과 <em>기계 학습 기반 방법</em>이 있다. 통계적 방법으로는 평균과 표준 편차를 이용한 <em>3-시그마 규칙(3-sigma rule)</em>이 있으며, 측정된 데이터가 평균으로부터 3배의 표준 편차를 벗어나면 이상값으로 간주하고 제거한다.</p>
<p>이를 수식으로 표현하면, 측정된 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_k</span><script type="math/tex">\mathbf{z}_k</script></span>가 평균 <span class="arithmatex"><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span>와 표준 편차 <span class="arithmatex"><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>를 벗어나는지 확인하는 방식으로 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\left| \mathbf{z}_k - \mu \right| &gt; 3 \sigma
</div>
<script type="math/tex; mode=display">
\left| \mathbf{z}_k - \mu \right| > 3 \sigma
</script>
</div>
<p>이 경우, 해당 데이터는 이상값으로 판단하고 필터링된다.</p>
<p>기계 학습 기반 방법은 과거의 데이터를 바탕으로 학습된 모델을 통해 정상 데이터와 이상값을 분리하는 방법이다. 이러한 기법을 적용하면 복잡한 이상값을 보다 정밀하게 탐지할 수 있다. 하지만 기계 학습 기반 방법은 더 많은 계산 자원이 필요하므로 실시간 처리에는 적합하지 않을 수 있다.</p>
<h3 id="5">5. 센서 데이터의 잡음 모델링</h3>
<p>센서 데이터 분석 및 처리에서 중요한 또 다른 요소는 센서의 잡음 특성을 정확히 모델링하는 것이다. 센서마다 고유한 잡음 특성을 가지고 있으며, 이러한 특성을 반영하지 않으면 데이터 분석 결과의 정확도가 떨어질 수 있다.</p>
<p>잡음 모델링의 대표적인 방법으로는 <em>백색 잡음(white noise)</em>과 <em>갈색 잡음(brown noise)</em>이 있다. </p>
<p>백색 잡음은 모든 주파수 성분이 동일한 세기를 가지는 잡음으로, 센서 데이터에 첨가되는 일반적인 잡음 모델이다. 백색 잡음의 분포는 일반적으로 평균이 0이고 분산이 <span class="arithmatex"><span class="MathJax_Preview">\sigma^2</span><script type="math/tex">\sigma^2</script></span>인 가우시안 분포로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{w}_k \sim \mathcal{N}(0, \sigma^2)
</div>
<script type="math/tex; mode=display">
\mathbf{w}_k \sim \mathcal{N}(0, \sigma^2)
</script>
</div>
<p>갈색 잡음은 저주파 성분이 강한 잡음으로, 주로 긴 시간 동안 측정이 이루어지는 센서에서 발생하는 잡음이다. 갈색 잡음은 시간에 따라 누적되는 특성을 가지고 있으므로, 이를 정확하게 모델링하기 위해서는 시간이 흐를수록 증가하는 분산을 고려해야 한다.</p>
<p>센서의 잡음 특성을 모델링하는 과정에서, 잡음 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>를 설정하는 것이 중요하다. 이 행렬은 센서 데이터의 불확실성을 표현하며, 상태 추정 시 필터가 잡음에 대해 얼마나 민감하게 반응할지를 결정한다.</p>
<h3 id="6">6. 실시간 센서 데이터 처리</h3>
<p>로봇 시뮬레이션에서는 센서 데이터가 실시간으로 수집되며, 이를 실시간으로 처리하는 것이 매우 중요하다. 실시간 처리에서 중요한 요소는 다음과 같다.</p>
<ol>
<li>
<p><strong>처리 시간</strong>: 센서 데이터의 수집 주기와 처리 주기 사이의 시간 간격을 최소화해야 한다. 센서 데이터의 지연(latency)은 로봇의 실시간 동작에 큰 영향을 미치므로, 빠른 데이터 처리 알고리즘을 사용하는 것이 필수적이다.</p>
</li>
<li>
<p><strong>메모리 관리</strong>: 실시간 처리에서는 메모리 관리가 중요한 역할을 한다. 특히, 센서 데이터가 대량으로 수집될 경우 메모리 부족 현상이 발생할 수 있으므로, 적절한 메모리 관리 기법이 필요하다.</p>
</li>
<li>
<p><strong>데이터 큐(queue) 사용</strong>: 실시간 데이터 처리를 위해, 센서 데이터를 처리하기 전 큐에 저장하고 순차적으로 처리하는 방법이 자주 사용된다. 큐에 저장된 데이터는 처리 우선순위에 따라 처리되며, 이러한 방식으로 데이터 처리 속도와 효율성을 높일 수 있다.</p>
</li>
</ol>
<p>실시간 처리에서 데이터의 처리는 주로 다음과 같은 순서로 이루어진다:
- 센서 데이터 수집
- 데이터 전처리(필터링, 이상값 제거)
- 상태 추정 및 보정
- 데이터 출력 및 시각화</p>
<h3 id="7">7. 센서 데이터의 전처리</h3>
<p>센서 데이터의 전처리는 데이터 분석의 첫 단계로, 실제 데이터를 사용하기 전에 데이터를 정제하고 처리하여 더 정확한 분석을 가능하게 한다. 센서 데이터 전처리 과정은 다음과 같은 단계로 이루어진다.</p>
<h4 id="a-normalization">a. 데이터 정규화(Normalization)</h4>
<p>다양한 센서에서 측정된 데이터는 범위가 다를 수 있다. 예를 들어, IMU(관성 측정 장치)는 가속도 데이터를 m/s²로 제공하는 반면, GPS는 위치 데이터를 위도와 경도 좌표로 제공한다. 이러한 다른 범위의 데이터를 비교하기 위해서는 정규화(normalization) 과정을 거쳐야 한다.</p>
<p>정규화는 데이터를 특정 범위 내로 변환하는 과정이다. 데이터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_k</span><script type="math/tex">\mathbf{z}_k</script></span>를 정규화하는 방법 중 하나는 최소-최대 정규화이다. 이를 통해 데이터가 0과 1 사이로 변환된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{z}_k' = \frac{\mathbf{z}_k - \min(\mathbf{z})}{\max(\mathbf{z}) - \min(\mathbf{z})}
</div>
<script type="math/tex; mode=display">
\mathbf{z}_k' = \frac{\mathbf{z}_k - \min(\mathbf{z})}{\max(\mathbf{z}) - \min(\mathbf{z})}
</script>
</div>
<p>이 방식은 특히 여러 센서의 데이터를 하나의 융합된 상태로 결합할 때 유용하다.</p>
<h4 id="b-smoothing">b. 데이터 스무딩(Smoothing)</h4>
<p>센서 데이터는 시간에 따라 급격한 변화가 발생할 수 있다. 이를 완화하고 데이터의 연속성을 확보하기 위해 스무딩(smoothing) 기법이 사용된다. 스무딩은 잡음을 제거하면서 데이터의 변동성을 줄여 더 안정적인 분석을 가능하게 한다.</p>
<p>대표적인 스무딩 방법으로는 이동 평균(Moving Average)이 있다. 이동 평균은 주어진 데이터의 일정 범위 내에서 평균값을 계산하여 급격한 변화를 완화한다. 이동 평균은 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{z}_k^{\text{smoothed}} = \frac{1}{N} \sum_{i=k-N+1}^{k} \mathbf{z}_i
</div>
<script type="math/tex; mode=display">
\mathbf{z}_k^{\text{smoothed}} = \frac{1}{N} \sum_{i=k-N+1}^{k} \mathbf{z}_i
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>은 윈도우 크기(window size)이다. 윈도우 크기가 클수록 데이터의 변동성이 더 많이 완화된다.</p>
<h4 id="c">c. 고급 필터링 기법</h4>
<p>센서 데이터가 더욱 복잡한 경우, 단순한 스무딩 기법보다 고급 필터링 기법을 적용해야 할 때도 있다. 고급 필터링 기법으로는 저주파 필터(Low-pass filter), 칼만 필터(Kalman filter), 및 입자 필터(Particle filter) 등이 있다.</p>
<ul>
<li>
<p><strong>저주파 필터(Low-pass filter)</strong>는 빠른 변동을 줄이기 위해 높은 주파수를 제거하는 필터이다. 이는 급격한 변화에 민감한 센서 데이터에서 자주 사용된다.</p>
</li>
<li>
<p><strong>칼만 필터(Kalman filter)</strong>는 이전에 설명한 바와 같이, 연속적인 상태 변화를 추정하기 위한 알고리즘으로, 시스템의 동적 특성을 반영하여 보다 정확한 상태 추정을 제공한다.</p>
</li>
<li>
<p><strong>입자 필터(Particle filter)</strong>는 비선형 및 비가우시안 시스템에서도 효과적으로 작동하는 필터로, 로봇의 위치 추정 등에서 자주 사용된다. 입자 필터는 확률적 방법을 통해 센서 데이터의 분포를 추정하는 기법이다.</p>
</li>
</ul>
<h3 id="8">8. 데이터 융합 알고리즘 적용</h3>
<p>센서 데이터가 전처리된 후에는, 데이터를 융합하여 로봇의 상태를 추정하는 과정이 이루어진다. 이를 위해 다양한 데이터 융합 알고리즘이 사용되며, 가장 일반적으로 사용되는 알고리즘은 확장 칼만 필터(Extended Kalman Filter, EKF)이다.</p>
<p>확장 칼만 필터는 비선형 시스템의 상태 추정을 위해 사용되는 알고리즘으로, 시스템의 상태를 예측하고 센서 데이터를 이용하여 상태를 보정한다. 확장 칼만 필터에서 사용되는 비선형 시스템의 상태 방정식은 다음과 같이 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_k = f(\mathbf{x}_{k-1}, \mathbf{u}_k) + \mathbf{w}_k
</div>
<script type="math/tex; mode=display">
\mathbf{x}_k = f(\mathbf{x}_{k-1}, \mathbf{u}_k) + \mathbf{w}_k
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">f(\cdot)</span><script type="math/tex">f(\cdot)</script></span>는 비선형 상태 전이 함수(state transition function)를 나타낸다. 측정 방정식 역시 비선형 함수를 사용하여 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{z}_k = h(\mathbf{x}_k) + \mathbf{v}_k
</div>
<script type="math/tex; mode=display">
\mathbf{z}_k = h(\mathbf{x}_k) + \mathbf{v}_k
</script>
</div>
<p>확장 칼만 필터는 이 비선형 함수 <span class="arithmatex"><span class="MathJax_Preview">f(\cdot)</span><script type="math/tex">f(\cdot)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">h(\cdot)</span><script type="math/tex">h(\cdot)</script></span>를 테일러 급수로 선형화하여 칼만 필터를 적용한다. 테일러 급수를 사용하여 선형화된 시스템에서 칼만 필터는 상태 예측과 보정을 수행하게 된다.</p>
<h3 id="9">9. 확장 칼만 필터의 적용 단계</h3>
<p>확장 칼만 필터(EKF)는 비선형 시스템에서 칼만 필터의 개념을 확장한 것으로, 로봇 시뮬레이션에서 센서 데이터를 기반으로 상태를 추정하는 데 매우 유용하다. EKF는 예측(prediction) 단계와 업데이트(update) 단계로 나뉜다.</p>
<h4 id="a">a. 예측 단계</h4>
<p>확장 칼만 필터의 첫 번째 단계는 이전 상태와 시스템의 동역학을 이용하여 현재 상태를 예측하는 것이다. 시스템 상태는 다음과 같은 상태 전이 방정식으로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{k|k-1} = f(\mathbf{x}_{k-1}, \mathbf{u}_k)
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{k|k-1} = f(\mathbf{x}_{k-1}, \mathbf{u}_k)
</script>
</div>
<p>이때, 예측된 상태에 대한 공분산은 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k|k-1} = \mathbf{F}_k \mathbf{P}_{k-1} \mathbf{F}_k^T + \mathbf{Q}_k
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k|k-1} = \mathbf{F}_k \mathbf{P}_{k-1} \mathbf{F}_k^T + \mathbf{Q}_k
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}_k</span><script type="math/tex">\mathbf{F}_k</script></span>는 상태 전이 행렬의 야코비안(Jacobian)이며, 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{F}_k = \frac{\partial f(\mathbf{x}_{k-1}, \mathbf{u}_k)}{\partial \mathbf{x}_{k-1}}
</div>
<script type="math/tex; mode=display">
\mathbf{F}_k = \frac{\partial f(\mathbf{x}_{k-1}, \mathbf{u}_k)}{\partial \mathbf{x}_{k-1}}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}_k</span><script type="math/tex">\mathbf{Q}_k</script></span>는 시스템 노이즈 공분산 행렬이다.</li>
</ul>
<h4 id="b">b. 업데이트 단계</h4>
<p>예측된 상태가 센서 측정값과 비교되며, 이를 통해 상태를 보정한다. 센서 측정값은 다음과 같은 비선형 측정 방정식을 통해 얻어진다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{z}_k = h(\mathbf{x}_k) + \mathbf{v}_k
</div>
<script type="math/tex; mode=display">
\mathbf{z}_k = h(\mathbf{x}_k) + \mathbf{v}_k
</script>
</div>
<p>예측된 상태 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{k|k-1}</span><script type="math/tex">\mathbf{x}_{k|k-1}</script></span>을 기반으로 측정값을 예측하면, 그 차이(측정 오차)는 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{y}_k = \mathbf{z}_k - h(\mathbf{x}_{k|k-1})
</div>
<script type="math/tex; mode=display">
\mathbf{y}_k = \mathbf{z}_k - h(\mathbf{x}_{k|k-1})
</script>
</div>
<p>상태 업데이트를 위한 칼만 이득(Kalman gain)은 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}_k^T \left( \mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^T + \mathbf{R}_k \right)^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}_k^T \left( \mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^T + \mathbf{R}_k \right)^{-1}
</script>
</div>
<p>여기서,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}_k</span><script type="math/tex">\mathbf{H}_k</script></span>는 측정 함수의 야코비안이며, 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{H}_k = \frac{\partial h(\mathbf{x}_k)}{\partial \mathbf{x}_k}
</div>
<script type="math/tex; mode=display">
\mathbf{H}_k = \frac{\partial h(\mathbf{x}_k)}{\partial \mathbf{x}_k}
</script>
</div>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_k</span><script type="math/tex">\mathbf{R}_k</script></span>는 측정 잡음 공분산 행렬이다.</li>
</ul>
<p>업데이트된 상태는 칼만 이득을 이용하여 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_k = \mathbf{x}_{k|k-1} + \mathbf{K}_k \mathbf{y}_k
</div>
<script type="math/tex; mode=display">
\mathbf{x}_k = \mathbf{x}_{k|k-1} + \mathbf{K}_k \mathbf{y}_k
</script>
</div>
<p>업데이트된 공분산 행렬은 다음과 같이 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_k = \left( \mathbf{I} - \mathbf{K}_k \mathbf{H}_k \right) \mathbf{P}_{k|k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_k = \left( \mathbf{I} - \mathbf{K}_k \mathbf{H}_k \right) \mathbf{P}_{k|k-1}
</script>
</div>
<p>이 과정을 통해 센서 측정값의 오차를 보정하고 상태를 추정하게 된다.</p>
<h3 id="10">10. 실시간 센서 데이터 융합을 위한 고려사항</h3>
<p>로봇 시뮬레이션에서 실시간으로 센서 데이터를 융합하려면 다양한 센서가 서로 다른 주기로 데이터를 제공하므로, 이를 효율적으로 처리하는 것이 중요하다. 특히, 고주기 센서(IMU, 가속도계, 자이로스코프 등)와 저주기 센서(GPS 등)의 융합에서 몇 가지 중요한 사항을 고려해야 한다.</p>
<h4 id="a_1">a. 센서 데이터의 시간 동기화</h4>
<p>서로 다른 주기로 수집된 데이터를 융합하려면 시간 동기화가 필수적이다. 예를 들어, IMU 데이터는 초당 수백 Hz로 수집되지만 GPS 데이터는 초당 1~10 Hz로 수집될 수 있다. 이러한 데이터를 효과적으로 결합하기 위해서는 데이터를 동일한 시간 기준으로 변환하는 작업이 필요하다.</p>
<p>이를 위해 가장 많이 사용하는 방법 중 하나는 <strong>시간 보간(time interpolation)</strong>이다. 고주기 센서 데이터는 그대로 사용하고, 저주기 센서 데이터는 최신 값 또는 보간된 값을 이용하여 고주기 데이터에 맞춘다.</p>
<h4 id="b_1">b. 주기 차이에 따른 상태 예측</h4>
<p>센서 데이터의 주기가 다를 경우, 예측 단계에서 고주기 센서 데이터는 자주 업데이트되지만, 저주기 센서 데이터는 상대적으로 덜 빈번하게 업데이트된다. 따라서 저주기 센서 데이터가 들어오지 않는 동안에는 상태 예측만 수행하고, 데이터가 들어올 때 상태 업데이트를 수행하는 방식으로 설계할 수 있다.</p>
<p>이를 통해 시스템의 효율성을 높이고, 고주기 데이터로 빠른 동작을 예측할 수 있다.</p>
<h4 id="c_1">c. 융합된 센서 데이터의 잡음 모델링</h4>
<p>각 센서의 잡음 특성이 다르기 때문에, 센서 데이터를 융합할 때 각 센서의 잡음 공분산을 정확히 모델링하는 것이 중요하다. IMU 데이터는 보통 백색 잡음을 따르며, GPS 데이터는 더 복잡한 잡음 모델이 필요할 수 있다.</p>
<p>이를 고려하여 각 센서에 맞는 잡음 모델을 적용하고, 이를 융합한 시스템에 반영해야 보다 정확한 상태 추정이 가능한다.</p>
<h3 id="11">11. 센서 데이터 융합 결과의 검증 및 분석</h3>
<p>센서 데이터를 융합한 후에는 그 결과를 검증하고 분석하는 과정이 필요하다. 검증 과정에서는 실제 측정값과 융합된 상태 추정값의 오차를 분석하여 융합 알고리즘의 성능을 평가할 수 있다. 이러한 오차는 주로 다음과 같은 방법으로 측정된다.</p>
<h4 id="a-root-mean-square-error-rmse">a. 루트 평균 제곱 오차(Root Mean Square Error, RMSE)</h4>
<p>루트 평균 제곱 오차는 상태 추정값과 실제 값 사이의 차이를 측정하는 방법으로, 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{RMSE} = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (\mathbf{z}_i - \mathbf{x}_i)^2}
</div>
<script type="math/tex; mode=display">
\text{RMSE} = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (\mathbf{z}_i - \mathbf{x}_i)^2}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>은 데이터 포인트의 개수, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_i</span><script type="math/tex">\mathbf{z}_i</script></span>는 실제 측정값, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_i</span><script type="math/tex">\mathbf{x}_i</script></span>는 추정값이다. RMSE는 오차의 크기를 정량적으로 평가하는 데 유용한 척도이다.</p>
<h4 id="b_2">b. 오차 공분산 분석</h4>
<p>상태 추정값의 공분산 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}_k</span><script type="math/tex">\mathbf{P}_k</script></span>을 분석하여 센서 데이터 융합의 불확실성을 평가할 수 있다. 공분산이 작을수록 시스템의 불확실성이 적으며, 상태 추정값의 신뢰도가 높다는 것을 의미한다. 공분산 분석을 통해 센서 데이터의 품질과 융합 결과의 신뢰성을 평가할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2803/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2803/" class="btn btn-xs btn-link">
        시뮬레이션 결과 시각화 도구
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2801/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2801/" class="btn btn-xs btn-link">
        시뮬레이션 데이터 기록 및 분석
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>