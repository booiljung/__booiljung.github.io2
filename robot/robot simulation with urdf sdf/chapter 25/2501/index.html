<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot%20simulation%20with%20urdf%20sdf/chapter%2025/2501/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Gazebo 플러그인 활용 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Gazebo \ud50c\ub7ec\uadf8\uc778\uc758 \uac1c\uc694", url: "#_top", children: [
          ]},
          {title: "Gazebo \ud50c\ub7ec\uadf8\uc778\uc758 \uc8fc\uc694 \uae30\ub2a5", url: "#gazebo_1", children: [
          ]},
          {title: "Gazebo \ud50c\ub7ec\uadf8\uc778\uc758 \uad6c\uc870", url: "#gazebo_2", children: [
          ]},
          {title: "URDF\uc640 SDF\uc5d0\uc11c Gazebo \ud50c\ub7ec\uadf8\uc778 \uc124\uc815", url: "#urdf-sdf-gazebo", children: [
          ]},
          {title: "Gazebo \ud50c\ub7ec\uadf8\uc778\uc758 \uc885\ub958\uc640 \uc0ac\uc6a9 \uc0ac\ub840", url: "#gazebo_3", children: [
          ]},
          {title: "\ud50c\ub7ec\uadf8\uc778 \uac1c\ubc1c \ubc0f \ucf54\ub4dc \uad6c\uc870", url: "#_1", children: [
          ]},
          {title: "Gazebo \ud50c\ub7ec\uadf8\uc778 \uac1c\ubc1c \uc608\uc81c", url: "#gazebo_4", children: [
              {title: "1. \ud50c\ub7ec\uadf8\uc778 \ud5e4\ub354 \ud30c\uc77c", url: "#1" },
              {title: "2. \ud50c\ub7ec\uadf8\uc778 \uad6c\ud604 \ud30c\uc77c", url: "#2" },
              {title: "3. \ud50c\ub7ec\uadf8\uc778 \ub3d9\uc791 \uc6d0\ub9ac", url: "#3" },
              {title: "4. \ud50c\ub7ec\uadf8\uc778 \ucef4\ud30c\uc77c \ubc0f \uc2e4\ud589", url: "#4" },
          ]},
          {title: "5. Gazebo \ud50c\ub7ec\uadf8\uc778\uc758 \uc8fc\uc694 \ud568\uc218 \ubc0f \uc774\ubca4\ud2b8", url: "#5-gazebo", children: [
              {title: "\uc8fc\uc694 \ud568\uc218", url: "#_2" },
              {title: "\uc8fc\uc694 \uc774\ubca4\ud2b8", url: "#_3" },
          ]},
          {title: "Gazebo \ud50c\ub7ec\uadf8\uc778\uc5d0\uc11c \ubb3c\ub9ac \uc5d4\uc9c4 \uc81c\uc5b4", url: "#gazebo_5", children: [
          ]},
          {title: "Gazebo \ud50c\ub7ec\uadf8\uc778\uc5d0\uc11c PID \uc81c\uc5b4\uae30\uc758 \uad6c\ud604", url: "#gazebo-pid", children: [
              {title: "PID \uc81c\uc5b4\uae30\uc758 \uad6c\uc131 \uc694\uc18c", url: "#pid" },
              {title: "PID \uc81c\uc5b4\uae30 \uc804\uccb4 \uc218\uc2dd", url: "#pid_1" },
              {title: "Gazebo\uc5d0\uc11c PID \uc81c\uc5b4\uae30 \uc0ac\uc6a9\ud558\uae30", url: "#gazebo-pid_1" },
              {title: "PID \ud29c\ub2dd", url: "#pid_2" },
              {title: "PID \uc81c\uc5b4\uae30\uc758 \uc548\uc815\uc131 \ubd84\uc11d", url: "#pid_3" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2502/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2502/" class="btn btn-xs btn-link">
        로봇과 센서에 플러그인 적용
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter%2024/2403/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter%2024/2403/" class="btn btn-xs btn-link">
        Gazebo에서 동적 환경 시뮬레이션
      </a>
    </div>
    
  </div>

    

    <h3 id="gazebo">Gazebo 플러그인의 개요</h3>
<p>Gazebo 플러그인은 로봇 시뮬레이션에서 특정 기능을 확장하거나, 기존의 기능을 세부적으로 제어할 수 있도록 하는 소프트웨어 컴포넌트이다. 플러그인은 로봇 모델의 물리적 속성, 센서 데이터의 수집 및 처리, 제어 시스템과의 통합 등을 구현하는 데 중요한 역할을 한다. URDF 또는 SDF 파일과 함께 사용되며, 로봇의 동작을 제어하거나 시뮬레이션 환경을 제어할 수 있다.</p>
<p>플러그인은 크게 두 가지 역할을 담당한다. 첫 번째는 <strong>로봇의 동작을 제어</strong>하는 것이고, 두 번째는 <strong>시뮬레이션 환경과의 상호작용</strong>을 관리하는 것이다. 이를 통해 사용자는 복잡한 시뮬레이션 환경에서 로봇의 정확한 동작을 모델링하고, 다양한 환경에서 로봇의 성능을 테스트할 수 있다.</p>
<h3 id="gazebo_1">Gazebo 플러그인의 주요 기능</h3>
<ol>
<li><strong>로봇 제어</strong></li>
<li>Gazebo 플러그인은 로봇의 모터 제어, 조인트 움직임, 센서의 데이터 수집 및 처리를 담당할 수 있다. 로봇의 동작 제어는 주로 PID 제어기를 통해 이루어지며, 이를 통해 사용자는 로봇의 조인트나 휠의 정확한 위치 및 속도를 제어할 수 있다.</li>
<li>PID 제어기의 수식은 다음과 같다:</li>
</ol>
<p>$$
   u(t) = K_p \cdot e(t) + K_i \cdot \int_0^t e(\tau) d\tau + K_d \cdot \frac{d e(t)}{dt}</p>
<p>$$</p>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>는 제어 신호
   - <span class="arithmatex"><span class="MathJax_Preview">e(t)</span><script type="math/tex">e(t)</script></span>는 목표값과 실제값의 차이(오차)
   - <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span>는 각각 비례, 적분, 미분 게인이다.</p>
<ol>
<li><strong>센서 데이터 처리</strong></li>
<li>Gazebo 플러그인을 통해 사용자는 로봇에 장착된 카메라, LiDAR, IMU와 같은 센서로부터 데이터를 수집하고, 해당 데이터를 실시간으로 처리할 수 있다.</li>
<li>센서 데이터의 수집과 처리는 주로 센서 플러그인을 통해 이루어지며, 이를 통해 로봇의 위치, 속도, 가속도 등의 물리적 데이터를 분석하고 처리할 수 있다.</li>
<li>예를 들어, IMU 센서에서 가속도 데이터를 수집하는 공식은 다음과 같다:</li>
</ol>
<p>$$
   \mathbf{a} = \frac{d\mathbf{v}}{dt}</p>
<p>$$</p>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>는 가속도 벡터
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>는 속도 벡터이다.</p>
<h3 id="gazebo_2">Gazebo 플러그인의 구조</h3>
<p>Gazebo 플러그인은 크게 <strong>월드 플러그인</strong>, <strong>모델 플러그인</strong>, <strong>센서 플러그인</strong>으로 구분할 수 있다.</p>
<ol>
<li><strong>월드 플러그인</strong>은 시뮬레이션 전체를 제어하는 데 사용된다. 이 플러그인을 통해 시뮬레이션 환경을 설정하고, 다양한 객체를 추가하거나 삭제할 수 있다.</li>
<li><strong>모델 플러그인</strong>은 로봇 모델 자체를 제어한다. 이 플러그인을 사용하여 로봇의 동작, 조인트 제어, 충돌 처리 등을 구현할 수 있다.</li>
<li><strong>센서 플러그인</strong>은 로봇에 장착된 센서를 제어하고, 센서 데이터를 처리한다. 이를 통해 사용자는 시뮬레이션 내에서 센서 데이터를 실시간으로 수집하고 분석할 수 있다.</li>
</ol>
<h3 id="urdf-sdf-gazebo">URDF와 SDF에서 Gazebo 플러그인 설정</h3>
<p>플러그인은 URDF 또는 SDF 파일에서 직접 설정할 수 있다. 각 플러그인은 XML 태그로 정의되며, 플러그인의 이름과 파라미터를 지정할 수 있다. 예를 들어, URDF에서 플러그인을 설정하는 방법은 다음과 같다:</p>
<pre><code class="language-xml">&lt;gazebo&gt;
  &lt;plugin name=&quot;my_plugin&quot; filename=&quot;libmy_plugin.so&quot;&gt;
    &lt;param1&gt;value1&lt;/param1&gt;
    &lt;param2&gt;value2&lt;/param2&gt;
  &lt;/plugin&gt;
&lt;/gazebo&gt;
</code></pre>
<p>SDF에서도 유사하게 플러그인을 설정할 수 있으며, SDF의 플러그인 구조는 URDF보다 더 유연하고 확장성이 높다.</p>
<h3 id="gazebo_3">Gazebo 플러그인의 종류와 사용 사례</h3>
<ol>
<li><strong>월드 플러그인</strong></li>
<li>월드 플러그인은 전체 시뮬레이션 환경을 제어한다. 예를 들어, 특정 시간이 경과한 후 시뮬레이션에 새로운 객체를 추가하거나, 기존 객체를 제거할 수 있다. 또한, 시뮬레이션 중에 중력이나 마찰 계수와 같은 물리적 특성을 동적으로 변경할 수 있다.</li>
<li>
<p>월드 플러그인의 일반적인 사용 사례는 다음과 같다:</p>
<ul>
<li>시뮬레이션 시간에 따른 환경 변화</li>
<li>로봇의 동작에 따른 실시간 환경 반응</li>
<li>다중 로봇 시스템의 환경 내 상호작용</li>
</ul>
</li>
<li>
<p><strong>모델 플러그인</strong></p>
</li>
<li>모델 플러그인은 로봇 자체의 동작을 제어하는 데 사용된다. 이 플러그인을 통해 사용자는 로봇의 특정 부위를 움직이거나, 센서 데이터를 분석하여 로봇의 행동을 결정할 수 있다.</li>
<li>예를 들어, 6자유도 로봇 팔의 조인트를 제어하는 플러그인을 작성할 수 있다. 플러그인은 PID 제어기와 결합하여 각 조인트의 각도를 제어하고, 목표 위치에 도달할 수 있도록 도와준다.</li>
<li>이때, 각 조인트의 회전 행렬은 다음과 같이 표현될 수 있다:</li>
</ol>
<p>$$
   \mathbf{R}_z(\theta) = 
   \begin{bmatrix}
   \cos{\theta} &amp; -\sin{\theta} &amp; 0 \
   \sin{\theta} &amp; \cos{\theta} &amp; 0 \
   0 &amp; 0 &amp; 1
   \end{bmatrix}</p>
<p>$$</p>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>는 회전각이다.</p>
<p>이 회전 행렬은 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>-축을 기준으로 로봇 조인트의 회전을 설명한다. 이를 통해 로봇의 조인트가 주어진 각도로 회전하며, 플러그인은 로봇의 동작을 제어할 수 있다.</p>
<ol>
<li><strong>센서 플러그인</strong></li>
<li>센서 플러그인은 시뮬레이션 내에서 로봇에 장착된 센서들을 제어한다. 예를 들어, 카메라 센서를 사용하여 로봇 주변의 이미지를 수집하거나, LiDAR 센서를 사용하여 로봇 주변의 거리 데이터를 측정할 수 있다.</li>
<li>카메라 센서에서 이미지를 수집하는 경우, 플러그인은 특정 주기로 이미지를 캡처하고 이를 시뮬레이션 내에서 사용할 수 있도록 설정한다. LiDAR 센서의 경우, 다음과 같은 거리 측정 공식을 사용할 수 있다:</li>
</ol>
<p>$$
   d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2}</p>
<p>$$</p>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>는 두 점 사이의 거리
   - <span class="arithmatex"><span class="MathJax_Preview">(x_1, y_1, z_1)</span><script type="math/tex">(x_1, y_1, z_1)</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">(x_2, y_2, z_2)</span><script type="math/tex">(x_2, y_2, z_2)</script></span>는 두 점의 좌표이다.</p>
<p>센서 플러그인은 이러한 데이터를 실시간으로 수집하고, 로봇의 동작에 반영하거나 외부 시스템에 전달할 수 있다.</p>
<h3 id="_1">플러그인 개발 및 코드 구조</h3>
<p>Gazebo 플러그인을 개발할 때는 C++ 언어를 주로 사용하며, Gazebo API를 활용하여 플러그인의 동작을 정의한다. 플러그인 개발은 주로 세 가지 단계로 나눌 수 있다:</p>
<ol>
<li><strong>플러그인 초기화</strong></li>
<li>플러그인이 처음 로드될 때, 초기화 과정을 거친다. 이 과정에서 플러그인은 필요한 파라미터를 설정하고, 시뮬레이션과 상호작용할 준비를 한다.</li>
<li>
<p>초기화 단계에서는 URDF나 SDF 파일에서 전달된 파라미터 값을 읽어들이다. 예를 들어, 조인트의 초기 위치나 속도를 설정할 수 있다.</p>
</li>
<li>
<p><strong>플러그인 업데이트</strong></p>
</li>
<li>플러그인은 시뮬레이션이 진행되는 동안 주기적으로 업데이트된다. 업데이트 함수는 주어진 주기마다 호출되며, 이때 로봇의 동작을 제어하거나, 센서 데이터를 수집하고 처리할 수 있다.</li>
<li>
<p>업데이트 주기는 주로 시뮬레이션의 시간 단위로 설정되며, 사용자는 이를 통해 로봇의 동작 속도를 조정할 수 있다. 일반적으로 1ms 또는 10ms 단위로 설정된다.</p>
</li>
<li>
<p><strong>플러그인 종료</strong></p>
</li>
<li>시뮬레이션이 종료되면, 플러그인은 이를 감지하고 종료 절차를 밟습니다. 이때 로봇의 상태를 저장하거나, 필요한 데이터를 기록할 수 있다. 또한, 시뮬레이션 중에 사용된 자원을 해제하고, 메모리 누수가 발생하지 않도록 관리한다.</li>
</ol>
<h3 id="gazebo_4">Gazebo 플러그인 개발 예제</h3>
<p>다음은 간단한 Gazebo 모델 플러그인을 개발하는 예제이다. 이 플러그인은 로봇의 조인트를 제어하는 역할을 한다. 플러그인은 기본적으로 C++로 작성되며, Gazebo API를 사용하여 구현된다.</p>
<h4 id="1">1. 플러그인 헤더 파일</h4>
<p>먼저 플러그인의 헤더 파일을 정의한다. 여기서는 플러그인 클래스의 선언과 주요 변수 및 함수들을 정의한다.</p>
<pre><code class="language-cpp">#ifndef _MY_PLUGIN_HH_
#define _MY_PLUGIN_HH_

#include &lt;gazebo/gazebo.hh&gt;
#include &lt;gazebo/physics/physics.hh&gt;
#include &lt;gazebo/common/common.hh&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Float64.h&gt;

namespace gazebo
{
  class MyPlugin : public ModelPlugin
  {
  public:
    MyPlugin() : ModelPlugin() {}

    void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf);

  private:
    void OnUpdate();

    // ROS 노드 핸들러
    ros::NodeHandle nh_;

    // ROS Subscriber
    ros::Subscriber joint_sub_;

    // 업데이트 이벤트 연결
    event::ConnectionPtr updateConnection_;

    // 조인트 포인터
    physics::JointPtr joint_;

    // 제어 입력 값
    double input_;
  };
}
#endif
</code></pre>
<h4 id="2">2. 플러그인 구현 파일</h4>
<p>플러그인의 동작을 구현하는 <code>.cpp</code> 파일이다. 여기서 조인트 제어 로직을 작성한다.</p>
<pre><code class="language-cpp">#include &quot;my_plugin.hh&quot;
#include &lt;functional&gt;

namespace gazebo
{
  void MyPlugin::Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)
  {
    // Gazebo 모델의 조인트 가져오기
    this-&gt;joint_ = _model-&gt;GetJoint(&quot;joint_name&quot;);

    // ROS Subscriber 설정
    this-&gt;joint_sub_ = nh_.subscribe(&quot;/joint_input&quot;, 1, &amp;MyPlugin::OnUpdate, this);

    // 업데이트 이벤트 연결
    this-&gt;updateConnection_ = event::Events::ConnectWorldUpdateBegin(
      std::bind(&amp;MyPlugin::OnUpdate, this));
  }

  void MyPlugin::OnUpdate()
  {
    // ROS로부터 입력값 받기
    ros::spinOnce();

    // 조인트 제어
    this-&gt;joint_-&gt;SetForce(0, this-&gt;input_);
  }
}

GZ_REGISTER_MODEL_PLUGIN(MyPlugin)
</code></pre>
<h4 id="3">3. 플러그인 동작 원리</h4>
<ul>
<li>
<p><strong>Load 함수</strong>: 이 함수는 플러그인이 처음 로드될 때 호출된다. 로봇 모델에서 특정 조인트를 가져와 제어할 준비를 한다. 또한 ROS 노드를 초기화하고, ROS 메시지를 수신할 수 있도록 Subscriber를 설정한다.</p>
</li>
<li>
<p><strong>OnUpdate 함수</strong>: 이 함수는 Gazebo 시뮬레이션이 업데이트될 때마다 호출된다. ROS로부터 입력값을 수신하고, 이를 사용하여 로봇 조인트에 힘을 가한다. 이때, 조인트에 가해지는 힘은 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}</span><script type="math/tex">\mathbf{F}</script></span>로 표현할 수 있으며, 다음과 같이 정의된다:</p>
</li>
</ul>
<p>$$
  \mathbf{F} = m \mathbf{a}</p>
<p>$$</p>
<p>여기서:
  - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}</span><script type="math/tex">\mathbf{F}</script></span>는 조인트에 가해지는 힘
  - <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 조인트의 질량
  - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>는 조인트의 가속도이다.</p>
<p>이 예제에서는 조인트에 직접 힘을 가하는 방식으로 동작을 제어한다. 실제 시뮬레이션에서는 PID 제어기나 더욱 정밀한 제어 방법을 사용할 수 있다.</p>
<h4 id="4">4. 플러그인 컴파일 및 실행</h4>
<p>플러그인을 컴파일하려면 <code>CMakeLists.txt</code> 파일을 작성하고, 이를 통해 C++ 파일을 빌드해야 한다. 플러그인 컴파일 후, URDF나 SDF 파일에서 플러그인을 호출하여 시뮬레이션에서 실행할 수 있다.</p>
<pre><code class="language-xml">&lt;gazebo&gt;
  &lt;plugin name=&quot;my_plugin&quot; filename=&quot;libmy_plugin.so&quot;/&gt;
&lt;/gazebo&gt;
</code></pre>
<p>URDF나 SDF 파일에 위와 같이 플러그인을 정의한 후, Gazebo에서 시뮬레이션을 실행하면 플러그인이 로드되고, 로봇의 조인트 제어가 가능한다.</p>
<h3 id="5-gazebo">5. Gazebo 플러그인의 주요 함수 및 이벤트</h3>
<p>Gazebo 플러그인은 다양한 이벤트와 함수를 제공하여 시뮬레이션의 여러 측면을 제어할 수 있다. 이러한 함수와 이벤트는 플러그인 내부에서 시뮬레이션의 특정 상태나 동작을 감지하고 처리하는 데 사용된다.</p>
<h4 id="_2">주요 함수</h4>
<ol>
<li><strong>Load()</strong></li>
<li>플러그인이 로드될 때 호출되는 함수이다. 시뮬레이션이 시작될 때 로봇 모델과 관련된 파라미터를 초기화하고 필요한 요소들을 설정한다.</li>
<li>예를 들어, 로봇 모델에서 특정 링크나 조인트를 가져와 제어할 수 있으며, 센서를 초기화할 수 있다.</li>
</ol>
<p><code>cpp
   void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)
   {
       // 모델의 특정 조인트를 가져오기
       this-&gt;joint_ = _model-&gt;GetJoint("joint_name");
   }</code></p>
<ol>
<li><strong>Init()</strong></li>
<li>
<p>플러그인이 초기화된 후, 시뮬레이션이 시작되기 전에 호출된다. 시뮬레이션 중 사용할 변수를 초기화하거나, 첫 번째 업데이트 전에 필요한 계산을 수행할 수 있다.</p>
</li>
<li>
<p><strong>Reset()</strong></p>
</li>
<li>시뮬레이션이 다시 시작될 때 호출된다. 이 함수는 시뮬레이션이 중단되었다가 재시작될 때나, 시뮬레이션이 리셋될 때 사용된다. 플러그인의 상태를 초기화하고, 변수나 상태 값을 리셋하는 데 사용된다.</li>
</ol>
<p><code>cpp
   void Reset()
   {
       // 변수를 초기 상태로 리셋
       this-&gt;input_ = 0.0;
   }</code></p>
<ol>
<li><strong>OnUpdate()</strong></li>
<li>
<p>시뮬레이션이 업데이트될 때마다 주기적으로 호출된다. 이 함수는 플러그인의 주된 제어 로직이 실행되는 곳이다. 주기적으로 호출되기 때문에, 로봇의 동작을 실시간으로 제어하거나, 센서 데이터를 수집하고 처리할 수 있다.</p>
</li>
<li>
<p>시뮬레이션에서의 시간은 고정된 주기로 흘러가며, 일반적으로 1ms 또는 10ms 주기로 이 함수가 호출된다.</p>
</li>
</ol>
<p><code>cpp
   void OnUpdate()
   {
       // 주기적으로 조인트 제어
       this-&gt;joint_-&gt;SetForce(0, this-&gt;input_);
   }</code></p>
<h4 id="_3">주요 이벤트</h4>
<ol>
<li><strong>ConnectWorldUpdateBegin()</strong></li>
<li>시뮬레이션이 업데이트되기 시작할 때 발생하는 이벤트이다. 플러그인은 이 이벤트에 연결되어 주기적으로 OnUpdate 함수를 호출할 수 있다.</li>
</ol>
<p><code>cpp
   this-&gt;updateConnection = event::Events::ConnectWorldUpdateBegin(
       std::bind(&amp;MyPlugin::OnUpdate, this));</code></p>
<ol>
<li><strong>ConnectWorldUpdateEnd()</strong></li>
<li>
<p>시뮬레이션이 업데이트를 마친 후 발생하는 이벤트이다. 이를 통해 시뮬레이션의 프레임이 종료된 후 추가적인 작업을 수행할 수 있다.</p>
</li>
<li>
<p><strong>ConnectBeforePhysicsUpdate()</strong></p>
</li>
<li>
<p>물리 엔진이 업데이트되기 직전에 발생하는 이벤트이다. 이를 통해 물리 연산이 적용되기 전에 로봇의 상태를 조정할 수 있다. 예를 들어, 로봇의 위치나 속도를 조정할 수 있다.</p>
</li>
<li>
<p><strong>ConnectAfterPhysicsUpdate()</strong></p>
</li>
<li>물리 엔진이 업데이트된 후 발생하는 이벤트이다. 이 이벤트는 물리 엔진이 계산된 데이터를 기반으로 로봇의 상태를 업데이트한 후, 추가적인 작업을 수행하는 데 사용된다.</li>
</ol>
<h3 id="gazebo_5">Gazebo 플러그인에서 물리 엔진 제어</h3>
<p>Gazebo에서 로봇의 물리적 동작을 제어하려면, 물리 엔진과의 상호작용이 필요하다. Gazebo는 ODE, Bullet, DART, Simbody와 같은 여러 물리 엔진을 지원하며, 각 엔진은 물리적 동작을 시뮬레이션하는 데 필요한 다양한 기능을 제공한다.</p>
<ol>
<li><strong>조인트 제어</strong></li>
<li>Gazebo 플러그인은 조인트의 위치, 속도, 가속도 등을 제어할 수 있다. 조인트의 위치를 제어할 때는 다음과 같은 방식으로 각도를 설정할 수 있다:</li>
</ol>
<p>$$
   \theta(t) = \theta_0 + \omega t + \frac{1}{2} \alpha t^2</p>
<p>$$</p>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">\theta(t)</span><script type="math/tex">\theta(t)</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>에서의 조인트 각도
   - <span class="arithmatex"><span class="MathJax_Preview">\theta_0</span><script type="math/tex">\theta_0</script></span>는 초기 각도
   - <span class="arithmatex"><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span>는 각속도
   - <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 각가속도이다.</p>
<ol>
<li><strong>힘과 토크 제어</strong></li>
<li>조인트에 힘이나 토크를 가하는 방식으로 동작을 제어할 수 있다. 이때 힘과 토크는 뉴턴의 운동 법칙에 따라 결정된다:</li>
</ol>
<p>$$
   \mathbf{F} = m \mathbf{a}</p>
<p>$$</p>
<p>$$
   \tau = I \alpha</p>
<p>$$</p>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}</span><script type="math/tex">\mathbf{F}</script></span>는 힘
   - <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 질량
   - <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>는 가속도
   - <span class="arithmatex"><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span>는 토크
   - <span class="arithmatex"><span class="MathJax_Preview">I</span><script type="math/tex">I</script></span>는 관성 모멘트
   - <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>는 각가속도이다.</p>
<ol>
<li><strong>조인트 속도 제어</strong></li>
<li>조인트의 속도를 제어하는 방법도 지원된다. PID 제어기를 사용하여 목표 속도에 도달할 수 있도록 조인트에 힘을 가하는 방식이다. PID 제어기는 다음과 같이 정의된다:</li>
</ol>
<p>$$
   u(t) = K_p \cdot e(t) + K_i \cdot \int_0^t e(\tau) d\tau + K_d \cdot \frac{d e(t)}{dt}</p>
<p>$$</p>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>는 제어 신호
   - <span class="arithmatex"><span class="MathJax_Preview">e(t)</span><script type="math/tex">e(t)</script></span>는 목표값과 실제값의 차이 (오차)
   - <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span>는 각각 비례, 적분, 미분 게인이다.</p>
<h3 id="gazebo-pid">Gazebo 플러그인에서 PID 제어기의 구현</h3>
<p>Gazebo에서 로봇의 조인트나 다른 물리적 요소를 제어할 때 PID 제어기를 자주 사용한다. PID 제어기는 목표값과 실제값의 차이를 줄이기 위한 제어 알고리즘으로, Gazebo 플러그인에서 중요한 역할을 한다. PID 제어기는 Proportional(비례), Integral(적분), Derivative(미분) 세 가지 요소로 이루어져 있다.</p>
<h4 id="pid">PID 제어기의 구성 요소</h4>
<ol>
<li><strong>비례 제어 (Proportional Control, <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>)</strong></li>
<li>비례 제어는 목표값과 실제값 간의 오차에 비례하여 제어 신호를 생성한다. 오차가 클수록 더 큰 제어 신호가 발생하며, 오차가 작아질수록 제어 신호도 작아진다.</li>
</ol>
<p>$$
   P = K_p \cdot e(t)</p>
<p>$$</p>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>는 비례 제어 신호
   - <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>는 비례 게인
   - <span class="arithmatex"><span class="MathJax_Preview">e(t)</span><script type="math/tex">e(t)</script></span>는 목표값과 실제값의 차이 (오차)이다.</p>
<ol>
<li><strong>적분 제어 (Integral Control, <span class="arithmatex"><span class="MathJax_Preview">I</span><script type="math/tex">I</script></span>)</strong></li>
<li>적분 제어는 시간에 따라 누적된 오차를 기반으로 제어 신호를 생성한다. 이는 시스템이 목표값에 천천히 도달하는 경향이 있을 때, 오차를 줄이기 위한 신호를 제공한다.</li>
</ol>
<p>$$
   I = K_i \cdot \int_0^t e(\tau) d\tau</p>
<p>$$</p>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">I</span><script type="math/tex">I</script></span>는 적분 제어 신호
   - <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>는 적분 게인
   - <span class="arithmatex"><span class="MathJax_Preview">\int_0^t e(\tau) d\tau</span><script type="math/tex">\int_0^t e(\tau) d\tau</script></span>는 시간에 따른 오차의 누적이다.</p>
<ol>
<li><strong>미분 제어 (Derivative Control, <span class="arithmatex"><span class="MathJax_Preview">D</span><script type="math/tex">D</script></span>)</strong></li>
<li>미분 제어는 오차의 변화율에 따라 제어 신호를 생성한다. 이는 시스템의 과도한 반응을 줄이기 위한 요소로 작용하며, 오차가 빠르게 변화하는 경우 이를 억제한다.</li>
</ol>
<p>$$
   D = K_d \cdot \frac{d e(t)}{dt}</p>
<p>$$</p>
<p>여기서:
   - <span class="arithmatex"><span class="MathJax_Preview">D</span><script type="math/tex">D</script></span>는 미분 제어 신호
   - <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span>는 미분 게인
   - <span class="arithmatex"><span class="MathJax_Preview">\frac{d e(t)}{dt}</span><script type="math/tex">\frac{d e(t)}{dt}</script></span>는 오차의 변화율이다.</p>
<h4 id="pid_1">PID 제어기 전체 수식</h4>
<p>PID 제어기의 전체 제어 신호는 비례, 적분, 미분 제어의 합으로 이루어진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
u(t) = K_p \cdot e(t) + K_i \cdot \int_0^t e(\tau) d\tau + K_d \cdot \frac{d e(t)}{dt}
</div>
<script type="math/tex; mode=display">
u(t) = K_p \cdot e(t) + K_i \cdot \int_0^t e(\tau) d\tau + K_d \cdot \frac{d e(t)}{dt}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>는 전체 제어 신호이다.
- <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span>는 각각 비례, 적분, 미분 게인이다.
- <span class="arithmatex"><span class="MathJax_Preview">e(t)</span><script type="math/tex">e(t)</script></span>는 목표값과 실제값 간의 오차이다.</p>
<h4 id="gazebo-pid_1">Gazebo에서 PID 제어기 사용하기</h4>
<p>Gazebo 플러그인에서 PID 제어기를 사용하려면, 조인트 또는 링크에 PID 제어기를 설정하고 주기적으로 오차를 계산하여 제어 신호를 생성한다. 이는 Gazebo의 업데이트 함수에서 주기적으로 계산되며, 각 조인트에 필요한 힘이나 토크를 적용하는 방식으로 구현된다.</p>
<pre><code class="language-cpp">// PID 제어기 초기화
common::PID pid(0.1, 0.01, 0.001);

// 목표 각도 설정
double target_position = 1.57;  // 라디안 단위 (90도)

// 현재 조인트의 각도 가져오기
double current_position = this-&gt;joint_-&gt;Position(0);

// 오차 계산
double error = target_position - current_position;

// PID 제어기를 사용하여 힘 계산
double force = pid.Update(error, dt);

// 계산된 힘을 조인트에 적용
this-&gt;joint_-&gt;SetForce(0, force);
</code></pre>
<p>위 예제에서는 PID 제어기를 사용하여 조인트의 목표 각도와 실제 각도 간의 오차를 계산하고, 이를 기반으로 조인트에 힘을 가하는 방식으로 제어가 이루어진다.</p>
<h4 id="pid_2">PID 튜닝</h4>
<p>PID 제어기의 성능은 <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span> 값을 어떻게 설정하느냐에 따라 크게 달라진다. 이러한 값을 설정하는 과정을 <strong>PID 튜닝</strong>이라고 하며, 시스템의 반응 특성에 맞게 조정해야 한다.</p>
<ul>
<li><strong><span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span> (비례 게인)</strong>: 너무 크면 시스템이 불안정해질 수 있고, 너무 작으면 시스템이 느리게 반응한다.</li>
<li><strong><span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span> (적분 게인)</strong>: 적분 제어는 오차의 누적을 처리하므로, <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span> 값이 너무 크면 시스템이 과도하게 반응할 수 있다.</li>
<li><strong><span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span> (미분 게인)</strong>: 미분 제어는 빠른 오차 변화를 억제하므로, <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span> 값이 너무 크면 시스템이 반응을 너무 억제하게 되어 느려질 수 있다.</li>
</ul>
<h4 id="pid_3">PID 제어기의 안정성 분석</h4>
<p>PID 제어기의 안정성을 분석할 때, <strong>루트 궤적(root locus)</strong>을 사용할 수 있다. 루트 궤적은 시스템의 특성 방정식의 근이 제어 파라미터에 따라 어떻게 변하는지를 나타낸다. 루트 궤적 분석을 통해 시스템의 안정성을 보장하는 <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span> 값을 찾을 수 있다.</p>
<p>시스템의 특성 방정식은 일반적으로 다음과 같은 형태를 갖는다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
P(s) = \frac{1}{s^2 + 2 \zeta \omega_n s + \omega_n^2}
</div>
<script type="math/tex; mode=display">
P(s) = \frac{1}{s^2 + 2 \zeta \omega_n s + \omega_n^2}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">P(s)</span><script type="math/tex">P(s)</script></span>는 시스템의 전달 함수
- <span class="arithmatex"><span class="MathJax_Preview">\zeta</span><script type="math/tex">\zeta</script></span>는 감쇠비
- <span class="arithmatex"><span class="MathJax_Preview">\omega_n</span><script type="math/tex">\omega_n</script></span>은 자연 진동수이다.</p>
<p>PID 제어기를 적용하면 시스템의 폐루프 전달 함수는 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
P_{closed}(s) = \frac{K_p + K_i/s + K_d s}{s^2 + 2 \zeta \omega_n s + \omega_n^2 + (K_p + K_i/s + K_d s)}
</div>
<script type="math/tex; mode=display">
P_{closed}(s) = \frac{K_p + K_i/s + K_d s}{s^2 + 2 \zeta \omega_n s + \omega_n^2 + (K_p + K_i/s + K_d s)}
</script>
</div>
<p>이 방정식을 기반으로 루트 궤적을 분석하여 시스템의 안정성을 확인할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2502/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2502/" class="btn btn-xs btn-link">
        로봇과 센서에 플러그인 적용
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter%2024/2403/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter%2024/2403/" class="btn btn-xs btn-link">
        Gazebo에서 동적 환경 시뮬레이션
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>