<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot_simulation_with_unity/chapter_12/1203/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>SDF를 활용한 로봇 시뮬레이션 예제 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "SDF \ud30c\uc77c \uad6c\uc870 \uc774\ud574", url: "#_top", children: [
              {title: "\ub9c1\ud06c\uc758 \uad00\uc131 \ubc0f \uc9c8\ub7c9 \uc124\uc815", url: "#_1" },
              {title: "\ub9c1\ud06c\uc758 \ucda9\ub3cc \ubc0f \uc2dc\uac01\uc801 \uc694\uc18c \uc124\uc815", url: "#_2" },
          ]},
          {title: "\uc870\uc778\ud2b8 \uc124\uc815", url: "#_3", children: [
              {title: "\ud68c\uc804 \uc870\uc778\ud2b8 \uc815\uc758", url: "#_4" },
              {title: "\ud68c\uc804 \ucd95\uacfc \ubc94\uc704", url: "#_5" },
          ]},
          {title: "Unity\uc5d0\uc11c SDF \ud30c\uc77c \ubd88\ub7ec\uc624\uae30", url: "#unity-sdf", children: [
              {title: "SDF \ud30c\uc77c \ubcc0\ud658 \ucf54\ub4dc \uc608\uc81c", url: "#sdf_1" },
          ]},
          {title: "Unity\uc5d0\uc11c URDF\ub85c \ubcc0\ud658\ub41c \ub85c\ubd07 \ubaa8\ub378 \uc0ac\uc6a9", url: "#unity-urdf", children: [
              {title: "Unity\uc5d0\uc11c URDF Import", url: "#unity-urdf-import" },
              {title: "URDF\ub85c \ub85c\ubd07 \ubaa8\ub378 \ubd88\ub7ec\uc624\uae30 \uc608\uc81c", url: "#urdf" },
          ]},
          {title: "Unity\uc5d0\uc11c \ub85c\ubd07\uc758 \uc6c0\uc9c1\uc784 \uc81c\uc5b4", url: "#unity", children: [
              {title: "C# \ucf54\ub4dc\ub85c \ub85c\ubd07 \uc870\uc778\ud2b8 \uc81c\uc5b4", url: "#c" },
          ]},
          {title: "\uc13c\uc11c \uc2dc\ubbac\ub808\uc774\uc158 \ubc0f \ub370\uc774\ud130 \ucc98\ub9ac", url: "#_6", children: [
              {title: "Unity\uc5d0\uc11c IMU \uc13c\uc11c \uc2dc\ubbac\ub808\uc774\uc158", url: "#unity-imu" },
              {title: "LiDAR \uc2dc\ubbac\ub808\uc774\uc158", url: "#lidar" },
              {title: "\uc13c\uc11c \ub370\uc774\ud130 \ucc98\ub9ac", url: "#_7" },
              {title: "\uc13c\uc11c \ub370\uc774\ud130\ub97c \uc81c\uc5b4 \uc54c\uace0\ub9ac\uc998\uc5d0 \ubc18\uc601\ud558\ub294 \uc608\uc81c", url: "#_8" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_13/1301/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_13/1301/" class="btn btn-xs btn-link">
        가제보와 Unity의 차이점
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1202/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1202/" class="btn btn-xs btn-link">
        SDF에서 Unity로의 변환
      </a>
    </div>
    
  </div>

    

    <h2 id="sdf">SDF 파일 구조 이해</h2>
<p>SDF(Simulation Description Format)는 로봇 시뮬레이션을 위한 XML 기반의 포맷이다. SDF 파일은 로봇의 모델, 물리적 속성, 센서, 조인트, 링크 등을 기술하며, 다양한 시뮬레이션 소프트웨어에서 로봇의 시뮬레이션 환경을 설정할 수 있다. SDF 파일의 기본 구조는 다음과 같다.</p>
<pre><code class="language-xml">&lt;sdf version='1.6'&gt;
  &lt;model name='robot_model'&gt;
    &lt;link name='base_link'&gt;
      &lt;!-- 링크의 물리적 속성 정의 --&gt;
      &lt;inertial&gt;
        &lt;mass&gt;1.0&lt;/mass&gt;
        &lt;inertia&gt;
          &lt;ixx&gt;0.1&lt;/ixx&gt;
          &lt;iyy&gt;0.1&lt;/iyy&gt;
          &lt;izz&gt;0.1&lt;/izz&gt;
        &lt;/inertia&gt;
      &lt;/inertial&gt;
      &lt;!-- 충돌 설정 --&gt;
      &lt;collision name='collision'&gt;
        &lt;geometry&gt;
          &lt;box&gt;
            &lt;size&gt;1 1 1&lt;/size&gt;
          &lt;/box&gt;
        &lt;/geometry&gt;
      &lt;/collision&gt;
      &lt;!-- 시각적 속성 정의 --&gt;
      &lt;visual name='visual'&gt;
        &lt;geometry&gt;
          &lt;box&gt;
            &lt;size&gt;1 1 1&lt;/size&gt;
          &lt;/box&gt;
        &lt;/geometry&gt;
      &lt;/visual&gt;
    &lt;/link&gt;
    &lt;!-- 조인트 정의 --&gt;
    &lt;joint name='joint_1' type='revolute'&gt;
      &lt;parent&gt;base_link&lt;/parent&gt;
      &lt;child&gt;link_1&lt;/child&gt;
      &lt;axis&gt;
        &lt;xyz&gt;0 0 1&lt;/xyz&gt;
        &lt;limit&gt;
          &lt;lower&gt;-1.57&lt;/lower&gt;
          &lt;upper&gt;1.57&lt;/upper&gt;
        &lt;/limit&gt;
      &lt;/axis&gt;
    &lt;/joint&gt;
  &lt;/model&gt;
&lt;/sdf&gt;
</code></pre>
<p>위 예제는 기본적인 SDF 파일의 구조로, 로봇 모델의 링크, 관성(inertia), 충돌, 시각적 속성(visual), 조인트 등을 정의하고 있다.</p>
<h3 id="_1">링크의 관성 및 질량 설정</h3>
<p>로봇의 움직임 시뮬레이션에서 중요한 요소 중 하나는 각 링크의 관성과 질량이다. SDF 파일에서 이를 정의하기 위해 <code>&lt;inertial&gt;</code> 태그를 사용한다. 관성 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{I}</span><script type="math/tex">\mathbf{I}</script></span>는 다음과 같은 3x3 행렬로 나타낼 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{I} = \begin{bmatrix} I_{xx} &amp; I_{xy} &amp; I_{xz} \\ I_{yx} &amp; I_{yy} &amp; I_{yz} \\ I_{zx} &amp; I_{zy} &amp; I_{zz} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{I} = \begin{bmatrix} I_{xx} & I_{xy} & I_{xz} \\ I_{yx} & I_{yy} & I_{yz} \\ I_{zx} & I_{zy} & I_{zz} \end{bmatrix}
</script>
</div>
<p>SDF 파일에서 각 성분은 다음과 같이 설정할 수 있다.</p>
<pre><code class="language-xml">&lt;inertial&gt;
  &lt;mass&gt;1.0&lt;/mass&gt;
  &lt;inertia&gt;
    &lt;ixx&gt;0.1&lt;/ixx&gt;
    &lt;iyy&gt;0.1&lt;/iyy&gt;
    &lt;izz&gt;0.1&lt;/izz&gt;
  &lt;/inertia&gt;
&lt;/inertial&gt;
</code></pre>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">I_{xx}, I_{yy}, I_{zz}</span><script type="math/tex">I_{xx}, I_{yy}, I_{zz}</script></span>는 각 링크의 주요 관성 모멘트이며, 링크가 회전할 때 관성의 영향을 계산하는 데 사용된다.</p>
<h3 id="_2">링크의 충돌 및 시각적 요소 설정</h3>
<p>링크의 충돌 속성은 시뮬레이션에서 물체 간의 상호작용을 정의하는데 사용된다. 이는 주로 충돌 시 발생하는 힘과 물체의 반응을 시뮬레이션하는데 중요한 역할을 한다. 시각적 요소는 실제로 화면에 보여질 때의 로봇의 외관을 정의한다.</p>
<p>충돌 및 시각적 요소는 각각 <code>&lt;collision&gt;</code>과 <code>&lt;visual&gt;</code> 태그로 정의된다. 예를 들어, 링크의 충돌 영역을 정의할 때는 다음과 같이 정의할 수 있다.</p>
<pre><code class="language-xml">&lt;collision name='collision'&gt;
  &lt;geometry&gt;
    &lt;box&gt;
      &lt;size&gt;1 1 1&lt;/size&gt;
    &lt;/box&gt;
  &lt;/geometry&gt;
&lt;/collision&gt;
</code></pre>
<p>이와 유사하게 시각적 요소도 동일한 구조를 따른다.</p>
<pre><code class="language-xml">&lt;visual name='visual'&gt;
  &lt;geometry&gt;
    &lt;box&gt;
      &lt;size&gt;1 1 1&lt;/size&gt;
    &lt;/box&gt;
  &lt;/geometry&gt;
&lt;/visual&gt;
</code></pre>
<p>이 예제에서는 큐브(box) 형태의 링크를 정의했으며, 각 면의 크기는 1x1x1로 설정되어 있다.</p>
<h2 id="_3">조인트 설정</h2>
<p>로봇의 움직임을 정의하는 중요한 요소 중 하나는 각 링크 간의 관계를 설정하는 <strong>조인트(joint)</strong>이다. SDF 파일에서 조인트는 두 링크 사이의 연결을 정의하며, 회전 또는 직선 운동 등의 움직임을 가능하게 한다. 조인트는 다양한 유형이 있으며, 여기서는 <strong>회전 조인트(revolute joint)</strong>를 예로 들어 설명한다.</p>
<h3 id="_4">회전 조인트 정의</h3>
<p>회전 조인트는 두 링크 사이에서 특정 축을 기준으로 회전하는 움직임을 허용한다. SDF 파일에서 회전 조인트를 설정할 때는 <code>type='revolute'</code>로 정의하며, 회전 축과 회전 범위를 설정할 수 있다. 예제는 다음과 같다.</p>
<pre><code class="language-xml">&lt;joint name='joint_1' type='revolute'&gt;
  &lt;parent&gt;base_link&lt;/parent&gt;
  &lt;child&gt;link_1&lt;/child&gt;
  &lt;axis&gt;
    &lt;xyz&gt;0 0 1&lt;/xyz&gt;
    &lt;limit&gt;
      &lt;lower&gt;-1.57&lt;/lower&gt;
      &lt;upper&gt;1.57&lt;/upper&gt;
    &lt;/limit&gt;
  &lt;/axis&gt;
&lt;/joint&gt;
</code></pre>
<p>이 조인트는 <code>base_link</code>와 <code>link_1</code> 사이에서 회전하는 조인트를 정의한다. 회전 축은 <code>xyz</code>로 정의되며, 여기서는 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>축을 기준으로 회전하게 설정되어 있다.</p>
<h3 id="_5">회전 축과 범위</h3>
<p>조인트의 회전 축은 3차원 벡터로 정의되며, 위 예제에서는 <span class="arithmatex"><span class="MathJax_Preview">(0, 0, 1)</span><script type="math/tex">(0, 0, 1)</script></span>로 설정되어 있으므로 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>축을 기준으로 회전한다. 조인트가 회전할 수 있는 범위는 각도 제한으로 설정할 수 있으며, 이 값은 라디안(radians)으로 입력된다.</p>
<ul>
<li><strong>하한(최소 회전 각도)</strong>: <span class="arithmatex"><span class="MathJax_Preview">-1.57</span><script type="math/tex">-1.57</script></span> 라디안은 약 <span class="arithmatex"><span class="MathJax_Preview">-90^\circ</span><script type="math/tex">-90^\circ</script></span>에 해당한다.</li>
<li><strong>상한(최대 회전 각도)</strong>: <span class="arithmatex"><span class="MathJax_Preview">1.57</span><script type="math/tex">1.57</script></span> 라디안은 약 <span class="arithmatex"><span class="MathJax_Preview">90^\circ</span><script type="math/tex">90^\circ</script></span>에 해당한다.</li>
</ul>
<p>따라서, 이 조인트는 <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>축을 기준으로 <span class="arithmatex"><span class="MathJax_Preview">-90^\circ</span><script type="math/tex">-90^\circ</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">90^\circ</span><script type="math/tex">90^\circ</script></span>까지 회전할 수 있다.</p>
<h2 id="unity-sdf">Unity에서 SDF 파일 불러오기</h2>
<p>Unity는 기본적으로 SDF 파일을 직접 불러오는 기능을 제공하지 않으므로, 이를 위해 추가적인 변환 또는 플러그인이 필요하다. SDF 파일을 Unity에서 로봇 시뮬레이션으로 변환하는 과정은 다음과 같다.</p>
<ol>
<li><strong>SDF 파일 변환 도구 사용</strong>: SDF 파일을 URDF로 변환하거나, Unity에서 사용할 수 있는 포맷으로 변환해야 한다. 이를 위해 SDF를 URDF로 변환하는 도구 또는 플러그인을 사용할 수 있다.</li>
<li><strong>Unity 로봇 플러그인 설치</strong>: Unity에서 로봇 시뮬레이션을 위한 플러그인을 설치해야 한다. 이를 통해 변환된 URDF 또는 SDF 파일을 Unity 환경에 통합할 수 있다.</li>
<li><strong>SDF 파일 로딩 및 설정</strong>: 변환된 파일을 Unity에 불러온 후, 물리 엔진과 연동하여 로봇의 시뮬레이션을 설정한다. 로봇의 조인트, 링크, 센서 등이 Unity 물리 엔진과 상호작용하도록 설정하는 것이 중요하다.</li>
</ol>
<h3 id="sdf_1">SDF 파일 변환 코드 예제</h3>
<p>SDF 파일을 Unity에서 사용할 수 있는 URDF 포맷으로 변환하는 Python 스크립트 예제는 다음과 같다.</p>
<pre><code class="language-python">import os
import subprocess

def convert_sdf_to_urdf(sdf_file, urdf_file):
    command = f&quot;sdf2urdf {sdf_file} -o {urdf_file}&quot;
    subprocess.run(command, shell=True, check=True)

if __name__ == &quot;__main__&quot;:
    sdf_file = &quot;robot_model.sdf&quot;
    urdf_file = &quot;robot_model.urdf&quot;
    convert_sdf_to_urdf(sdf_file, urdf_file)
</code></pre>
<p>이 스크립트는 SDF 파일을 URDF로 변환하여 Unity에서 사용할 수 있게 한다.</p>
<h2 id="unity-urdf">Unity에서 URDF로 변환된 로봇 모델 사용</h2>
<p>SDF 파일을 URDF로 변환한 후, Unity에서 이를 로딩하고 물리 기반 시뮬레이션을 설정하는 과정은 다음과 같다.</p>
<h3 id="unity-urdf-import">Unity에서 URDF Import</h3>
<ol>
<li>
<p><strong>Unity 프로젝트 설정</strong>: 먼저 Unity 프로젝트를 새로 생성하거나 기존 프로젝트에 URDF Import 플러그인을 설치한다. Unity Asset Store에서 ROS와의 통합을 위한 ROS#이나 Robot SDK와 같은 플러그인을 사용할 수 있다. 이러한 플러그인은 URDF 형식의 파일을 Unity로 불러오는 기능을 제공한다.</p>
</li>
<li>
<p><strong>URDF 파일 로딩</strong>: 변환된 URDF 파일을 Unity에 임포트한다. 이 과정에서 로봇의 링크와 조인트가 자동으로 인식되어 Unity의 물리 엔진과 상호작용할 수 있다.</p>
</li>
<li>
<p><strong>물리 설정 조정</strong>: Unity에서 URDF 파일이 임포트된 후, 로봇 모델의 물리 설정을 조정한다. 링크 간의 충돌 설정, 관성 설정, 조인트의 회전 및 이동 범위 설정 등을 Unity 내에서 조정할 수 있다.</p>
</li>
</ol>
<h3 id="urdf">URDF로 로봇 모델 불러오기 예제</h3>
<p>다음은 Unity에서 URDF 파일을 불러오는 C# 코드의 예제이다. 이 코드는 URDF Import 플러그인을 사용하여 로봇 모델을 로드하고, 로봇의 움직임을 시뮬레이션한다.</p>
<pre><code class="language-csharp">using UnityEngine;
using RosSharp.Urdf;

public class RobotLoader : MonoBehaviour
{
    public string urdfFilePath;

    void Start()
    {
        LoadURDF();
    }

    void LoadURDF()
    {
        GameObject robot = UrdfRobotExtensions.Load(urdfFilePath);
        if (robot != null)
        {
            Debug.Log(&quot;URDF 파일 로딩 성공!&quot;);
            robot.transform.position = Vector3.zero;
        }
        else
        {
            Debug.LogError(&quot;URDF 파일 로딩 실패!&quot;);
        }
    }
}
</code></pre>
<p>위 코드는 URDF 파일을 로드하고, 로봇 모델을 Unity의 환경에서 초기화한다. URDF 파일 경로를 입력하면 로봇이 Unity 환경에 생성되며, 물리 엔진과 상호작용하게 된다.</p>
<h2 id="unity">Unity에서 로봇의 움직임 제어</h2>
<p>로봇을 Unity 환경에 불러온 후, 로봇의 움직임을 제어할 수 있다. 로봇의 조인트(joint)을 제어하기 위해서는 Unity의 물리 엔진을 활용하여 직접적인 힘(force) 또는 토크(torque)를 적용할 수 있다.</p>
<h3 id="c">C# 코드로 로봇 조인트 제어</h3>
<p>Unity에서 로봇의 조인트를 제어하려면 <code>HingeJoint</code> 또는 <code>ArticulationBody</code>를 사용하여 회전 조인트에 토크를 적용할 수 있다. 예를 들어, 로봇의 팔을 회전시키는 예제는 다음과 같다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class RobotArmController : MonoBehaviour
{
    public HingeJoint joint;
    public float torque = 10f;

    void Update()
    {
        JointMotor motor = joint.motor;
        motor.force = torque;
        motor.targetVelocity = 50;
        joint.motor = motor;
    }
}
</code></pre>
<p>이 코드에서는 <code>HingeJoint</code>를 사용하여 특정 조인트에 회전 운동을 적용하고, 일정한 힘을 가해 로봇 팔이 회전하도록 설정한다.</p>
<h2 id="_6">센서 시뮬레이션 및 데이터 처리</h2>
<p>로봇 시뮬레이션에서 중요한 요소 중 하나는 센서 데이터를 생성하고 처리하는 것이다. Unity에서는 다양한 센서(예: 카메라, IMU, 라이다(LiDAR))를 시뮬레이션할 수 있으며, 이를 통해 로봇의 주변 환경을 감지하고 제어 알고리즘에 반영할 수 있다.</p>
<h3 id="unity-imu">Unity에서 IMU 센서 시뮬레이션</h3>
<p>IMU(Inertial Measurement Unit)는 가속도, 각속도, 그리고 때로는 자기장을 측정하는 센서이다. Unity에서는 물리 엔진을 사용하여 IMU 데이터를 생성할 수 있다. IMU 시뮬레이션을 위해서는 Unity의 물리 엔진에서 가속도와 각속도를 계산하고, 센서 노이즈를 추가하여 보다 현실적인 데이터를 생성한다.</p>
<p>IMU 센서 데이터를 생성하는 C# 코드 예제는 다음과 같다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class ImuSensor : MonoBehaviour
{
    public Vector3 acceleration;
    public Vector3 angularVelocity;
    public float noiseFactor = 0.02f;

    void FixedUpdate()
    {
        // 가속도 및 각속도 계산
        acceleration = transform.InverseTransformDirection(GetComponent&lt;Rigidbody&gt;().velocity) / Time.fixedDeltaTime;
        angularVelocity = GetComponent&lt;Rigidbody&gt;().angularVelocity;

        // 노이즈 추가
        acceleration += Random.insideUnitSphere * noiseFactor;
        angularVelocity += Random.insideUnitSphere * noiseFactor;

        Debug.Log(&quot;가속도: &quot; + acceleration + &quot; / 각속도: &quot; + angularVelocity);
    }
}
</code></pre>
<p>이 코드는 Unity의 <code>Rigidbody</code> 컴포넌트를 사용하여 로봇의 가속도와 각속도를 계산하고, IMU 센서 데이터를 시뮬레이션한다. <code>Random.insideUnitSphere</code>를 사용하여 센서 노이즈를 추가하고, 현실적인 IMU 데이터를 출력한다.</p>
<h3 id="lidar">LiDAR 시뮬레이션</h3>
<p>LiDAR(Light Detection and Ranging) 센서는 레이저를 사용하여 주변 환경의 깊이 정보를 측정한다. Unity에서는 레이캐스트(Raycast) 기능을 사용하여 LiDAR 데이터를 시뮬레이션할 수 있다. Raycast는 가상의 레이저를 특정 방향으로 발사하여 물체와의 충돌 지점을 감지한다.</p>
<p>LiDAR 시뮬레이션을 위한 C# 코드 예제는 다음과 같다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class LidarSensor : MonoBehaviour
{
    public float maxDistance = 10f;
    public int rayCount = 360;
    public float noiseFactor = 0.01f;

    void FixedUpdate()
    {
        for (int i = 0; i &lt; rayCount; i++)
        {
            float angle = (360f / rayCount) * i;
            Vector3 direction = Quaternion.Euler(0, angle, 0) * transform.forward;
            RaycastHit hit;

            if (Physics.Raycast(transform.position, direction, out hit, maxDistance))
            {
                float distance = hit.distance + Random.Range(-noiseFactor, noiseFactor);
                Debug.Log(&quot;Ray &quot; + i + &quot;: Distance = &quot; + distance);
            }
        }
    }
}
</code></pre>
<p>이 코드는 360개의 레이캐스트를 발사하여 주변 물체의 거리 정보를 측정한다. 각 레이캐스트는 로봇의 주변 환경에서 충돌 지점을 감지하며, 센서 노이즈를 추가하여 현실적인 LiDAR 데이터를 시뮬레이션한다.</p>
<h3 id="_7">센서 데이터 처리</h3>
<p>센서 데이터를 시뮬레이션한 후, 해당 데이터를 로봇의 제어 알고리즘에 반영하는 과정이 필요하다. Unity에서 생성된 IMU, LiDAR 등의 데이터를 사용하여 로봇의 경로 계획, 충돌 회피, 또는 환경 인식 등의 알고리즘을 구현할 수 있다. 이를 위해 센서 데이터를 실시간으로 처리하고, Unity의 물리 엔진과 상호작용하여 로봇의 동작을 제어한다.</p>
<h3 id="_8">센서 데이터를 제어 알고리즘에 반영하는 예제</h3>
<p>다음은 센서 데이터를 활용하여 로봇의 간단한 장애물 회피 알고리즘을 구현하는 예제이다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class ObstacleAvoidance : MonoBehaviour
{
    public float speed = 5f;
    public float turnSpeed = 90f;
    public float obstacleDistanceThreshold = 1f;

    private LidarSensor lidar;

    void Start()
    {
        lidar = GetComponent&lt;LidarSensor&gt;();
    }

    void Update()
    {
        bool obstacleDetected = false;

        for (int i = 0; i &lt; lidar.rayCount; i++)
        {
            float distance = lidar.GetRayDistance(i);

            if (distance &lt; obstacleDistanceThreshold)
            {
                obstacleDetected = true;
                break;
            }
        }

        if (obstacleDetected)
        {
            // 장애물이 있으면 회전
            transform.Rotate(0, turnSpeed * Time.deltaTime, 0);
        }
        else
        {
            // 장애물이 없으면 전진
            transform.Translate(Vector3.forward * speed * Time.deltaTime);
        }
    }
}
</code></pre>
<p>이 코드는 LiDAR 센서 데이터를 사용하여 로봇이 장애물을 감지하면 회전하고, 장애물이 없을 경우 전진하는 간단한 장애물 회피 알고리즘을 구현한 예제이다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_13/1301/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_13/1301/" class="btn btn-xs btn-link">
        가제보와 Unity의 차이점
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../1202/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../1202/" class="btn btn-xs btn-link">
        SDF에서 Unity로의 변환
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>