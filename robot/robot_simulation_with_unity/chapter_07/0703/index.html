<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot_simulation_with_unity/chapter_07/0703/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>ROS-Unity 통합 시뮬레이션 환경 구성 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ud544\uc694 \uc870\uac74", url: "#_top", children: [
          ]},
          {title: "ROS \uc124\uce58 \ubc0f \uc124\uc815", url: "#ros", children: [
          ]},
          {title: "Unity \uc124\uce58 \ubc0f \ucd08\uae30 \uc124\uc815", url: "#unity", children: [
          ]},
          {title: "ROS# \uc124\uce58 \ubc0f \uc124\uc815", url: "#ros_1", children: [
          ]},
          {title: "ROS\uc640 Unity \uac04\uc758 \ud1b5\uc2e0 \uc124\uc815", url: "#ros-unity", children: [
          ]},
          {title: "\uc704\uce58 \ub370\uc774\ud130 \ud37c\ube14\ub9ac\uc2dc \ub178\ub4dc (Python \uc608\uc81c)", url: "#python", children: [
              {title: "ROS-Unity \ud1b5\ud569 \uc2dc\ubbac\ub808\uc774\uc158 \ud658\uacbd \uad6c\uc131", url: "#ros-unity_1" },
          ]},
          {title: "ROS \uba54\uc2dc\uc9c0\uc5d0 \ud0c0\uc784\uc2a4\ud0ec\ud504 \ucd94\uac00 (Python \uc608\uc81c)", url: "#ros-python", children: [
              {title: "\ub370\uc774\ud130 \ubcc0\ud658 \ubc0f \uc88c\ud45c\uacc4 \uc77c\uce58", url: "#_6" },
              {title: "\ub514\ubc84\uae45 \ubc0f \ud14c\uc2a4\ud2b8", url: "#_7" },
              {title: "\uc608\uc81c \ud504\ub85c\uc81d\ud2b8 \uad6c\uc131", url: "#_8" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_08/0801/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_08/0801/" class="btn btn-xs btn-link">
        성능 최적화 기법
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0702/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0702/" class="btn btn-xs btn-link">
        ROS 메시지 구조 및 Unity에서의 사용
      </a>
    </div>
    
  </div>

    

    <p>로봇 운영 체제(ROS)와 Unity를 통합하여 시뮬레이션 환경을 구성하는 것은 복잡한 로봇 애플리케이션을 개발하고 테스트하는 데 있어 강력한 도구를 제공한다. 이 절에서는 ROS와 Unity를 통합하기 위한 환경 설정 단계, 필요한 도구 및 패키지, 그리고 기본적인 통신 설정 방법에 대해 상세히 설명한다.</p>
<h3 id="_1">필요 조건</h3>
<p>ROS와 Unity를 성공적으로 통합하기 위해서는 다음과 같은 소프트웨어와 도구가 필요하다:</p>
<ul>
<li><strong>ROS</strong>: 로봇 애플리케이션 개발을 위한 오픈 소스 프레임워크. ROS의 버전은 Unity와의 호환성을 고려하여 선택해야 한다. 일반적으로 ROS Noetic 또는 ROS2가 많이 사용된다.</li>
<li><strong>Unity</strong>: 실시간 3D 개발 플랫폼으로, 시뮬레이션 환경을 구축하는 데 사용된다. Unity의 최신 버전을 사용하는 것이 좋다.</li>
<li><strong>ROS#</strong>: ROS와 Unity 간의 통신을 가능하게 하는 오픈 소스 프로젝트. GitHub에서 ROS#를 클론하여 사용한다.</li>
<li><strong>Visual Studio</strong>: Unity와 ROS# 스크립트를 개발하고 디버깅하기 위한 통합 개발 환경(IDE).</li>
</ul>
<h3 id="ros">ROS 설치 및 설정</h3>
<p>먼저, ROS를 설치하고 기본 설정을 진행한다. 여기서는 ROS Noetic을 기준으로 설명한다.</p>
<ol>
<li>
<p><strong>ROS Noetic 설치</strong>:
    <code>bash
    sudo apt update
    sudo apt install ros-noetic-desktop-full</code></p>
</li>
<li>
<p><strong>환경 설정</strong>:
    <code>bash
    echo "source /opt/ros/noetic/setup.bash" &gt;&gt; ~/.bashrc
    source ~/.bashrc</code></p>
</li>
<li>
<p><strong>ROS 워크스페이스 생성</strong>:
    <code>bash
    mkdir -p ~/catkin_ws/src
    cd ~/catkin_ws/
    catkin_make</code></p>
</li>
<li>
<p><strong>워크스페이스 환경 설정</strong>:
    <code>bash
    echo "source ~/catkin_ws/devel/setup.bash" &gt;&gt; ~/.bashrc
    source ~/.bashrc</code></p>
</li>
</ol>
<h3 id="unity">Unity 설치 및 초기 설정</h3>
<p>Unity를 설치하고 ROS와의 통합을 위한 기본 프로젝트를 설정한다.</p>
<ol>
<li>
<p><strong>Unity 다운로드 및 설치</strong>:
    Unity Hub를 통해 Unity의 최신 버전을 다운로드하고 설치한다.</p>
</li>
<li>
<p><strong>새 Unity 프로젝트 생성</strong>:</p>
<ul>
<li>Unity Hub를 열고 "New Project"를 클릭한다.</li>
<li>"3D" 템플릿을 선택하고 프로젝트 이름을 지정한 후 "Create"를 클릭한다.</li>
</ul>
</li>
<li>
<p><strong>필수 패키지 설치</strong>:
    Unity 프로젝트 내에서 필요한 패키지를 설치한다. 예를 들어, <code>Cinemachine</code>과 <code>ProBuilder</code> 같은 패키지를 추가할 수 있다.</p>
</li>
</ol>
<h3 id="ros_1">ROS# 설치 및 설정</h3>
<p>ROS#는 ROS와 Unity 간의 통신을 가능하게 하는 브리지 역할을 한다. ROS#를 설치하고 설정하는 과정은 다음과 같다.</p>
<ol>
<li>
<p><strong>ROS# 클론</strong>:
    <code>bash
    cd ~/catkin_ws/src
    git clone https://github.com/siemens/ros-sharp.git</code></p>
</li>
<li>
<p><strong>ROS# 빌드</strong>:
    <code>bash
    cd ~/catkin_ws/
    catkin_make</code></p>
</li>
<li>
<p><strong>Unity 프로젝트에 ROS# 추가</strong>:</p>
<ul>
<li>ROS#의 Unity 패키지를 빌드한다.</li>
<li><code>ros-sharp</code> 디렉토리 내의 <code>RosSharp.sln</code> 파일을 Visual Studio로 열고 빌드한다.</li>
<li>빌드된 DLL 파일을 Unity 프로젝트의 <code>Assets</code> 폴더에 복사한다.</li>
</ul>
</li>
</ol>
<h3 id="ros-unity">ROS와 Unity 간의 통신 설정</h3>
<p>ROS와 Unity 간의 통신을 설정하기 위해서는 ROS 노드와 Unity 클라이언트 간의 연결을 구성해야 한다. 여기서는 기본적인 Publisher-Subscriber 모델을 설정하는 방법을 설명한다.</p>
<ol>
<li>
<p><strong>ROS 노드 설정</strong>:
    ROS에서 데이터를 퍼블리시할 노드를 작성한다. 예를 들어, 로봇의 위치 데이터를 퍼블리시하는 노드를 생성할 수 있다.</p>
<p>```python</p>
<h1 id="python">위치 데이터 퍼블리시 노드 (Python 예제)</h1>
<p>import rospy
from geometry_msgs.msg import Pose</p>
<p>def publisher():
    rospy.init_node('pose_publisher', anonymous=True)
    pub = rospy.Publisher('robot_pose', Pose, queue_size=10)
    rate = rospy.Rate(10) # 10Hz
    while not rospy.is_shutdown():
        pose = Pose()
        # pose 데이터 설정
        pub.publish(pose)
        rate.sleep()</p>
<p>if <strong>name</strong> == '<strong>main</strong>':
    try:
        publisher()
    except rospy.ROSInterruptException:
        pass
```</p>
</li>
<li>
<p><strong>Unity에서 ROS# 설정</strong>:
    Unity 내에서 ROS#를 사용하여 ROS 노드와 통신할 수 있도록 설정한다.</p>
<ul>
<li>Unity 프로젝트 내에서 <code>RosConnector</code> 스크립트를 추가한다.</li>
<li><code>RosConnector</code>의 <code>Ros Bridge Server Url</code>을 ROS 마스터의 IP 주소와 포트로 설정한다. 예를 들어, <code>ws://192.168.1.2:9090</code>와 같이 설정한다.</li>
<li>필요한 메시지 타입을 Unity에 정의하고, Publisher 또는 Subscriber를 설정한다.</li>
</ul>
<p>```csharp
// Unity C# 예제
using RosSharp.RosBridgeClient;
using RosSharp.RosBridgeClient.MessageTypes.Geometry;
using UnityEngine;</p>
<p>public class PoseSubscriber : MonoBehaviour
{
    private PoseSubscriberSubscriber poseSubscriber;</p>
<pre><code>void Start()
{
    poseSubscriber = new PoseSubscriberSubscriber();
    poseSubscriber.Subscribe("/robot_pose");
}

void Update()
{
    Pose pose = poseSubscriber.GetPose();
    if (pose != null)
    {
        // Unity 오브젝트의 위치 및 회전 업데이트
        transform.position = new Vector3(pose.position.x, pose.position.y, pose.position.z);
        transform.rotation = new Quaternion(pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w);
    }
}
</code></pre>
<p>}
```</p>
</li>
</ol>
<h2 id="ros-unity_1">ROS-Unity 통합 시뮬레이션 환경 구성</h2>
<p>로봇 운영 체제(ROS)와 Unity를 통합하여 시뮬레이션 환경을 구성하는 것은 복잡한 로봇 애플리케이션을 개발하고 테스트하는 데 있어 강력한 도구를 제공한다. 이 절에서는 ROS와 Unity를 통합하기 위한 환경 설정 단계, 필요한 도구 및 패키지, 그리고 기본적인 통신 설정 방법에 대해 상세히 설명한다.</p>
<h3 id="_2">필요 조건</h3>
<p>ROS와 Unity를 성공적으로 통합하기 위해서는 다음과 같은 소프트웨어와 도구가 필요하다:</p>
<ul>
<li><strong>ROS</strong>: 로봇 애플리케이션 개발을 위한 오픈 소스 프레임워크. ROS의 버전은 Unity와의 호환성을 고려하여 선택해야 한다. 일반적으로 ROS Noetic 또는 ROS2가 많이 사용된다.</li>
<li><strong>Unity</strong>: 실시간 3D 개발 플랫폼으로, 시뮬레이션 환경을 구축하는 데 사용된다. Unity의 최신 버전을 사용하는 것이 좋다.</li>
<li><strong>ROS#</strong>: ROS와 Unity 간의 통신을 가능하게 하는 오픈 소스 프로젝트. GitHub에서 ROS#를 클론하여 사용한다.</li>
<li><strong>Visual Studio</strong>: Unity와 ROS# 스크립트를 개발하고 디버깅하기 위한 통합 개발 환경(IDE).</li>
</ul>
<h3 id="ros_2">ROS 설치 및 설정</h3>
<p>먼저, ROS를 설치하고 기본 설정을 진행한다. 여기서는 ROS Noetic을 기준으로 설명한다.</p>
<ol>
<li>
<p><strong>ROS Noetic 설치</strong>:
    <code>bash
    sudo apt update
    sudo apt install ros-noetic-desktop-full</code></p>
</li>
<li>
<p><strong>환경 설정</strong>:
    <code>bash
    echo "source /opt/ros/noetic/setup.bash" &gt;&gt; ~/.bashrc
    source ~/.bashrc</code></p>
</li>
<li>
<p><strong>ROS 워크스페이스 생성</strong>:
    <code>bash
    mkdir -p ~/catkin_ws/src
    cd ~/catkin_ws/
    catkin_make</code></p>
</li>
<li>
<p><strong>워크스페이스 환경 설정</strong>:
    <code>bash
    echo "source ~/catkin_ws/devel/setup.bash" &gt;&gt; ~/.bashrc
    source ~/.bashrc</code></p>
</li>
</ol>
<h3 id="unity_1">Unity 설치 및 초기 설정</h3>
<p>Unity를 설치하고 ROS와의 통합을 위한 기본 프로젝트를 설정한다.</p>
<ol>
<li>
<p><strong>Unity 다운로드 및 설치</strong>:
    Unity Hub를 통해 Unity의 최신 버전을 다운로드하고 설치한다.</p>
</li>
<li>
<p><strong>새 Unity 프로젝트 생성</strong>:</p>
<ul>
<li>Unity Hub를 열고 "New Project"를 클릭한다.</li>
<li>"3D" 템플릿을 선택하고 프로젝트 이름을 지정한 후 "Create"를 클릭한다.</li>
</ul>
</li>
<li>
<p><strong>필수 패키지 설치</strong>:
    Unity 프로젝트 내에서 필요한 패키지를 설치한다. 예를 들어, <code>Cinemachine</code>과 <code>ProBuilder</code> 같은 패키지를 추가할 수 있다.</p>
</li>
</ol>
<h3 id="ros_3">ROS# 설치 및 설정</h3>
<p>ROS#는 ROS와 Unity 간의 통신을 가능하게 하는 브리지 역할을 한다. ROS#를 설치하고 설정하는 과정은 다음과 같다.</p>
<ol>
<li>
<p><strong>ROS# 클론</strong>:
    <code>bash
    cd ~/catkin_ws/src
    git clone https://github.com/siemens/ros-sharp.git</code></p>
</li>
<li>
<p><strong>ROS# 빌드</strong>:
    <code>bash
    cd ~/catkin_ws/
    catkin_make</code></p>
</li>
<li>
<p><strong>Unity 프로젝트에 ROS# 추가</strong>:</p>
<ul>
<li>ROS#의 Unity 패키지를 빌드한다.</li>
<li><code>ros-sharp</code> 디렉토리 내의 <code>RosSharp.sln</code> 파일을 Visual Studio로 열고 빌드한다.</li>
<li>빌드된 DLL 파일을 Unity 프로젝트의 <code>Assets</code> 폴더에 복사한다.</li>
</ul>
</li>
</ol>
<h3 id="ros-unity_2">ROS와 Unity 간의 통신 설정</h3>
<p>ROS와 Unity 간의 통신을 설정하기 위해서는 ROS 노드와 Unity 클라이언트 간의 연결을 구성해야 한다. 여기서는 기본적인 Publisher-Subscriber 모델을 설정하는 방법을 설명한다.</p>
<h4 id="ros_4">ROS 노드 설정</h4>
<p>ROS에서 데이터를 퍼블리시할 노드를 작성한다. 예를 들어, 로봇의 위치 데이터를 퍼블리시하는 노드를 생성할 수 있다.</p>
<pre><code class="language-python">import rospy
from geometry_msgs.msg import Pose

def publisher():
    rospy.init_node('pose_publisher', anonymous=True)
    pub = rospy.Publisher('robot_pose', Pose, queue_size=10)
    rate = rospy.Rate(10) # 10Hz
    while not rospy.is_shutdown():
        pose = Pose()
        # pose 데이터 설정
        pub.publish(pose)
        rate.sleep()

if __name__ == '__main__':
    try:
        publisher()
    except rospy.ROSInterruptException:
        pass
</code></pre>
<h4 id="unity-ros">Unity에서 ROS# 설정</h4>
<p>Unity 내에서 ROS#를 사용하여 ROS 노드와 통신할 수 있도록 설정한다.</p>
<ul>
<li>
<p><strong>RosConnector 설정</strong>:</p>
<ul>
<li>Unity 프로젝트 내에서 <code>RosConnector</code> 스크립트를 추가한다.</li>
<li><code>RosConnector</code>의 <code>Ros Bridge Server Url</code>을 ROS 마스터의 IP 주소와 포트로 설정한다. 예를 들어, <code>ws://192.168.1.2:9090</code>와 같이 설정한다.</li>
</ul>
</li>
<li>
<p><strong>Subscriber 설정</strong>:</p>
<ul>
<li>필요한 메시지 타입을 Unity에 정의하고, Subscriber를 설정한다.</li>
<li>예를 들어, 로봇의 위치 데이터를 수신하기 위한 Subscriber를 설정할 수 있다.</li>
</ul>
</li>
</ul>
<pre><code class="language-csharp">// Unity C# 예제
using RosSharp.RosBridgeClient;
using RosSharp.RosBridgeClient.MessageTypes.Geometry;
using UnityEngine;

public class PoseSubscriber : MonoBehaviour
{
    private PoseSubscriberSubscriber poseSubscriber;

    void Start()
    {
        poseSubscriber = new PoseSubscriberSubscriber();
        poseSubscriber.Subscribe(&quot;/robot_pose&quot;);
    }

    void Update()
    {
        Pose pose = poseSubscriber.GetPose();
        if (pose != null)
        {
            // Unity 오브젝트의 위치 및 회전 업데이트
            transform.position = new Vector3(pose.position.x, pose.position.y, pose.position.z);
            transform.rotation = new Quaternion(pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w);
        }
    }
}
</code></pre>
<h3 id="publisher-unity-ros">Publisher 설정 (Unity에서 ROS로 데이터 전송)</h3>
<p>Unity에서 ROS로 데이터를 퍼블리시하기 위해서는 Publisher를 설정해야 한다. 예를 들어, Unity에서 로봇의 제어 명령을 ROS로 전송할 수 있다.</p>
<pre><code class="language-csharp">// Unity C# 예제
using RosSharp.RosBridgeClient;
using RosSharp.RosBridgeClient.MessageTypes.Geometry;
using UnityEngine;

public class PosePublisher : MonoBehaviour
{
    private PosePublisherPublisher posePublisher;
    public float publishRate = 10f;
    private float timer;

    void Start()
    {
        posePublisher = new PosePublisherPublisher();
        posePublisher.Advertise();
    }

    void Update()
    {
        timer += Time.deltaTime;
        if (timer &gt; 1f / publishRate)
        {
            Pose pose = new Pose();
            pose.position = new Point
            {
                x = transform.position.x,
                y = transform.position.y,
                z = transform.position.z
            };
            pose.orientation = new QuaternionMsg
            {
                x = transform.rotation.x,
                y = transform.rotation.y,
                z = transform.rotation.z,
                w = transform.rotation.w
            };
            posePublisher.Publish(pose);
            timer = 0f;
        }
    }
}
</code></pre>
<h4 id="ros-publisher">ROS에서 Publisher 노드 설정</h4>
<p>Unity에서 퍼블리시한 데이터를 수신하기 위한 ROS 노드를 설정한다.</p>
<pre><code class="language-python">import rospy
from geometry_msgs.msg import Pose

def callback(data):
    rospy.loginfo(rospy.get_caller_id() + &quot; I heard pose: %s&quot;, data)

def listener():
    rospy.init_node('pose_listener', anonymous=True)
    rospy.Subscriber('unity_robot_pose', Pose, callback)
    rospy.spin()

if __name__ == '__main__':
    listener()
</code></pre>
<h3 id="_3">메시지 타입 정의</h3>
<p>ROS와 Unity 간에 주고받는 메시지의 타입을 정확히 정의해야 한다. ROS에서는 표준 메시지 타입을 사용할 수 있으며, Unity에서는 해당 메시지 타입을 정확히 매핑해야 한다.</p>
<ul>
<li>
<p><strong>ROS 메시지 타입</strong>:</p>
<ul>
<li>ROS에서는 <code>geometry_msgs/Pose</code>와 같은 표준 메시지 타입을 사용할 수 있다.</li>
<li>필요에 따라 커스텀 메시지 타입을 정의할 수도 있다.</li>
</ul>
</li>
<li>
<p><strong>Unity 메시지 타입</strong>:</p>
<ul>
<li>Unity에서는 ROS 메시지 타입을 C# 클래스로 매핑하여 사용한다.</li>
<li>ROS#는 일반적으로 ROS 메시지 타입을 자동으로 변환할 수 있도록 지원한다.</li>
</ul>
</li>
</ul>
<h3 id="_4">네트워크 설정</h3>
<p>ROS와 Unity가 동일한 네트워크에 연결되어 있어야 통신이 원활하게 이루어진다. 특히, ROS 마스터와 Unity 클라이언트가 서로를 인식할 수 있도록 IP 주소와 포트가 올바르게 설정되어야 한다.</p>
<ul>
<li>
<p><strong>ROS 마스터 IP 설정</strong>:
    <code>bash
    export ROS_MASTER_URI=http://&lt;ROS_MASTER_IP&gt;:11311
    export ROS_HOSTNAME=&lt;ROS_MASTER_IP&gt;</code>
    <code>&lt;ROS_MASTER_IP&gt;</code>는 ROS 마스터가 실행 중인 머신의 IP 주소로 대체해야 한다.</p>
</li>
<li>
<p><strong>Unity 클라이언트 설정</strong>:
    <code>RosConnector</code>의 <code>Ros Bridge Server Url</code>을 ROS 마스터의 IP 주소와 포트(<code>ws://&lt;ROS_MASTER_IP&gt;:9090</code>)로 설정한다.</p>
</li>
</ul>
<h3 id="_5">동기화 및 타이밍</h3>
<p>ROS와 Unity 간의 데이터 교환 시 타이밍과 동기화가 중요하다. 특히, 실시간 애플리케이션에서는 데이터의 지연이나 손실이 성능에 영향을 줄 수 있다.</p>
<ul>
<li>
<p><strong>데이터 주기 설정</strong>:
    ROS와 Unity에서 데이터를 퍼블리시하고 서브스크라이브하는 주기를 일치시켜야 한다. 예를 들어, ROS 노드와 Unity 스크립트 모두 10Hz로 데이터를 주고받도록 설정할 수 있다.</p>
</li>
<li>
<p><strong>타임스탬프 관리</strong>:
    메시지에 타임스탬프를 포함시켜 데이터의 일관성을 유지할 수 있다. ROS 메시지 타입에는 일반적으로 <code>header</code> 필드가 포함되어 있어 타임스탬프를 추가할 수 있다.</p>
<p>```python</p>
<h1 id="ros-python">ROS 메시지에 타임스탬프 추가 (Python 예제)</h1>
<p>import rospy
from geometry_msgs.msg import Pose</p>
<p>def publisher():
    rospy.init_node('pose_publisher', anonymous=True)
    pub = rospy.Publisher('robot_pose', Pose, queue_size=10)
    rate = rospy.Rate(10) # 10Hz
    while not rospy.is_shutdown():
        pose = Pose()
        pose.header.stamp = rospy.Time.now()
        # pose 데이터 설정
        pub.publish(pose)
        rate.sleep()
```</p>
<p>```csharp
// Unity 메시지에 타임스탬프 추가 (C# 예제)
using RosSharp.RosBridgeClient;
using RosSharp.RosBridgeClient.MessageTypes.Geometry;
using RosSharp.RosBridgeClient.MessageTypes.Std;
using UnityEngine;</p>
<p>public class PosePublisher : MonoBehaviour
{
    private PosePublisherPublisher posePublisher;
    public float publishRate = 10f;
    private float timer;</p>
<pre><code>void Start()
{
    posePublisher = new PosePublisherPublisher();
    posePublisher.Advertise();
}

void Update()
{
    timer += Time.deltaTime;
    if (timer &gt; 1f / publishRate)
    {
        Pose pose = new Pose();
        pose.header = new HeaderMsg
        {
            stamp = new TimeMsg(Time.time),
            frame_id = "unity_frame"
        };
        pose.position = new Point
        {
            x = transform.position.x,
            y = transform.position.y,
            z = transform.position.z
        };
        pose.orientation = new QuaternionMsg
        {
            x = transform.rotation.x,
            y = transform.rotation.y,
            z = transform.rotation.z,
            w = transform.rotation.w
        };
        posePublisher.Publish(pose);
        timer = 0f;
    }
}
</code></pre>
<p>}
```</p>
</li>
</ul>
<h3 id="_6">데이터 변환 및 좌표계 일치</h3>
<p>ROS와 Unity는 기본적으로 다른 좌표계를 사용한다. ROS는 오른손 좌표계를 사용하며, Unity는 왼손 좌표계를 사용한다. 따라서 데이터 변환이 필요할 수 있다.</p>
<ul>
<li>
<p><strong>좌표 변환</strong>:</p>
<ul>
<li>위치 데이터: ROS의 <span class="arithmatex"><span class="MathJax_Preview">(x, y, z)</span><script type="math/tex">(x, y, z)</script></span> 좌표계를 Unity의 <span class="arithmatex"><span class="MathJax_Preview">(x, y, z)</span><script type="math/tex">(x, y, z)</script></span> 좌표계로 변환할 때, 축의 방향을 조정해야 할 수 있다.</li>
<li>회전 데이터: 쿼터니언을 변환할 때, 축의 방향과 회전 순서를 맞춰야 한다.</li>
</ul>
<p>예를 들어, ROS의 <span class="arithmatex"><span class="MathJax_Preview">(x, y, z)</span><script type="math/tex">(x, y, z)</script></span>를 Unity의 <span class="arithmatex"><span class="MathJax_Preview">(x, z, y)</span><script type="math/tex">(x, z, y)</script></span>로 변환하는 경우가 있다.</p>
<p>```csharp
// Unity에서 ROS 좌표계를 Unity 좌표계로 변환 (C# 예제)
Vector3 ConvertRosToUnityPosition(Vector3 rosPosition)
{
    return new Vector3(rosPosition.x, rosPosition.z, rosPosition.y);
}</p>
<p>Quaternion ConvertRosToUnityRotation(Quaternion rosRotation)
{
    return new Quaternion(rosRotation.x, rosRotation.z, rosRotation.y, rosRotation.w);
}
```</p>
</li>
</ul>
<h3 id="_7">디버깅 및 테스트</h3>
<p>ROS와 Unity 간의 통신이 정상적으로 이루어지는지 확인하기 위해서는 디버깅과 테스트가 필요하다.</p>
<ul>
<li>
<p><strong>ROS 노드 디버깅</strong>:</p>
<ul>
<li><code>rostopic list</code>: 활성화된 모든 토픽을 확인한다.</li>
<li><code>rostopic echo /robot_pose</code>: 특정 토픽의 메시지를 실시간으로 확인한다.</li>
<li><code>rosnode list</code>: 활성화된 모든 노드를 확인한다.</li>
</ul>
</li>
<li>
<p><strong>Unity 디버깅</strong>:</p>
<ul>
<li>Unity 콘솔을 통해 오류 메시지와 로그를 확인한다.</li>
<li><code>RosConnector</code>의 연결 상태를 확인한다.</li>
<li>메시지 수신 및 발신이 정상적으로 이루어지는지 스크립트를 통해 확인한다.</li>
</ul>
</li>
<li>
<p><strong>통신 테스트</strong>:</p>
<ul>
<li>ROS 노드가 퍼블리시하는 메시지가 Unity에서 제대로 수신되는지 확인한다.</li>
<li>Unity에서 퍼블리시하는 메시지가 ROS에서 제대로 수신되는지 확인한다.</li>
<li>데이터의 일관성과 정확성을 검증한다.</li>
</ul>
</li>
</ul>
<h3 id="_8">예제 프로젝트 구성</h3>
<p>통신 설정을 마친 후, ROS와 Unity가 통신하는 간단한 예제 프로젝트를 구성하여 전체 프로세스를 테스트할 수 있다.</p>
<ol>
<li>
<p><strong>ROS 측</strong>:</p>
<ul>
<li>위치 데이터를 퍼블리시하는 노드 (<code>pose_publisher.py</code>).</li>
<li>Unity에서 퍼블리시하는 데이터를 수신하는 노드 (<code>pose_listener.py</code>).</li>
</ul>
</li>
<li>
<p><strong>Unity 측</strong>:</p>
<ul>
<li><code>RosConnector</code> 설정.</li>
<li><code>PoseSubscriber</code> 스크립트를 적용한 게임 오브젝트.</li>
<li><code>PosePublisher</code> 스크립트를 적용한 게임 오브젝트.</li>
</ul>
</li>
<li>
<p><strong>테스트 시나리오</strong>:</p>
<ul>
<li>ROS 노드가 주기적으로 위치 데이터를 퍼블리시하면 Unity 내의 게임 오브젝트가 해당 위치로 이동하는지 확인한다.</li>
<li>Unity에서 게임 오브젝트의 위치를 변경하면 ROS 노드가 해당 데이터를 수신하는지 확인한다.</li>
</ul>
</li>
<li>
<p><strong>검증</strong>:</p>
<ul>
<li>Unity와 ROS 간의 데이터 교환이 원활하게 이루어지는지 확인한다.</li>
<li>좌표 변환이 올바르게 적용되었는지 검증한다.</li>
<li>실시간으로 데이터가 업데이트되는지 확인한다.</li>
</ul>
</li>
</ol>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_08/0801/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_08/0801/" class="btn btn-xs btn-link">
        성능 최적화 기법
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0702/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0702/" class="btn btn-xs btn-link">
        ROS 메시지 구조 및 Unity에서의 사용
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>