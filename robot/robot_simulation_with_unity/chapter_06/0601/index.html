<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot_simulation_with_unity/chapter_06/0601/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Unity에서 C#을 이용한 로봇 제어 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "C# \uc2a4\ud06c\ub9bd\ud2b8 \uae30\ubcf8 \uad6c\uc870", url: "#_top", children: [
          ]},
          {title: "\ub85c\ubd07 \uc774\ub3d9 \uc81c\uc5b4", url: "#_1", children: [
          ]},
          {title: "\ubb3c\ub9ac \uae30\ubc18 \uc774\ub3d9 \uc81c\uc5b4", url: "#_2", children: [
          ]},
          {title: "\uc13c\uc11c \ub370\uc774\ud130 \ud65c\uc6a9", url: "#_3", children: [
          ]},
          {title: "\uacbd\ub85c \uacc4\ud68d \ubc0f \uc774\ub3d9 \uc81c\uc5b4", url: "#_4", children: [
          ]},
          {title: "\uc2e4\uc2dc\uac04 \ub85c\ubd07 \uc81c\uc5b4", url: "#_5", children: [
          ]},
          {title: "PID \uc81c\uc5b4\ub97c \uc774\uc6a9\ud55c \uc815\ubc00 \ub85c\ubd07 \uc81c\uc5b4", url: "#pid", children: [
              {title: "PID \uc81c\uc5b4\uae30\uc758 \uad6c\uc131 \uc694\uc18c", url: "#pid_1" },
              {title: "C#\uc744 \uc774\uc6a9\ud55c PID \ucee8\ud2b8\ub864\ub7ec \uad6c\ud604", url: "#c-pid" },
              {title: "\ub85c\ubd07 \uc774\ub3d9\uc5d0 PID \uc81c\uc5b4\uae30 \uc801\uc6a9", url: "#pid_2" },
              {title: "PID \uac8c\uc778 \ud29c\ub2dd", url: "#pid_3" },
          ]},
          {title: "\uc0c1\ud0dc \uba38\uc2e0\uc744 \uc774\uc6a9\ud55c \ub85c\ubd07 \ud589\ub3d9 \uc81c\uc5b4", url: "#_6", children: [
              {title: "\uc0c1\ud0dc \uba38\uc2e0\uc758 \uae30\ubcf8 \uac1c\ub150", url: "#_7" },
              {title: "C#\uc744 \uc774\uc6a9\ud55c \uc0c1\ud0dc \uba38\uc2e0 \uad6c\ud604", url: "#c_1" },
              {title: "\uc0c1\ud0dc \uc804\ud658 \uc870\uac74 \uc124\uc815", url: "#_8" },
              {title: "\uc0c1\ud0dc \uba38\uc2e0\uc758 \uc7a5\uc810", url: "#_9" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0602/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0602/" class="btn btn-xs btn-link">
        경로 계획 및 이동 제어
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_05/0503/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_05/0503/" class="btn btn-xs btn-link">
        센서 노이즈 시뮬레이션
      </a>
    </div>
    
  </div>

    

    <p>로봇 시뮬레이션에서 로봇의 동작을 제어하기 위해서는 프로그래밍 언어인 C#을 활용한 스크립팅이 필수적이다. Unity는 C#을 주요 스크립팅 언어로 사용하며, 이를 통해 로봇의 다양한 동작과 상호작용을 구현할 수 있다. 이 절에서는 Unity에서 C#을 이용하여 로봇을 제어하는 기본적인 방법부터 고급 제어 기법까지 다룬다.</p>
<h3 id="c">C# 스크립트 기본 구조</h3>
<p>Unity에서 로봇을 제어하기 위해서는 C# 스크립트를 작성하고 이를 로봇 모델에 부착해야 한다. C# 스크립트는 주로 <code>MonoBehaviour</code> 클래스를 상속받아 작성되며, 다음과 같은 기본 구조를 갖는다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class RobotController : MonoBehaviour
{
    // 로봇의 속성 변수 선언
    public float speed = 5.0f;

    // 초기화 메서드
    void Start()
    {
        // 초기 설정
    }

    // 프레임마다 호출되는 업데이트 메서드
    void Update()
    {
        // 로봇 제어 로직
    }

    // 물리 계산과 관련된 FixedUpdate 메서드
    void FixedUpdate()
    {
        // 물리 기반 로봇 제어
    }
}
</code></pre>
<ul>
<li><strong>변수 선언</strong>: 로봇의 속도, 방향 등 제어에 필요한 변수들을 선언한다.</li>
<li><strong>Start() 메서드</strong>: 스크립트가 활성화될 때 한 번 호출되며, 초기 설정을 수행한다.</li>
<li><strong>Update() 메서드</strong>: 매 프레임마다 호출되며, 사용자 입력이나 비물리적 동작을 처리한다.</li>
<li><strong>FixedUpdate() 메서드</strong>: 일정한 시간 간격으로 호출되며, 물리 계산과 관련된 로직을 처리한다.</li>
</ul>
<h3 id="_1">로봇 이동 제어</h3>
<p>로봇의 이동을 제어하기 위해서는 주로 <code>Update()</code> 또는 <code>FixedUpdate()</code> 메서드에서 로봇의 위치와 회전을 변경한다. 예를 들어, 키보드 입력을 받아 로봇을 전진, 후진, 좌우로 이동시키는 기본적인 코드는 다음과 같다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class RobotController : MonoBehaviour
{
    public float moveSpeed = 5.0f;
    public float turnSpeed = 100.0f;

    void Update()
    {
        // 전진 및 후진
        float move = Input.GetAxis(&quot;Vertical&quot;) * moveSpeed * Time.deltaTime;
        transform.Translate(0, 0, move);

        // 좌우 회전
        float turn = Input.GetAxis(&quot;Horizontal&quot;) * turnSpeed * Time.deltaTime;
        transform.Rotate(0, turn, 0);
    }
}
</code></pre>
<ul>
<li><strong>Input.GetAxis("Vertical")</strong>: 키보드의 상하 화살표 또는 W/S 키 입력을 받아 전진과 후진을 제어한다.</li>
<li><strong>Input.GetAxis("Horizontal")</strong>: 키보드의 좌우 화살표 또는 A/D 키 입력을 받아 좌우 회전을 제어한다.</li>
<li><strong>transform.Translate()</strong>: 로봇의 위치를 이동시킨다.</li>
<li><strong>transform.Rotate()</strong>: 로봇의 회전을 변경한다.</li>
</ul>
<h3 id="_2">물리 기반 이동 제어</h3>
<p>물리 엔진을 활용하여 로봇을 더욱 현실감 있게 제어하려면 <code>Rigidbody</code> 컴포넌트를 사용하여 힘과 토크를 적용해야 한다. 이를 위해서는 <code>FixedUpdate()</code> 메서드에서 물리 기반의 제어 로직을 작성한다.</p>
<pre><code class="language-csharp">using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class RobotController : MonoBehaviour
{
    public float force = 500f;
    public float torque = 200f;
    private Rigidbody rb;

    void Start()
    {
        rb = GetComponent&lt;Rigidbody&gt;();
    }

    void FixedUpdate()
    {
        // 전진 및 후진
        float move = Input.GetAxis(&quot;Vertical&quot;);
        rb.AddForce(transform.forward * move * force);

        // 좌우 회전
        float turn = Input.GetAxis(&quot;Horizontal&quot;);
        rb.AddTorque(transform.up * turn * torque);
    }
}
</code></pre>
<ul>
<li><strong>Rigidbody 컴포넌트</strong>: 로봇에 물리적 속성을 부여하기 위해 Rigidbody 컴포넌트를 추가한다.</li>
<li><strong>AddForce()</strong>: 로봇에 힘을 적용하여 이동을 제어한다.</li>
<li><strong>AddTorque()</strong>: 로봇에 회전력을 적용하여 회전을 제어한다.</li>
</ul>
<h3 id="_3">센서 데이터 활용</h3>
<p>로봇 제어의 고도화를 위해서는 센서 데이터를 활용하는 것이 중요하다. 예를 들어, 거리 센서나 카메라 데이터를 기반으로 장애물을 피하거나 특정 목표를 향해 이동하도록 제어할 수 있다. 다음은 간단한 거리 센서를 활용한 장애물 회피 로직의 예이다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class RobotController : MonoBehaviour
{
    public float moveSpeed = 5.0f;
    public float turnSpeed = 100.0f;
    public float obstacleDistance = 2.0f;

    void Update()
    {
        // 레이캐스트를 이용한 장애물 감지
        RaycastHit hit;
        if (Physics.Raycast(transform.position, transform.forward, out hit, obstacleDistance))
        {
            // 장애물이 감지되면 회전
            float turn = turnSpeed * Time.deltaTime;
            transform.Rotate(0, turn, 0);
        }
        else
        {
            // 장애물이 없으면 전진
            float move = moveSpeed * Time.deltaTime;
            transform.Translate(0, 0, move);
        }
    }
}
</code></pre>
<ul>
<li><strong>Physics.Raycast()</strong>: 로봇의 앞쪽으로 레이캐스트를 발사하여 장애물을 감지한다.</li>
<li><strong>RaycastHit</strong>: 레이캐스트가 충돌한 객체에 대한 정보를 담는 구조체이다.</li>
<li><strong>장애물 회피 로직</strong>: 장애물이 감지되면 로봇을 회전시켜 회피하고, 그렇지 않으면 전진한다.</li>
</ul>
<h3 id="_4">경로 계획 및 이동 제어</h3>
<p>로봇이 특정 경로를 따라 이동하도록 하기 위해서는 경로 계획 알고리즘을 구현해야 한다. 대표적인 알고리즘으로는 A* 알고리즘, Dijkstra 알고리즘 등이 있으며, 이를 C#으로 구현하여 로봇의 이동 경로를 결정할 수 있다. 간단한 경로 계획의 예는 다음과 같다.</p>
<pre><code class="language-csharp">using UnityEngine;
using System.Collections.Generic;

public class RobotController : MonoBehaviour
{
    public List&lt;Vector3&gt; path;
    public float speed = 5.0f;
    private int currentWaypoint = 0;

    void Update()
    {
        if (currentWaypoint &lt; path.Count)
        {
            Vector3 target = path[currentWaypoint];
            Vector3 direction = target - transform.position;
            float step = speed * Time.deltaTime;

            if (direction.magnitude &lt; step)
            {
                currentWaypoint++;
            }
            else
            {
                Vector3 move = direction.normalized * step;
                transform.Translate(move, Space.World);
            }
        }
    }
}
</code></pre>
<ul>
<li><strong>path</strong>: 로봇이 따라갈 경로의 웨이포인트 목록이다.</li>
<li><strong>currentWaypoint</strong>: 현재 목표로 하는 웨이포인트의 인덱스이다.</li>
<li><strong>경로 따라 이동</strong>: 로봇이 현재 웨이포인트로 이동하고, 도달하면 다음 웨이포인트로 넘어간다.</li>
</ul>
<h3 id="_5">실시간 로봇 제어</h3>
<p>실시간으로 로봇을 제어하기 위해서는 사용자 입력이나 외부 이벤트에 따라 로봇의 동작을 즉시 변경할 수 있어야 한다. 이를 위해 이벤트 리스너나 콜백 함수를 활용하여 실시간 제어 로직을 구현할 수 있다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class RobotController : MonoBehaviour
{
    public float speed = 5.0f;
    private bool isMoving = false;

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            isMoving = !isMoving;
        }

        if (isMoving)
        {
            transform.Translate(Vector3.forward * speed * Time.deltaTime);
        }
    }
}
</code></pre>
<ul>
<li><strong>Input.GetKeyDown(KeyCode.Space)</strong>: 스페이스 키를 눌렀을 때 로봇의 이동 상태를 토글한다.</li>
<li><strong>isMoving</strong>: 로봇이 이동 중인지 여부를 나타내는 변수이다.</li>
<li><strong>실시간 제어</strong>: 사용자의 입력에 따라 로봇의 동작을 실시간으로 변경한다.</li>
</ul>
<h3 id="pid">PID 제어를 이용한 정밀 로봇 제어</h3>
<p>PID(Proportional-Integral-Derivative) 제어기는 로봇의 동작을 정밀하게 제어하기 위해 널리 사용되는 피드백 제어 알고리즘이다. PID 제어기는 현재 오차, 오차의 누적, 오차의 변화율을 기반으로 제어 신호를 생성하여 로봇의 움직임을 조정한다. 이 절에서는 PID 제어기의 기본 개념과 Unity에서 C#을 이용한 구현 방법을 설명한다.</p>
<h4 id="pid_1">PID 제어기의 구성 요소</h4>
<p>PID 제어기는 세 가지 주요 요소로 구성된다:</p>
<ol>
<li><strong>비례(Proportional, P)</strong>: 현재 오차에 비례하여 제어 신호를 생성한다.</li>
<li><strong>적분(Integral, I)</strong>: 오차의 누적에 비례하여 제어 신호를 생성한다.</li>
<li><strong>미분(Derivative, D)</strong>: 오차의 변화율에 비례하여 제어 신호를 생성한다.</li>
</ol>
<p>PID 제어기의 출력 <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>는 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
u(t) = K_p e(t) + K_i \int_{0}^{t} e(\tau) d\tau + K_d \frac{de(t)}{dt}
</div>
<script type="math/tex; mode=display">
u(t) = K_p e(t) + K_i \int_{0}^{t} e(\tau) d\tau + K_d \frac{de(t)}{dt}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">e(t)</span><script type="math/tex">e(t)</script></span>는 현재 오차
- <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>는 비례 게인
- <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>는 적분 게인
- <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span>는 미분 게인</p>
<h4 id="c-pid">C#을 이용한 PID 컨트롤러 구현</h4>
<p>Unity에서 PID 제어기를 구현하기 위해서는 C# 스크립트를 작성하여 로봇의 목표 위치나 속도에 도달하도록 제어 신호를 생성해야 한다. 다음은 간단한 PID 컨트롤러의 구현 예제이다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class PIDController : MonoBehaviour
{
    public float Kp = 1.0f;
    public float Ki = 0.0f;
    public float Kd = 0.0f;

    private float integral = 0.0f;
    private float previousError = 0.0f;

    public float Compute(float setpoint, float actual, float deltaTime)
    {
        float error = setpoint - actual;
        integral += error * deltaTime;
        float derivative = (error - previousError) / deltaTime;
        previousError = error;

        float output = Kp * error + Ki * integral + Kd * derivative;
        return output;
    }
}
</code></pre>
<ul>
<li><strong>Kp, Ki, Kd</strong>: 각각 비례, 적분, 미분 게인 값을 설정한다.</li>
<li><strong>Compute() 메서드</strong>: 목표값(setpoint)과 실제값(actual)의 오차를 기반으로 제어 신호를 계산한다.</li>
</ul>
<h4 id="pid_2">로봇 이동에 PID 제어기 적용</h4>
<p>PID 제어기를 로봇의 이동에 적용하여 목표 위치에 정밀하게 도달하도록 제어할 수 있다. 다음은 PID 컨트롤러를 이용하여 로봇의 속도를 조정하는 예제이다.</p>
<pre><code class="language-csharp">using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class RobotPIDController : MonoBehaviour
{
    public Vector3 targetPosition;
    public float maxSpeed = 10.0f;

    private Rigidbody rb;
    private PIDController pid;

    void Start()
    {
        rb = GetComponent&lt;Rigidbody&gt;();
        pid = new PIDController();
        pid.Kp = 2.0f;
        pid.Ki = 0.5f;
        pid.Kd = 1.0f;
    }

    void FixedUpdate()
    {
        Vector3 errorVector = targetPosition - transform.position;
        float distance = errorVector.magnitude;
        Vector3 direction = errorVector.normalized;

        // PID 컨트롤러를 사용하여 속도 계산
        float controlSignal = pid.Compute(0.0f, distance, Time.fixedDeltaTime);

        // 속도 제한
        float speed = Mathf.Clamp(controlSignal, -maxSpeed, maxSpeed);

        // 로봇에 힘을 적용하여 이동
        rb.AddForce(direction * speed);
    }
}
</code></pre>
<ul>
<li><strong>targetPosition</strong>: 로봇이 도달해야 할 목표 위치이다.</li>
<li><strong>PIDController</strong>: 이전에 구현한 PID 컨트롤러를 사용하여 거리 오차에 기반한 제어 신호를 계산한다.</li>
<li><strong>AddForce()</strong>: 계산된 속도를 방향에 따라 로봇에 적용하여 이동을 제어한다.</li>
</ul>
<h4 id="pid_3">PID 게인 튜닝</h4>
<p>PID 컨트롤러의 성능은 <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span> 게인의 설정에 크게 좌우된다. 적절한 게인 값을 찾기 위해서는 다음과 같은 튜닝 방법을 사용할 수 있다:</p>
<ol>
<li><strong>비례 게인 <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span> 조정</strong>: <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>를 점차 증가시키면서 시스템의 응답 속도를 높이고 과도한 진동이 발생하지 않도록 한다.</li>
<li><strong>적분 게인 <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span> 조정</strong>: 정적 오차를 제거하기 위해 <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>를 서서히 증가시킨다. 너무 크게 설정하면 시스템이 불안정해질 수 있다.</li>
<li><strong>미분 게인 <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span> 조정</strong>: 응답의 과도한 진동을 줄이기 위해 <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span>를 조정한다. 미분 게인이 너무 크면 노이즈에 민감해질 수 있다.</li>
</ol>
<p>PID 게인 튜닝은 경험과 실험을 통해 최적의 값을 찾아내는 과정이 필요하다. Unity의 디버깅 도구를 활용하여 오차와 제어 신호를 시각화하면 튜닝 과정을 보다 효율적으로 진행할 수 있다.</p>
<h3 id="_6">상태 머신을 이용한 로봇 행동 제어</h3>
<p>상태 머신(State Machine)은 로봇의 다양한 행동을 체계적으로 관리하기 위한 유용한 도구이다. 상태 머신을 사용하면 로봇이 특정 조건에 따라 다양한 상태를 전환하면서 복잡한 동작을 수행할 수 있다. 이 절에서는 상태 머신의 기본 개념과 Unity에서 C#을 이용한 구현 방법을 설명한다.</p>
<h4 id="_7">상태 머신의 기본 개념</h4>
<p>상태 머신은 다음과 같은 구성 요소로 이루어져 있다:</p>
<ul>
<li><strong>상태(State)</strong>: 로봇이 특정 시점에 있을 수 있는 상태이다. 예를 들어, 대기 상태, 이동 상태, 장애물 회피 상태 등이 있다.</li>
<li><strong>전이(Transition)</strong>: 한 상태에서 다른 상태로의 전환 조건을 정의한다.</li>
<li><strong>행동(Action)</strong>: 각 상태에서 수행되는 동작을 정의한다.</li>
</ul>
<h4 id="c_1">C#을 이용한 상태 머신 구현</h4>
<p>Unity에서 상태 머신을 구현하기 위해서는 상태 클래스를 정의하고, 현재 상태에 따라 적절한 행동을 수행하도록 스크립트를 작성해야 한다. 다음은 간단한 상태 머신의 구현 예제이다.</p>
<pre><code class="language-csharp">using UnityEngine;

// 상태 인터페이스 정의
public interface IState
{
    void Enter();
    void Execute();
    void Exit();
}

// 대기 상태
public class IdleState : IState
{
    private RobotController robot;

    public IdleState(RobotController robot)
    {
        this.robot = robot;
    }

    public void Enter()
    {
        Debug.Log(&quot;Entering Idle State&quot;);
        robot.StopMovement();
    }

    public void Execute()
    {
        // 대기 상태에서의 로직
        if (robot.HasTarget())
        {
            robot.ChangeState(new MoveState(robot));
        }
    }

    public void Exit()
    {
        Debug.Log(&quot;Exiting Idle State&quot;);
    }
}

// 이동 상태
public class MoveState : IState
{
    private RobotController robot;

    public MoveState(RobotController robot)
    {
        this.robot = robot;
    }

    public void Enter()
    {
        Debug.Log(&quot;Entering Move State&quot;);
        robot.StartMovement();
    }

    public void Execute()
    {
        // 이동 상태에서의 로직
        if (!robot.HasTarget())
        {
            robot.ChangeState(new IdleState(robot));
        }
    }

    public void Exit()
    {
        Debug.Log(&quot;Exiting Move State&quot;);
        robot.StopMovement();
    }
}

// 상태 머신을 관리하는 로봇 컨트롤러
public class RobotController : MonoBehaviour
{
    private IState currentState;

    void Start()
    {
        ChangeState(new IdleState(this));
    }

    void Update()
    {
        if (currentState != null)
        {
            currentState.Execute();
        }
    }

    public void ChangeState(IState newState)
    {
        if (currentState != null)
        {
            currentState.Exit();
        }

        currentState = newState;

        if (currentState != null)
        {
            currentState.Enter();
        }
    }

    public bool HasTarget()
    {
        // 목표 지점이 있는지 확인하는 로직
        return false;
    }

    public void StartMovement()
    {
        // 이동 시작 로직
    }

    public void StopMovement()
    {
        // 이동 정지 로직
    }
}
</code></pre>
<ul>
<li><strong>IState 인터페이스</strong>: 각 상태가 구현해야 할 메서드를 정의한다.</li>
<li><strong>IdleState</strong>: 로봇이 대기 상태일 때의 행동을 정의한다.</li>
<li><strong>MoveState</strong>: 로봇이 이동 상태일 때의 행동을 정의한다.</li>
<li><strong>RobotController</strong>: 현재 상태를 관리하고 상태 전환을 수행한다.</li>
</ul>
<h4 id="_8">상태 전환 조건 설정</h4>
<p>상태 전환 조건은 로봇의 센서 데이터나 외부 이벤트에 따라 설정할 수 있다. 예를 들어, 로봇이 목표 지점에 도달했을 때 대기 상태로 전환하거나, 장애물이 감지되었을 때 회피 상태로 전환할 수 있다. 다음은 장애물 감지 시 상태를 전환하는 예제이다.</p>
<pre><code class="language-csharp">public class MoveState : IState
{
    private RobotController robot;

    public MoveState(RobotController robot)
    {
        this.robot = robot;
    }

    public void Enter()
    {
        Debug.Log(&quot;Entering Move State&quot;);
        robot.StartMovement();
    }

    public void Execute()
    {
        // 이동 상태에서의 로직
        if (!robot.HasTarget())
        {
            robot.ChangeState(new IdleState(robot));
        }

        if (robot.IsObstacleDetected())
        {
            robot.ChangeState(new AvoidObstacleState(robot));
        }
    }

    public void Exit()
    {
        Debug.Log(&quot;Exiting Move State&quot;);
        robot.StopMovement();
    }
}
</code></pre>
<ul>
<li><strong>IsObstacleDetected()</strong>: 장애물이 감지되었는지 여부를 반환하는 메서드이다.</li>
<li><strong>AvoidObstacleState</strong>: 장애물을 회피하는 상태를 추가로 구현해야 한다.</li>
</ul>
<h4 id="_9">상태 머신의 장점</h4>
<ul>
<li><strong>유지보수 용이성</strong>: 상태별로 코드를 분리하여 관리하기 때문에 코드의 가독성과 유지보수성이 향상된다.</li>
<li><strong>확장성</strong>: 새로운 상태를 추가하거나 기존 상태를 수정하기 쉽다.</li>
<li><strong>명확한 로직 흐름</strong>: 상태 전환 조건을 명확히 정의하여 로봇의 행동 흐름을 체계적으로 관리할 수 있다.</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0602/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0602/" class="btn btn-xs btn-link">
        경로 계획 및 이동 제어
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_05/0503/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_05/0503/" class="btn btn-xs btn-link">
        센서 노이즈 시뮬레이션
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>