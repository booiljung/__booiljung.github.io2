<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot_simulation_with_unity/chapter_10/1001/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>모바일 로봇 시뮬레이션 - 소프트웨어 융합</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ubaa8\ubc14\uc77c \ub85c\ubd07\uc758 \uac1c\uc694", url: "#_top", children: [
              {title: "\ubaa8\ubc14\uc77c \ub85c\ubd07\uc758 \uc8fc\uc694 \uad6c\uc131 \uc694\uc18c", url: "#_2" },
          ]},
          {title: "Unity\uc5d0\uc11c\uc758 \ubaa8\ubc14\uc77c \ub85c\ubd07 \ubaa8\ub378\ub9c1", url: "#unity", children: [
              {title: "\ub85c\ubd07 \ubaa8\ub378\ub9c1 \ub2e8\uacc4", url: "#_3" },
          ]},
          {title: "\ubb3c\ub9ac \uc5d4\uc9c4 \uc124\uc815", url: "#_4", children: [
              {title: "Rigidbody \ucef4\ud3ec\ub10c\ud2b8 \ucd94\uac00", url: "#rigidbody" },
              {title: "\ucda9\ub3cc \ucc98\ub9ac", url: "#_5" },
          ]},
          {title: "\uc774\ub3d9 \uba54\ucee4\ub2c8\uc998 \uad6c\ud604", url: "#_6", children: [
              {title: "\ud720 \uae30\ubc18 \uc774\ub3d9", url: "#_7" },
          ]},
          {title: "\uacbd\ub85c \uacc4\ud68d \ubc0f \ub124\ube44\uac8c\uc774\uc158", url: "#_8", children: [
              {title: "NavMesh \uc124\uc815", url: "#navmesh" },
          ]},
          {title: "\uc13c\uc11c \ud1b5\ud569", url: "#_9", children: [
              {title: "\ub77c\uc774\ub2e4(LiDAR) \uc13c\uc11c \ucd94\uac00", url: "#lidar" },
              {title: "\uce74\uba54\ub77c \uc13c\uc11c \uc124\uc815", url: "#_10" },
              {title: "IMU \uc13c\uc11c \ud1b5\ud569", url: "#imu" },
          ]},
          {title: "\uc13c\uc11c \ub370\uc774\ud130 \ucc98\ub9ac", url: "#_11", children: [
              {title: "\ub370\uc774\ud130 \ud544\ud130\ub9c1", url: "#_12" },
              {title: "\uc13c\uc11c \ud4e8\uc804", url: "#_13" },
          ]},
          {title: "\uc81c\uc5b4 \uc2dc\uc2a4\ud15c \uad6c\ud604", url: "#_14", children: [
              {title: "PID \uc81c\uc5b4", url: "#pid" },
              {title: "\uacbd\ub85c \ucd94\uc801 \uc54c\uace0\ub9ac\uc998", url: "#_15" },
          ]},
          {title: "\uc608\uc81c \ud504\ub85c\uc81d\ud2b8: \uc790\uc728 \uc774\ub3d9 \ubaa8\ubc14\uc77c \ub85c\ubd07", url: "#_16", children: [
              {title: "\ud504\ub85c\uc81d\ud2b8 \uc124\uc815", url: "#_17" },
              {title: "\uc2dc\ubbac\ub808\uc774\uc158 \ud658\uacbd \uad6c\ucd95", url: "#_18" },
              {title: "\uc2dc\ubbac\ub808\uc774\uc158 \uc2e4\ud589", url: "#_19" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1002/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1002/" class="btn btn-xs btn-link">
        매니퓰레이터 시뮬레이션
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_09/TODO.0902/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_09/TODO.0902/" class="btn btn-xs btn-link">
        로봇 동작 테스트 및 오류 수정
      </a>
    </div>
    
  </div>

    

    <p>모바일 로봇은 자율적으로 이동하며 환경과 상호작용하는 로봇으로, 다양한 응용 분야에서 활용된다. Unity를 활용한 모바일 로봇 시뮬레이션은 로봇의 동작을 가상 환경에서 테스트하고 최적화할 수 있는 강력한 도구를 제공한다. 이 절에서는 모바일 로봇 시뮬레이션의 기본 개념부터 구현 방법까지 상세히 다룬다.</p>
<h3 id="_1">모바일 로봇의 개요</h3>
<p>모바일 로봇은 주로 이동성을 기반으로 다양한 작업을 수행한다. 대표적인 예로는 자율 주행 차량, 드론, 로봇 청소기 등이 있다. 이러한 로봇들은 센서와 제어 시스템을 통해 주변 환경을 인식하고, 주어진 목표를 달성하기 위해 경로를 계획하고 이동한다.</p>
<h4 id="_2">모바일 로봇의 주요 구성 요소</h4>
<ol>
<li><strong>이동 시스템</strong>: 로봇의 이동을 담당하며, 휠, 트랙, 다리 등 다양한 형태가 있다.</li>
<li><strong>센서</strong>: 주변 환경을 인식하기 위해 사용되며, 라이다(LiDAR), 카메라, 초음파 센서 등이 포함된다.</li>
<li><strong>제어 시스템</strong>: 로봇의 움직임을 제어하며, 경로 계획과 실시간 제어 알고리즘이 포함된다.</li>
<li><strong>전원 공급 장치</strong>: 로봇의 모든 시스템에 전력을 공급한다.</li>
</ol>
<h3 id="unity">Unity에서의 모바일 로봇 모델링</h3>
<p>Unity를 사용하여 모바일 로봇을 시뮬레이션하기 위해서는 먼저 로봇 모델을 정확하게 구축해야 한다. 이를 위해 3D 모델링 도구를 사용하거나 기존 모델을 가져와 사용할 수 있다.</p>
<h4 id="_3">로봇 모델링 단계</h4>
<ol>
<li><strong>3D 모델 준비</strong>: Blender, Maya 등 3D 모델링 소프트웨어를 사용하여 로봇의 3D 모델을 생성한다. 또는 Unity Asset Store에서 적합한 모델을 다운로드할 수 있다.</li>
<li><strong>모델 가져오기</strong>: 생성한 3D 모델을 Unity 프로젝트에 임포트한다. 파일 형식은 FBX, OBJ 등이 일반적으로 사용된다.</li>
<li><strong>로봇 구성 요소 분리</strong>: 로봇의 각 부품을 개별적으로 제어할 수 있도록 계층 구조를 설정한다. 예를 들어, 휠, 본체, 센서 등을 별도의 오브젝트로 분리한다.</li>
</ol>
<pre><code class="language-csharp">// 예제: 로봇의 휠 회전 스크립트
using UnityEngine;

public class WheelController : MonoBehaviour
{
    public float rotationSpeed = 100f;

    void Update()
    {
        float rotation = rotationSpeed * Time.deltaTime;
        transform.Rotate(Vector3.right, rotation);
    }
}
</code></pre>
<h3 id="_4">물리 엔진 설정</h3>
<p>모바일 로봇 시뮬레이션에서 물리적 정확성은 매우 중요하다. Unity의 물리 엔진을 활용하여 로봇의 움직임과 상호작용을 현실적으로 구현할 수 있다.</p>
<h4 id="rigidbody">Rigidbody 컴포넌트 추가</h4>
<p>로봇의 각 구성 요소에 Rigidbody 컴포넌트를 추가하여 물리적 속성을 부여한다. Rigidbody는 질량, 중력, 충돌 등의 물리적 특성을 정의한다.</p>
<pre><code class="language-csharp">// 예제: Rigidbody 설정
using UnityEngine;

public class RobotPhysics : MonoBehaviour
{
    void Start()
    {
        Rigidbody rb = gameObject.AddComponent&lt;Rigidbody&gt;();
        rb.mass = 10f;
        rb.drag = 1f;
        rb.angularDrag = 0.5f;
    }
}
</code></pre>
<h4 id="_5">충돌 처리</h4>
<p>로봇이 환경과 상호작용할 때 충돌을 정확하게 처리하기 위해 Collider 컴포넌트를 사용한다. 휠과 본체에 적절한 Collider를 설정하여 충돌을 감지하고 반응을 구현한다.</p>
<h3 id="_6">이동 메커니즘 구현</h3>
<p>모바일 로봇의 이동은 주로 휠의 회전이나 다리의 움직임을 통해 이루어진다. 이 절에서는 휠 기반 로봇의 이동 메커니즘을 중점적으로 다룬다.</p>
<h4 id="_7">휠 기반 이동</h4>
<p>휠 기반 로봇은 각 휠의 속도와 방향을 제어하여 이동한다. 이를 위해 각 휠에 독립적인 속도 제어가 필요하다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v} = \frac{r}{2} (\omega_{left} + \omega_{right})
</div>
<script type="math/tex; mode=display">
\mathbf{v} = \frac{r}{2} (\omega_{left} + \omega_{right})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>는 로봇의 선속도, <span class="arithmatex"><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span>은 휠의 반지름, <span class="arithmatex"><span class="MathJax_Preview">\omega_{left}</span><script type="math/tex">\omega_{left}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\omega_{right}</span><script type="math/tex">\omega_{right}</script></span>는 좌우 휠의 각속도이다.</p>
<pre><code class="language-csharp">// 예제: 휠 속도 제어 스크립트
using UnityEngine;

public class MobileRobotController : MonoBehaviour
{
    public Rigidbody leftWheel;
    public Rigidbody rightWheel;
    public float maxTorque = 100f;

    void Update()
    {
        float torque = Input.GetAxis(&quot;Vertical&quot;) * maxTorque;
        leftWheel.AddTorque(Vector3.right * torque);
        rightWheel.AddTorque(Vector3.right * torque);
    }
}
</code></pre>
<h3 id="_8">경로 계획 및 네비게이션</h3>
<p>로봇이 목표 지점으로 이동하기 위해서는 효과적인 경로 계획과 네비게이션 시스템이 필요하다. Unity의 NavMesh를 활용하여 로봇의 경로를 계획할 수 있다.</p>
<h4 id="navmesh">NavMesh 설정</h4>
<ol>
<li><strong>NavMesh 베이크</strong>: 환경에 NavMesh를 베이크하여 로봇이 이동할 수 있는 영역을 정의한다.</li>
<li><strong>NavMeshAgent 추가</strong>: 로봇에 NavMeshAgent 컴포넌트를 추가하여 자동으로 경로를 따라 이동하도록 설정한다.</li>
</ol>
<pre><code class="language-csharp">// 예제: NavMeshAgent를 이용한 이동
using UnityEngine;
using UnityEngine.AI;

public class RobotNavigator : MonoBehaviour
{
    public Transform target;
    private NavMeshAgent agent;

    void Start()
    {
        agent = GetComponent&lt;NavMeshAgent&gt;();
        agent.destination = target.position;
    }

    void Update()
    {
        if (agent.remainingDistance &lt; 0.5f)
        {
            // 목표 도착 시 처리
        }
    }
}
</code></pre>
<h3 id="_9">센서 통합</h3>
<p>모바일 로봇이 환경을 효과적으로 인식하고 상호작용하기 위해서는 다양한 센서가 필요하다. Unity를 사용하면 라이다(LiDAR), 카메라, IMU(Inertial Measurement Unit) 등 여러 센서를 시뮬레이션할 수 있다. 이 절에서는 각 센서의 통합 방법과 Unity에서의 설정 과정을 다룬다.</p>
<h4 id="lidar">라이다(LiDAR) 센서 추가</h4>
<p>라이다 센서는 로봇의 주변 환경을 3D로 스캔하여 거리 데이터를 제공한다. Unity에서 라이다 센서를 구현하기 위해서는 레이캐스팅(ray casting)을 활용할 수 있다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class LiDARSensor : MonoBehaviour
{
    public int numberOfRays = 360;
    public float maxDistance = 10f;
    public float angle = 360f;
    public float scanRate = 10f;

    void Update()
    {
        if (Time.frameCount % Mathf.RoundToInt(60 / scanRate) == 0)
        {
            Scan();
        }
    }

    void Scan()
    {
        float angleStep = angle / numberOfRays;
        for (int i = 0; i &lt; numberOfRays; i++)
        {
            float currentAngle = transform.eulerAngles.y + i * angleStep;
            Vector3 direction = Quaternion.Euler(0, currentAngle, 0) * Vector3.forward;
            RaycastHit hit;
            if (Physics.Raycast(transform.position, direction, out hit, maxDistance))
            {
                Debug.DrawRay(transform.position, direction * hit.distance, Color.red);
                // 거리 데이터 처리
            }
            else
            {
                Debug.DrawRay(transform.position, direction * maxDistance, Color.green);
                // 최대 거리 처리
            }
        }
    }
}
</code></pre>
<h4 id="_10">카메라 센서 설정</h4>
<p>카메라 센서는 로봇이 시각 정보를 수집할 수 있도록 도와준다. Unity에서 카메라를 로봇에 부착하고, 필요한 설정을 통해 시뮬레이션 환경에서의 시각 데이터를 얻을 수 있다.</p>
<ol>
<li><strong>카메라 추가</strong>: 로봇 모델에 카메라 오브젝트를 추가한다.</li>
<li><strong>카메라 설정</strong>: 해상도, 시야각(Field of View) 등을 설정한다.</li>
<li><strong>이미지 처리</strong>: 카메라에서 캡처한 이미지를 실시간으로 처리하거나 저장할 수 있다.</li>
</ol>
<pre><code class="language-csharp">using UnityEngine;

public class CameraSensor : MonoBehaviour
{
    public Camera robotCamera;
    public RenderTexture renderTexture;

    void Start()
    {
        if (robotCamera != null &amp;&amp; renderTexture != null)
        {
            robotCamera.targetTexture = renderTexture;
        }
    }

    void Update()
    {
        // 이미지 처리 로직 추가
    }
}
</code></pre>
<h4 id="imu">IMU 센서 통합</h4>
<p>IMU 센서는 가속도, 각속도, 자기장을 측정하여 로봇의 자세와 움직임을 추적한다. Unity에서는 Rigidbody 컴포넌트를 활용하여 IMU 데이터를 시뮬레이션할 수 있다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class IMUSensor : MonoBehaviour
{
    private Rigidbody rb;

    void Start()
    {
        rb = GetComponent&lt;Rigidbody&gt;();
    }

    void Update()
    {
        Vector3 acceleration = rb.velocity / Time.deltaTime;
        Vector3 angularVelocity = rb.angularVelocity;

        // IMU 데이터 처리
    }
}
</code></pre>
<h3 id="_11">센서 데이터 처리</h3>
<p>센서로부터 수집된 데이터는 로봇의 의사 결정과 제어에 중요한 역할을 한다. Unity에서는 C# 스크립트를 사용하여 데이터를 실시간으로 처리하고, 로봇의 동작에 반영할 수 있다.</p>
<h4 id="_12">데이터 필터링</h4>
<p>실제 환경에서는 센서 데이터에 노이즈가 포함될 수 있다. 이를 보정하기 위해 필터링 기법을 적용할 수 있다. 예를 들어, 칼만 필터(Kalman Filter)를 사용하여 노이즈를 줄이고 데이터의 정확성을 높일 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\hat{x}}_{k|k-1} = \mathbf{F} \mathbf{\hat{x}}_{k-1|k-1} + \mathbf{B} \mathbf{u}_k
</div>
<script type="math/tex; mode=display">
\mathbf{\hat{x}}_{k|k-1} = \mathbf{F} \mathbf{\hat{x}}_{k-1|k-1} + \mathbf{B} \mathbf{u}_k
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k|k-1} = \mathbf{F} \mathbf{P}_{k-1|k-1} \mathbf{F}^\top + \mathbf{Q}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k|k-1} = \mathbf{F} \mathbf{P}_{k-1|k-1} \mathbf{F}^\top + \mathbf{Q}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}^\top (\mathbf{H} \mathbf{P}_{k|k-1} \mathbf{H}^\top + \mathbf{R})^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}^\top (\mathbf{H} \mathbf{P}_{k|k-1} \mathbf{H}^\top + \mathbf{R})^{-1}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\hat{x}}_{k|k} = \mathbf{\hat{x}}_{k|k-1} + \mathbf{K}_k (\mathbf{z}_k - \mathbf{H} \mathbf{\hat{x}}_{k|k-1})
</div>
<script type="math/tex; mode=display">
\mathbf{\hat{x}}_{k|k} = \mathbf{\hat{x}}_{k|k-1} + \mathbf{K}_k (\mathbf{z}_k - \mathbf{H} \mathbf{\hat{x}}_{k|k-1})
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P}_{k|k} = (\mathbf{I} - \mathbf{K}_k \mathbf{H}) \mathbf{P}_{k|k-1}
</div>
<script type="math/tex; mode=display">
\mathbf{P}_{k|k} = (\mathbf{I} - \mathbf{K}_k \mathbf{H}) \mathbf{P}_{k|k-1}
</script>
</div>
<h4 id="_13">센서 퓨전</h4>
<p>여러 센서로부터 수집된 데이터를 통합하여 보다 정확한 환경 인식을 구현할 수 있다. 예를 들어, 라이다와 카메라 데이터를 결합하여 장애물을 정확하게 감지하고, 로봇의 위치를 추정할 수 있다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class SensorFusion : MonoBehaviour
{
    public LiDARSensor liDAR;
    public CameraSensor cameraSensor;
    public IMUSensor imu;

    void Update()
    {
        // 센서 데이터 수집
        var liDARData = liDAR.GetData();
        var cameraData = cameraSensor.GetImage();
        var imuData = imu.GetData();

        // 센서 데이터 통합 및 처리
    }
}
</code></pre>
<h3 id="_14">제어 시스템 구현</h3>
<p>모바일 로봇의 움직임을 제어하기 위해서는 센서 데이터에 기반한 제어 알고리즘이 필요하다. Unity에서는 C# 스크립트를 사용하여 다양한 제어 알고리즘을 구현할 수 있다.</p>
<h4 id="pid">PID 제어</h4>
<p>PID(Proportional-Integral-Derivative) 제어기는 로봇의 목표 속도나 위치를 정확하게 달성하기 위해 널리 사용된다. PID 제어기를 구현하여 로봇의 속도와 방향을 조절할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
u(t) = K_p e(t) + K_i \int_{0}^{t} e(\tau) d\tau + K_d \frac{de(t)}{dt}
</div>
<script type="math/tex; mode=display">
u(t) = K_p e(t) + K_i \int_{0}^{t} e(\tau) d\tau + K_d \frac{de(t)}{dt}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">u(t)</span><script type="math/tex">u(t)</script></span>는 제어 입력, <span class="arithmatex"><span class="MathJax_Preview">e(t)</span><script type="math/tex">e(t)</script></span>는 오차, <span class="arithmatex"><span class="MathJax_Preview">K_p</span><script type="math/tex">K_p</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_i</span><script type="math/tex">K_i</script></span>, <span class="arithmatex"><span class="MathJax_Preview">K_d</span><script type="math/tex">K_d</script></span>는 각각 비례, 적분, 미분 게인이다.</p>
<pre><code class="language-csharp">using UnityEngine;

public class PIDController : MonoBehaviour
{
    public float Kp = 1.0f;
    public float Ki = 0.1f;
    public float Kd = 0.05f;
    public float setPoint = 0f;

    private float integral = 0f;
    private float previousError = 0f;

    void Update()
    {
        float current = GetCurrentValue();
        float error = setPoint - current;
        integral += error * Time.deltaTime;
        float derivative = (error - previousError) / Time.deltaTime;
        float output = Kp * error + Ki * integral + Kd * derivative;
        ApplyControl(output);
        previousError = error;
    }

    float GetCurrentValue()
    {
        // 현재 값 반환 (예: 속도, 위치 등)
        return 0f;
    }

    void ApplyControl(float output)
    {
        // 제어 입력 적용 (예: 모터 속도 조절)
    }
}
</code></pre>
<h4 id="_15">경로 추적 알고리즘</h4>
<p>로봇이 미리 정의된 경로를 따라 정확하게 이동할 수 있도록 경로 추적 알고리즘을 구현한다. 대표적인 알고리즘으로는 Pure Pursuit, Stanley Controller 등이 있다.</p>
<pre><code class="language-csharp">using UnityEngine;
using UnityEngine.AI;

public class PathTracking : MonoBehaviour
{
    public Transform[] waypoints;
    private int currentWaypoint = 0;
    private NavMeshAgent agent;

    void Start()
    {
        agent = GetComponent&lt;NavMeshAgent&gt;();
        if (waypoints.Length &gt; 0)
        {
            agent.destination = waypoints[currentWaypoint].position;
        }
    }

    void Update()
    {
        if (!agent.pathPending &amp;&amp; agent.remainingDistance &lt; 0.5f)
        {
            currentWaypoint = (currentWaypoint + 1) % waypoints.Length;
            agent.destination = waypoints[currentWaypoint].position;
        }
    }
}
</code></pre>
<h3 id="_16">예제 프로젝트: 자율 이동 모바일 로봇</h3>
<p>이 절에서는 앞서 설명한 요소들을 통합하여 자율적으로 이동하는 모바일 로봇 시뮬레이션 예제를 구현한다. 이 예제는 로봇이 지정된 경로를 따라 이동하며, 장애물을 피하는 기본적인 기능을 포함한다.</p>
<h4 id="_17">프로젝트 설정</h4>
<ol>
<li><strong>Unity 프로젝트 생성</strong>: 새로운 Unity 프로젝트를 생성하고, 필요한 패키지를 설치한다.</li>
<li><strong>로봇 모델 추가</strong>: 3D 모델링 도구나 Asset Store에서 로봇 모델을 가져온다.</li>
<li><strong>센서 추가</strong>: 라이다, 카메라, IMU 센서를 로봇에 부착한다.</li>
<li><strong>물리 설정</strong>: Rigidbody와 Collider를 설정하여 물리적 상호작용을 구현한다.</li>
<li><strong>제어 스크립트 추가</strong>: PID 제어기와 경로 추적 스크립트를 로봇에 적용한다.</li>
</ol>
<h4 id="_18">시뮬레이션 환경 구축</h4>
<ol>
<li><strong>지형 추가</strong>: 로봇이 이동할 수 있는 평평한 지형을 추가하고, 장애물을 배치한다.</li>
<li><strong>NavMesh 베이크</strong>: 환경에 NavMesh를 베이크하여 로봇이 이동할 수 있는 영역을 정의한다.</li>
<li><strong>경로 설정</strong>: 로봇이 따라갈 경로의 웨이포인트를 설정한다.</li>
</ol>
<h4 id="_19">시뮬레이션 실행</h4>
<ol>
<li><strong>시뮬레이션 시작</strong>: 플레이 모드에서 로봇의 자율 이동을 관찰한다.</li>
<li><strong>데이터 모니터링</strong>: 센서 데이터와 제어 입력을 실시간으로 모니터링하여 로봇의 동작을 분석한다.</li>
<li><strong>디버깅 및 최적화</strong>: 필요에 따라 스크립트를 수정하고, 로봇의 성능을 최적화한다.</li>
</ol>
<pre><code class="language-csharp">using UnityEngine;

public class AutonomousMobileRobot : MonoBehaviour
{
    public PIDController speedController;
    public PathTracking pathTracker;
    public LiDARSensor liDAR;
    public CameraSensor cameraSensor;
    public IMUSensor imu;

    void Start()
    {
        // 초기 설정
    }

    void Update()
    {
        // 센서 데이터 수집 및 처리
        SensorFusion();

        // 경로 추적 및 제어
        pathTracker.Update();
        speedController.Update();
    }

    void SensorFusion()
    {
        // 센서 데이터 통합 로직
    }
}
</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../1002/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../1002/" class="btn btn-xs btn-link">
        매니퓰레이터 시뮬레이션
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_09/TODO.0902/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_09/TODO.0902/" class="btn btn-xs btn-link">
        로봇 동작 테스트 및 오류 수정
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>