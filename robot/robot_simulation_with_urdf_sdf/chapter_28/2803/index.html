<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot_simulation_with_urdf_sdf/chapter_28/2803/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>시뮬레이션 결과 시각화 도구 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "3D \uc2dc\uac01\ud654 \ub3c4\uad6c", url: "#_top", children: [
              {title: "Gazebo", url: "#gazebo" },
              {title: "RViz", url: "#rviz" },
          ]},
          {title: "2D \uc2dc\uac01\ud654 \ub3c4\uad6c", url: "#2d", children: [
              {title: "matplotlib", url: "#matplotlib" },
          ]},
          {title: "\ud50c\ub86f\uc758 \uae30\ubcf8 \ubd84\uc11d \ub3c4\uad6c", url: "#_1", children: [
          ]},
          {title: "3D \uacbd\ub85c \uc2dc\uac01\ud654", url: "#3d_1", children: [
              {title: "matplotlib\uc758 3D \ud50c\ub86f", url: "#matplotlib-3d" },
          ]},
          {title: "\uc13c\uc11c \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#_2", children: [
              {title: "\uce74\uba54\ub77c \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#_3" },
          ]},
          {title: "LIDAR \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#lidar", children: [
              {title: "2D LIDAR \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#2d-lidar" },
              {title: "3D LIDAR \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#3d-lidar" },
          ]},
          {title: "IMU \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#imu", children: [
              {title: "\uac00\uc18d\ub3c4 \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#_4" },
              {title: "\uac01\uc18d\ub3c4 \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#_5" },
          ]},
          {title: "\ud3ec\uc778\ud2b8 \ud074\ub77c\uc6b0\ub4dc \uc2dc\uac01\ud654 \ub3c4\uad6c", url: "#_6", children: [
              {title: "PCL(Point Cloud Library)", url: "#pclpoint-cloud-library" },
          ]},
          {title: "\ub85c\uadf8 \ub370\uc774\ud130 \uc2dc\uac01\ud654", url: "#_7", children: [
              {title: "\ub370\uc774\ud130 \ub85c\uae45\uacfc \uc2dc\uac01\ud654", url: "#_8" },
          ]},
          {title: "\ud50c\ub85c\ud305 \uc635\uc158 \ucd5c\uc801\ud654", url: "#_9", children: [
              {title: "\uc5ec\ub7ec \ucd95\uc744 \uac00\uc9c4 \ud50c\ub86f", url: "#_10" },
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_29/2901/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_29/2901/" class="btn btn-xs btn-link">
        멀티 조인트 로봇 시뮬레이션
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2802/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2802/" class="btn btn-xs btn-link">
        센서 데이터 분석 및 처리
      </a>
    </div>
    
  </div>

    

    <h3 id="3d">3D 시각화 도구</h3>
<p>로봇 시뮬레이션에서 가장 일반적으로 사용되는 시각화 도구는 3D 시각화이다. Gazebo, Rviz와 같은 툴을 통해 로봇의 움직임, 센서 데이터, 환경과의 상호작용을 실시간으로 시각화할 수 있다.</p>
<h4 id="gazebo">Gazebo</h4>
<p>Gazebo는 로봇 시뮬레이션의 기본 시각화 도구로서, 물리 엔진을 기반으로 로봇의 동작을 시뮬레이션하고, 환경과의 상호작용을 실시간으로 시각화할 수 있다. Gazebo의 주요 기능 중 하나는 센서 데이터를 실시간으로 시각화하여, 카메라, LIDAR, IMU 등의 출력을 확인할 수 있다는 점이다. 또한, Gazebo는 로봇의 동역학, 충돌 모델, 그리고 다양한 물리적 특성을 시각적으로 확인할 수 있는 강력한 도구이다.</p>
<h4 id="rviz">RViz</h4>
<p>RViz는 ROS(Robot Operating System)에서 주로 사용되는 시각화 도구로, URDF 모델을 기반으로 로봇의 상태와 센서 데이터를 시각화할 수 있다. RViz는 센서 데이터를 주로 처리하는 데 강점을 가지며, 카메라, LIDAR, 그리고 포인트 클라우드 데이터를 시각화하는 데 자주 사용된다.</p>
<p>RViz를 사용하면 시뮬레이션 중에 로봇의 위치 및 자세를 확인할 수 있으며, 다양한 센서의 출력을 동일한 화면에서 함께 확인할 수 있어 시스템의 디버깅과 분석에 큰 도움이 된다.</p>
<h3 id="2d">2D 시각화 도구</h3>
<p>3D 시각화 도구와 더불어, 2D 시각화 도구도 로봇 시뮬레이션 결과를 분석하는 데 중요한 역할을 한다. 특히, 시간에 따른 데이터를 분석할 때 2D 플롯은 직관적이고 유용하다.</p>
<h4 id="matplotlib">matplotlib</h4>
<p><code>matplotlib</code>는 파이썬에서 가장 널리 사용되는 2D 시각화 도구로, 시뮬레이션 데이터의 시간에 따른 변화를 플로팅하는 데 적합한다. 이를 통해 센서 데이터의 변화를 시간축에 따라 플롯하거나, 로봇의 경로를 2D 평면에 그릴 수 있다. 다음은 matplotlib로 간단한 시간에 따른 위치 변화를 플로팅하는 예이다.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

time = [0, 1, 2, 3, 4, 5]
position = [0, 1, 4, 9, 16, 25]

plt.plot(time, position)
plt.xlabel('Time (s)')
plt.ylabel('Position (m)')
plt.title('Time vs Position')
plt.show()
</code></pre>
<h3 id="_1">플롯의 기본 분석 도구</h3>
<p>플롯을 통해 시간에 따른 데이터를 시각화하는 경우, 특정 이벤트나 동작을 분석하기 위해 다양한 수학적 기법을 적용할 수 있다. 예를 들어, 시간에 따른 로봇의 속도 변화를 분석할 때, 속도 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}(t)</span><script type="math/tex">\mathbf{v}(t)</script></span>는 위치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>의 시간에 대한 도함수로 계산된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v}(t) = \frac{d \mathbf{x}(t)}{dt}
</div>
<script type="math/tex; mode=display">
\mathbf{v}(t) = \frac{d \mathbf{x}(t)}{dt}
</script>
</div>
<p>동일한 방식으로, 가속도 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}(t)</span><script type="math/tex">\mathbf{a}(t)</script></span>는 속도의 시간에 대한 도함수로 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{a}(t) = \frac{d \mathbf{v}(t)}{dt}
</div>
<script type="math/tex; mode=display">
\mathbf{a}(t) = \frac{d \mathbf{v}(t)}{dt}
</script>
</div>
<p>이러한 분석은 시뮬레이션 결과의 정확성과 로봇 동작의 효율성을 평가하는 데 중요한 역할을 한다.</p>
<h3 id="3d_1">3D 경로 시각화</h3>
<p>로봇의 시뮬레이션 결과에서 경로를 시각화하는 것은 로봇이 주행한 경로를 분석하는 데 매우 중요한 도구이다. 특히, 3D 공간에서 로봇의 움직임을 시각화하면 경로 최적화, 장애물 회피, 자율 주행 시스템의 성능을 분석할 수 있다.</p>
<h4 id="matplotlib-3d">matplotlib의 3D 플롯</h4>
<p><code>matplotlib</code>의 3D 플롯 기능을 사용하면 시간에 따른 로봇의 위치 변화를 3차원 공간에서 시각화할 수 있다. 이를 위해서는 <code>Axes3D</code> 클래스를 사용하여 3D 그래프를 생성해야 한다.</p>
<p>예시:</p>
<pre><code class="language-python">from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

x = [0, 1, 2, 3, 4, 5]
y = [0, 1, 2, 1, 0, -1]
z = [0, 0.5, 1, 1.5, 2, 2.5]

ax.plot(x, y, z, label='Robot Path')
ax.set_xlabel('X Position')
ax.set_ylabel('Y Position')
ax.set_zlabel('Z Position')
plt.title('3D Path Visualization')
plt.show()
</code></pre>
<p>이 코드에서는 로봇이 3차원 공간에서 움직인 경로를 시각화할 수 있다. 각 축은 로봇의 위치 데이터를 나타내며, 경로는 시간 순서에 따라 그려진다.</p>
<h3 id="_2">센서 데이터 시각화</h3>
<p>로봇 시뮬레이션에서 중요한 데이터 중 하나는 센서 데이터이다. 센서 데이터는 카메라, LIDAR, IMU와 같은 다양한 센서로부터 수집되며, 이를 시각화함으로써 로봇의 환경 인식 및 동작 제어 성능을 평가할 수 있다.</p>
<h4 id="_3">카메라 데이터 시각화</h4>
<p>카메라 데이터는 일반적으로 이미지 형태로 출력되므로, 카메라 센서로부터 수집된 이미지를 실시간으로 표시하거나 분석할 수 있다. OpenCV 라이브러리를 사용하여 시뮬레이션 중 수집된 카메라 이미지를 표시할 수 있다.</p>
<pre><code class="language-python">import cv2

image = cv2.imread('camera_image.jpg')

cv2.imshow('Camera View', image)
cv2.waitKey(0)
cv2.destroyAllWindows()
</code></pre>
<p>이 코드는 시뮬레이션 중에 카메라 센서로부터 수집된 이미지를 화면에 표시하는 간단한 예시이다. 이를 통해 로봇이 촬영한 이미지를 실시간으로 확인하고, 로봇이 환경을 어떻게 인식하고 있는지 평가할 수 있다.</p>
<h3 id="lidar">LIDAR 데이터 시각화</h3>
<p>LIDAR(Light Detection and Ranging) 데이터는 로봇이 주변 환경을 인식하는 데 사용되는 중요한 정보이다. LIDAR는 주변 객체와의 거리를 측정하여 2D 또는 3D 포인트 클라우드 데이터를 생성한다. 이를 시각화하면 로봇이 인식한 환경의 지형을 확인할 수 있다.</p>
<h4 id="2d-lidar">2D LIDAR 데이터 시각화</h4>
<p>LIDAR 데이터는 일반적으로 2D 평면에서 점의 집합으로 표현된다. 각 점은 LIDAR 센서에서 측정된 거리와 각도를 나타내며, 이를 시각화하면 로봇이 인식하는 주변 환경을 알 수 있다.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np

angles = np.linspace(-np.pi / 2, np.pi / 2, 360)
distances = np.random.uniform(0.5, 10.0, 360)

x = distances * np.cos(angles)
y = distances * np.sin(angles)

plt.scatter(x, y)
plt.xlabel('X Position (m)')
plt.ylabel('Y Position (m)')
plt.title('2D LIDAR Scan Visualization')
plt.axis('equal')
plt.show()
</code></pre>
<p>이 코드에서는 2D LIDAR 데이터를 시각화하여 로봇 주변의 객체들이 어떻게 분포되어 있는지 볼 수 있다. 각 점은 LIDAR 센서가 측정한 거리와 각도를 바탕으로 계산된 좌표를 나타낸다.</p>
<h4 id="3d-lidar">3D LIDAR 데이터 시각화</h4>
<p>3D LIDAR는 로봇이 3차원 공간에서 환경을 인식하는 데 사용된다. 3D 포인트 클라우드를 생성하여 로봇이 주변 공간을 어떻게 감지하는지 분석할 수 있다.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

theta = np.linspace(0, 2 * np.pi, 360)
phi = np.linspace(0, np.pi, 180)
r = np.random.uniform(0.5, 10.0, (180, 360))

x = r * np.sin(phi[:, None]) * np.cos(theta)
y = r * np.sin(phi[:, None]) * np.sin(theta)
z = r * np.cos(phi[:, None])

ax.scatter(x, y, z)
ax.set_xlabel('X Position (m)')
ax.set_ylabel('Y Position (m)')
ax.set_zlabel('Z Position (m)')
plt.title('3D LIDAR Scan Visualization')
plt.show()
</code></pre>
<p>이 코드에서는 3D LIDAR로부터 수집된 포인트 클라우드를 시각화하여 로봇이 인식한 3차원 환경을 분석할 수 있다. 각 점은 LIDAR에서 측정한 거리와 각도 데이터를 사용하여 3D 좌표로 변환된 결과이다.</p>
<h3 id="imu">IMU 데이터 시각화</h3>
<p>IMU(Inertial Measurement Unit) 데이터는 로봇의 자세, 가속도, 각속도 등을 측정하여 로봇의 움직임을 평가하는 데 사용된다. IMU 데이터를 시각화하면 로봇의 동작을 보다 명확하게 이해할 수 있다.</p>
<h4 id="_4">가속도 데이터 시각화</h4>
<p>IMU의 가속도 데이터를 시각화하여 로봇의 가속 상태를 분석할 수 있다. 이를 통해 로봇이 특정 시간에 어떻게 가속하거나 감속하는지를 평가할 수 있다.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

time = [0, 1, 2, 3, 4, 5]
acc_x = [0, 0.1, 0.2, 0.3, 0.2, 0]
acc_y = [0, -0.1, -0.2, -0.1, 0, 0.1]
acc_z = [9.8, 9.8, 9.8, 9.7, 9.7, 9.6]

plt.plot(time, acc_x, label='X Acceleration')
plt.plot(time, acc_y, label='Y Acceleration')
plt.plot(time, acc_z, label='Z Acceleration')
plt.xlabel('Time (s)')
plt.ylabel('Acceleration (m/s^2)')
plt.title('IMU Acceleration Data')
plt.legend()
plt.show()
</code></pre>
<p>이 플롯은 시간에 따른 IMU의 가속도 데이터를 시각화하여 로봇의 가속 상태를 평가할 수 있게 한다.</p>
<h4 id="_5">각속도 데이터 시각화</h4>
<p>IMU의 각속도 데이터를 시각화하여 로봇의 회전 상태를 분석할 수 있다. 각속도는 로봇이 특정 시간에 얼마나 빠르게 회전하는지를 나타낸다.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

time = [0, 1, 2, 3, 4, 5]
gyro_x = [0, 0.05, 0.1, 0.15, 0.1, 0.05]
gyro_y = [0, -0.05, -0.1, -0.05, 0, 0.05]
gyro_z = [0.01, 0.02, 0.03, 0.02, 0.01, 0]

plt.plot(time, gyro_x, label='X Gyro')
plt.plot(time, gyro_y, label='Y Gyro')
plt.plot(time, gyro_z, label='Z Gyro')
plt.xlabel('Time (s)')
plt.ylabel('Angular Velocity (rad/s)')
plt.title('IMU Gyroscope Data')
plt.legend()
plt.show()
</code></pre>
<p>이 플롯은 로봇의 각속도 데이터를 시각화하여 로봇의 회전 동작을 분석하는 데 유용하다.</p>
<h3 id="_6">포인트 클라우드 시각화 도구</h3>
<p>포인트 클라우드는 로봇이 3D 공간에서 수집한 데이터의 집합으로, 특히 LIDAR와 같은 센서에서 자주 사용된다. 포인트 클라우드는 로봇 주변의 환경을 매우 상세하게 시각화할 수 있어, 환경 인식과 장애물 회피 시스템을 설계하는 데 필수적인 도구이다.</p>
<h4 id="pclpoint-cloud-library">PCL(Point Cloud Library)</h4>
<p>PCL(Point Cloud Library)은 포인트 클라우드를 처리하고 시각화하는 강력한 도구이다. 이 라이브러리를 사용하면 3D 포인트 클라우드를 시각화하고, 이를 바탕으로 필터링, 세분화, 군집화 등의 다양한 처리 작업을 수행할 수 있다.</p>
<p>PCL을 이용하여 포인트 클라우드를 시각화하는 예시는 다음과 같다.</p>
<pre><code class="language-cpp">#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/visualization/pcl_visualizer.h&gt;

int main(int argc, char** argv) {
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

    // 포인트 클라우드 파일을 읽음
    pcl::io::loadPCDFile&lt;pcl::PointXYZ&gt;(&quot;sample.pcd&quot;, *cloud);

    // PCL 시각화 도구 초기화
    pcl::visualization::PCLVisualizer::Ptr viewer(new pcl::visualization::PCLVisualizer(&quot;3D Viewer&quot;));
    viewer-&gt;setBackgroundColor(0, 0, 0);
    viewer-&gt;addPointCloud&lt;pcl::PointXYZ&gt;(cloud, &quot;sample cloud&quot;);
    viewer-&gt;setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, &quot;sample cloud&quot;);
    viewer-&gt;addCoordinateSystem(1.0);
    viewer-&gt;initCameraParameters();

    // 시각화 루프
    while (!viewer-&gt;wasStopped()) {
        viewer-&gt;spinOnce(100);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    return 0;
}
</code></pre>
<p>이 코드는 PCL 라이브러리를 사용하여 <code>.pcd</code> 포인트 클라우드 파일을 읽고, 시각화 도구를 통해 이를 3D로 표시하는 예이다. 포인트 클라우드 데이터를 직접적으로 시각화하면서 로봇의 환경 인식을 시각적으로 확인할 수 있다.</p>
<h3 id="_7">로그 데이터 시각화</h3>
<p>시뮬레이션 동안 수집된 로그 데이터를 시각화하면 로봇의 동작을 분석하고 최적화하는 데 매우 유용하다. 특히, 시간에 따른 위치, 속도, 가속도와 같은 데이터를 플로팅하면 시스템의 성능을 보다 명확하게 이해할 수 있다.</p>
<h4 id="_8">데이터 로깅과 시각화</h4>
<p>로그 데이터를 실시간으로 저장하고 시각화할 수 있다. 예를 들어, 로봇의 상태 데이터를 CSV 파일에 기록한 후 이를 시각화할 수 있다.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt
import pandas as pd

log_data = pd.read_csv('robot_log.csv')

plt.plot(log_data['time'], log_data['position_x'], label='X Position')
plt.plot(log_data['time'], log_data['position_y'], label='Y Position')
plt.plot(log_data['time'], log_data['position_z'], label='Z Position')
plt.xlabel('Time (s)')
plt.ylabel('Position (m)')
plt.title('Robot Position Over Time')
plt.legend()
plt.show()
</code></pre>
<p>이 코드는 CSV 파일에 기록된 로봇의 시간에 따른 위치 데이터를 플로팅하여, 시뮬레이션 중 로봇이 어떻게 이동했는지 분석하는 데 사용할 수 있다. 로그 데이터를 시각화하면 로봇의 동작을 정확히 추적하고, 의도한 대로 동작하지 않은 부분을 쉽게 찾아낼 수 있다.</p>
<h3 id="_9">플로팅 옵션 최적화</h3>
<p>시각화 도구를 사용할 때는 데이터의 가독성을 높이기 위해 다양한 플로팅 옵션을 활용할 수 있다. 특히, 복잡한 데이터를 시각화할 때는 플롯에 여러 개의 축을 추가하거나, 데이터를 여러 개의 그래프로 분리하여 시각화하는 것이 유용할 수 있다.</p>
<h4 id="_10">여러 축을 가진 플롯</h4>
<p>복수의 데이터를 시각화할 때, 여러 개의 축을 사용하는 방법은 데이터를 직관적으로 표현하는 데 유용하다.</p>
<pre><code class="language-python">fig, ax1 = plt.subplots()

ax1.set_xlabel('Time (s)')
ax1.set_ylabel('Position (m)', color='tab:blue')
ax1.plot(log_data['time'], log_data['position_x'], label='X Position', color='tab:blue')
ax1.plot(log_data['time'], log_data['position_y'], label='Y Position', color='tab:cyan')
ax1.plot(log_data['time'], log_data['position_z'], label='Z Position', color='tab:green')
ax1.tick_params(axis='y', labelcolor='tab:blue')

ax2 = ax1.twinx()
ax2.set_ylabel('Velocity (m/s)', color='tab:red')
ax2.plot(log_data['time'], log_data['velocity_x'], label='X Velocity', color='tab:red')
ax2.plot(log_data['time'], log_data['velocity_y'], label='Y Velocity', color='tab:orange')
ax2.plot(log_data['time'], log_data['velocity_z'], label='Z Velocity', color='tab:pink')
ax2.tick_params(axis='y', labelcolor='tab:red')

fig.tight_layout()
plt.title('Position and Velocity Over Time')
plt.show()
</code></pre>
<p>이 예시에서는 위치와 속도 데이터를 동시에 시각화하기 위해 두 개의 y축을 사용하는 방법을 보여준다. 이를 통해 데이터의 상호관계를 보다 명확하게 파악할 수 있으며, 데이터를 보다 직관적으로 분석할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_29/2901/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_29/2901/" class="btn btn-xs btn-link">
        멀티 조인트 로봇 시뮬레이션
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../2802/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../2802/" class="btn btn-xs btn-link">
        센서 데이터 분석 및 처리
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>