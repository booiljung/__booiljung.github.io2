<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/robot/robot_simulation_with_urdf_sdf/chapter_22/2201/">
    <link rel="shortcut icon" href="../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>동역학 시뮬레이션 개요 - 실험 도서관</title>
    <link href="../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../css/highlight.css">
    <link href="../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "1. \ub3d9\uc5ed\ud559\uc758 \uae30\ubcf8 \uac1c\ub150", url: "#_top", children: [
          ]},
          {title: "2. \ub274\ud134-\uc624\uc77c\ub7ec \ubc29\uc815\uc2dd", url: "#2-", children: [
              {title: "\uc120\ud615 \uc6b4\ub3d9", url: "#_1" },
              {title: "\ud68c\uc804 \uc6b4\ub3d9", url: "#_2" },
          ]},
          {title: "3. \ub77c\uadf8\ub791\uc8fc \ubc29\uc815\uc2dd", url: "#3", children: [
          ]},
          {title: "4. \ub3d9\uc5ed\ud559 \uc2dc\ubbac\ub808\uc774\uc158\uc758 \uc885\ub958", url: "#4", children: [
              {title: "\uc5f0\uc18d \uc2dc\uac04 \ub3d9\uc5ed\ud559 \uc2dc\ubbac\ub808\uc774\uc158", url: "#_3" },
              {title: "\uc774\uc0b0 \uc2dc\uac04 \ub3d9\uc5ed\ud559 \uc2dc\ubbac\ub808\uc774\uc158", url: "#_4" },
          ]},
          {title: "5. \ub3d9\uc5ed\ud559 \uc2dc\ubbac\ub808\uc774\uc158\uc758 \uc548\uc815\uc131", url: "#5", children: [
              {title: "\uc624\uc77c\ub7ec \ubc29\ubc95", url: "#_5" },
              {title: "\ub7f0\uc9c0-\ucfe0\ud0c0 \ubc29\ubc95", url: "#-" },
          ]},
          {title: "6. \ub3d9\uc5ed\ud559 \uc2dc\ubbac\ub808\uc774\uc158\uc5d0\uc11c \ubb3c\ub9ac \uc5d4\uc9c4\uc758 \uc5ed\ud560", url: "#6", children: [
              {title: "\ucda9\ub3cc \ucc98\ub9ac", url: "#_6" },
              {title: "\uc911\ub825\uacfc \ub9c8\ucc30", url: "#_7" },
          ]},
          {title: "7. \ub3d9\uc5ed\ud559 \uc2dc\ubbac\ub808\uc774\uc158\uc758 \uc218\uce58 \uc801\ubd84 \ubc29\ubc95", url: "#7", children: [
              {title: "\uc624\uc77c\ub7ec-\ub9c8\ub8e8\uc57c\ub9c8 \ubc29\ubc95", url: "#-_1" },
              {title: "\uc2ec\ud50c\ub809\ud2f1 \uc801\ubd84\ubc95", url: "#_8" },
          ]},
          {title: "8. \ub3d9\uc5ed\ud559 \uc2dc\ubbac\ub808\uc774\uc158\uc758 \uc751\uc6a9", url: "#8", children: [
          ]},
        ];

    </script>
    <script src="../../../../js/base.js"></script>
      <script src="../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2202/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2202/" class="btn btn-xs btn-link">
        URDF/SDF에서 물리 엔진 설정
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_21/2103/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_21/2103/" class="btn btn-xs btn-link">
        기본 로봇 시뮬레이션 실행
      </a>
    </div>
    
  </div>

    

    <h3 id="1">1. 동역학의 기본 개념</h3>
<p>동역학(Dynamics)은 물체의 운동을 연구하는 학문으로, 뉴턴의 운동 법칙에 기반을 둔다. 로봇의 동역학 시뮬레이션은 로봇이 외부 힘이나 토크에 의해 어떻게 움직이는지를 예측하기 위해 수학적 모델을 적용한다. 이를 위해 물체의 위치, 속도, 가속도뿐만 아니라 관성, 질량 중심 등 물리적 속성도 고려해야 한다.</p>
<p>로봇의 동역학은 두 가지로 나눌 수 있다:
1. <strong>정적 동역학</strong>: 로봇이 정지 상태에 있을 때의 힘의 평형을 분석.
2. <strong>동적 동역학</strong>: 시간에 따른 로봇의 움직임을 분석.</p>
<p>동역학 시뮬레이션에서 가장 중요한 목표는 로봇의 자세와 위치를 시간에 따라 예측하는 것이다. 이를 위해 두 가지 방법이 사용된다:
- <strong>순방향 동역학(Forward Dynamics)</strong>: 주어진 힘이나 토크로부터 로봇의 가속도와 움직임을 계산.
- <strong>역방향 동역학(Inverse Dynamics)</strong>: 원하는 가속도나 움직임을 달성하기 위해 필요한 힘이나 토크를 계산.</p>
<h3 id="2-">2. 뉴턴-오일러 방정식</h3>
<p>로봇의 동역학을 계산할 때는 뉴턴-오일러 방정식(Newton-Euler Equations)이 많이 사용된다. 뉴턴-오일러 방정식은 힘과 토크를 통해 물체의 선형 운동과 회전 운동을 동시에 기술한다. 이를 통해 링크(link)의 동역학을 계산할 수 있다.</p>
<h4 id="_1">선형 운동</h4>
<p>로봇의 질량 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>과 가속도 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span> 사이의 관계는 뉴턴의 제2법칙에 의해 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{F} = m \mathbf{a}
</div>
<script type="math/tex; mode=display">
\mathbf{F} = m \mathbf{a}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}</span><script type="math/tex">\mathbf{F}</script></span>는 물체에 작용하는 총 외력(Force) 벡터.
- <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 물체의 질량.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>는 물체의 가속도 벡터.</p>
<h4 id="_2">회전 운동</h4>
<p>회전 운동은 각가속도 <span class="arithmatex"><span class="MathJax_Preview">\boldsymbol{\alpha}</span><script type="math/tex">\boldsymbol{\alpha}</script></span>와 관성 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{I}</span><script type="math/tex">\mathbf{I}</script></span>를 기반으로 기술된다. 회전 운동에 대한 뉴턴의 제2법칙은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\boldsymbol{\tau} = \mathbf{I} \boldsymbol{\alpha} + \mathbf{\omega} \times (\mathbf{I} \mathbf{\omega})
</div>
<script type="math/tex; mode=display">
\boldsymbol{\tau} = \mathbf{I} \boldsymbol{\alpha} + \mathbf{\omega} \times (\mathbf{I} \mathbf{\omega})
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\boldsymbol{\tau}</span><script type="math/tex">\boldsymbol{\tau}</script></span>는 물체에 작용하는 총 토크(Torque) 벡터.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{I}</span><script type="math/tex">\mathbf{I}</script></span>는 물체의 관성 행렬(Inertia Matrix).
- <span class="arithmatex"><span class="MathJax_Preview">\boldsymbol{\alpha}</span><script type="math/tex">\boldsymbol{\alpha}</script></span>는 각가속도 벡터.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\omega}</span><script type="math/tex">\mathbf{\omega}</script></span>는 각속도 벡터.
- <span class="arithmatex"><span class="MathJax_Preview">\times</span><script type="math/tex">\times</script></span>는 벡터곱.</p>
<p>이 방정식은 물체의 회전 운동을 계산하는 데 사용된다. 물체의 질량 중심이 시간에 따라 어떻게 움직이는지 예측할 수 있으며, 이는 로봇의 링크 사이의 상호작용을 시뮬레이션하는 데 필수적이다.</p>
<h3 id="3">3. 라그랑주 방정식</h3>
<p>라그랑주(Lagrange) 동역학은 뉴턴-오일러 방정식과는 다른 접근법으로, 에너지 보존 법칙을 기반으로 한다. 라그랑주 방정식은 로봇 시스템이 어떻게 에너지를 소모하고 저장하는지를 계산한다. 라그랑주 함수 <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span>은 운동 에너지 <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>와 위치 에너지 <span class="arithmatex"><span class="MathJax_Preview">V</span><script type="math/tex">V</script></span>의 차이로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
L = T - V
</div>
<script type="math/tex; mode=display">
L = T - V
</script>
</div>
<p>라그랑주 방정식을 사용하여 시스템의 운동을 결정하는 방법은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{q}_i} \right) - \frac{\partial L}{\partial q_i} = Q_i
</div>
<script type="math/tex; mode=display">
\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{q}_i} \right) - \frac{\partial L}{\partial q_i} = Q_i
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">q_i</span><script type="math/tex">q_i</script></span>는 일반화 좌표(Generalized Coordinates).
- <span class="arithmatex"><span class="MathJax_Preview">\dot{q}_i</span><script type="math/tex">\dot{q}_i</script></span>는 일반화 속도(Generalized Velocities).
- <span class="arithmatex"><span class="MathJax_Preview">Q_i</span><script type="math/tex">Q_i</script></span>는 일반화 힘(Generalized Forces).</p>
<p>라그랑주 방정식은 복잡한 멀티 조인트 로봇의 동역학을 해석하는 데 유용하며, 시스템의 모든 에너지를 종합적으로 고려할 수 있다.</p>
<h3 id="4">4. 동역학 시뮬레이션의 종류</h3>
<p>로봇의 동역학 시뮬레이션은 크게 두 가지로 구분된다: <strong>연속 시간 시뮬레이션</strong>과 <strong>이산 시간 시뮬레이션</strong>. 실제 로봇 시스템은 연속적으로 작동하지만, 컴퓨터는 이산 시간 시뮬레이션을 통해 이를 계산한다.</p>
<h4 id="_3">연속 시간 동역학 시뮬레이션</h4>
<p>연속 시간 시뮬레이션에서는 시간 변수 <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>가 연속적으로 변화하며, 로봇의 상태 변수 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}(t)</span><script type="math/tex">\mathbf{x}(t)</script></span>가 시간에 따라 변화한다. 연속 시간 동역학은 미분방정식으로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\frac{d \mathbf{x}}{dt} = f(\mathbf{x}, \mathbf{u}, t)
</div>
<script type="math/tex; mode=display">
\frac{d \mathbf{x}}{dt} = f(\mathbf{x}, \mathbf{u}, t)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>는 시스템의 상태 벡터 (예: 위치, 속도, 각도 등).
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}</span><script type="math/tex">\mathbf{u}</script></span>는 시스템에 작용하는 입력 벡터 (예: 힘, 토크 등).
- <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>는 시스템의 상태 변화 함수.</p>
<p>연속 시간 시뮬레이션은 로봇의 실제 동작을 모사하는 데 매우 정확하지만, 컴퓨터로 직접적으로 구현하기 어려울 수 있다.</p>
<h4 id="_4">이산 시간 동역학 시뮬레이션</h4>
<p>이산 시간 시뮬레이션은 시간 변수를 작은 간격으로 나누어 계산한다. 이러한 시뮬레이션은 차분방정식을 사용하며, 시간 간격 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span> 동안 상태 변화를 계산하는 방식이다. 이산 시간 동역학은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{k+1} = \mathbf{x}_k + \Delta t \cdot f(\mathbf{x}_k, \mathbf{u}_k, t_k)
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{k+1} = \mathbf{x}_k + \Delta t \cdot f(\mathbf{x}_k, \mathbf{u}_k, t_k)
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_k</span><script type="math/tex">\mathbf{x}_k</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t_k</span><script type="math/tex">t_k</script></span>에서의 상태 벡터.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_k</span><script type="math/tex">\mathbf{u}_k</script></span>는 시간 <span class="arithmatex"><span class="MathJax_Preview">t_k</span><script type="math/tex">t_k</script></span>에서의 입력 벡터.
- <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>는 시간 간격.</p>
<p>이산 시간 시뮬레이션은 컴퓨터에서 쉽게 구현할 수 있으며, 로봇 제어 및 시뮬레이션에서 일반적으로 사용된다.</p>
<h3 id="5">5. 동역학 시뮬레이션의 안정성</h3>
<p>동역학 시뮬레이션의 중요한 요소 중 하나는 <strong>안정성</strong>이다. 이산 시간 시뮬레이션에서 시간 간격 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>가 너무 크면 시뮬레이션 결과가 부정확해지거나 불안정해질 수 있다. 안정성을 확보하기 위해서는 작은 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>를 선택하거나, 더 정교한 수치 적분 방법을 사용할 필요가 있다.</p>
<h4 id="_5">오일러 방법</h4>
<p>가장 기본적인 수치 적분 방법은 오일러 방법이다. 이 방법은 상태 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>를 현재 시간에서의 상태와 그 미분값을 이용하여 다음 상태를 계산한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{k+1} = \mathbf{x}_k + \Delta t \cdot \mathbf{\dot{x}}_k
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{k+1} = \mathbf{x}_k + \Delta t \cdot \mathbf{\dot{x}}_k
</script>
</div>
<p>오일러 방법은 구현이 간단하지만, 큰 시간 간격에서는 불안정해질 수 있다.</p>
<h4 id="-">런지-쿠타 방법</h4>
<p>런지-쿠타(Runge-Kutta) 방법은 보다 안정적인 수치 적분 방법으로, 보다 작은 오차로 상태 변화를 계산할 수 있다. 4차 런지-쿠타 방법은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{k}_1 = f(\mathbf{x}_k, \mathbf{u}_k, t_k)
</div>
<script type="math/tex; mode=display">
\mathbf{k}_1 = f(\mathbf{x}_k, \mathbf{u}_k, t_k)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{k}_2 = f(\mathbf{x}_k + \frac{\Delta t}{2} \mathbf{k}_1, \mathbf{u}_k, t_k + \frac{\Delta t}{2})
</div>
<script type="math/tex; mode=display">
\mathbf{k}_2 = f(\mathbf{x}_k + \frac{\Delta t}{2} \mathbf{k}_1, \mathbf{u}_k, t_k + \frac{\Delta t}{2})
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{k}_3 = f(\mathbf{x}_k + \frac{\Delta t}{2} \mathbf{k}_2, \mathbf{u}_k, t_k + \frac{\Delta t}{2})
</div>
<script type="math/tex; mode=display">
\mathbf{k}_3 = f(\mathbf{x}_k + \frac{\Delta t}{2} \mathbf{k}_2, \mathbf{u}_k, t_k + \frac{\Delta t}{2})
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{k}_4 = f(\mathbf{x}_k + \Delta t \mathbf{k}_3, \mathbf{u}_k, t_k + \Delta t)
</div>
<script type="math/tex; mode=display">
\mathbf{k}_4 = f(\mathbf{x}_k + \Delta t \mathbf{k}_3, \mathbf{u}_k, t_k + \Delta t)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{k+1} = \mathbf{x}_k + \frac{\Delta t}{6} (\mathbf{k}_1 + 2 \mathbf{k}_2 + 2 \mathbf{k}_3 + \mathbf{k}_4)
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{k+1} = \mathbf{x}_k + \frac{\Delta t}{6} (\mathbf{k}_1 + 2 \mathbf{k}_2 + 2 \mathbf{k}_3 + \mathbf{k}_4)
</script>
</div>
<p>런지-쿠타 방법은 오일러 방법보다 정확하며, 시간 간격 <span class="arithmatex"><span class="MathJax_Preview">\Delta t</span><script type="math/tex">\Delta t</script></span>가 커도 상대적으로 안정적이다.</p>
<h3 id="6">6. 동역학 시뮬레이션에서 물리 엔진의 역할</h3>
<p>동역학 시뮬레이션을 효과적으로 수행하기 위해서는 물리 엔진(Physics Engine)이 필수적이다. 물리 엔진은 로봇의 동역학과 상호작용하는 외부 환경을 처리하며, 실제와 유사한 물리적 상호작용을 모사한다.</p>
<p>물리 엔진은 다음과 같은 역할을 한다:
- <strong>충돌 감지</strong>: 로봇의 링크와 환경 사이, 혹은 로봇의 각 부분 사이의 충돌을 감지하고 이를 처리한다.
- <strong>힘 및 토크 적용</strong>: 로봇에 작용하는 외부 힘(중력, 마찰 등)과 내부 토크(모터, 액추에이터 등)를 계산하고 적용한다.
- <strong>관성 처리</strong>: 로봇의 질량 중심과 관성 모멘트를 계산하여, 로봇의 물리적 동작을 실제처럼 표현한다.</p>
<h4 id="_6">충돌 처리</h4>
<p>로봇 시뮬레이션에서 충돌 처리(Collision Handling)는 매우 중요한 요소 중 하나다. 로봇이 외부 환경과 상호작용할 때 충돌이 발생할 수 있으며, 이를 처리하지 않으면 비현실적인 시뮬레이션이 된다. 물리 엔진은 충돌이 발생했을 때 충격력을 계산하고, 이를 기반으로 로봇의 움직임을 조정한다.</p>
<h4 id="_7">중력과 마찰</h4>
<p>로봇 동역학 시뮬레이션에서는 중력(Gravity)과 마찰(Friction)을 고려해야 한다. 중력은 로봇의 모든 링크에 일정하게 작용하며, 로봇의 무게중심을 기준으로 힘을 발생시킨다. 중력은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{F}_{\text{gravity}} = m \mathbf{g}
</div>
<script type="math/tex; mode=display">
\mathbf{F}_{\text{gravity}} = m \mathbf{g}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{F}_{\text{gravity}}</span><script type="math/tex">\mathbf{F}_{\text{gravity}}</script></span>는 중력에 의해 발생하는 힘.
- <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 로봇의 질량.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{g}</span><script type="math/tex">\mathbf{g}</script></span>는 중력 가속도 벡터 (일반적으로 <span class="arithmatex"><span class="MathJax_Preview">9.81 \, \text{m/s}^2</span><script type="math/tex">9.81 \, \text{m/s}^2</script></span>).</p>
<p>마찰은 로봇의 이동을 방해하는 힘으로, 마찰 계수와 접촉 면적에 의해 결정된다. 물리 엔진은 마찰을 모델링하여, 로봇의 움직임이 환경에 의해 어떻게 저항을 받는지 시뮬레이션한다.</p>
<h3 id="7">7. 동역학 시뮬레이션의 수치 적분 방법</h3>
<p>동역학 시뮬레이션에서 시간에 따른 상태 변화는 보통 수치 적분(Numerical Integration)을 통해 계산된다. 가장 일반적으로 사용되는 수치 적분 방법은 오일러 방법과 런지-쿠타 방법이지만, 특정 시뮬레이션에서는 더 복잡한 적분 방법이 필요할 수 있다.</p>
<h4 id="-_1">오일러-마루야마 방법</h4>
<p>오일러-마루야마(Euler-Maruyama) 방법은 확률적 동역학 시스템(Stochastic Dynamical Systems)을 처리하기 위한 수치 적분 방법이다. 로봇이 불확실한 환경에서 동작할 때, 확률적 변동을 고려하는 것이 중요하다. 오일러-마루야마 방법은 확률적 미분방정식(Stochastic Differential Equations, SDE)을 적분하여 다음과 같이 상태 변화를 계산한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{x}_{k+1} = \mathbf{x}_k + \Delta t \cdot f(\mathbf{x}_k, \mathbf{u}_k, t_k) + \sqrt{\Delta t} \cdot g(\mathbf{x}_k) \mathbf{W}_k
</div>
<script type="math/tex; mode=display">
\mathbf{x}_{k+1} = \mathbf{x}_k + \Delta t \cdot f(\mathbf{x}_k, \mathbf{u}_k, t_k) + \sqrt{\Delta t} \cdot g(\mathbf{x}_k) \mathbf{W}_k
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">g(\mathbf{x}_k)</span><script type="math/tex">g(\mathbf{x}_k)</script></span>는 확률적 변동을 표현하는 함수.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{W}_k</span><script type="math/tex">\mathbf{W}_k</script></span>는 위너 과정(Wiener Process, 백색 잡음)으로, 난수를 포함한 확률적 요소.</p>
<h4 id="_8">심플렉틱 적분법</h4>
<p>심플렉틱 적분법(Symplectic Integration)은 동역학 시스템의 에너지를 보존하면서 상태를 적분하는 방법이다. 이는 오일러 방법보다 안정적이며, 특히 에너지가 보존되는 시스템에서 효과적이다. 심플렉틱 적분법은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_{k+1} = \mathbf{p}_k + \Delta t \cdot \nabla \mathbf{H}_q(\mathbf{q}_k, \mathbf{p}_k)
</div>
<script type="math/tex; mode=display">
\mathbf{p}_{k+1} = \mathbf{p}_k + \Delta t \cdot \nabla \mathbf{H}_q(\mathbf{q}_k, \mathbf{p}_k)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{q}_{k+1} = \mathbf{q}_k + \Delta t \cdot \nabla \mathbf{H}_p(\mathbf{q}_{k+1}, \mathbf{p}_{k+1})
</div>
<script type="math/tex; mode=display">
\mathbf{q}_{k+1} = \mathbf{q}_k + \Delta t \cdot \nabla \mathbf{H}_p(\mathbf{q}_{k+1}, \mathbf{p}_{k+1})
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 운동량 벡터.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span>는 위치 벡터.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{H}</span><script type="math/tex">\mathbf{H}</script></span>는 해밀토니안(Hamiltonian)으로, 에너지를 표현하는 함수.</p>
<p>이 방법은 특히 로봇이 오랫동안 움직일 때 에너지 보존이 중요한 경우에 유리하다.</p>
<h3 id="8">8. 동역학 시뮬레이션의 응용</h3>
<p>동역학 시뮬레이션은 로봇 설계 및 제어에서 광범위하게 응용된다. 예를 들어:
- <strong>로봇 설계 검증</strong>: 로봇의 동작을 사전에 시뮬레이션하여, 실제 구현 전에 설계를 검증할 수 있다.
- <strong>제어 알고리즘 테스트</strong>: 로봇의 제어 알고리즘을 시뮬레이션 환경에서 테스트하고 조정할 수 있다.
- <strong>멀티 조인트 로봇 시뮬레이션</strong>: 멀티 조인트 로봇의 복잡한 동역학을 분석하고, 각 조인트의 상호작용을 시뮬레이션할 수 있다.</p>
<p>동역학 시뮬레이션은 로봇 개발 과정에서 중요한 도구로, 이를 통해 실제 환경에서의 실험 비용과 시간을 줄일 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../2202/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../2202/" class="btn btn-xs btn-link">
        URDF/SDF에서 물리 엔진 설정
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../chapter_21/2103/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../chapter_21/2103/" class="btn btn-xs btn-link">
        기본 로봇 시뮬레이션 실행
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>