<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/math/linear_algebra/eigen_library/chapter_03/0306/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>행렬식 계산 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ud589\ub82c\uc2dd\uc758 \uc815\uc758", url: "#_top", children: [
          ]},
          {title: "Eigen \ub77c\uc774\ube0c\ub7ec\ub9ac\uc5d0\uc11c \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#eigen", children: [
          ]},
          {title: "\ud589\ub82c\uc2dd \uacc4\uc0b0\uc758 \uc8fc\uc694 \uc131\uc9c8", url: "#_2", children: [
          ]},
          {title: "\uc18c\ud589\ub82c\uc2dd(Minor)\uacfc \uc5ec\uc778\uc790(Cofactor)", url: "#minor-cofactor", children: [
              {title: "\uc18c\ud589\ub82c\uc2dd(Minor)", url: "#minor" },
              {title: "\uc5ec\uc778\uc790(Cofactor)", url: "#cofactor" },
          ]},
          {title: "\ud589\ub82c\uc2dd\uc758 \uc7ac\uadc0\uc801 \uacc4\uc0b0 (Laplace \uc804\uac1c)", url: "#laplace", children: [
              {title: "\uc608\uc2dc: 3 \\times 33 \\times 3 \ud589\ub82c\uc758 \ud589\ub82c\uc2dd", url: "#3-times-33-times-3" },
          ]},
          {title: "Eigen\uc5d0\uc11c\uc758 \uace0\ucc28\uc6d0 \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#eigen_1", children: [
          ]},
          {title: "\ud589\ub82c \ubd84\ud574\uc640 \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#_3", children: [
              {title: "LU \ubd84\ud574\ub97c \ud1b5\ud55c \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#lu" },
              {title: "Eigen\uc5d0\uc11c LU \ubd84\ud574\ub97c \ud1b5\ud55c \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#eigen-lu" },
          ]},
          {title: "QR \ubd84\ud574\ub97c \ud1b5\ud55c \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#qr", children: [
              {title: "Eigen\uc5d0\uc11c QR \ubd84\ud574\ub97c \ud1b5\ud55c \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#eigen-qr" },
          ]},
          {title: "Cholesky \ubd84\ud574\ub97c \ud1b5\ud55c \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#cholesky", children: [
              {title: "Eigen\uc5d0\uc11c Cholesky \ubd84\ud574\ub97c \ud1b5\ud55c \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#eigen-cholesky" },
          ]},
          {title: "\ub300\uac01\ud654(Diagonalization)\uc640 \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#diagonalization", children: [
              {title: "Eigen\uc5d0\uc11c \uace0\uc720\uac12\uc744 \ud1b5\ud55c \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#eigen_2" },
          ]},
          {title: "SVD(\ud2b9\uc774\uac12 \ubd84\ud574)\ub97c \ud1b5\ud55c \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#svd", children: [
              {title: "Eigen\uc5d0\uc11c SVD\ub97c \ud1b5\ud55c \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#eigen-svd" },
          ]},
          {title: "\ud589\ub82c\uc2dd \uacc4\uc0b0\uc758 \uc218\uce58\uc801 \ubb38\uc81c", url: "#_4", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0307/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0307/" class="btn btn-xs btn-link">
        대각행렬과 대각합
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0305/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0305/" class="btn btn-xs btn-link">
        행렬의 역행렬 계산
      </a>
    </div>
    
  </div>

    

    <p>행렬식(Determinant)은 정방행렬(square matrix)에 대해 정의되며, 선형대수학에서 매우 중요한 역할을 한다. 행렬의 행렬식은 여러 방식으로 계산할 수 있으며, Eigen 라이브러리에서는 다양한 방법으로 이를 효율적으로 다룰 수 있다. 이번 절에서는 행렬식을 계산하는 방법, 그 이론적 배경, 그리고 Eigen 라이브러리에서의 실제 구현 방식을 다룬다.</p>
<h3 id="_1">행렬식의 정의</h3>
<p>우선, 행렬식은 주어진 정방행렬에 대해 스칼라 값을 반환하는 함수로 정의된다. 행렬식은 일반적으로 다음과 같이 표기한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A})
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A})
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> 정방행렬을 의미하며, 그 행렬식은 주로 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 열이나 행을 통해 재귀적으로 정의된다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script></span> 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 대한 행렬식은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = a_{11} a_{22} - a_{12} a_{21}
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = a_{11} a_{22} - a_{12} a_{21}
</script>
</div>
<p>보다 일반적으로, <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> 행렬에 대한 행렬식은 다음과 같이 주어진다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = \sum_{i=1}^{n} (-1)^{i+1} a_{1i} \text{det}(\mathbf{A}_{1i})
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = \sum_{i=1}^{n} (-1)^{i+1} a_{1i} \text{det}(\mathbf{A}_{1i})
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{1i}</span><script type="math/tex">\mathbf{A}_{1i}</script></span>는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 1행과 i열을 제거한 <span class="arithmatex"><span class="MathJax_Preview">(n-1) \times (n-1)</span><script type="math/tex">(n-1) \times (n-1)</script></span> 행렬이다.</p>
<h3 id="eigen">Eigen 라이브러리에서 행렬식 계산</h3>
<p>Eigen 라이브러리에서 행렬의 행렬식을 계산하는 것은 매우 간단하다. 다음과 같은 방식으로 사용할 수 있다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    Eigen::Matrix2d mat;
    mat(0, 0) = 3;
    mat(1, 0) = 2;
    mat(0, 1) = 1;
    mat(1, 1) = 4;
    std::cout &lt;&lt; &quot;행렬의 행렬식은: &quot; &lt;&lt; mat.determinant() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>위의 코드는 <span class="arithmatex"><span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script></span> 행렬에 대한 행렬식을 구하는 방법을 보여준다. 더 큰 <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> 행렬의 경우에도 동일한 방식으로 계산할 수 있으며, Eigen 라이브러리는 이 과정에서 효율적인 알고리즘을 활용하여 계산 속도를 최적화한다.</p>
<h3 id="_2">행렬식 계산의 주요 성질</h3>
<p>행렬식은 여러 중요한 성질을 가지고 있으며, 이를 이해하는 것은 행렬 연산을 깊이 있게 다루는 데 필수적이다. 몇 가지 중요한 성질을 소개하면 다음과 같다.</p>
<ol>
<li><strong>교환 법칙</strong>: 정방행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>에 대해,</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \text{det}(\mathbf{A} \mathbf{B}) = \text{det}(\mathbf{A}) \cdot \text{det}(\mathbf{B})
</div>
<script type="math/tex; mode=display">
   \text{det}(\mathbf{A} \mathbf{B}) = \text{det}(\mathbf{A}) \cdot \text{det}(\mathbf{B})
</script>
</div>
<ol>
<li><strong>전치 행렬의 행렬식</strong>: <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>가 <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> 행렬일 때,</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \text{det}(\mathbf{A}^{T}) = \text{det}(\mathbf{A})
</div>
<script type="math/tex; mode=display">
   \text{det}(\mathbf{A}^{T}) = \text{det}(\mathbf{A})
</script>
</div>
<ol>
<li><strong>역행렬과 행렬식</strong>: 만약 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>가 가역행렬이라면, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 역행렬에 대한 행렬식은 다음과 같다.</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \text{det}(\mathbf{A}^{-1}) = \frac{1}{\text{det}(\mathbf{A})}
</div>
<script type="math/tex; mode=display">
   \text{det}(\mathbf{A}^{-1}) = \frac{1}{\text{det}(\mathbf{A})}
</script>
</div>
<ol>
<li><strong>특정 행렬 연산에 대한 행렬식의 변화</strong>: 행렬의 행이나 열을 특정 상수로 곱하면, 그 행렬식은 해당 상수만큼 변하게 된다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-번째 행을 상수 <span class="arithmatex"><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span>로 곱하면,</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
   \text{det}(\mathbf{A}) = c \cdot \text{det}(\mathbf{A'})
</div>
<script type="math/tex; mode=display">
   \text{det}(\mathbf{A}) = c \cdot \text{det}(\mathbf{A'})
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A'}</span><script type="math/tex">\mathbf{A'}</script></span>는 변형되지 않은 나머지 행렬이다.</p>
<p>이러한 성질들은 행렬식을 계산하고 해석하는 데 있어 매우 중요한 역할을 한다. 특히 선형대수학에서 행렬의 고유값을 찾거나, 선형 방정식의 해를 구할 때 유용하다.</p>
<h3 id="minor-cofactor">소행렬식(Minor)과 여인자(Cofactor)</h3>
<p>행렬식 계산의 기본적인 과정에서 중요한 개념은 소행렬식과 여인자이다. 이 두 개념은 <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> 행렬의 행렬식을 재귀적으로 정의하고 계산하는 데 사용된다.</p>
<h4 id="minor">소행렬식(Minor)</h4>
<p>소행렬식은 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 어떤 특정 행과 열을 제거하고 남은 행렬의 행렬식을 말한다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 i번째 행과 j번째 열을 제거한 <span class="arithmatex"><span class="MathJax_Preview">(n-1) \times (n-1)</span><script type="math/tex">(n-1) \times (n-1)</script></span> 행렬을 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{ij}</span><script type="math/tex">\mathbf{A}_{ij}</script></span>라고 하면, 이때의 행렬식을 <span class="arithmatex"><span class="MathJax_Preview">M_{ij}</span><script type="math/tex">M_{ij}</script></span>라고 정의한다. 이를 수식으로 표현하면,</p>
<div class="arithmatex">
<div class="MathJax_Preview">
M_{ij} = \text{det}(\mathbf{A}_{ij})
</div>
<script type="math/tex; mode=display">
M_{ij} = \text{det}(\mathbf{A}_{ij})
</script>
</div>
<h4 id="cofactor">여인자(Cofactor)</h4>
<p>여인자는 소행렬식에 행과 열의 인덱스에 따라 부호를 더한 값이다. 즉, 행렬의 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>-번째 행과 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>-번째 열에 해당하는 여인자 <span class="arithmatex"><span class="MathJax_Preview">C_{ij}</span><script type="math/tex">C_{ij}</script></span>는 다음과 같이 정의된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
C_{ij} = (-1)^{i+j} M_{ij}
</div>
<script type="math/tex; mode=display">
C_{ij} = (-1)^{i+j} M_{ij}
</script>
</div>
<p>이때 <span class="arithmatex"><span class="MathJax_Preview">(-1)^{i+j}</span><script type="math/tex">(-1)^{i+j}</script></span>는 소행렬식의 부호를 결정하는 역할을 하며, 이는 교차 패턴으로 부호가 달라지게 한다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> 행렬에서의 여인자 부호는 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{pmatrix}
+ &amp; - &amp; + \\
- &amp; + &amp; - \\
+ &amp; - &amp; +
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\begin{pmatrix}
+ & - & + \\
- & + & - \\
+ & - & +
\end{pmatrix}
</script>
</div>
<h3 id="laplace">행렬식의 재귀적 계산 (Laplace 전개)</h3>
<p>이제 <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> 행렬의 행렬식을 계산하는 방법으로, Laplace 전개에 대해 설명하겠다. 이 방법은 행이나 열을 기준으로 소행렬식과 여인자를 이용해 행렬식을 재귀적으로 구하는 방법이다.</p>
<p>예를 들어, <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 첫 번째 행을 기준으로 행렬식을 전개하면, 다음과 같이 구할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = a_{11} C_{11} + a_{12} C_{12} + \cdots + a_{1n} C_{1n}
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = a_{11} C_{11} + a_{12} C_{12} + \cdots + a_{1n} C_{1n}
</script>
</div>
<p>이를 좀 더 일반적으로 표현하면,</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = \sum_{j=1}^{n} a_{1j} C_{1j}
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = \sum_{j=1}^{n} a_{1j} C_{1j}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">C_{1j}</span><script type="math/tex">C_{1j}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 첫 번째 행과 j번째 열을 제거한 소행렬식의 여인자이다.</p>
<h4 id="3-times-33-times-3">예시: <span class="arithmatex"><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> 행렬의 행렬식</h4>
<p><span class="arithmatex"><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 대해 행렬식을 직접 계산해 보자.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \begin{pmatrix}
a_{11} &amp; a_{12} &amp; a_{13} \\
a_{21} &amp; a_{22} &amp; a_{23} \\
a_{31} &amp; a_{32} &amp; a_{33}
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \begin{pmatrix}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{pmatrix}
</script>
</div>
<p>이 행렬의 행렬식은 첫 번째 행을 기준으로 Laplace 전개를 사용하여 다음과 같이 계산할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = a_{11} \begin{vmatrix} a_{22} &amp; a_{23} \\ a_{32} &amp; a_{33} \end{vmatrix}
- a_{12} \begin{vmatrix} a_{21} &amp; a_{23} \\ a_{31} &amp; a_{33} \end{vmatrix}
+ a_{13} \begin{vmatrix} a_{21} &amp; a_{22} \\ a_{31} &amp; a_{32} \end{vmatrix}
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = a_{11} \begin{vmatrix} a_{22} & a_{23} \\ a_{32} & a_{33} \end{vmatrix}
- a_{12} \begin{vmatrix} a_{21} & a_{23} \\ a_{31} & a_{33} \end{vmatrix}
+ a_{13} \begin{vmatrix} a_{21} & a_{22} \\ a_{31} & a_{32} \end{vmatrix}
</script>
</div>
<p>각각의 <span class="arithmatex"><span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script></span> 행렬식을 계산하여 다음과 같은 결과를 얻는다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = a_{11}(a_{22}a_{33} - a_{23}a_{32}) - a_{12}(a_{21}a_{33} - a_{23}a_{31}) + a_{13}(a_{21}a_{32} - a_{22}a_{31})
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = a_{11}(a_{22}a_{33} - a_{23}a_{32}) - a_{12}(a_{21}a_{33} - a_{23}a_{31}) + a_{13}(a_{21}a_{32} - a_{22}a_{31})
</script>
</div>
<p>이 방식으로 <span class="arithmatex"><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> 이상의 큰 행렬에 대해서도 재귀적으로 행렬식을 구할 수 있다.</p>
<h3 id="eigen_1">Eigen에서의 고차원 행렬식 계산</h3>
<p>Eigen 라이브러리는 고차원 행렬의 행렬식을 계산하는 데 있어 매우 효율적인 알고리즘을 사용한다. 특히, 일반적인 <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> 행렬의 경우, 행렬 분해 알고리즘(예: LU 분해)을 사용하여 더 빠른 계산을 수행한다.</p>
<p>예를 들어, <span class="arithmatex"><span class="MathJax_Preview">4 \times 4</span><script type="math/tex">4 \times 4</script></span> 이상의 큰 행렬에 대해서도 Eigen의 <code>determinant()</code> 함수를 그대로 사용할 수 있으며, 내부적으로 LU 분해를 통해 계산 효율을 높인다. 다음은 Eigen 라이브러리를 사용한 예시이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    Eigen::Matrix4d mat;
    mat &lt;&lt; 1, 2, 3, 4,
           5, 6, 7, 8,
           9, 10, 11, 12,
           13, 14, 15, 16;

    std::cout &lt;&lt; &quot;행렬의 행렬식은: &quot; &lt;&lt; mat.determinant() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>이 예제에서 Eigen은 내부적으로 LU 분해를 사용하여 행렬식을 효율적으로 계산한다. <span class="arithmatex"><span class="MathJax_Preview">4 \times 4</span><script type="math/tex">4 \times 4</script></span> 이상의 행렬에서도 계산은 빠르고 정확하게 이루어진다.</p>
<h3 id="_3">행렬 분해와 행렬식 계산</h3>
<p>대규모 행렬에 대한 효율적인 행렬식 계산을 위해, 행렬 분해 방법이 많이 사용된다. 대표적인 분해 방법으로는 LU 분해, QR 분해, 그리고 Cholesky 분해 등이 있다. 이러한 방법은 행렬식을 직접적으로 계산하는 대신, 행렬을 더 간단한 형태로 분해하여 행렬식을 계산할 수 있도록 도와준다.</p>
<h4 id="lu">LU 분해를 통한 행렬식 계산</h4>
<p>LU 분해는 주어진 정방행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>를 두 개의 삼각행렬의 곱으로 분해하는 방법이다. 이때 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 하삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>과 상삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>로 다음과 같이 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{L} \mathbf{U}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{L} \mathbf{U}
</script>
</div>
<p>LU 분해를 이용하면, 행렬의 행렬식은 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>의 대각 원소들의 곱으로 계산된다. 즉, 다음과 같은 성질을 이용할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = \text{det}(\mathbf{L}) \cdot \text{det}(\mathbf{U})
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = \text{det}(\mathbf{L}) \cdot \text{det}(\mathbf{U})
</script>
</div>
<p>LU 분해에서 하삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>의 대각 원소는 모두 1이므로, <span class="arithmatex"><span class="MathJax_Preview">\text{det}(\mathbf{L}) = 1</span><script type="math/tex">\text{det}(\mathbf{L}) = 1</script></span>이다. 따라서, 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 행렬식은 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>의 대각 원소들의 곱으로 표현된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = \prod_{i=1}^{n} u_{ii}
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = \prod_{i=1}^{n} u_{ii}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">u_{ii}</span><script type="math/tex">u_{ii}</script></span>는 상삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>의 대각 원소이다.</p>
<h4 id="eigen-lu">Eigen에서 LU 분해를 통한 행렬식 계산</h4>
<p>Eigen 라이브러리에서는 LU 분해를 간단하게 사용할 수 있으며, 이를 통해 대규모 행렬의 행렬식을 효율적으로 계산할 수 있다. 다음은 LU 분해를 사용하는 예시이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    Eigen::Matrix3d mat;
    mat &lt;&lt; 4, 3, 2,
           2, 1, 3,
           3, 4, 1;

    Eigen::FullPivLU&lt;Eigen::Matrix3d&gt; lu_decomp(mat);
    std::cout &lt;&lt; &quot;행렬의 LU 분해를 통한 행렬식은: &quot; &lt;&lt; lu_decomp.determinant() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>이 코드에서 <code>FullPivLU</code> 클래스는 행렬의 LU 분해를 수행하며, <code>determinant()</code> 함수는 분해된 행렬의 대각 원소들의 곱을 통해 행렬식을 계산한다. 이를 통해 큰 행렬에서도 효율적인 계산이 가능하다.</p>
<h3 id="qr">QR 분해를 통한 행렬식 계산</h3>
<p>QR 분해는 주어진 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>를 직교행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>와 상삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>의 곱으로 분해하는 방법이다. QR 분해는 주로 직교성(orthogonality)을 보존하는 성질을 갖고 있어 수치적으로 안정적인 계산이 가능하다. 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 대해 다음과 같이 분해할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{Q} \mathbf{R}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{Q} \mathbf{R}
</script>
</div>
<p>여기서, 직교행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>는 대각 원소들이 모두 1인 행렬이므로, 그 행렬식은 다음과 같다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{Q}) = 1
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{Q}) = 1
</script>
</div>
<p>따라서, 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 행렬식은 상삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>의 대각 원소들의 곱으로 구할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = \prod_{i=1}^{n} r_{ii}
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = \prod_{i=1}^{n} r_{ii}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">r_{ii}</span><script type="math/tex">r_{ii}</script></span>는 상삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>의 대각 원소이다.</p>
<h4 id="eigen-qr">Eigen에서 QR 분해를 통한 행렬식 계산</h4>
<p>Eigen 라이브러리에서는 QR 분해도 쉽게 수행할 수 있다. 다음은 QR 분해를 사용하여 행렬식을 계산하는 예시이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    Eigen::Matrix3d mat;
    mat &lt;&lt; 4, 3, 2,
           2, 1, 3,
           3, 4, 1;

    Eigen::HouseholderQR&lt;Eigen::Matrix3d&gt; qr_decomp(mat);
    Eigen::Matrix3d R = qr_decomp.matrixQR().triangularView&lt;Eigen::Upper&gt;();
    std::cout &lt;&lt; &quot;행렬의 QR 분해를 통한 행렬식은: &quot; &lt;&lt; R.diagonal().prod() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>위 코드는 QR 분해를 통해 상삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>을 추출하고, 그 대각 원소들의 곱을 통해 행렬식을 계산하는 방식이다. QR 분해는 LU 분해에 비해 수치적으로 더 안정적인 경우가 많아 특정 상황에서 유용하다.</p>
<h3 id="cholesky">Cholesky 분해를 통한 행렬식 계산</h3>
<p>Cholesky 분해는 대칭행렬이면서 양의 정부호(positive definite)인 행렬에 대해서만 적용 가능한 분해 방식이다. 이는 주어진 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>를 하삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>과 그 전치행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}^{T}</span><script type="math/tex">\mathbf{L}^{T}</script></span>의 곱으로 분해한다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{L} \mathbf{L}^{T}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{L} \mathbf{L}^{T}
</script>
</div>
<p>이때, 행렬식은 하삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>의 대각 원소들의 곱의 제곱으로 계산된다. 수식으로 표현하면,</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = \left( \prod_{i=1}^{n} l_{ii} \right)^2
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = \left( \prod_{i=1}^{n} l_{ii} \right)^2
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">l_{ii}</span><script type="math/tex">l_{ii}</script></span>는 하삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>의 대각 원소이다.</p>
<h4 id="eigen-cholesky">Eigen에서 Cholesky 분해를 통한 행렬식 계산</h4>
<p>Eigen 라이브러리에서 Cholesky 분해는 <code>LLT</code> 클래스를 사용하여 간단하게 구현할 수 있다. 다음은 Cholesky 분해를 사용하여 행렬식을 계산하는 예시이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    Eigen::Matrix3d mat;
    mat &lt;&lt; 4, 12, -16,
           12, 37, -43,
           -16, -43, 98;

    Eigen::LLT&lt;Eigen::Matrix3d&gt; llt_decomp(mat);
    Eigen::Matrix3d L = llt_decomp.matrixL();
    double detA = std::pow(L.diagonal().prod(), 2);
    std::cout &lt;&lt; &quot;행렬의 Cholesky 분해를 통한 행렬식은: &quot; &lt;&lt; detA &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>이 코드는 양의 정부호 대칭행렬에 대해 Cholesky 분해를 수행하고, 그 대각 원소들의 곱의 제곱을 통해 행렬식을 계산하는 방식이다.</p>
<h3 id="diagonalization">대각화(Diagonalization)와 행렬식 계산</h3>
<p>대각화는 정방행렬이 고유값과 고유벡터를 통해 대각행렬로 변환될 수 있는 과정을 말한다. 정방행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>가 대각화 가능한 경우, 다음과 같이 표현할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{P} \mathbf{D} \mathbf{P}^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{P} \mathbf{D} \mathbf{P}^{-1}
</script>
</div>
<p>여기서, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 고유벡터들로 이루어진 행렬이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 고유값들로 구성된 대각행렬이다. 이 경우, 행렬식은 대각행렬의 대각 원소(즉, 고유값)들의 곱으로 계산할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = \text{det}(\mathbf{D}) = \prod_{i=1}^{n} \lambda_{i}
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = \text{det}(\mathbf{D}) = \prod_{i=1}^{n} \lambda_{i}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\lambda_{i}</span><script type="math/tex">\lambda_{i}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 i번째 고유값이다. 대각화가 가능한 행렬의 경우, 고유값의 곱을 통해 매우 쉽게 행렬식을 계산할 수 있다.</p>
<h4 id="eigen_2">Eigen에서 고유값을 통한 행렬식 계산</h4>
<p>Eigen 라이브러리에서는 고유값을 쉽게 구할 수 있는 기능을 제공하며, 이를 통해 행렬식도 계산할 수 있다. 고유값은 <code>EigenSolver</code> 클래스를 사용하여 구할 수 있으며, 이 고유값들을 이용하여 행렬식을 계산할 수 있다. 다음은 고유값을 이용해 행렬식을 계산하는 예시이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    Eigen::Matrix3d mat;
    mat &lt;&lt; 4, -2, 1,
           -2, 4, -2,
           1, -2, 3;

    Eigen::EigenSolver&lt;Eigen::Matrix3d&gt; solver(mat);
    Eigen::Vector3cd eigenvalues = solver.eigenvalues();

    std::cout &lt;&lt; &quot;행렬의 고유값을 이용한 행렬식은: &quot; 
              &lt;&lt; eigenvalues.prod() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>이 코드는 고유값을 계산한 후, 그 고유값들의 곱을 통해 행렬식을 구하는 방식이다. 만약 행렬이 대각화 가능하다면, 이 방법을 통해 수치적으로 매우 안정적인 행렬식 계산이 가능하다.</p>
<h3 id="svd">SVD(특이값 분해)를 통한 행렬식 계산</h3>
<p>특이값 분해(SVD, Singular Value Decomposition)는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>를 세 개의 행렬로 분해하는 방식이다. 이때 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 다음과 같이 분해된다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^{T}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^{T}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}</span><script type="math/tex">\mathbf{V}</script></span>는 각각 직교행렬이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Sigma}</span><script type="math/tex">\mathbf{\Sigma}</script></span>는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 특이값들이 대각 성분으로 들어 있는 대각행렬이다. 만약 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>가 정방행렬이라면, 이 특이값들의 곱을 통해 행렬식을 계산할 수 있다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = \text{det}(\mathbf{\Sigma}) = \prod_{i=1}^{n} \sigma_{i}
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = \text{det}(\mathbf{\Sigma}) = \prod_{i=1}^{n} \sigma_{i}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\sigma_{i}</span><script type="math/tex">\sigma_{i}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 i번째 특이값이다.</p>
<h4 id="eigen-svd">Eigen에서 SVD를 통한 행렬식 계산</h4>
<p>Eigen에서는 <code>JacobiSVD</code> 클래스를 이용하여 특이값 분해를 수행할 수 있다. 특이값들을 얻은 후, 그 곱을 통해 행렬식을 계산할 수 있다. 다음은 SVD를 통해 행렬식을 구하는 예시이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    Eigen::Matrix3d mat;
    mat &lt;&lt; 4, 3, 2,
           3, 2, 1,
           2, 1, 3;

    Eigen::JacobiSVD&lt;Eigen::Matrix3d&gt; svd(mat);
    Eigen::Vector3d singularValues = svd.singularValues();

    std::cout &lt;&lt; &quot;행렬의 SVD를 통한 행렬식은: &quot; 
              &lt;&lt; singularValues.prod() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>위 코드는 SVD를 통해 특이값을 계산하고, 그 특이값들의 곱을 이용하여 행렬식을 구하는 방식이다. SVD는 수치적으로 매우 안정적이며, 행렬의 크기나 조건 수가 매우 클 때 유용하게 사용할 수 있다.</p>
<h3 id="_4">행렬식 계산의 수치적 문제</h3>
<p>행렬식 계산은 수치적으로 매우 민감한 작업이 될 수 있다. 특히, 행렬의 크기가 커지거나, 행렬이 특이(singular)에 가까울수록 계산 과정에서 오차가 발생할 수 있다. 이 경우, LU 분해나 QR 분해와 같은 방법은 행렬의 조건 수가 좋지 않을 때에도 비교적 안정적인 방법으로 사용된다.</p>
<p>특히, 고유값을 이용한 행렬식 계산 방법은 행렬이 대각화 가능할 때에만 유효하며, 대각화 불가능한 행렬에 대해서는 사용할 수 없다. 또한, SVD는 행렬의 특이성 여부에 관계없이 사용할 수 있으며, 가장 수치적으로 안정적인 방법 중 하나로 알려져 있다.</p>
<p>따라서, 실제로 행렬식을 계산할 때에는 사용되는 행렬의 성질과 조건을 잘 파악하고, 적절한 분해 방법을 선택하는 것이 중요하다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0307/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0307/" class="btn btn-xs btn-link">
        대각행렬과 대각합
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0305/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0305/" class="btn btn-xs btn-link">
        행렬의 역행렬 계산
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>