<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/math/linear_algebra/eigen_library/chapter_01/0101/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Eigen의 주요 기능 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "1. \ubca1\ud130 \ubc0f \ud589\ub82c \uc5f0\uc0b0", url: "#_top", children: [
              {title: "\ub367\uc148 \ubc0f \ube84\uc148", url: "#_1" },
              {title: "\uc2a4\uce7c\ub77c \uacf1\uc148", url: "#_2" },
              {title: "\ub0b4\uc801", url: "#_3" },
              {title: "\uc678\uc801", url: "#_4" },
          ]},
          {title: "2. \ud589\ub82c \uacf1\uc148", url: "#2", children: [
          ]},
          {title: "3. \uc5ed\ud589\ub82c \uacc4\uc0b0", url: "#3", children: [
          ]},
          {title: "4. \uc804\uce58 \ud589\ub82c", url: "#4", children: [
          ]},
          {title: "5. \ub300\uac01 \ud589\ub82c \ubc0f \ub300\uac01\ud654", url: "#5", children: [
          ]},
          {title: "6. \uace0\uc720\uac12 \ubc0f \uace0\uc720\ubca1\ud130 \uacc4\uc0b0", url: "#6", children: [
              {title: "\uace0\uc720\uac12 \uacc4\uc0b0", url: "#_5" },
              {title: "\uace0\uc720\ubca1\ud130 \uacc4\uc0b0", url: "#_6" },
          ]},
          {title: "7. \ud589\ub82c \ubd84\ud574", url: "#7", children: [
              {title: "LU \ubd84\ud574", url: "#lu" },
              {title: "QR \ubd84\ud574", url: "#qr" },
              {title: "SVD (\ud2b9\uc774\uac12 \ubd84\ud574)", url: "#svd" },
          ]},
          {title: "8. \uc120\ud615 \ubc29\uc815\uc2dd\uc758 \ud574\ubc95", url: "#8", children: [
              {title: "\uc9c1\uc811 \ud574\ubc95", url: "#_7" },
              {title: "\ubc18\ubcf5 \ud574\ubc95", url: "#_8" },
          ]},
          {title: "9. \ud589\ub82c\uc2dd \uacc4\uc0b0", url: "#9", children: [
          ]},
          {title: "10. \ud76c\uc18c \ud589\ub82c \uc9c0\uc6d0", url: "#10", children: [
              {title: "\ud76c\uc18c \ud589\ub82c\uc758 \uc800\uc7a5 \ubc29\uc2dd", url: "#_9" },
              {title: "\ud76c\uc18c \ud589\ub82c\uc758 \uc5f0\uc0b0", url: "#_10" },
              {title: "\ud76c\uc18c \uc120\ud615 \ubc29\uc815\uc2dd\uc758 \ud574\ubc95", url: "#_11" },
          ]},
          {title: "11. \ud589\ub82c \ud06c\uae30 \ubcc0\uacbd \ubc0f \ucd08\uae30\ud654", url: "#11", children: [
              {title: "\ud06c\uae30 \ubcc0\uacbd", url: "#_12" },
              {title: "\ucd08\uae30\ud654", url: "#_13" },
          ]},
          {title: "12. \ube14\ub85d \uc5f0\uc0b0", url: "#12", children: [
              {title: "\ube14\ub85d \ucc38\uc870", url: "#_14" },
              {title: "\ube14\ub85d \uc218\uc815", url: "#_15" },
          ]},
          {title: "13. \ub9f5\ud551(Map) \ubc0f \uba54\ubaa8\ub9ac \uad00\ub9ac", url: "#13-map", children: [
              {title: "\ub9f5\ud551 \uae30\ub2a5", url: "#_16" },
              {title: "\uba54\ubaa8\ub9ac \uc815\ub82c", url: "#_17" },
          ]},
          {title: "14. \ud15c\ud50c\ub9bf \uc9c0\uc6d0", url: "#14", children: [
              {title: "\uc815\uc801 \ud06c\uae30\uc640 \ub3d9\uc801 \ud06c\uae30", url: "#_18" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0102/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0102/" class="btn btn-xs btn-link">
        Eigen의 특징
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../01_preface_ko/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../01_preface_ko/" class="btn btn-xs btn-link">
        소개
      </a>
    </div>
    
  </div>

    

    <h3 id="1">1. 벡터 및 행렬 연산</h3>
<p>Eigen 라이브러리는 벡터와 행렬에 대한 기본적인 연산을 매우 효율적으로 처리할 수 있도록 설계되어 있다. 이 라이브러리에서 제공하는 주요 연산들은 다음과 같다.</p>
<h4 id="_1">덧셈 및 뺄셈</h4>
<p>벡터와 행렬의 덧셈과 뺄셈은 차원만 맞다면 간단히 이루어진다. 예를 들어, 두 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}, \mathbf{b} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{a}, \mathbf{b} \in \mathbb{R}^n</script></span> 에 대해 덧셈과 뺄셈은 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{c} = \mathbf{a} + \mathbf{b}
</div>
<script type="math/tex; mode=display">
\mathbf{c} = \mathbf{a} + \mathbf{b}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{d} = \mathbf{a} - \mathbf{b}
</div>
<script type="math/tex; mode=display">
\mathbf{d} = \mathbf{a} - \mathbf{b}
</script>
</div>
<p>이때 두 벡터의 크기가 같아야 연산이 가능하며, 행렬의 경우도 마찬가지로 동일한 차원을 가져야 한다.</p>
<h4 id="_2">스칼라 곱셈</h4>
<p>스칼라와 벡터 또는 행렬의 곱셈은 매우 직관적이다. 스칼라 <span class="arithmatex"><span class="MathJax_Preview">k \in \mathbb{R}</span><script type="math/tex">k \in \mathbb{R}</script></span>와 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{v} \in \mathbb{R}^n</script></span>의 곱은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{w} = k \cdot \mathbf{v}
</div>
<script type="math/tex; mode=display">
\mathbf{w} = k \cdot \mathbf{v}
</script>
</div>
<p>행렬의 경우에도 동일하게 적용되며, 모든 원소에 스칼라 값이 곱해진다.</p>
<h4 id="_3">내적</h4>
<p>두 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}, \mathbf{b} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{a}, \mathbf{b} \in \mathbb{R}^n</script></span>의 내적은 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{a} \cdot \mathbf{b} = \sum_{i=1}^{n} a_i b_i
</div>
<script type="math/tex; mode=display">
\mathbf{a} \cdot \mathbf{b} = \sum_{i=1}^{n} a_i b_i
</script>
</div>
<p>Eigen에서는 <code>.dot()</code> 함수를 통해 쉽게 계산할 수 있다.</p>
<h4 id="_4">외적</h4>
<p>3차원 벡터의 외적은 다음과 같은 형태로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{a} \times \mathbf{b} = 
\begin{vmatrix}
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
a_1 &amp; a_2 &amp; a_3 \\
b_1 &amp; b_2 &amp; b_3
\end{vmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{a} \times \mathbf{b} = 
\begin{vmatrix}
\mathbf{i} & \mathbf{j} & \mathbf{k} \\
a_1 & a_2 & a_3 \\
b_1 & b_2 & b_3
\end{vmatrix}
</script>
</div>
<p>Eigen에서는 <code>.cross()</code> 함수를 사용하여 외적을 계산할 수 있다.</p>
<h3 id="2">2. 행렬 곱셈</h3>
<p>행렬 곱셈은 다양한 분야에서 매우 중요한 연산으로, Eigen에서는 효율적인 방식으로 이를 처리한다. 두 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span> 와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B} \in \mathbb{R}^{n \times p}</span><script type="math/tex">\mathbf{B} \in \mathbb{R}^{n \times p}</script></span> 의 곱은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \mathbf{A} \cdot \mathbf{B}
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \mathbf{A} \cdot \mathbf{B}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
C_{ij} = \sum_{k=1}^{n} A_{ik} B_{kj}
</div>
<script type="math/tex; mode=display">
C_{ij} = \sum_{k=1}^{n} A_{ik} B_{kj}
</script>
</div>
<p>Eigen에서는 <code>*</code> 연산자를 사용하여 이와 같은 행렬 곱셈을 쉽게 수행할 수 있다.</p>
<h3 id="3">3. 역행렬 계산</h3>
<p>Eigen은 행렬의 역행렬 계산을 위한 다양한 방법을 제공한다. 정방행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>의 역행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}^{-1}</span><script type="math/tex">\mathbf{A}^{-1}</script></span>은 다음 조건을 만족하는 행렬이다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \cdot \mathbf{A}^{-1} = \mathbf{I}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \cdot \mathbf{A}^{-1} = \mathbf{I}
</script>
</div>
<p>Eigen에서는 <code>.inverse()</code> 함수를 사용하여 역행렬을 쉽게 계산할 수 있다. 단, 역행렬이 존재하려면 행렬이 가역적이어야 하며, 이는 행렬의 행렬식이 0이 아니어야 함을 의미한다.</p>
<h3 id="4">4. 전치 행렬</h3>
<p>행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>의 전치 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}^T \in \mathbb{R}^{n \times m}</span><script type="math/tex">\mathbf{A}^T \in \mathbb{R}^{n \times m}</script></span>은 원래 행렬의 행과 열을 바꾼 형태로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
A^T_{ij} = A_{ji}
</div>
<script type="math/tex; mode=display">
A^T_{ij} = A_{ji}
</script>
</div>
<p>전치 연산은 대칭행렬이나 다양한 최적화 문제에서 자주 사용된다. Eigen에서는 <code>.transpose()</code> 함수를 통해 쉽게 전치행렬을 얻을 수 있다.</p>
<h3 id="5">5. 대각 행렬 및 대각화</h3>
<p>대각 행렬은 모든 비대각 원소가 0인 행렬을 의미한다. 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>가 대각행렬일 때, 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
D_{ij} = 0 \quad \text{for} \quad i \neq j
</div>
<script type="math/tex; mode=display">
D_{ij} = 0 \quad \text{for} \quad i \neq j
</script>
</div>
<p>대각화는 주어진 행렬을 고유값과 고유벡터로 분해하여 대각 행렬로 변환하는 과정이다. 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>를 대각화하면 다음과 같은 형태가 된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{P} \mathbf{\Lambda} \mathbf{P}^{-1}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{P} \mathbf{\Lambda} \mathbf{P}^{-1}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Lambda}</span><script type="math/tex">\mathbf{\Lambda}</script></span>는 대각 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>는 고유벡터로 이루어진 행렬이다.</p>
<p>Eigen에서는 <code>.eigenvalues()</code> 및 <code>.eigenvectors()</code> 함수를 통해 고유값과 고유벡터를 쉽게 계산할 수 있다.</p>
<h3 id="6">6. 고유값 및 고유벡터 계산</h3>
<p>고유값과 고유벡터는 행렬의 중요한 특성 중 하나로, 다양한 응용 분야에서 자주 사용된다. 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>에 대해 고유값 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>와 고유벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{v} \in \mathbb{R}^n</script></span>는 다음 조건을 만족한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \mathbf{v} = \lambda \mathbf{v}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \mathbf{v} = \lambda \mathbf{v}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>는 고유값, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>는 고유벡터이다. 고유값과 고유벡터를 구하는 문제는 대각화 문제와 밀접하게 연관되며, Eigen에서는 행렬의 고유값과 고유벡터를 쉽게 계산할 수 있는 함수들이 제공된다.</p>
<h4 id="_5">고유값 계산</h4>
<p>Eigen에서 고유값은 <code>.eigenvalues()</code> 함수를 통해 쉽게 구할 수 있으며, 이 함수는 행렬의 고유값을 반환한다. 예를 들어, 정방행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 대해 고유값은 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\lambda_1, \lambda_2, \dots, \lambda_n
</div>
<script type="math/tex; mode=display">
\lambda_1, \lambda_2, \dots, \lambda_n
</script>
</div>
<h4 id="_6">고유벡터 계산</h4>
<p>고유벡터는 고유값과 함께 중요한 역할을 한다. Eigen에서는 <code>.eigenvectors()</code> 함수를 사용하여 고유벡터를 계산할 수 있다. 고유값과 고유벡터는 다양한 물리적 현상과 시스템의 동작을 분석하는 데 중요한 역할을 한다.</p>
<h3 id="7">7. 행렬 분해</h3>
<p>Eigen은 다양한 행렬 분해 방법을 제공하며, 이를 통해 행렬을 보다 효율적으로 분석하고 계산할 수 있다. 대표적인 행렬 분해 기법으로는 LU 분해, QR 분해, SVD(특이값 분해)가 있다.</p>
<h4 id="lu">LU 분해</h4>
<p>LU 분해는 주어진 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>를 두 개의 행렬, 하삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>과 상삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>로 분해하는 방법이다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{L} \mathbf{U}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{L} \mathbf{U}
</script>
</div>
<p>LU 분해는 역행렬 계산, 연립 방정식 해법 등에서 매우 유용하다. Eigen에서는 <code>.lu()</code> 메서드를 사용하여 LU 분해를 수행할 수 있다.</p>
<h4 id="qr">QR 분해</h4>
<p>QR 분해는 행렬을 직교행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>와 상삼각행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>로 분해하는 방법이다. 주어진 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 대해 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{Q} \mathbf{R}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{Q} \mathbf{R}
</script>
</div>
<p>QR 분해는 선형 회귀나 최소 제곱 문제에서 자주 사용된다. Eigen에서는 <code>.qr()</code> 메서드를 통해 쉽게 QR 분해를 수행할 수 있다.</p>
<h4 id="svd">SVD (특이값 분해)</h4>
<p>특이값 분해(SVD)는 임의의 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>를 세 개의 행렬, 직교 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U} \in \mathbb{R}^{m \times m}</span><script type="math/tex">\mathbf{U} \in \mathbb{R}^{m \times m}</script></span>, 대각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Sigma} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{\Sigma} \in \mathbb{R}^{m \times n}</script></span>, 직교 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}^T \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{V}^T \in \mathbb{R}^{n \times n}</script></span>로 분해하는 방법이다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^T
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^T
</script>
</div>
<p>특이값 분해는 데이터 분석, 신호 처리 등에서 자주 사용되며, Eigen에서는 <code>.svd()</code> 메서드를 통해 이를 쉽게 수행할 수 있다.</p>
<h3 id="8">8. 선형 방정식의 해법</h3>
<p>Eigen에서는 다양한 선형 방정식의 해법을 제공하여 복잡한 수학 문제를 쉽게 풀 수 있게 해준다. 일반적인 선형 방정식의 형태는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \mathbf{x} = \mathbf{b}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \mathbf{x} = \mathbf{b}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>은 계수 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{x} \in \mathbb{R}^n</script></span>은 미지수 벡터, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{b} \in \mathbb{R}^n</script></span>은 결과 벡터이다. 이 문제의 해를 찾는 방법은 다양하며, Eigen에서는 이를 위한 다양한 함수들이 제공된다.</p>
<h4 id="_7">직접 해법</h4>
<p>직접 해법은 LU 분해나 QR 분해와 같은 방법을 사용하여 선형 방정식을 푸는 방식이다. Eigen에서는 이러한 분해 방법을 사용하여 방정식을 풀 수 있다.</p>
<h4 id="_8">반복 해법</h4>
<p>큰 규모의 희소 행렬을 다룰 때는 직접 해법보다 반복 해법이 더 효율적일 수 있다. Eigen에서는 Conjugate Gradient(CGS), BiCGSTAB 등의 반복 해법을 제공하여 대규모 행렬에 대한 해를 빠르게 구할 수 있다.</p>
<h3 id="9">9. 행렬식 계산</h3>
<p>행렬의 행렬식은 행렬의 성질을 파악하는 중요한 도구 중 하나이다. 정방행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>의 행렬식 <span class="arithmatex"><span class="MathJax_Preview">\det(\mathbf{A})</span><script type="math/tex">\det(\mathbf{A})</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\det(\mathbf{A}) = \sum_{\sigma \in S_n} \text{sgn}(\sigma) \prod_{i=1}^{n} A_{i,\sigma(i)}
</div>
<script type="math/tex; mode=display">
\det(\mathbf{A}) = \sum_{\sigma \in S_n} \text{sgn}(\sigma) \prod_{i=1}^{n} A_{i,\sigma(i)}
</script>
</div>
<p>Eigen에서는 <code>.determinant()</code> 함수를 사용하여 쉽게 행렬식을 계산할 수 있다. 행렬식은 역행렬이 존재하는지 여부를 판단하거나, 선형 독립성 여부를 판단하는 데 유용하다.</p>
<h3 id="10">10. 희소 행렬 지원</h3>
<p>Eigen 라이브러리는 대규모 데이터를 다룰 때 중요한 희소 행렬(sparse matrix) 연산도 지원한다. 희소 행렬은 대부분의 원소가 0인 행렬을 말하며, 이러한 행렬을 효율적으로 저장하고 처리하기 위해 Eigen에서는 전용 자료 구조와 연산을 제공한다.</p>
<h4 id="_9">희소 행렬의 저장 방식</h4>
<p>희소 행렬은 주로 다음과 같은 방식으로 저장된다:</p>
<ul>
<li><strong>CSR(Compressed Sparse Row) 방식</strong>: 행을 기준으로 비-0 원소의 값과 인덱스를 저장한다.</li>
<li><strong>CSC(Compressed Sparse Column) 방식</strong>: 열을 기준으로 비-0 원소를 저장하는 방식이다.</li>
</ul>
<p>Eigen에서는 CSR 방식을 기본적으로 사용하며, <code>SparseMatrix</code> 클래스를 통해 희소 행렬을 다룰 수 있다.</p>
<h4 id="_10">희소 행렬의 연산</h4>
<p>희소 행렬 역시 기본적인 덧셈, 뺄셈, 곱셈 등의 연산이 가능하다. 예를 들어, 희소 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>에 대해 덧셈은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \mathbf{A} + \mathbf{B}
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \mathbf{A} + \mathbf{B}
</script>
</div>
<p>희소 행렬의 곱셈도 일반적인 행렬 곱셈과 동일하게 수행되지만, 비-0 원소들에 대해서만 연산이 이루어지므로 성능이 크게 향상된다.</p>
<h4 id="_11">희소 선형 방정식의 해법</h4>
<p>희소 행렬을 사용한 선형 방정식은 직접적인 방법보다는 반복적 방법을 통해 풀리는 경우가 많다. Eigen은 이러한 희소 선형 방정식에 적합한 다양한 알고리즘을 제공한다. 대표적으로는 Conjugate Gradient Method와 같은 반복적 방법이 있으며, 이는 매우 큰 희소 행렬을 효율적으로 처리할 수 있다.</p>
<p>Eigen에서는 희소 행렬을 위한 특별한 클래스와 함수가 제공되며, <code>.solve()</code>와 같은 함수를 통해 빠르고 효율적으로 해를 구할 수 있다.</p>
<h3 id="11">11. 행렬 크기 변경 및 초기화</h3>
<p>Eigen에서는 행렬의 크기를 동적으로 변경하거나 다양한 방식으로 초기화할 수 있는 기능을 제공한다.</p>
<h4 id="_12">크기 변경</h4>
<p>행렬이나 벡터의 크기를 동적으로 변경할 수 있으며, 이때 메모리 할당이 자동으로 관리된다. 예를 들어, 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 크기를 <span class="arithmatex"><span class="MathJax_Preview">m \times n</span><script type="math/tex">m \times n</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">p \times q</span><script type="math/tex">p \times q</script></span>로 변경하려면, 다음과 같이 <code>.resize()</code> 함수를 사용한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}.resize(p, q)
</div>
<script type="math/tex; mode=display">
\mathbf{A}.resize(p, q)
</script>
</div>
<p>이 연산은 기존에 저장된 값들이 새로운 크기에 맞게 재배치되거나 초기화된다.</p>
<h4 id="_13">초기화</h4>
<p>행렬이나 벡터를 0으로 초기화하거나, 랜덤 값으로 초기화할 수 있다. 예를 들어, 크기 <span class="arithmatex"><span class="MathJax_Preview">m \times n</span><script type="math/tex">m \times n</script></span>의 행렬을 0으로 초기화하려면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}.setZero(m, n)
</div>
<script type="math/tex; mode=display">
\mathbf{A}.setZero(m, n)
</script>
</div>
<p>랜덤 값으로 초기화하려면:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}.setRandom(m, n)
</div>
<script type="math/tex; mode=display">
\mathbf{A}.setRandom(m, n)
</script>
</div>
<p>또한, 특정 상수로 행렬을 초기화하려면 <code>.setConstant()</code> 함수를 사용할 수 있다.</p>
<h3 id="12">12. 블록 연산</h3>
<p>Eigen은 블록 연산을 통해 행렬의 일부분을 참조하거나 수정하는 기능을 제공한다. 이를 통해 큰 행렬에서 작은 부분만을 대상으로 연산을 수행할 수 있으며, 이는 계산 효율성을 높이는 데 큰 도움이 된다.</p>
<h4 id="_14">블록 참조</h4>
<p>주어진 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>에서 일부 행과 열을 참조하려면 <code>.block()</code> 함수를 사용할 수 있다. 예를 들어, 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 일부 블록 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B} \in \mathbb{R}^{p \times q}</span><script type="math/tex">\mathbf{B} \in \mathbb{R}^{p \times q}</script></span>는 다음과 같이 참조할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{B} = \mathbf{A}.block(i, j, p, q)
</div>
<script type="math/tex; mode=display">
\mathbf{B} = \mathbf{A}.block(i, j, p, q)
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>는 블록의 시작 행 인덱스, <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>는 시작 열 인덱스이며, <span class="arithmatex"><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>는 행의 수, <span class="arithmatex"><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>는 열의 수를 나타낸다.</p>
<h4 id="_15">블록 수정</h4>
<p>블록을 참조한 후, 해당 블록을 수정할 수도 있다. 예를 들어, 블록 내의 값을 모두 0으로 설정하려면 다음과 같이 할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}.block(i, j, p, q).setZero()
</div>
<script type="math/tex; mode=display">
\mathbf{A}.block(i, j, p, q).setZero()
</script>
</div>
<p>블록 연산은 큰 행렬을 다루는 경우 매우 유용하며, 데이터 분석, 컴퓨터 그래픽스 등 다양한 분야에서 사용된다.</p>
<h3 id="13-map">13. 맵핑(Map) 및 메모리 관리</h3>
<p>Eigen에서는 외부 데이터 배열을 행렬이나 벡터로 "맵핑"하는 기능을 제공하여, 복사 없이 외부 데이터를 사용 가능하게 한다. 이는 특히 메모리 효율성을 높이기 위한 중요한 기능이다.</p>
<h4 id="_16">맵핑 기능</h4>
<p>외부의 C++ 배열을 Eigen의 행렬이나 벡터로 변환하려면 <code>Map</code> 클래스를 사용할 수 있다. 예를 들어, 주어진 배열 <code>float data[4] = {1, 2, 3, 4};</code>을 벡터로 변환하려면 다음과 같이 한다:</p>
<pre><code class="language-cpp">Map&lt;Vector4f&gt; vec(data);
</code></pre>
<p>이렇게 하면 배열 <code>data</code>의 값이 <code>vec</code> 벡터로 맵핑된다. 이 과정에서 복사가 일어나지 않기 때문에 매우 효율적이다.</p>
<h4 id="_17">메모리 정렬</h4>
<p>Eigen은 성능을 최적화하기 위해 메모리 정렬을 고려한 데이터를 저장한다. 특히 대규모 행렬 연산에서는 메모리 정렬이 연산 성능에 중요한 영향을 미칠 수 있다. Eigen은 기본적으로 SSE(Single Instruction Multiple Data)나 AVX(Advanced Vector Extensions)와 같은 벡터화 연산을 지원하며, 이를 통해 성능을 극대화한다.</p>
<h3 id="14">14. 템플릿 지원</h3>
<p>Eigen은 C++ 템플릿 기반 라이브러리로, 행렬의 크기, 데이터 타입 등 다양한 파라미터를 템플릿을 통해 처리할 수 있다. 이는 정적 크기 행렬과 동적 크기 행렬을 모두 지원하는 유연성을 제공하며, 사용자 정의 타입의 데이터도 처리할 수 있다.</p>
<h4 id="_18">정적 크기와 동적 크기</h4>
<p>Eigen은 정적 크기 행렬과 동적 크기 행렬을 모두 지원한다. 정적 크기 행렬은 크기가 컴파일 시간에 고정되며, 이는 성능 최적화에 유리하다. 동적 크기 행렬은 런타임에 크기가 결정되며, 유연성이 높다. 예를 들어, 정적 크기 행렬은 다음과 같이 정의된다:</p>
<pre><code class="language-cpp">Matrix&lt;float, 3, 3&gt; mat;
</code></pre>
<p>동적 크기 행렬은 다음과 같이 정의된다:</p>
<pre><code class="language-cpp">MatrixXf mat;
</code></pre>
<p>템플릿 기반의 유연성을 활용하면, 사용자는 행렬의 데이터 타입도 템플릿으로 지정할 수 있어, 예를 들어 <code>double</code>, <code>float</code>뿐만 아니라 사용자 정의 데이터 타입으로도 연산이 가능하다. 이러한 기능 덕분에 Eigen은 수치 계산 라이브러리로서 높은 유연성과 성능을 제공하며, 다양한 응용 분야에서 활용될 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0102/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0102/" class="btn btn-xs btn-link">
        Eigen의 특징
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../01_preface_ko/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../01_preface_ko/" class="btn btn-xs btn-link">
        소개
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>