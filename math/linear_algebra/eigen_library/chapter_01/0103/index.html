<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/math/linear_algebra/eigen_library/chapter_01/0103/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>설치 및 환경 설정 - 소프트웨어 융합</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\uc124\uce58 \ubc29\ubc95", url: "#_top", children: [
              {title: "\ud328\ud0a4\uc9c0 \ub9e4\ub2c8\uc800\ub97c \uc0ac\uc6a9\ud55c \uc124\uce58", url: "#_2" },
              {title: "\uc18c\uc2a4 \ucf54\ub4dc \uc9c1\uc811 \ub2e4\uc6b4\ub85c\ub4dc \ubc0f \uc124\uce58", url: "#_3" },
          ]},
          {title: "\ud658\uacbd \uc124\uc815", url: "#_4", children: [
              {title: "C++ \ud504\ub85c\uc81d\ud2b8\uc5d0\uc11c\uc758 Eigen \uc124\uc815", url: "#c-eigen" },
              {title: "CMake\ub97c \uc774\uc6a9\ud55c \uc124\uc815", url: "#cmake" },
              {title: "Makefile\uc744 \uc774\uc6a9\ud55c \uc124\uc815", url: "#makefile" },
              {title: "IDE\uc5d0\uc11c\uc758 \ud658\uacbd \uc124\uc815", url: "#ide" },
          ]},
          {title: "Eigen\uc758 \ub514\ub809\ud1a0\ub9ac \uad6c\uc870", url: "#eigen", children: [
              {title: "\ubca1\ud130\uc640 \ud589\ub82c\uc758 \uc120\uc5b8", url: "#_5" },
              {title: "\ud589\ub82c\uacfc \ubca1\ud130\uc758 \uae30\ubcf8 \uc5f0\uc0b0", url: "#_6" },
          ]},
          {title: "\uba54\ubaa8\ub9ac \uad00\ub9ac\uc640 \uc131\ub2a5 \ucd5c\uc801\ud654", url: "#_10", children: [
              {title: "\uc9c0\uc5f0 \ud3c9\uac00", url: "#_11" },
              {title: "\uba54\ubaa8\ub9ac \uc815\ub82c", url: "#_12" },
              {title: "Eigen\uc5d0\uc11c\uc758 \ube14\ub85d \uc5f0\uc0b0", url: "#eigen_1" },
          ]},
          {title: "\uace0\uae09 \ubd84\ud574 \uae30\ubc95", url: "#_17", children: [
              {title: "LU \ubd84\ud574", url: "#lu" },
              {title: "QR \ubd84\ud574", url: "#qr" },
              {title: "Cholesky \ubd84\ud574", url: "#cholesky" },
              {title: "SVD (\ud2b9\uc774\uac12 \ubd84\ud574)", url: "#svd" },
              {title: "\uace0\uc720\uac12 \ubd84\ud574", url: "#_18" },
          ]},
          {title: "\uc218\uce58 \uc548\uc815\uc131\uacfc \uc5f0\uc0b0 \uc815\ud655\ub3c4", url: "#_19", children: [
              {title: "\uc870\uac74 \uc218", url: "#_20" },
              {title: "\uc815\uaddc \ubc29\uc815\uc2dd\uacfc \uc548\uc815\uc131", url: "#_21" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0104/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0104/" class="btn btn-xs btn-link">
        Eigen과 C++ 표준 라이브러리의 비교
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0102/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0102/" class="btn btn-xs btn-link">
        Eigen의 특징
      </a>
    </div>
    
  </div>

    

    <p>Eigen 라이브러리는 고성능 선형 대수 연산을 제공하는 C++ 템플릿 라이브러리로, 행렬 및 벡터 연산을 비롯하여 다양한 수학적 연산을 효율적으로 수행할 수 있다. Eigen을 사용하기 위해서는 먼저 환경 설정과 설치 과정을 정확하게 이해해야 한다. 이 섹션에서는 Eigen 라이브러리를 설치하고 환경을 설정하는 방법에 대해 설명하겠다.</p>
<h3 id="_1">설치 방법</h3>
<p>Eigen 라이브러리는 헤더 온리(header-only) 라이브러리이다. 즉, 라이브러리 자체를 설치할 필요 없이, 프로젝트에서 헤더 파일을 포함하는 것만으로도 사용할 수 있다. Eigen의 설치는 크게 두 가지 방법으로 나뉜다:</p>
<ol>
<li><strong>패키지 매니저를 사용한 설치</strong></li>
<li><strong>소스 코드 직접 다운로드 및 설치</strong></li>
</ol>
<h4 id="_2">패키지 매니저를 사용한 설치</h4>
<p>대부분의 리눅스 배포판에서는 <code>apt</code>, <code>yum</code> 등의 패키지 매니저를 통해 Eigen을 간편하게 설치할 수 있다. 이 방법은 Eigen을 최신 버전이 아니더라도 손쉽게 설치할 수 있다는 장점이 있다.</p>
<p>Ubuntu를 기준으로 한 설치 명령어는 다음과 같다:</p>
<pre><code class="language-bash">sudo apt-get install libeigen3-dev
</code></pre>
<p>이 명령어는 <code>eigen3</code> 디렉토리에 필요한 헤더 파일들을 설치한다. 설치 후, <code>#include &lt;Eigen/Dense&gt;</code>와 같은 방법으로 헤더 파일을 포함할 수 있다.</p>
<h4 id="_3">소스 코드 직접 다운로드 및 설치</h4>
<p>패키지 매니저에서 제공하는 버전보다 최신 버전을 사용하거나 특정한 목적을 위해 소스 코드를 직접 관리하고 싶은 경우, Eigen의 공식 GitHub 저장소나 <a href="https://eigen.tuxfamily.org/">Eigen 공식 홈페이지</a>에서 소스 코드를 다운로드할 수 있다.</p>
<pre><code class="language-bash">git clone https://gitlab.com/libeigen/eigen.git
</code></pre>
<p>다운로드한 후에는 프로젝트 디렉토리에서 Eigen 헤더 파일들을 참조할 수 있도록 설정해야 한다. 다운로드한 디렉토리 내의 <code>Eigen</code> 서브디렉토리를 프로젝트의 헤더 파일 경로에 추가한다. 이를 위해 다음과 같은 명령어를 프로젝트의 빌드 시스템에 추가할 수 있다.</p>
<ul>
<li>
<p><strong>CMake</strong>에서의 설정:
  <code>cmake
  include_directories("/path/to/eigen")</code></p>
</li>
<li>
<p><strong>Makefile</strong>에서의 설정:
  <code>make
  CXXFLAGS += -I/path/to/eigen</code></p>
</li>
</ul>
<h3 id="_4">환경 설정</h3>
<h4 id="c-eigen">C++ 프로젝트에서의 Eigen 설정</h4>
<p>Eigen은 헤더 파일만 포함하면 바로 사용할 수 있기 때문에 별도의 빌드 과정은 필요 없다. 그러나 프로젝트에서 적절한 환경 설정을 통해 효율적인 개발 환경을 구성할 수 있다. </p>
<p><strong>CMake</strong>와 <strong>Makefile</strong>은 대표적으로 사용되는 빌드 시스템이다. Eigen을 사용하는 프로젝트에서는 프로젝트의 빌드 시스템에서 헤더 경로를 설정하고, 필요에 따라 특정 옵션을 활성화할 수 있다.</p>
<h4 id="cmake">CMake를 이용한 설정</h4>
<p>CMake는 C++ 프로젝트에서 널리 사용되는 빌드 시스템이다. Eigen 라이브러리를 사용하는 프로젝트를 CMake로 설정할 때는 다음과 같은 방식으로 헤더 파일 경로를 추가한다:</p>
<ol>
<li>먼저, <code>find_package</code> 명령을 사용하여 Eigen을 찾는다. 만약 시스템에 Eigen이 설치되어 있다면 CMake는 이를 자동으로 검색한다.</li>
</ol>
<p><code>cmake
   find_package(Eigen3 REQUIRED)</code></p>
<ol>
<li>이후, <code>target_link_libraries</code>를 통해 라이브러리를 링크한다. 그러나 Eigen은 헤더 온리 라이브러리이므로, 실제로는 링크할 대상이 없다. 대신 <code>target_include_directories</code>로 헤더 파일 경로를 명시해준다:</li>
</ol>
<p><code>cmake
   target_include_directories(${PROJECT_NAME} PRIVATE${EIGEN3_INCLUDE_DIR})</code></p>
<p>이로써 CMake를 통해 프로젝트 내에서 Eigen을 사용할 준비가 완료된다. CMake는 프로젝트의 모든 파일에서 <code>#include &lt;Eigen/Dense&gt;</code>를 통해 Eigen 헤더 파일을 사용할 수 있도록 환경을 구성한다.</p>
<h4 id="makefile">Makefile을 이용한 설정</h4>
<p>Makefile을 사용하는 프로젝트에서 Eigen을 설정하는 과정은 매우 간단한다. Makefile의 컴파일 옵션에 헤더 파일 경로를 추가하는 방식이다. 다음은 간단한 예시이다:</p>
<pre><code class="language-makefile">CXX = g++
CXXFLAGS = -I/path/to/eigen

main: main.o
    $(CXX) -o main main.o$(CXXFLAGS)

main.o: main.cpp
    $(CXX) -c main.cpp$(CXXFLAGS)
</code></pre>
<p>이 설정을 통해, <code>main.cpp</code> 파일에서 Eigen 헤더 파일을 사용할 수 있다.</p>
<h4 id="ide">IDE에서의 환경 설정</h4>
<p>Eigen을 사용하는 C++ 프로젝트를 개발할 때, IDE를 활용하면 더욱 편리하게 개발할 수 있다. 대표적인 C++ IDE로는 <strong>Visual Studio</strong>, <strong>CLion</strong>, <strong>Eclipse CDT</strong> 등이 있다. 각 IDE에서 Eigen을 설정하는 방법은 다음과 같다.</p>
<h5 id="visual-studio-eigen">Visual Studio에서 Eigen 설정</h5>
<p>Visual Studio에서 Eigen 라이브러리를 사용하려면, 프로젝트 설정에 헤더 파일 경로를 추가해야 한다. Visual Studio에서는 다음과 같은 절차로 설정할 수 있다:</p>
<ol>
<li><strong>프로젝트 속성(Project Properties)</strong>으로 이동한다.</li>
<li><strong>C/C++ → 일반(General)</strong> 항목으로 이동하여 <strong>추가 포함 디렉터리(Additional Include Directories)</strong>에 Eigen 헤더 파일 경로를 추가한다. 예를 들어, 소스 코드를 다운로드한 경우 <code>C:/path/to/eigen</code>과 같은 경로를 추가한다.</li>
<li><strong>확인(OK)</strong> 버튼을 눌러 설정을 저장하고, 프로젝트에서 Eigen을 사용할 수 있다.</li>
</ol>
<p>이제 프로젝트 내에서 <code>#include &lt;Eigen/Dense&gt;</code>와 같은 방식으로 Eigen 라이브러리를 사용할 수 있다.</p>
<h5 id="clion-eigen">CLion에서 Eigen 설정</h5>
<p>CLion은 기본적으로 CMake를 사용하여 프로젝트를 관리하므로, 이전에 설명한 CMake 설정 방법을 그대로 적용할 수 있다. 다음은 CLion에서 Eigen을 설정하는 방법이다:</p>
<ol>
<li>프로젝트의 <strong>CMakeLists.txt</strong> 파일을 엽니다.</li>
<li><code>find_package(Eigen3 REQUIRED)</code>와 <code>target_include_directories</code> 명령을 추가하여 Eigen 헤더 파일 경로를 지정한다.</li>
<li>CLion은 <code>CMakeLists.txt</code>를 자동으로 분석하고, 설정한 헤더 파일 경로를 사용하여 Eigen 라이브러리를 참조한다.</li>
</ol>
<p>이후 CLion의 코드 편집기에서 Eigen 관련 함수 및 클래스에 대한 자동 완성 기능과 오류 탐지가 활성화된다.</p>
<h5 id="eclipse-cdt-eigen">Eclipse CDT에서 Eigen 설정</h5>
<p>Eclipse CDT에서도 Eigen을 사용하기 위해 헤더 파일 경로를 지정해야 한다. Eclipse에서 설정하는 방법은 다음과 같다:</p>
<ol>
<li><strong>프로젝트 속성(Project Properties)</strong>을 엽니다.</li>
<li><strong>C/C++ General → Paths and Symbols</strong>로 이동한다.</li>
<li><strong>Includes</strong> 탭에서 <strong>GNU C++</strong>을 선택한 후, <strong>Add</strong> 버튼을 클릭하여 Eigen 헤더 파일 경로를 추가한다.</li>
<li>소스 코드 다운로드 경로나 패키지 매니저를 통해 설치된 경로를 지정한다. 예를 들어, <code>/usr/include/eigen3</code>와 같은 경로를 추가한다.</li>
</ol>
<p>이 설정을 완료한 후, 프로젝트 내에서 Eigen을 사용할 수 있다.</p>
<h3 id="eigen">Eigen의 디렉토리 구조</h3>
<p>Eigen 라이브러리는 다양한 기능을 제공하며, 이를 효율적으로 관리하기 위해 헤더 파일들이 여러 디렉토리에 분산되어 있다. 주요 디렉토리 구조는 다음과 같다:</p>
<pre><code class="language-plaintext">eigen/
│
├── Dense
├── Core
├── Geometry
├── LU
├── Cholesky
├── SVD
├── QR
└── Eigenvalues
</code></pre>
<p>각각의 디렉토리는 Eigen에서 제공하는 특정 기능을 담당한다. 예를 들어:</p>
<ul>
<li><code>Dense</code>: 기본적인 밀집 행렬 연산과 벡터 연산을 위한 헤더 파일들이 위치한다.</li>
<li><code>Core</code>: 기본적인 선형 대수 연산을 지원하는 핵심적인 헤더 파일들이 포함되어 있다.</li>
<li><code>Geometry</code>: 3D 변환, 회전 행렬, 쿼터니언과 같은 기하학적 연산에 관련된 헤더 파일들이 포함된다.</li>
<li><code>LU</code>, <code>Cholesky</code>, <code>SVD</code>, <code>QR</code>: 각각 LU 분해, Cholesky 분해, 특이값 분해(SVD), QR 분해에 관련된 기능을 제공한다.</li>
<li><code>Eigenvalues</code>: 행렬의 고유값과 고유벡터를 구하는 데 필요한 함수들이 포함되어 있다.</li>
</ul>
<p>각 헤더 파일은 필요에 따라 선택적으로 포함하여 사용할 수 있으며, <code>#include &lt;Eigen/Dense&gt;</code>와 같은 방식으로 모든 기능을 한 번에 가져오는 방법도 가능한다.</p>
<h4 id="_5">벡터와 행렬의 선언</h4>
<p>Eigen에서는 벡터와 행렬을 선언하는 것이 매우 직관적이다. <code>VectorXd</code>, <code>MatrixXd</code> 등의 클래스 템플릿을 사용하여 다양한 크기의 벡터와 행렬을 선언할 수 있다. 예를 들어, 다음과 같은 코드로 크기가 3인 벡터를 선언할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Vector3d v;
</code></pre>
<p>이 코드는 3차원 실수 벡터를 선언한다. 만약 3x3 실수 행렬을 선언하고 싶다면, 다음과 같이 작성할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d m;
</code></pre>
<p>보다 일반적인 크기의 벡터나 행렬을 선언할 때는 다음과 같은 템플릿을 사용할 수 있다:</p>
<pre><code class="language-cpp">Eigen::VectorXd v(n);  // 크기가 n인 벡터
Eigen::MatrixXd m(n, m);  // 크기가 n x m인 행렬
</code></pre>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>은 행렬의 행과 열을 나타낸다.</p>
<h4 id="_6">행렬과 벡터의 기본 연산</h4>
<p>Eigen에서는 행렬과 벡터의 기본적인 연산이 매우 간단하게 처리된다. 예를 들어, 덧셈, 뺄셈, 곱셈 등의 연산은 직관적인 연산자 오버로딩을 통해 C++ 코드에서 자연스럽게 사용할 수 있다.</p>
<h5 id="_7">벡터 연산</h5>
<p>다음은 Eigen을 사용하여 벡터 간의 기본적인 연산을 수행하는 예시이다:</p>
<pre><code class="language-cpp">Eigen::Vector3d v1(1.0, 2.0, 3.0);
Eigen::Vector3d v2(4.0, 5.0, 6.0);

// 벡터 덧셈
Eigen::Vector3d v3 = v1 + v2;

// 벡터 스칼라 곱
Eigen::Vector3d v4 = v1 * 2.0;

// 벡터 내적
double dot_product = v1.dot(v2);

// 벡터 외적
Eigen::Vector3d cross_product = v1.cross(v2);
</code></pre>
<p>위 코드는 벡터의 덧셈, 스칼라 곱, 내적, 외적 연산을 보여준다. 벡터 내적은 <code>dot()</code> 함수를, 외적은 <code>cross()</code> 함수를 통해 수행된다. 또한, 스칼라 곱은 <code>*</code> 연산자를 사용하여 쉽게 구현할 수 있다.</p>
<h5 id="_8">행렬 연산</h5>
<p>행렬에 대해서도 마찬가지로 덧셈, 뺄셈, 곱셈, 전치 등의 연산을 매우 간단하게 수행할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d m1;
m1 &lt;&lt; 1, 2, 3,
      4, 5, 6,
      7, 8, 9;

Eigen::Matrix3d m2;
m2 &lt;&lt; 9, 8, 7,
      6, 5, 4,
      3, 2, 1;

// 행렬 덧셈
Eigen::Matrix3d m3 = m1 + m2;

// 행렬 곱셈
Eigen::Matrix3d m4 = m1 * m2;

// 행렬 전치
Eigen::Matrix3d m5 = m1.transpose();
</code></pre>
<p>위 코드에서 <code>&lt;&lt;</code> 연산자는 행렬에 값을 한 번에 할당하는 데 사용된다. 행렬 간의 덧셈, 곱셈 연산은 각각 <code>+</code>와 <code>*</code> 연산자를 통해 간단하게 수행되며, 행렬의 전치는 <code>transpose()</code> 함수를 사용하여 수행할 수 있다.</p>
<h5 id="_9">행렬과 벡터 곱셈</h5>
<p>Eigen에서 행렬과 벡터의 곱셈은 자연스러운 방식으로 처리된다. 다음은 <span class="arithmatex"><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> 행렬과 3차원 벡터 간의 곱셈 예시이다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d m;
m &lt;&lt; 1, 2, 3,
     4, 5, 6,
     7, 8, 9;

Eigen::Vector3d v(1, 2, 3);

// 행렬과 벡터 곱셈
Eigen::Vector3d result = m * v;
</code></pre>
<p>위 코드는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{m}</span><script type="math/tex">\mathbf{m}</script></span>와 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>의 곱을 계산한다. 수학적으로 이는 다음과 같은 연산에 해당한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{m} \mathbf{v} = 
\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
7 &amp; 8 &amp; 9
\end{pmatrix}
\begin{pmatrix}
1 \\
2 \\
3
\end{pmatrix}
=
\begin{pmatrix}
14 \\
32 \\
50
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{m} \mathbf{v} = 
\begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{pmatrix}
\begin{pmatrix}
1 \\
2 \\
3
\end{pmatrix}
=
\begin{pmatrix}
14 \\
32 \\
50
\end{pmatrix}
</script>
</div>
<p>이처럼, Eigen에서는 행렬과 벡터 간의 곱셈도 직관적으로 작성할 수 있다.</p>
<h3 id="_10">메모리 관리와 성능 최적화</h3>
<p>Eigen은 성능을 극대화하기 위해 메모리 관리와 관련하여 여러 가지 최적화 기능을 제공한다. 특히, 자동으로 표현식을 평가하지 않고, 이를 늦추는 방식을 사용하여 불필요한 메모리 할당을 줄이는 <strong>지연 평가(Lazy Evaluation)</strong>가 중요한 역할을 한다.</p>
<h4 id="_11">지연 평가</h4>
<p>지연 평가란, 연산을 즉시 수행하지 않고, 필요할 때까지 연산을 미루는 방식이다. 이로 인해 메모리 사용을 최소화하면서도 효율적으로 연산을 수행할 수 있다.</p>
<p>예를 들어, 다음과 같은 코드를 고려해 봅시다:</p>
<pre><code class="language-cpp">Eigen::MatrixXd m1(1000, 1000);
Eigen::MatrixXd m2(1000, 1000);
Eigen::MatrixXd m3(1000, 1000);

// 세 행렬의 덧셈
Eigen::MatrixXd result = m1 + m2 + m3;
</code></pre>
<p>일반적으로는 두 행렬의 덧셈 결과를 먼저 계산한 후, 그 결과와 다른 행렬을 다시 더하는 방식으로 진행된다. 그러나 Eigen에서는 지연 평가를 통해 중간 결과를 저장하지 않고, 최종 결과만 계산할 수 있다. 이를 통해 중간에 불필요한 메모리 사용을 피할 수 있다.</p>
<h4 id="_12">메모리 정렬</h4>
<p>Eigen은 성능을 높이기 위해 메모리 정렬(memory alignment)을 지원한다. Eigen에서 사용되는 모든 동적 할당된 메모리는 16바이트 경계로 정렬되며, 이를 통해 SIMD(단일 명령 다중 데이터) 명령어 세트를 효율적으로 사용할 수 있다. </p>
<p>다음은 정렬된 메모리를 사용하는 예시이다:</p>
<pre><code class="language-cpp">Eigen::Matrix&lt;float, Eigen::Dynamic, Eigen::Dynamic, Eigen::AutoAlign&gt; matrix;
</code></pre>
<p><code>Eigen::AutoAlign</code> 옵션은 메모리를 자동으로 정렬하여 성능을 최적화한다.</p>
<h4 id="eigen_1">Eigen에서의 블록 연산</h4>
<p>행렬의 일부 블록에 접근하고 연산하는 것은 수치 해석에서 매우 중요한 작업이다. Eigen은 이러한 블록 연산을 쉽게 처리할 수 있는 기능을 제공한다. 이를 통해 큰 행렬을 작은 부분으로 나누어 처리하거나, 부분 행렬을 수정할 수 있다.</p>
<h5 id="_13">블록 접근</h5>
<p>Eigen에서 블록을 접근하기 위해서는 <code>block()</code> 함수를 사용할 수 있다. 이 함수는 행렬의 특정 부분에 접근할 수 있도록 해준다. 다음은 블록 접근의 예시이다:</p>
<pre><code class="language-cpp">Eigen::Matrix4d m;
m &lt;&lt; 1, 2, 3, 4,
     5, 6, 7, 8,
     9, 10, 11, 12,
     13, 14, 15, 16;

// 2x2 블록에 접근
Eigen::Matrix2d sub_matrix = m.block&lt;2, 2&gt;(1, 1);
</code></pre>
<p>위 코드는 <span class="arithmatex"><span class="MathJax_Preview">4 \times 4</span><script type="math/tex">4 \times 4</script></span> 행렬에서 <span class="arithmatex"><span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script></span> 블록을 추출하는 예시이다. <code>m.block&lt;2, 2&gt;(1, 1)</code>은 행렬 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>에서 (1, 1) 위치에서 시작하는 <span class="arithmatex"><span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script></span> 크기의 부분 행렬을 추출한다. 결과는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{sub\_matrix} = 
\begin{pmatrix}
6 &amp; 7 \\
10 &amp; 11
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{sub\_matrix} = 
\begin{pmatrix}
6 & 7 \\
10 & 11
\end{pmatrix}
</script>
</div>
<h5 id="_14">블록 수정</h5>
<p>블록 연산을 통해 행렬의 특정 부분을 수정할 수도 있다. 다음은 특정 블록을 수정하는 예시이다:</p>
<pre><code class="language-cpp">Eigen::Matrix4d m;
m &lt;&lt; 1, 2, 3, 4,
     5, 6, 7, 8,
     9, 10, 11, 12,
     13, 14, 15, 16;

// 2x2 블록에 값 할당
m.block&lt;2, 2&gt;(1, 1) &lt;&lt; 0, 0,
                       0, 0;
</code></pre>
<p>위 코드는 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> 행렬의 (1, 1) 위치에서 시작하는 <span class="arithmatex"><span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script></span> 블록에 새로운 값을 할당한다. 수정된 행렬은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{m} = 
\begin{pmatrix}
1 &amp; 2 &amp; 3 &amp; 4 \\
5 &amp; 0 &amp; 0 &amp; 8 \\
9 &amp; 0 &amp; 0 &amp; 12 \\
13 &amp; 14 &amp; 15 &amp; 16
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{m} = 
\begin{pmatrix}
1 & 2 & 3 & 4 \\
5 & 0 & 0 & 8 \\
9 & 0 & 0 & 12 \\
13 & 14 & 15 & 16
\end{pmatrix}
</script>
</div>
<p>이처럼, 블록 연산을 사용하면 큰 행렬의 부분적인 연산을 매우 효율적으로 처리할 수 있다.</p>
<h5 id="_15">행 및 열 추출</h5>
<p>Eigen에서는 행렬의 특정 행이나 열에 쉽게 접근할 수 있는 함수도 제공한다. <code>row()</code>와 <code>col()</code> 함수를 사용하여 행렬의 특정 행 또는 열에 접근할 수 있다.</p>
<p>예를 들어, <span class="arithmatex"><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> 행렬의 첫 번째 행과 두 번째 열을 추출하려면 다음과 같이 작성할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d m;
m &lt;&lt; 1, 2, 3,
     4, 5, 6,
     7, 8, 9;

// 첫 번째 행 추출
Eigen::Vector3d first_row = m.row(0);

// 두 번째 열 추출
Eigen::Vector3d second_col = m.col(1);
</code></pre>
<p>위 코드에서 <code>m.row(0)</code>은 첫 번째 행인 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{[1, 2, 3]}</span><script type="math/tex">\mathbf{[1, 2, 3]}</script></span>을, <code>m.col(1)</code>은 두 번째 열인 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{[2, 5, 8]}</span><script type="math/tex">\mathbf{[2, 5, 8]}</script></span>을 각각 반환한다.</p>
<h5 id="_16">행렬 대각선 접근</h5>
<p>Eigen에서는 행렬의 대각선 요소에 접근하거나 대각선 요소를 설정하는 것도 매우 간단한다. 다음은 대각선 접근과 수정의 예시이다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d m;
m &lt;&lt; 1, 2, 3,
     4, 5, 6,
     7, 8, 9;

// 대각선 추출
Eigen::Vector3d diag = m.diagonal();

// 대각선 수정
m.diagonal() &lt;&lt; 10, 11, 12;
</code></pre>
<p>위 코드에서 <code>m.diagonal()</code> 함수는 행렬 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>의 대각선 요소인 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{[1, 5, 9]}</span><script type="math/tex">\mathbf{[1, 5, 9]}</script></span>을 추출한다. 또한, 대각선을 수정하여 <span class="arithmatex"><span class="MathJax_Preview">10, 11, 12</span><script type="math/tex">10, 11, 12</script></span>로 변경할 수 있다. 수정된 행렬은 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{m} = 
\begin{pmatrix}
10 &amp; 2 &amp; 3 \\
4 &amp; 11 &amp; 6 \\
7 &amp; 8 &amp; 12
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{m} = 
\begin{pmatrix}
10 & 2 & 3 \\
4 & 11 & 6 \\
7 & 8 & 12
\end{pmatrix}
</script>
</div>
<h3 id="_17">고급 분해 기법</h3>
<p>Eigen은 다양한 행렬 분해 기법을 제공한다. 이러한 기법들은 선형 시스템의 해를 구하거나, 고유값 문제를 해결하는 데 필수적이다. Eigen이 제공하는 주요 분해 기법으로는 <strong>LU 분해</strong>, <strong>QR 분해</strong>, <strong>Cholesky 분해</strong>, <strong>SVD (특이값 분해)</strong> 등이 있다.</p>
<h4 id="lu">LU 분해</h4>
<p>LU 분해는 행렬을 하삼각 행렬(Lower triangular matrix)과 상삼각 행렬(Upper triangular matrix)로 분해하는 방법이다. Eigen에서는 <code>PartialPivLU</code> 클래스가 LU 분해를 수행한다.</p>
<pre><code class="language-cpp">Eigen::Matrix3d m;
m &lt;&lt; 2, -1, 0,
     -1, 2, -1,
     0, -1, 2;

Eigen::PartialPivLU&lt;Eigen::Matrix3d&gt; lu(m);
Eigen::Matrix3d L = lu.matrixL();
Eigen::Matrix3d U = lu.matrixU();
</code></pre>
<p>위 코드는 행렬 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>에 대해 LU 분해를 수행한다. 결과는 다음과 같이 하삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span>과 상삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">U</span><script type="math/tex">U</script></span>로 나뉜다.</p>
<h4 id="qr">QR 분해</h4>
<p>QR 분해는 행렬을 직교 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>와 상삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>로 분해하는 방법이다. QR 분해는 선형 시스템의 해를 구하는 데 매우 유용하다. Eigen에서는 <code>HouseholderQR</code> 클래스를 사용하여 QR 분해를 수행한다.</p>
<pre><code class="language-cpp">Eigen::MatrixXd m(3, 2);
m &lt;&lt; 1, 2,
     3, 4,
     5, 6;

Eigen::HouseholderQR&lt;Eigen::MatrixXd&gt; qr(m);
Eigen::MatrixXd Q = qr.householderQ();
Eigen::MatrixXd R = qr.matrixQR().template triangularView&lt;Eigen::Upper&gt;();
</code></pre>
<p>이 코드는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>을 구하는 과정이다.</p>
<h4 id="cholesky">Cholesky 분해</h4>
<p>Cholesky 분해는 양의 정부호(positive definite) 행렬을 하삼각 행렬과 그 전치 행렬의 곱으로 분해하는 방법이다. 이 분해는 주로 대칭 행렬이나 양의 정부호 행렬을 다룰 때 사용된다. Eigen에서는 <code>LLT</code> 클래스와 <code>LDLT</code> 클래스를 사용하여 Cholesky 분해를 수행할 수 있다.</p>
<h5 id="llt">LLT 분해</h5>
<p>LLT 분해는 행렬을 하삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>과 그 전치 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}^T</span><script type="math/tex">\mathbf{L}^T</script></span>로 분해하는 방식이다.</p>
<p>다음은 LLT 분해를 수행하는 예시이다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d m;
m &lt;&lt; 4, 1, 2,
     1, 2, 0,
     2, 0, 3;

Eigen::LLT&lt;Eigen::Matrix3d&gt; llt(m);
Eigen::Matrix3d L = llt.matrixL();
</code></pre>
<p>위 코드는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{m}</span><script type="math/tex">\mathbf{m}</script></span> 행렬에 대해 LLT 분해를 수행한다. 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>은 하삼각 행렬로, 다음과 같은 형태로 나타난다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{L} = 
\begin{pmatrix}
2 &amp; 0 &amp; 0 \\
0.5 &amp; 1.3228756555322954 &amp; 0 \\
1 &amp; -0.3779644730092272 &amp; 1.4907119849998598
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{L} = 
\begin{pmatrix}
2 & 0 & 0 \\
0.5 & 1.3228756555322954 & 0 \\
1 & -0.3779644730092272 & 1.4907119849998598
\end{pmatrix}
</script>
</div>
<p>이때 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{m}</span><script type="math/tex">\mathbf{m}</script></span>은 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L} \mathbf{L}^T</span><script type="math/tex">\mathbf{L} \mathbf{L}^T</script></span>로 표현될 수 있다.</p>
<h5 id="ldlt">LDLT 분해</h5>
<p>LDLT 분해는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{m}</span><script type="math/tex">\mathbf{m}</script></span>을 하삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>, 대각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>, 그리고 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}^T</span><script type="math/tex">\mathbf{L}^T</script></span>로 분해하는 방식이다. LDLT 분해는 Cholesky 분해와 유사하지만, 대칭이지만 양의 정부호가 아닌 행렬에도 적용 가능한다.</p>
<p>다음은 LDLT 분해를 수행하는 예시이다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d m;
m &lt;&lt; 4, 1, 2,
     1, 2, 0,
     2, 0, 3;

Eigen::LDLT&lt;Eigen::Matrix3d&gt; ldlt(m);
Eigen::Matrix3d L = ldlt.matrixL();
Eigen::Matrix3d D = ldlt.vectorD().asDiagonal();
</code></pre>
<p>이 코드는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{m}</span><script type="math/tex">\mathbf{m}</script></span>에 대해 LDLT 분해를 수행하고, 하삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>과 대각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{D}</span><script type="math/tex">\mathbf{D}</script></span>를 구하는 과정을 보여준다.</p>
<h4 id="svd">SVD (특이값 분해)</h4>
<p>SVD는 행렬을 세 개의 행렬의 곱으로 분해하는 방법으로, 수치 해석에서 매우 중요한 기법이다. 특이값 분해는 다음과 같은 형태로 행렬을 분해한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^T
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^T
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>는 직교 행렬이다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Sigma}</span><script type="math/tex">\mathbf{\Sigma}</script></span>는 대각 행렬로, 대각선에는 특이값이 들어간다.
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}</span><script type="math/tex">\mathbf{V}</script></span>는 직교 행렬이다.</p>
<p>Eigen에서는 <code>JacobiSVD</code> 클래스를 사용하여 특이값 분해를 수행한다.</p>
<p>다음은 SVD를 수행하는 예시이다:</p>
<pre><code class="language-cpp">Eigen::MatrixXd m(3, 2);
m &lt;&lt; 1, 0,
     0, 1,
     1, 1;

Eigen::JacobiSVD&lt;Eigen::MatrixXd&gt; svd(m, Eigen::ComputeThinU | Eigen::ComputeThinV);
Eigen::MatrixXd U = svd.matrixU();
Eigen::MatrixXd S = svd.singularValues().asDiagonal();
Eigen::MatrixXd V = svd.matrixV();
</code></pre>
<p>이 코드는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{m}</span><script type="math/tex">\mathbf{m}</script></span>에 대해 SVD를 수행하고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Sigma}</span><script type="math/tex">\mathbf{\Sigma}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}</span><script type="math/tex">\mathbf{V}</script></span> 행렬을 추출한다. 특이값 분해는 주로 차원 축소나 데이터 분석에서 사용되며, 매우 중요한 역할을 한다.</p>
<h4 id="_18">고유값 분해</h4>
<p>고유값 분해는 정사각 행렬의 고유값과 고유벡터를 구하는 방법이다. 고유값과 고유벡터는 선형 시스템의 해석, 미분 방정식의 해 구하기, 안정성 분석 등에 사용된다.</p>
<p>Eigen에서는 <code>EigenSolver</code> 클래스를 사용하여 고유값 분해를 수행할 수 있다.</p>
<p>다음은 고유값 분해를 수행하는 예시이다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d m;
m &lt;&lt; 1, 2, 3,
     0, 4, 5,
     0, 0, 6;

Eigen::EigenSolver&lt;Eigen::Matrix3d&gt; solver(m);
Eigen::Vector3d eigenvalues = solver.eigenvalues().real();
Eigen::Matrix3d eigenvectors = solver.eigenvectors().real();
</code></pre>
<p>위 코드는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{m}</span><script type="math/tex">\mathbf{m}</script></span>의 고유값과 고유벡터를 계산하는 과정이다. 고유값은 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{eigenvalues}</span><script type="math/tex">\mathbf{eigenvalues}</script></span>에, 고유벡터는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{eigenvectors}</span><script type="math/tex">\mathbf{eigenvectors}</script></span>에 저장된다. 계산된 고유값은 대각 행렬의 대각선에 위치하며, 고유벡터는 행렬의 열로 배치된다.</p>
<h3 id="_19">수치 안정성과 연산 정확도</h3>
<p>Eigen 라이브러리는 다양한 수치 해석 문제를 효율적으로 해결할 수 있지만, 수치 안정성과 연산 정확도에도 주의가 필요하다. 특히 큰 행렬이나 조건 수가 나쁜 행렬을 다룰 때는 부동소수점 오차나 불안정성이 발생할 수 있다.</p>
<h4 id="_20">조건 수</h4>
<p>행렬의 조건 수는 행렬이 얼마나 민감한지를 나타내는 지표이다. 조건 수가 크면 수치적으로 불안정한 행렬일 가능성이 높다. 조건 수는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\kappa(\mathbf{A}) = \|\mathbf{A}\| \|\mathbf{A}^{-1}\|
</div>
<script type="math/tex; mode=display">
\kappa(\mathbf{A}) = \|\mathbf{A}\| \|\mathbf{A}^{-1}\|
</script>
</div>
<p>Eigen에서 조건 수를 계산하는 방법은 다음과 같다:</p>
<pre><code class="language-cpp">Eigen::MatrixXd m(2, 2);
m &lt;&lt; 1, 2,
     3, 4;

double cond = m.jacobiSvd().singularValues()(0) / m.jacobiSvd().singularValues()(1);
</code></pre>
<p>위 코드는 SVD를 사용하여 행렬의 조건 수를 계산하는 방법을 보여준다.</p>
<h4 id="_21">정규 방정식과 안정성</h4>
<p>일반적으로, 선형 시스템을 풀 때는 직접적인 역행렬 계산을 피해야 한다. 대신, LU 분해, QR 분해, Cholesky 분해와 같은 분해 기법을 사용하는 것이 수치적으로 더 안정적이다.</p>
<p>정규 방정식 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}^T \mathbf{A} \mathbf{x} = \mathbf{A}^T \mathbf{b}</span><script type="math/tex">\mathbf{A}^T \mathbf{A} \mathbf{x} = \mathbf{A}^T \mathbf{b}</script></span>를 사용하는 것은 수치적으로 불안정할 수 있으며, 가급적 QR 분해나 SVD를 사용하는 것이 좋다. 이를 통해 계산의 안정성과 정확도를 높일 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0104/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0104/" class="btn btn-xs btn-link">
        Eigen과 C++ 표준 라이브러리의 비교
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0102/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0102/" class="btn btn-xs btn-link">
        Eigen의 특징
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>