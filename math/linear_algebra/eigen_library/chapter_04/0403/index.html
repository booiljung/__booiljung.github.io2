<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/math/linear_algebra/eigen_library/chapter_04/0403/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>벡터의 정규화 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ubca1\ud130\uc758 \uc815\uaddc\ud654", url: "#_top", children: [
              {title: "\ubca1\ud130\uc758 \uc815\uaddc\ud654 \uc815\uc758", url: "#_2" },
              {title: "\ubca1\ud130 \ud06c\uae30\uc758 \uacc4\uc0b0", url: "#_3" },
              {title: "Eigen\uc744 \ud65c\uc6a9\ud55c \ubca1\ud130 \uc815\uaddc\ud654", url: "#eigen" },
              {title: "\uc815\uaddc\ud654 \ubca1\ud130\uc758 \uc131\uc9c8", url: "#_4" },
              {title: "\ud2b9\uc218\ud55c \uacbd\uc6b0\uc758 \ubca1\ud130 \uc815\uaddc\ud654", url: "#_5" },
              {title: "Eigen \ub77c\uc774\ube0c\ub7ec\ub9ac\uc5d0\uc11c\uc758 \uc8fc\uc758 \uc0ac\ud56d", url: "#eigen_1" },
              {title: "\ub2e4\ucc28\uc6d0 \ubca1\ud130 \uc815\uaddc\ud654", url: "#_6" },
              {title: "\ubca1\ud130 \uc815\uaddc\ud654\uc758 \uc2e4\uc81c \uc751\uc6a9", url: "#_7" },
              {title: "Eigen\uc5d0\uc11c \ub2e4\ucc28\uc6d0 \ubca1\ud130\ub97c \ud65c\uc6a9\ud55c \uc751\uc6a9 \uc608\uc2dc", url: "#eigen_2" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <h1 id="_1">벡터의 정규화</h1>
<h3 id="_2">벡터의 정규화 정의</h3>
<p>벡터의 정규화는 주어진 벡터를 동일한 방향을 유지하면서 그 크기를 1로 만드는 작업이다. 이를 통해 벡터를 단위 벡터로 변환할 수 있다. 정규화는 컴퓨터 그래픽스, 물리 시뮬레이션, 데이터 과학 등 여러 응용 분야에서 필수적인 연산 중 하나로 사용된다. </p>
<p>수학적으로, 임의의 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} </span><script type="math/tex"> \mathbf{v} </script></span>의 정규화는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\hat{v}} = \frac{\mathbf{v}}{\|\mathbf{v}\|}
</div>
<script type="math/tex; mode=display">
\mathbf{\hat{v}} = \frac{\mathbf{v}}{\|\mathbf{v}\|}
</script>
</div>
<p>여기서:</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} </span><script type="math/tex"> \mathbf{v} </script></span>는 정규화할 벡터이다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview"> \mathbf{\hat{v}} </span><script type="math/tex"> \mathbf{\hat{v}} </script></span>는 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} </span><script type="math/tex"> \mathbf{v} </script></span>의 정규화된 벡터이다.</li>
<li><span class="arithmatex"><span class="MathJax_Preview"> \|\mathbf{v}\| </span><script type="math/tex"> \|\mathbf{v}\| </script></span>는 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} </span><script type="math/tex"> \mathbf{v} </script></span>의 크기(또는 노름)로, 다음과 같이 계산된다:</li>
</ul>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{v}\| = \sqrt{v_1^2 + v_2^2 + \cdots + v_n^2}
</div>
<script type="math/tex; mode=display">
\|\mathbf{v}\| = \sqrt{v_1^2 + v_2^2 + \cdots + v_n^2}
</script>
</div>
<p>즉, 벡터의 각 성분의 제곱의 합에 대한 제곱근이 벡터의 크기가 된다.</p>
<h3 id="_3">벡터 크기의 계산</h3>
<p>벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} </span><script type="math/tex"> \mathbf{v} </script></span>의 크기, 즉 노름은 벡터의 유클리드 거리로 정의된다. n-차원 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} = [v_1, v_2, \cdots, v_n] </span><script type="math/tex"> \mathbf{v} = [v_1, v_2, \cdots, v_n] </script></span>의 크기는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{v}\| = \sqrt{v_1^2 + v_2^2 + \cdots + v_n^2}
</div>
<script type="math/tex; mode=display">
\|\mathbf{v}\| = \sqrt{v_1^2 + v_2^2 + \cdots + v_n^2}
</script>
</div>
<p>이때, 벡터의 정규화는 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} </span><script type="math/tex"> \mathbf{v} </script></span>의 각 성분을 벡터의 크기로 나눈 값으로 정의된다.</p>
<h3 id="eigen">Eigen을 활용한 벡터 정규화</h3>
<p>Eigen 라이브러리는 C++에서 수학적 벡터와 행렬 연산을 효율적으로 수행할 수 있도록 설계된 라이브러리다. 이를 통해 벡터의 정규화를 간단하게 구현할 수 있다. 다음은 Eigen 라이브러리에서 벡터 정규화를 수행하는 예제 코드이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // Eigen 벡터 선언 및 초기화
    Eigen::Vector3d v(3.0, 4.0, 0.0);

    // 벡터 정규화
    Eigen::Vector3d v_normalized = v.normalized();

    // 결과 출력
    std::cout &lt;&lt; &quot;정규화된 벡터: &quot; &lt;&lt; v_normalized.transpose() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>위 예제에서 <code>Eigen::Vector3d</code>는 3차원 실수 벡터를 정의하며, <code>normalized()</code> 함수는 벡터의 정규화된 값을 반환한다. 주어진 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} = [3, 4, 0] </span><script type="math/tex"> \mathbf{v} = [3, 4, 0] </script></span>의 크기는 <span class="arithmatex"><span class="MathJax_Preview"> \|\mathbf{v}\| = 5 </span><script type="math/tex"> \|\mathbf{v}\| = 5 </script></span>이므로, 정규화된 벡터는 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{\hat{v}} = [\frac{3}{5}, \frac{4}{5}, 0] </span><script type="math/tex"> \mathbf{\hat{v}} = [\frac{3}{5}, \frac{4}{5}, 0] </script></span>이 된다.</p>
<h3 id="_4">정규화 벡터의 성질</h3>
<p>정규화된 벡터는 다음과 같은 중요한 성질을 가진다:</p>
<ol>
<li><strong>크기</strong>: 정규화된 벡터의 크기는 항상 1이다. 즉, 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{\hat{v}} </span><script type="math/tex"> \mathbf{\hat{v}} </script></span>는 항상 단위 벡터로 변환된다. 이를 수식으로 나타내면:</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{\hat{v}}\| = 1
</div>
<script type="math/tex; mode=display">
\|\mathbf{\hat{v}}\| = 1
</script>
</div>
<ol>
<li>
<p><strong>방향</strong>: 정규화된 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{\hat{v}} </span><script type="math/tex"> \mathbf{\hat{v}} </script></span>는 원래 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} </span><script type="math/tex"> \mathbf{v} </script></span>와 동일한 방향을 가진다. 즉, 방향은 유지되지만 크기만 변한다.</p>
</li>
<li>
<p><strong>스칼라 곱</strong>: 두 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v_1} </span><script type="math/tex"> \mathbf{v_1} </script></span>와 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v_2} </span><script type="math/tex"> \mathbf{v_2} </script></span>가 있을 때, 이 벡터들을 각각 정규화한 후 스칼라 곱(내적)을 계산하면, 원래 벡터 간의 코사인 유사도와 동일하다:</p>
</li>
</ol>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\hat{v_1}} \cdot \mathbf{\hat{v_2}} = \cos{\theta}
</div>
<script type="math/tex; mode=display">
\mathbf{\hat{v_1}} \cdot \mathbf{\hat{v_2}} = \cos{\theta}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview"> \theta </span><script type="math/tex"> \theta </script></span>는 두 벡터 사이의 각도이다. 이는 두 벡터 간의 유사도를 측정하는 데 유용하게 사용된다.</p>
<h3 id="_5">특수한 경우의 벡터 정규화</h3>
<ol>
<li>
<p><strong>영벡터의 정규화</strong>: 영벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{0} </span><script type="math/tex"> \mathbf{0} </script></span>는 모든 성분이 0인 벡터를 의미한다. 영벡터의 정규화는 수학적으로 정의되지 않는다. 벡터의 크기가 0이기 때문에, 이를 나눌 수 없기 때문이다. 이러한 경우 정규화 함수는 예외 처리를 해야 한다.</p>
</li>
<li>
<p><strong>정규화의 안정성</strong>: 실수 계산에서는 부동소수점 연산의 불확실성으로 인해 벡터의 정규화가 완벽하게 수행되지 않을 수 있다. 특히, 벡터의 크기가 매우 작거나 매우 큰 경우에는 정규화 과정에서 오차가 발생할 수 있으므로, 수치적으로 안정한 방법이 필요할 수 있다.</p>
</li>
</ol>
<h3 id="eigen_1">Eigen 라이브러리에서의 주의 사항</h3>
<p>Eigen 라이브러리에서 <code>normalized()</code> 함수는 정규화된 벡터를 반환하지만, 원래 벡터 자체를 변경하지 않는다. 만약 원래 벡터 자체를 정규화하고자 한다면 <code>normalize()</code> 함수를 사용해야 한다. 아래는 이를 사용하는 예제이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // Eigen 벡터 선언 및 초기화
    Eigen::Vector3d v(3.0, 4.0, 0.0);

    // 벡터 자체를 정규화
    v.normalize();

    // 결과 출력
    std::cout &lt;&lt; &quot;자체 정규화된 벡터: &quot; &lt;&lt; v.transpose() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>이 경우 벡터 <span class="arithmatex"><span class="MathJax_Preview"> v </span><script type="math/tex"> v </script></span>는 함수 호출 이후 정규화된 상태로 변환된다. 즉, 원래 벡터는 더 이상 <span class="arithmatex"><span class="MathJax_Preview"> [3, 4, 0] </span><script type="math/tex"> [3, 4, 0] </script></span>이 아니고, <span class="arithmatex"><span class="MathJax_Preview"> [\frac{3}{5}, \frac{4}{5}, 0] </span><script type="math/tex"> [\frac{3}{5}, \frac{4}{5}, 0] </script></span>로 바뀐다.</p>
<h3 id="_6">다차원 벡터 정규화</h3>
<p>다차원 벡터에 대해서도 동일한 방법으로 정규화를 적용할 수 있다. 예를 들어, n-차원 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} = [v_1, v_2, \cdots, v_n] </span><script type="math/tex"> \mathbf{v} = [v_1, v_2, \cdots, v_n] </script></span>의 정규화는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{\hat{v}} = \frac{1}{\|\mathbf{v}\|} \mathbf{v} = \left[ \frac{v_1}{\|\mathbf{v}\|}, \frac{v_2}{\|\mathbf{v}\|}, \cdots, \frac{v_n}{\|\mathbf{v}\|} \right]
</div>
<script type="math/tex; mode=display">
\mathbf{\hat{v}} = \frac{1}{\|\mathbf{v}\|} \mathbf{v} = \left[ \frac{v_1}{\|\mathbf{v}\|}, \frac{v_2}{\|\mathbf{v}\|}, \cdots, \frac{v_n}{\|\mathbf{v}\|} \right]
</script>
</div>
<p>Eigen 라이브러리는 이러한 다차원 벡터를 효율적으로 처리할 수 있다. 예를 들어, 4차원 벡터를 정규화하려면 다음과 같이 코드를 작성할 수 있다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // 4차원 벡터 선언 및 초기화
    Eigen::Vector4d v(1.0, 2.0, 3.0, 4.0);

    // 벡터 정규화
    Eigen::Vector4d v_normalized = v.normalized();

    // 결과 출력
    std::cout &lt;&lt; &quot;정규화된 4차원 벡터: &quot; &lt;&lt; v_normalized.transpose() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>이 코드는 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v} = [1, 2, 3, 4] </span><script type="math/tex"> \mathbf{v} = [1, 2, 3, 4] </script></span>인 4차원 벡터를 정규화하여 그 결과를 출력한다.</p>
<h3 id="_7">벡터 정규화의 실제 응용</h3>
<p>정규화된 벡터는 여러 분야에서 중요한 역할을 한다. 특히, 벡터의 방향 정보를 필요로 하는 다양한 응용에서 많이 사용된다. 아래에서는 몇 가지 대표적인 응용 사례를 소개한다.</p>
<h4 id="_8">컴퓨터 그래픽스에서의 응용</h4>
<p>컴퓨터 그래픽스에서 벡터 정규화는 표면의 법선 벡터 계산, 빛의 반사 계산, 물체의 회전과 같은 다양한 작업에서 필수적이다. 예를 들어, 법선 벡터는 표면의 기울기를 나타내는데, 이 벡터가 정규화되지 않으면 빛의 반사와 같은 계산에서 오류가 발생할 수 있다. 표면 법선 벡터를 정규화하면 표면의 기하학적 특성을 보다 정확하게 계산할 수 있다.</p>
<p>다음은 3D 그래픽스에서 법선 벡터를 정규화하는 예시이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // 임의의 3차원 벡터 정의
    Eigen::Vector3d normal_vector(3.0, 1.0, 2.0);

    // 법선 벡터 정규화
    Eigen::Vector3d normalized_normal = normal_vector.normalized();

    // 결과 출력
    std::cout &lt;&lt; &quot;정규화된 법선 벡터: &quot; &lt;&lt; normalized_normal.transpose() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>이 코드에서는 법선 벡터를 정규화하여 결과를 출력한다. 정규화된 벡터는 그래픽스 렌더링 엔진에서 빛과 표면 간의 상호작용을 계산할 때 사용된다.</p>
<h4 id="_9">물리 시뮬레이션에서의 응용</h4>
<p>물리 시뮬레이션에서는 물체의 속도 벡터나 가속도 벡터를 정규화하여 운동의 방향을 추적하거나, 물체 간의 충돌 및 반사 방향을 계산할 때 사용된다. 예를 들어, 충돌이 발생했을 때 물체가 반사하는 방향은 충돌 지점에서의 법선 벡터에 따라 결정되며, 이 벡터가 정규화되어야 물리적으로 정확한 계산이 가능하다.</p>
<p>다음은 물체의 속도 벡터를 정규화하는 예시이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // 물체의 속도 벡터 정의
    Eigen::Vector3d velocity(5.0, -3.0, 2.0);

    // 속도 벡터 정규화
    Eigen::Vector3d normalized_velocity = velocity.normalized();

    // 결과 출력
    std::cout &lt;&lt; &quot;정규화된 속도 벡터: &quot; &lt;&lt; normalized_velocity.transpose() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>이 코드는 물체의 속도 벡터를 정규화하여 그 방향만을 추출하고, 이후 물체의 운동 방향을 추적하거나 계산하는 데 사용할 수 있다.</p>
<h4 id="_10">머신 러닝에서의 응용</h4>
<p>머신 러닝에서는 데이터의 각 특성(feature)을 정규화하거나 표준화하는 과정이 필수적이다. 벡터 정규화는 주로 텍스트 데이터나 이미지 데이터의 특징 벡터(feature vector)를 유사도 분석에 사용할 때 적용된다. 예를 들어, 텍스트 데이터에서 단어의 빈도를 나타내는 벡터(벡터 공간 모델)를 정규화하여 코사인 유사도를 계산할 수 있다.</p>
<p>두 문서 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v_1} </span><script type="math/tex"> \mathbf{v_1} </script></span>과 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v_2} </span><script type="math/tex"> \mathbf{v_2} </script></span>의 코사인 유사도는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\cos{\theta} = \frac{\mathbf{v_1} \cdot \mathbf{v_2}}{\|\mathbf{v_1}\| \|\mathbf{v_2}\|}
</div>
<script type="math/tex; mode=display">
\cos{\theta} = \frac{\mathbf{v_1} \cdot \mathbf{v_2}}{\|\mathbf{v_1}\| \|\mathbf{v_2}\|}
</script>
</div>
<p>이때 벡터를 정규화하면 크기가 1로 통일되므로, 코사인 유사도는 단순히 내적으로 계산할 수 있다.</p>
<h3 id="eigen_2">Eigen에서 다차원 벡터를 활용한 응용 예시</h3>
<p>다차원 벡터는 일반적으로 데이터 분석에서 중요한 역할을 한다. 예를 들어, 이미지나 텍스트 데이터에서 고차원 특징 벡터를 사용해 유사도를 계산할 때 벡터의 정규화는 필수적이다. 다음은 Eigen을 사용해 5차원 벡터를 정규화하고, 이를 활용해 두 벡터 간의 코사인 유사도를 계산하는 예제이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // 5차원 벡터 선언 및 초기화
    Eigen::VectorXd v1(5);
    v1 &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0;

    Eigen::VectorXd v2(5);
    v2 &lt;&lt; 5.0, 4.0, 3.0, 2.0, 1.0;

    // 벡터 정규화
    Eigen::VectorXd v1_normalized = v1.normalized();
    Eigen::VectorXd v2_normalized = v2.normalized();

    // 코사인 유사도 계산
    double cosine_similarity = v1_normalized.dot(v2_normalized);

    // 결과 출력
    std::cout &lt;&lt; &quot;정규화된 벡터 1: &quot; &lt;&lt; v1_normalized.transpose() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;정규화된 벡터 2: &quot; &lt;&lt; v2_normalized.transpose() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;코사인 유사도: &quot; &lt;&lt; cosine_similarity &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>이 예제에서는 두 개의 5차원 벡터 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v_1} </span><script type="math/tex"> \mathbf{v_1} </script></span>과 <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{v_2} </span><script type="math/tex"> \mathbf{v_2} </script></span>를 정규화한 후, 그 사이의 코사인 유사도를 계산한다. 정규화된 벡터는 크기가 1이므로 유사도를 계산할 때 내적만으로 충분하다.</p>

  <br>
    

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>