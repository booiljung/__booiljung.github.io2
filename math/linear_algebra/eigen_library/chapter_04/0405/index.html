<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/math/linear_algebra/eigen_library/chapter_04/0405/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>벡터 투영 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\ubca1\ud130 \ud22c\uc601\uc758 \uc815\uc758", url: "#_top", children: [
          ]},
          {title: "\ud22c\uc601 \ubca1\ud130\uc758 \uae30\ud558\ud559\uc801 \ud574\uc11d", url: "#_2", children: [
          ]},
          {title: "Eigen \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \ud65c\uc6a9\ud55c \ubca1\ud130 \ud22c\uc601 \uad6c\ud604", url: "#eigen", children: [
          ]},
          {title: "\ud22c\uc601 \ubca1\ud130\uc758 \uc131\uc9c8", url: "#_3", children: [
              {title: "1. \ub3d9\uc77c \ubc29\ud5a5 \ubca1\ud130 \ud22c\uc601", url: "#1" },
              {title: "2. \uc218\uc9c1 \ubca1\ud130 \ud22c\uc601", url: "#2" },
              {title: "3. \uc9c1\uad50\uc131", url: "#3" },
          ]},
          {title: "Eigen \ub77c\uc774\ube0c\ub7ec\ub9ac\ub85c \ud22c\uc601 \uc131\uc9c8 \ud655\uc778", url: "#eigen_1", children: [
          ]},
          {title: "\ud22c\uc601 \ubca1\ud130\uc640 \uc720\ud074\ub9ac\ub4dc \uac70\ub9ac", url: "#_4", children: [
          ]},
          {title: "\uc815\uaddc\ud654\ub41c \ubca1\ud130\ub97c \uc0ac\uc6a9\ud55c \ud22c\uc601", url: "#_5", children: [
              {title: "\uc815\uaddc\ud654\ub41c \ubca1\ud130 \uc0ac\uc6a9 \uc2dc\uc758 Eigen \uad6c\ud604", url: "#eigen_2" },
          ]},
          {title: "\ubca1\ud130 \ud22c\uc601\uc758 \uc751\uc6a9", url: "#_6", children: [
              {title: "1. \uae30\uacc4 \ud559\uc2b5\uc5d0\uc11c\uc758 \uc751\uc6a9", url: "#1_1" },
              {title: "2. \ucef4\ud4e8\ud130 \uadf8\ub798\ud53d\uc2a4\uc5d0\uc11c\uc758 \uc751\uc6a9", url: "#2_1" },
              {title: "3. \ubb3c\ub9ac\ud559\uc5d0\uc11c\uc758 \uc751\uc6a9", url: "#3_1" },
          ]},
          {title: "\ubca1\ud130 \ud22c\uc601\uacfc \uc9c1\uad50 \ud22c\uc601", url: "#_7", children: [
              {title: "\uc9c1\uad50 \ud22c\uc601\uc758 \uc815\uc758", url: "#_8" },
              {title: "\uc9c1\uad50 \ud22c\uc601\uc758 \uc131\uc9c8", url: "#_9" },
          ]},
          {title: "\ube44\uc9c1\uad50 \ud22c\uc601", url: "#_10", children: [
          ]},
          {title: "Eigen \ub77c\uc774\ube0c\ub7ec\ub9ac\ub85c \ube44\uc9c1\uad50 \ud22c\uc601 \uad6c\ud604", url: "#eigen_3", children: [
          ]},
          {title: "\uc9c1\uad50 \ud22c\uc601\uacfc \ube44\uc9c1\uad50 \ud22c\uc601\uc758 \ube44\uad50", url: "#_11", children: [
              {title: "\uc9c1\uad50 \ud22c\uc601\uc758 \ud2b9\uc131:", url: "#_12" },
              {title: "\ube44\uc9c1\uad50 \ud22c\uc601\uc758 \ud2b9\uc131:", url: "#_13" },
          ]},
          {title: "\ud22c\uc601 \ud589\ub82c", url: "#_14", children: [
              {title: "\ud22c\uc601 \ud589\ub82c\uc744 \uc0ac\uc6a9\ud55c Eigen \uad6c\ud604", url: "#eigen_4" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0406/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0406/" class="btn btn-xs btn-link">
        벡터 크기 및 길이 계산
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0404/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0404/" class="btn btn-xs btn-link">
        벡터 간 각도 계산
      </a>
    </div>
    
  </div>

    

    <h3 id="_1">벡터 투영의 정의</h3>
<p>벡터 투영은 한 벡터를 다른 벡터 위에 투영하는 연산으로, 벡터 공간에서 매우 중요한 개념이다. 두 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>가 주어졌을 때, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대해 투영한 결과는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span> 방향으로의 성분만을 남기고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 수직인 성분을 제거한 벡터이다.</p>
<p>벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대해 투영한 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 다음과 같은 수식으로 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p} = \frac{\mathbf{a} \cdot \mathbf{b}}{\mathbf{b} \cdot \mathbf{b}} \mathbf{b}
</div>
<script type="math/tex; mode=display">
\mathbf{p} = \frac{\mathbf{a} \cdot \mathbf{b}}{\mathbf{b} \cdot \mathbf{b}} \mathbf{b}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a} \cdot \mathbf{b}</span><script type="math/tex">\mathbf{a} \cdot \mathbf{b}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>의 내적,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b} \cdot \mathbf{b}</span><script type="math/tex">\mathbf{b} \cdot \mathbf{b}</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>의 크기의 제곱을 의미한다.</p>
<h3 id="_2">투영 벡터의 기하학적 해석</h3>
<p>벡터 투영은 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>와 평행한 벡터 성분만을 추출하는 과정이다. 투영된 벡터는 항상 원래 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>와 평행하며, 크기는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span> 방향 성분에 해당한다. 기하학적으로 보면, 이는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span> 위에 직각으로 떨어뜨린 벡터라고 볼 수 있다.</p>
<h3 id="eigen">Eigen 라이브러리를 활용한 벡터 투영 구현</h3>
<p>Eigen 라이브러리에서는 벡터의 내적과 스칼라 곱 연산을 쉽게 수행할 수 있으므로, 벡터 투영도 간단히 구현할 수 있다. 아래의 예시는 Eigen 라이브러리를 사용하여 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대해 투영하는 방법을 보여준다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // Eigen 벡터 정의
    Eigen::Vector3d a(1.0, 2.0, 3.0);
    Eigen::Vector3d b(4.0, 5.0, 6.0);

    // 벡터 투영 계산
    Eigen::Vector3d projection = (a.dot(b) / b.dot(b)) * b;

    // 결과 출력
    std::cout &lt;&lt; &quot;Projection of a onto b: &quot; &lt;&lt; projection.transpose() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>위 코드는 3차원 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a} = (1.0, 2.0, 3.0)</span><script type="math/tex">\mathbf{a} = (1.0, 2.0, 3.0)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b} = (4.0, 5.0, 6.0)</span><script type="math/tex">\mathbf{b} = (4.0, 5.0, 6.0)</script></span>에 대해 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 투영하는 예제이다. <code>a.dot(b)</code>는 두 벡터의 내적을 계산하고, <code>b.dot(b)</code>는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>의 크기의 제곱을 계산한다. 이를 통해 벡터 투영을 구현할 수 있다.</p>
<h3 id="_3">투영 벡터의 성질</h3>
<p>벡터 투영에는 몇 가지 중요한 성질이 있다. 이러한 성질들은 수학적 특성과 물리적 해석에서 모두 유용하다.</p>
<h4 id="1">1. 동일 방향 벡터 투영</h4>
<p>만약 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>가 같은 방향을 가진 벡터라면, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대한 투영은 단순히 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span> 그 자체가 된다. 이때, 두 벡터는 서로 평행하므로, 다음 관계가 성립한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{a} = \frac{\mathbf{a} \cdot \mathbf{b}}{\mathbf{b} \cdot \mathbf{b}} \mathbf{b}
</div>
<script type="math/tex; mode=display">
\mathbf{a} = \frac{\mathbf{a} \cdot \mathbf{b}}{\mathbf{b} \cdot \mathbf{b}} \mathbf{b}
</script>
</div>
<h4 id="2">2. 수직 벡터 투영</h4>
<p>만약 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>가 서로 수직이면, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대한 투영은 0 벡터가 된다. 즉, 내적 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a} \cdot \mathbf{b} = 0</span><script type="math/tex">\mathbf{a} \cdot \mathbf{b} = 0</script></span>이므로 투영 벡터는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p} = \frac{0}{\mathbf{b} \cdot \mathbf{b}} \mathbf{b} = \mathbf{0}
</div>
<script type="math/tex; mode=display">
\mathbf{p} = \frac{0}{\mathbf{b} \cdot \mathbf{b}} \mathbf{b} = \mathbf{0}
</script>
</div>
<h4 id="3">3. 직교성</h4>
<p>벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 투영 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>를 비교하면, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 수직인 성분은 투영된 벡터에서 완전히 제거된다. 이로 인해 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a} - \mathbf{p}</span><script type="math/tex">\mathbf{a} - \mathbf{p}</script></span>는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 수직이 된다. 즉, 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a} - \mathbf{p}</span><script type="math/tex">\mathbf{a} - \mathbf{p}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>는 직교하며, 이는 다음과 같은 수식으로 표현될 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
(\mathbf{a} - \mathbf{p}) \cdot \mathbf{b} = 0
</div>
<script type="math/tex; mode=display">
(\mathbf{a} - \mathbf{p}) \cdot \mathbf{b} = 0
</script>
</div>
<h3 id="eigen_1">Eigen 라이브러리로 투영 성질 확인</h3>
<p>앞서 논의한 투영의 성질을 확인하기 위해, Eigen 라이브러리로 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>의 관계를 구현할 수 있다. 아래 코드는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>의 차이가 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>와 직교하는지를 확인하는 예제이다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // Eigen 벡터 정의
    Eigen::Vector3d a(1.0, 2.0, 3.0);
    Eigen::Vector3d b(4.0, 5.0, 6.0);

    // 벡터 투영 계산
    Eigen::Vector3d projection = (a.dot(b) / b.dot(b)) * b;

    // a - p가 b에 직교하는지 확인
    Eigen::Vector3d orthogonal_component = a - projection;
    double dot_product = orthogonal_component.dot(b);

    std::cout &lt;&lt; &quot;Dot product of (a - projection) and b: &quot; &lt;&lt; dot_product &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>위 코드는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a} - \mathbf{p}</span><script type="math/tex">\mathbf{a} - \mathbf{p}</script></span>가 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>와 직교하는지를 확인하기 위해 내적을 계산한다. 결과적으로 내적이 0에 가까운 값이 나와야 직교 관계가 성립함을 알 수 있다.</p>
<h3 id="_4">투영 벡터와 유클리드 거리</h3>
<p>벡터 투영은 벡터 간의 거리와도 밀접한 관련이 있다. 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>가 주어졌을 때, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span> 방향으로의 최소 거리는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a} - \mathbf{p}</span><script type="math/tex">\mathbf{a} - \mathbf{p}</script></span>의 크기, 즉 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>에서 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>까지의 거리로 계산할 수 있다. 이 거리는 수직선상의 거리이므로 유클리드 거리로 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Distance} = \|\mathbf{a} - \mathbf{p}\|
</div>
<script type="math/tex; mode=display">
\text{Distance} = \|\mathbf{a} - \mathbf{p}\|
</script>
</div>
<p>이를 통해, 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>로의 가장 가까운 점은 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>에 해당하며, 이때 거리는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a} - \mathbf{p}</span><script type="math/tex">\mathbf{a} - \mathbf{p}</script></span>의 크기이다.</p>
<p>Eigen을 사용하여 이 거리를 계산하는 방법은 다음과 같다:</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // Eigen 벡터 정의
    Eigen::Vector3d a(1.0, 2.0, 3.0);
    Eigen::Vector3d b(4.0, 5.0, 6.0);

    // 벡터 투영 계산
    Eigen::Vector3d projection = (a.dot(b) / b.dot(b)) * b;

    // 유클리드 거리 계산
    double distance = (a - projection).norm();

    std::cout &lt;&lt; &quot;Distance between a and its projection onto b: &quot; &lt;&lt; distance &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>위 코드는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>에서 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대한 투영된 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>까지의 거리를 계산한다. <code>norm()</code> 함수는 벡터의 크기를 계산하는 함수로, 이를 통해 벡터 간의 유클리드 거리를 구할 수 있다.</p>
<h3 id="_5">정규화된 벡터를 사용한 투영</h3>
<p>벡터 투영에서는 종종 단위 벡터를 사용하여 더 간단한 형태의 계산을 수행한다. 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>가 단위 벡터로 정규화된 경우, 즉 <span class="arithmatex"><span class="MathJax_Preview">\|\mathbf{b}\| = 1</span><script type="math/tex">\|\mathbf{b}\| = 1</script></span>일 때, 투영 공식은 더 간단해진다. 이 경우 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대해 투영한 결과는 다음과 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p} = (\mathbf{a} \cdot \mathbf{b}) \mathbf{b}
</div>
<script type="math/tex; mode=display">
\mathbf{p} = (\mathbf{a} \cdot \mathbf{b}) \mathbf{b}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>는 이미 정규화되어 있으므로, 분모에 있는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b} \cdot \mathbf{b}</span><script type="math/tex">\mathbf{b} \cdot \mathbf{b}</script></span>는 1이 된다.</p>
<h4 id="eigen_2">정규화된 벡터 사용 시의 Eigen 구현</h4>
<p>Eigen 라이브러리를 사용하여 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>를 정규화한 뒤 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 투영하는 예제는 다음과 같다:</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // Eigen 벡터 정의
    Eigen::Vector3d a(1.0, 2.0, 3.0);
    Eigen::Vector3d b(4.0, 5.0, 6.0);

    // 벡터 b를 정규화
    Eigen::Vector3d b_normalized = b.normalized();

    // 정규화된 벡터 b에 대한 a의 투영
    Eigen::Vector3d projection = (a.dot(b_normalized)) * b_normalized;

    // 결과 출력
    std::cout &lt;&lt; &quot;Projection of a onto normalized b: &quot; &lt;&lt; projection.transpose() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>이 코드에서는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>를 <code>normalized()</code> 함수를 사용하여 정규화한 후, 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 정규화된 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대해 투영한다. 정규화된 벡터를 사용하면, 투영 계산이 단순해지고 계산의 안정성을 높일 수 있다.</p>
<h3 id="_6">벡터 투영의 응용</h3>
<p>벡터 투영은 다양한 분야에서 응용된다. 특히 물리학, 컴퓨터 그래픽스, 신호 처리, 기계 학습 등의 분야에서 많이 사용되며, 이를 통해 데이터를 분석하거나 물체의 움직임을 예측하는 데 유용하다.</p>
<h4 id="1_1">1. 기계 학습에서의 응용</h4>
<p>기계 학습에서는 벡터 투영이 자주 사용된다. 예를 들어, 선형 회귀에서 데이터 점들을 회귀선으로 투영하는 과정은 벡터 투영과 매우 유사하다. 데이터를 하나의 하이퍼플레인에 맞추기 위해 각 데이터 벡터를 하이퍼플레인에 투영하고, 그 결과로 얻어진 투영 벡터들의 평균 제곱 오차를 최소화하는 것이 목표이다.</p>
<h4 id="2_1">2. 컴퓨터 그래픽스에서의 응용</h4>
<p>컴퓨터 그래픽스에서는 물체가 카메라에 의해 투영될 때, 화면 좌표계로 변환하는 과정에서 벡터 투영이 사용된다. 3D 공간의 물체는 2D 평면에 투영되어 화면에 나타나게 되며, 이 과정은 벡터 투영을 기반으로 한다. </p>
<h4 id="3_1">3. 물리학에서의 응용</h4>
<p>물리학에서 힘의 성분을 분석할 때 벡터 투영이 사용된다. 예를 들어, 물체에 작용하는 힘을 두 축으로 나누어 각각의 성분을 구하는 것은 벡터를 축에 대해 투영하는 것과 동일하다. 특히 경사면에서의 운동 분석이나 전기장 내의 입자 운동 분석 등에 벡터 투영이 활용된다.</p>
<h3 id="_7">벡터 투영과 직교 투영</h3>
<p>투영 벡터는 여러 종류가 있으며, 그중에서도 가장 일반적인 형태는 직교 투영이다. 직교 투영은 두 벡터가 이루는 각을 고려하지 않고, 단순히 한 벡터를 다른 벡터에 수직으로 내리는 투영 방식이다. 이는 벡터 간의 관계를 분석할 때 매우 유용하다.</p>
<h4 id="_8">직교 투영의 정의</h4>
<p>벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대해 직교 투영하는 경우, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>와 수직인 성분이 제거되며, 결과는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span> 방향으로만 남게 된다. 직교 투영은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p}_{\text{orth}} = \frac{\mathbf{a} \cdot \mathbf{b}}{\mathbf{b} \cdot \mathbf{b}} \mathbf{b}
</div>
<script type="math/tex; mode=display">
\mathbf{p}_{\text{orth}} = \frac{\mathbf{a} \cdot \mathbf{b}}{\mathbf{b} \cdot \mathbf{b}} \mathbf{b}
</script>
</div>
<p>여기서, 직교 투영 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{\text{orth}}</span><script type="math/tex">\mathbf{p}_{\text{orth}}</script></span>는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>에서 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 수직인 성분이 제거된 벡터이다.</p>
<h4 id="_9">직교 투영의 성질</h4>
<p>직교 투영의 중요한 성질 중 하나는 투영된 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{\text{orth}}</span><script type="math/tex">\mathbf{p}_{\text{orth}}</script></span>와 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a} - \mathbf{p}_{\text{orth}}</span><script type="math/tex">\mathbf{a} - \mathbf{p}_{\text{orth}}</script></span>가 서로 직교한다는 점이다. 즉, 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}_{\text{orth}}</span><script type="math/tex">\mathbf{p}_{\text{orth}}</script></span>를 빼면 남은 벡터는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>와 수직이 된다. 이는 수학적으로 다음과 같이 표현된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
(\mathbf{a} - \mathbf{p}_{\text{orth}}) \cdot \mathbf{b} = 0
</div>
<script type="math/tex; mode=display">
(\mathbf{a} - \mathbf{p}_{\text{orth}}) \cdot \mathbf{b} = 0
</script>
</div>
<p>직교 투영은 벡터의 직교성을 분석하거나 두 벡터 간의 관계를 직관적으로 파악할 때 매우 유용한 도구이다.</p>
<h3 id="_10">비직교 투영</h3>
<p>비직교 투영은 벡터가 특정 방향으로 투영되지만, 투영할 대상이 직교하지 않은 경우를 말한다. 이 경우, 투영은 단순히 벡터를 다른 벡터의 축에 평행하게 투영하는 것이 아니라, 임의의 각도에서 벡터를 다른 벡터 방향으로 투영하는 것을 포함한다.</p>
<p>비직교 투영에서는 두 벡터가 이루는 각도에 대한 고려가 필요하다. 두 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>가 이루는 각을 <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>라 할 때, 투영된 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>는 다음과 같은 형태로 나타난다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p} = \|\mathbf{a}\| \cos(\theta) \hat{\mathbf{b}}
</div>
<script type="math/tex; mode=display">
\mathbf{p} = \|\mathbf{a}\| \cos(\theta) \hat{\mathbf{b}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\|\mathbf{a}\|</span><script type="math/tex">\|\mathbf{a}\|</script></span>는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>의 크기,
- <span class="arithmatex"><span class="MathJax_Preview">\cos(\theta)</span><script type="math/tex">\cos(\theta)</script></span>는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span> 사이의 각도 <span class="arithmatex"><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>에 대한 코사인 값,
- <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{b}}</span><script type="math/tex">\hat{\mathbf{b}}</script></span>는 단위 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>이다.</p>
<p>이 공식은 두 벡터가 직교하지 않는 상황에서, 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span> 방향으로의 성분을 구하는 방식이다.</p>
<h3 id="eigen_3">Eigen 라이브러리로 비직교 투영 구현</h3>
<p>비직교 투영을 구현하기 위해서는 두 벡터 간의 각도를 고려한 투영 계산이 필요하다. Eigen 라이브러리를 사용하면 이 계산을 쉽게 할 수 있으며, 다음과 같은 코드를 통해 비직교 투영을 구현할 수 있다.</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;

int main() {
    // Eigen 벡터 정의
    Eigen::Vector3d a(1.0, 2.0, 3.0);
    Eigen::Vector3d b(4.0, 5.0, 6.0);

    // 벡터 b를 정규화
    Eigen::Vector3d b_normalized = b.normalized();

    // 두 벡터 간의 각도 계산
    double angle_cos = a.dot(b_normalized) / a.norm();
    double angle = std::acos(angle_cos);

    // 비직교 투영 계산
    Eigen::Vector3d projection = (a.norm() * std::cos(angle)) * b_normalized;

    // 결과 출력
    std::cout &lt;&lt; &quot;Non-orthogonal projection of a onto b: &quot; &lt;&lt; projection.transpose() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>이 코드는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>가 직교하지 않는 상황에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span> 방향으로 투영하는 방법을 보여준다. <code>std::acos()</code> 함수는 두 벡터 사이의 각도를 계산하고, 이를 바탕으로 코사인 값을 활용해 투영 벡터를 계산한다.</p>
<h3 id="_11">직교 투영과 비직교 투영의 비교</h3>
<p>직교 투영과 비직교 투영의 주요 차이점은 벡터가 투영되는 방향에 대한 제약 조건이다. 직교 투영에서는 두 벡터가 이루는 각도가 고려되지 않고, 수직으로 투영되기 때문에 결과 벡터는 항상 투영 대상 벡터에 평행하게 나타난다. 반면, 비직교 투영에서는 두 벡터가 이루는 각도가 고려되어야 하며, 결과 벡터는 벡터 간의 각도에 따라 달라진다.</p>
<h4 id="_12">직교 투영의 특성:</h4>
<ul>
<li>투영된 벡터는 항상 투영 대상 벡터와 평행하다.</li>
<li>두 벡터 간의 각도를 고려하지 않는다.</li>
<li>벡터 공간에서 직관적이며, 수직 성분을 제거하는 데 유용하다.</li>
</ul>
<h4 id="_13">비직교 투영의 특성:</h4>
<ul>
<li>두 벡터 간의 각도를 고려한다.</li>
<li>투영된 벡터는 투영 대상 벡터와 평행하지 않을 수 있다.</li>
<li>보다 복잡한 기하학적 문제에 적합하다.</li>
</ul>
<h3 id="_14">투영 행렬</h3>
<p>벡터 투영은 행렬 연산으로도 표현될 수 있다. 특히, 투영 행렬을 사용하면 임의의 벡터를 행렬 곱셈을 통해 투영할 수 있다. 투영 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>는 주어진 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대해 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{P} = \frac{\mathbf{b} \mathbf{b}^T}{\mathbf{b} \cdot \mathbf{b}}
</div>
<script type="math/tex; mode=display">
\mathbf{P} = \frac{\mathbf{b} \mathbf{b}^T}{\mathbf{b} \cdot \mathbf{b}}
</script>
</div>
<p>여기서:
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}^T</span><script type="math/tex">\mathbf{b}^T</script></span>는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>의 전치 행렬,
- <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b} \mathbf{b}^T</span><script type="math/tex">\mathbf{b} \mathbf{b}^T</script></span>는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>와 그 전치 행렬의 곱으로, 결과는 행렬이 된다.</p>
<p>이 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{P}</span><script type="math/tex">\mathbf{P}</script></span>를 사용하면, 주어진 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대해 투영하는 연산은 단순한 행렬 곱으로 표현할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{p} = \mathbf{P} \mathbf{a}
</div>
<script type="math/tex; mode=display">
\mathbf{p} = \mathbf{P} \mathbf{a}
</script>
</div>
<h4 id="eigen_4">투영 행렬을 사용한 Eigen 구현</h4>
<p>Eigen 라이브러리를 사용하여 투영 행렬을 구현하고, 이를 사용해 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대해 투영하는 방법은 다음과 같다:</p>
<pre><code class="language-cpp">#include &lt;Eigen/Dense&gt;
#include &lt;iostream&gt;

int main() {
    // Eigen 벡터 정의
    Eigen::Vector3d a(1.0, 2.0, 3.0);
    Eigen::Vector3d b(4.0, 5.0, 6.0);

    // 투영 행렬 계산
    Eigen::Matrix3d projection_matrix = (b * b.transpose()) / b.dot(b);

    // 투영 계산
    Eigen::Vector3d projection = projection_matrix * a;

    // 결과 출력
    std::cout &lt;&lt; &quot;Projection of a onto b using projection matrix: &quot; &lt;&lt; projection.transpose() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>이 코드는 투영 행렬을 계산하고, 이를 사용해 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{a}</span><script type="math/tex">\mathbf{a}</script></span>를 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span>에 대해 투영하는 예제이다. 투영 행렬은 특정 벡터에 대한 투영을 수식적으로 명확히 표현할 수 있는 도구로, 복잡한 벡터 연산을 단순화하는 데 유용하다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../0406/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../0406/" class="btn btn-xs btn-link">
        벡터 크기 및 길이 계산
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0404/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0404/" class="btn btn-xs btn-link">
        벡터 간 각도 계산
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>