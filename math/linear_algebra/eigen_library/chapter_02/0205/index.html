<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/math/linear_algebra/eigen_library/chapter_02/0205/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>행렬과 벡터의 기본 연산 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "1. \ub367\uc148\uacfc \ube84\uc148", url: "#_top", children: [
          ]},
          {title: "2. \uc2a4\uce7c\ub77c \uacf1\uc148", url: "#2", children: [
          ]},
          {title: "3. \ud589\ub82c \uacf1\uc148", url: "#3", children: [
          ]},
          {title: "4. \uc804\uce58 \ud589\ub82c", url: "#4", children: [
          ]},
          {title: "5. \ub0b4\uc801 (Dot Product)", url: "#5-dot-product", children: [
          ]},
          {title: "6. \uc678\uc801 (Cross Product)", url: "#6-cross-product", children: [
          ]},
          {title: "7. \uc5ed\ud589\ub82c", url: "#7", children: [
          ]},
          {title: "8. \ud589\ub82c\uc2dd", url: "#8", children: [
          ]},
          {title: "9. \ub300\uac01\ud569 (Trace)", url: "#9-trace", children: [
          ]},
          {title: "10. \ub2e8\uc704 \ud589\ub82c", url: "#10", children: [
          ]},
          {title: "11. \ub300\uce6d \ud589\ub82c", url: "#11", children: [
          ]},
          {title: "12. \ub300\uac01 \ud589\ub82c", url: "#12", children: [
          ]},
          {title: "13. \uace0\uc720\uac12\uacfc \uace0\uc720\ubca1\ud130", url: "#13", children: [
          ]},
          {title: "14. \uc9c1\uad50 \ud589\ub82c", url: "#14", children: [
          ]},
          {title: "15. QR \ubd84\ud574", url: "#15-qr", children: [
          ]},
          {title: "16. LU \ubd84\ud574", url: "#16-lu", children: [
          ]},
          {title: "17. SVD (\ud2b9\uc774\uac12 \ubd84\ud574)", url: "#17-svd", children: [
          ]},
          {title: "18. \ud589\ub82c\uc758 \ub178\ub984 (Matrix Norm)", url: "#18-matrix-norm", children: [
              {title: "1. Frobenius \ub178\ub984", url: "#1-frobenius" },
              {title: "2. 1-\ub178\ub984", url: "#2-1-" },
              {title: "3. \ubb34\ud55c \ub178\ub984 (Infinity Norm)", url: "#3-infinity-norm" },
          ]},
          {title: "19. \uc544\ub2e4\ub9c8\ub974 \uacf1 (Hadamard Product)", url: "#19-hadamard-product", children: [
          ]},
          {title: "20. \ube14\ub85d \ud589\ub82c (Block Matrix)", url: "#20-block-matrix", children: [
          ]},
          {title: "21. \ud589\ub82c \ubd84\ud574 (Matrix Decomposition)", url: "#21-matrix-decomposition", children: [
          ]},
          {title: "\ub300\ud45c\uc801\uc778 \ud589\ub82c \ubd84\ud574 \ubc29\ubc95", url: "#_1", children: [
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_03/0301/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_03/0301/" class="btn btn-xs btn-link">
        행렬 덧셈과 뺄셈
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0204/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0204/" class="btn btn-xs btn-link">
        Eigen의 템플릿 기법
      </a>
    </div>
    
  </div>

    

    <h3 id="1">1. 덧셈과 뺄셈</h3>
<p>행렬과 벡터의 덧셈과 뺄셈은 동일한 차원을 가진 경우에만 가능하다. 이를 수학적으로 표현하면, 두 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>가 같은 차원 <span class="arithmatex"><span class="MathJax_Preview">\mathbb{R}^{m \times n}</span><script type="math/tex">\mathbb{R}^{m \times n}</script></span>에 속해 있을 때 덧셈은 아래와 같이 이루어진다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \mathbf{A} + \mathbf{B}, \quad \mathbf{C}(i,j) = \mathbf{A}(i,j) + \mathbf{B}(i,j)
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \mathbf{A} + \mathbf{B}, \quad \mathbf{C}(i,j) = \mathbf{A}(i,j) + \mathbf{B}(i,j)
</script>
</div>
<p>위 수식에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}(i,j)</span><script type="math/tex">\mathbf{A}(i,j)</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}(i,j)</span><script type="math/tex">\mathbf{B}(i,j)</script></span>는 각각 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">(i,j)</span><script type="math/tex">(i,j)</script></span> 성분을 의미하며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}</span><script type="math/tex">\mathbf{C}</script></span>의 성분 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{C}(i,j)</span><script type="math/tex">\mathbf{C}(i,j)</script></span>는 두 행렬 성분의 합으로 정의된다. 벡터의 덧셈도 유사하며, 두 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}, \mathbf{v} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{u}, \mathbf{v} \in \mathbb{R}^n</script></span>에 대해 성분별로 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{w} = \mathbf{u} + \mathbf{v}, \quad \mathbf{w}(i) = \mathbf{u}(i) + \mathbf{v}(i)
</div>
<script type="math/tex; mode=display">
\mathbf{w} = \mathbf{u} + \mathbf{v}, \quad \mathbf{w}(i) = \mathbf{u}(i) + \mathbf{v}(i)
</script>
</div>
<p>벡터와 행렬의 뺄셈 역시 덧셈과 동일한 방식으로 성분별로 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{D} = \mathbf{A} - \mathbf{B}, \quad \mathbf{D}(i,j) = \mathbf{A}(i,j) - \mathbf{B}(i,j)
</div>
<script type="math/tex; mode=display">
\mathbf{D} = \mathbf{A} - \mathbf{B}, \quad \mathbf{D}(i,j) = \mathbf{A}(i,j) - \mathbf{B}(i,j)
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{z} = \mathbf{u} - \mathbf{v}, \quad \mathbf{z}(i) = \mathbf{u}(i) - \mathbf{v}(i)
</div>
<script type="math/tex; mode=display">
\mathbf{z} = \mathbf{u} - \mathbf{v}, \quad \mathbf{z}(i) = \mathbf{u}(i) - \mathbf{v}(i)
</script>
</div>
<p>Eigen 라이브러리에서 행렬과 벡터의 덧셈 및 뺄셈은 간단하게 <code>+</code> 및 <code>-</code> 연산자를 사용하여 구현할 수 있다. 예시 코드는 다음과 같다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d A, B, C;
C = A + B;
</code></pre>
<h3 id="2">2. 스칼라 곱셈</h3>
<p>행렬 또는 벡터에 스칼라 값을 곱하는 연산은 각 성분에 동일한 스칼라 값을 곱하는 방식으로 이루어진다. 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>과 스칼라 <span class="arithmatex"><span class="MathJax_Preview">c \in \mathbb{R}</span><script type="math/tex">c \in \mathbb{R}</script></span>에 대해 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{B} = c \mathbf{A}, \quad \mathbf{B}(i,j) = c \cdot \mathbf{A}(i,j)
</div>
<script type="math/tex; mode=display">
\mathbf{B} = c \mathbf{A}, \quad \mathbf{B}(i,j) = c \cdot \mathbf{A}(i,j)
</script>
</div>
<p>벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{u} \in \mathbb{R}^n</script></span>에 스칼라 <span class="arithmatex"><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span>를 곱하는 경우도 마찬가지로 성분별로 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v} = c \mathbf{u}, \quad \mathbf{v}(i) = c \cdot \mathbf{u}(i)
</div>
<script type="math/tex; mode=display">
\mathbf{v} = c \mathbf{u}, \quad \mathbf{v}(i) = c \cdot \mathbf{u}(i)
</script>
</div>
<p>이 연산은 행렬과 벡터의 크기를 조정하거나 방향성을 유지한 채 크기를 변경할 때 자주 사용된다. Eigen 라이브러리에서 스칼라 곱셈은 다음과 같이 구현된다:</p>
<pre><code class="language-cpp">Eigen::Vector3d u, v;
double c = 2.0;
v = c * u;
</code></pre>
<h3 id="3">3. 행렬 곱셈</h3>
<p>두 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B} \in \mathbb{R}^{n \times p}</span><script type="math/tex">\mathbf{B} \in \mathbb{R}^{n \times p}</script></span>의 곱은 일반적으로 아래와 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \mathbf{A} \mathbf{B}, \quad \mathbf{C}(i,j) = \sum_{k=1}^{n} \mathbf{A}(i,k) \mathbf{B}(k,j)
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \mathbf{A} \mathbf{B}, \quad \mathbf{C}(i,j) = \sum_{k=1}^{n} \mathbf{A}(i,k) \mathbf{B}(k,j)
</script>
</div>
<p>행렬 곱셈은 행렬의 행과 열을 서로 곱하여 합을 구하는 방식으로 계산되며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 열의 개수는 반드시 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>의 행의 개수와 일치해야 한다. 행렬 곱셈은 선형 변환을 표현하는 중요한 연산 중 하나이다.</p>
<p>벡터에 행렬을 곱하는 경우, 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>과 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{v} \in \mathbb{R}^n</script></span>이 주어졌을 때, 결과 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{w} \in \mathbb{R}^m</span><script type="math/tex">\mathbf{w} \in \mathbb{R}^m</script></span>는 아래와 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{w} = \mathbf{A} \mathbf{v}, \quad \mathbf{w}(i) = \sum_{k=1}^{n} \mathbf{A}(i,k) \mathbf{v}(k)
</div>
<script type="math/tex; mode=display">
\mathbf{w} = \mathbf{A} \mathbf{v}, \quad \mathbf{w}(i) = \sum_{k=1}^{n} \mathbf{A}(i,k) \mathbf{v}(k)
</script>
</div>
<p>Eigen 라이브러리에서 행렬 곱셈은 <code>*</code> 연산자를 통해 쉽게 구현할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d A, B, C;
C = A * B;

Eigen::Vector3d u, w;
w = A * u;
</code></pre>
<h3 id="4">4. 전치 행렬</h3>
<p>행렬의 전치(transpose)는 행과 열을 서로 바꾼 행렬을 의미한다. 주어진 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>에 대해 전치 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}^T \in \mathbb{R}^{n \times m}</span><script type="math/tex">\mathbf{A}^T \in \mathbb{R}^{n \times m}</script></span>는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}^T(i,j) = \mathbf{A}(j,i)
</div>
<script type="math/tex; mode=display">
\mathbf{A}^T(i,j) = \mathbf{A}(j,i)
</script>
</div>
<p>즉, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">(i,j)</span><script type="math/tex">(i,j)</script></span> 성분이 전치 행렬에서는 <span class="arithmatex"><span class="MathJax_Preview">(j,i)</span><script type="math/tex">(j,i)</script></span> 성분으로 이동하는 것이다. 전치 행렬은 주로 내적이나 역행렬 계산 등에 활용되며, Eigen 라이브러리에서는 <code>.transpose()</code> 함수를 사용하여 전치를 구할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d A, B;
B = A.transpose();
</code></pre>
<h3 id="5-dot-product">5. 내적 (Dot Product)</h3>
<p>두 벡터의 내적은 벡터 공간에서 중요한 연산 중 하나로, 두 벡터 사이의 각도를 계산하거나 벡터의 투영을 구하는 데 활용된다. 두 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}, \mathbf{v} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{u}, \mathbf{v} \in \mathbb{R}^n</script></span>의 내적은 아래와 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{u} \cdot \mathbf{v} = \sum_{i=1}^{n} \mathbf{u}(i) \mathbf{v}(i)
</div>
<script type="math/tex; mode=display">
\mathbf{u} \cdot \mathbf{v} = \sum_{i=1}^{n} \mathbf{u}(i) \mathbf{v}(i)
</script>
</div>
<p>내적의 결과는 스칼라 값이며, 이는 벡터 간의 평행성이나 직교성을 평가하는 데 유용하다. Eigen 라이브러리에서는 <code>.dot()</code> 함수를 사용하여 내적을 계산할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Vector3d u, v;
double dot_product = u.dot(v);
</code></pre>
<h3 id="6-cross-product">6. 외적 (Cross Product)</h3>
<p>외적은 3차원 공간에서 두 벡터 사이의 직교하는 벡터를 구하는 연산이다. 주어진 두 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}, \mathbf{v} \in \mathbb{R}^3</span><script type="math/tex">\mathbf{u}, \mathbf{v} \in \mathbb{R}^3</script></span>의 외적은 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{w} = \mathbf{u} \times \mathbf{v}
</div>
<script type="math/tex; mode=display">
\mathbf{w} = \mathbf{u} \times \mathbf{v}
</script>
</div>
<p>외적의 결과는 두 벡터와 직교하는 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{w}</span><script type="math/tex">\mathbf{w}</script></span>이며, 그 성분은 아래와 같다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{w} = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\ u_1 &amp; u_2 &amp; u_3 \\ v_1 &amp; v_2 &amp; v_3 \end{vmatrix}
= \left( u_2 v_3 - u_3 v_2 \right) \mathbf{i} - \left( u_1 v_3 - u_3 v_1 \right) \mathbf{j} + \left( u_1 v_2 - u_2 v_1 \right) \mathbf{k}
</div>
<script type="math/tex; mode=display">
\mathbf{w} = \begin{vmatrix} \mathbf{i} & \mathbf{j} & \mathbf{k} \\ u_1 & u_2 & u_3 \\ v_1 & v_2 & v_3 \end{vmatrix}
= \left( u_2 v_3 - u_3 v_2 \right) \mathbf{i} - \left( u_1 v_3 - u_3 v_1 \right) \mathbf{j} + \left( u_1 v_2 - u_2 v_1 \right) \mathbf{k}
</script>
</div>
<p>이 식에서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{i}, \mathbf{j}, \mathbf{k}</span><script type="math/tex">\mathbf{i}, \mathbf{j}, \mathbf{k}</script></span>는 각각 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, <span class="arithmatex"><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>, <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span> 방향의 단위 벡터이다.</p>
<p>외적은 벡터의 평면에서 수직인 벡터를 구하거나, 두 벡터가 이루는 평행사변형의 넓이를 구할 때 사용된다. Eigen 라이브러리에서 외적은 <code>.cross()</code> 함수를 사용하여 구할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Vector3d u, v, w;
w = u.cross(v);
</code></pre>
<h3 id="7">7. 역행렬</h3>
<p>역행렬은 주어진 정방행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>에 대해, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 곱했을 때 단위 행렬이 되는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}^{-1}</span><script type="math/tex">\mathbf{A}^{-1}</script></span>을 의미한다. 즉, 아래의 관계를 만족하는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}^{-1}</span><script type="math/tex">\mathbf{A}^{-1}</script></span>을 찾는 것이다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \mathbf{A}^{-1} = \mathbf{I}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \mathbf{A}^{-1} = \mathbf{I}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{I}</span><script type="math/tex">\mathbf{I}</script></span>는 단위 행렬(identity matrix)이다. 역행렬은 행렬이 정칙(invertible)일 때만 존재하며, 정칙 행렬은 행렬식(determinant)이 0이 아닌 행렬을 의미한다. </p>
<p>역행렬은 선형 방정식의 해를 구하거나, 시스템의 역을 구할 때 사용된다. Eigen 라이브러리에서는 <code>.inverse()</code> 함수를 사용하여 역행렬을 구할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d A, A_inv;
A_inv = A.inverse();
</code></pre>
<p>역행렬이 존재하는지 여부는 행렬식의 값에 따라 결정된다. 행렬식이 0일 경우 역행렬은 존재하지 않는다.</p>
<h3 id="8">8. 행렬식</h3>
<p>행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>의 행렬식(determinant)은 그 행렬의 고유한 스칼라 값을 의미하며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>가 역행렬을 가질 수 있는지 여부를 결정하는 중요한 지표이다. <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 행렬식은 <span class="arithmatex"><span class="MathJax_Preview">\det(\mathbf{A})</span><script type="math/tex">\det(\mathbf{A})</script></span>로 나타내며, 예를 들어 <span class="arithmatex"><span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script></span> 행렬의 경우 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\det(\mathbf{A}) = a_{11}a_{22} - a_{12}a_{21}
</div>
<script type="math/tex; mode=display">
\det(\mathbf{A}) = a_{11}a_{22} - a_{12}a_{21}
</script>
</div>
<p>더 높은 차원의 행렬식은 보다 복잡한 방식으로 계산되며, 다중 행과 열에 걸친 소행렬식(cofactor)을 활용한다. 행렬식이 0인 경우, 행렬은 역행렬을 갖지 않으며 "특이(singular)"하다고 한다.</p>
<p>Eigen 라이브러리에서는 <code>.determinant()</code> 함수를 사용하여 행렬식을 계산할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d A;
double det_A = A.determinant();
</code></pre>
<h3 id="9-trace">9. 대각합 (Trace)</h3>
<p>대각합(trace)은 정방행렬의 대각 성분의 합을 의미하며, 이는 행렬의 고유값의 합과 같다는 특징을 가진다. 주어진 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>에 대해 대각합은 아래와 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{Tr}(\mathbf{A}) = \sum_{i=1}^{n} \mathbf{A}(i,i)
</div>
<script type="math/tex; mode=display">
\text{Tr}(\mathbf{A}) = \sum_{i=1}^{n} \mathbf{A}(i,i)
</script>
</div>
<p>대각합은 주로 행렬의 특성을 요약하는 데 사용되며, 고유값 문제에서 중요한 역할을 한다. Eigen 라이브러리에서는 <code>.trace()</code> 함수를 사용하여 대각합을 구할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d A;
double trace_A = A.trace();
</code></pre>
<h3 id="10">10. 단위 행렬</h3>
<p>단위 행렬(identity matrix)은 주어진 차원의 정방 행렬에서 모든 대각 성분이 1이고, 그 외의 성분이 모두 0인 행렬이다. 단위 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{I} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{I} \in \mathbb{R}^{n \times n}</script></span>은 아래와 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{I} = 
\begin{pmatrix}
1 &amp; 0 &amp; \cdots &amp; 0 \\
0 &amp; 1 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; 1
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{I} = 
\begin{pmatrix}
1 & 0 & \cdots & 0 \\
0 & 1 & \cdots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \cdots & 1
\end{pmatrix}
</script>
</div>
<p>단위 행렬은 행렬 곱셈에서 항등원 역할을 한다. 즉, 임의의 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>에 대해 다음이 성립한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \mathbf{I} = \mathbf{I} \mathbf{A} = \mathbf{A}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \mathbf{I} = \mathbf{I} \mathbf{A} = \mathbf{A}
</script>
</div>
<p>단위 행렬은 주로 행렬 계산에서 기준점이 되는 행렬로 사용되며, 역행렬 계산, 선형 시스템 분석 등 다양한 곳에서 활용된다.</p>
<p>Eigen 라이브러리에서는 <code>Eigen::MatrixXd::Identity()</code> 함수를 통해 단위 행렬을 생성할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d I = Eigen::Matrix3d::Identity();
</code></pre>
<h3 id="11">11. 대칭 행렬</h3>
<p>대칭 행렬(symmetric matrix)은 주어진 행렬의 전치 행렬이 원래 행렬과 동일한 행렬을 의미한다. 즉, 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>에 대해 다음 조건을 만족하면 대칭 행렬이라고 한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}^T = \mathbf{A}
</div>
<script type="math/tex; mode=display">
\mathbf{A}^T = \mathbf{A}
</script>
</div>
<p>이 의미는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 <span class="arithmatex"><span class="MathJax_Preview">(i,j)</span><script type="math/tex">(i,j)</script></span> 성분과 <span class="arithmatex"><span class="MathJax_Preview">(j,i)</span><script type="math/tex">(j,i)</script></span> 성분이 동일하다는 것을 나타낸다. 즉, 아래가 성립한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}(i,j) = \mathbf{A}(j,i)
</div>
<script type="math/tex; mode=display">
\mathbf{A}(i,j) = \mathbf{A}(j,i)
</script>
</div>
<p>대칭 행렬은 선형 대수학에서 중요한 특성을 가지고 있으며, 특히 고유값이 실수(real number)라는 성질을 가진다. 물리학, 통계학, 제어 시스템에서 자주 등장하며, 예를 들어 공분산 행렬이 대칭 행렬의 대표적인 예이다.</p>
<p>Eigen 라이브러리에서 대칭 행렬을 생성하려면 행렬의 특정 성분을 직접 설정할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d A;
A(0, 1) = A(1, 0) = value;  // 대칭 관계 설정
</code></pre>
<h3 id="12">12. 대각 행렬</h3>
<p>대각 행렬(diagonal matrix)은 모든 비대각 성분이 0인 정방 행렬을 말한다. 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>이 대각 행렬이라면 다음과 같은 구조를 갖는다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A}(i,j) = 0 \quad \text{for } i \neq j
</div>
<script type="math/tex; mode=display">
\mathbf{A}(i,j) = 0 \quad \text{for } i \neq j
</script>
</div>
<p>즉, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 비대각 성분은 모두 0이고, 대각 성분은 0이 아닐 수 있다. 대각 행렬은 행렬 곱셈에서 계산이 간단하며, 고유값 문제나 선형 시스템 해석에서 중요한 역할을 한다.</p>
<p>대각 행렬은 Eigen 라이브러리에서 <code>Eigen::DiagonalMatrix</code> 클래스를 사용하여 생성할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Vector3d diag_values;
Eigen::DiagonalMatrix&lt;double, 3&gt; D(diag_values);
</code></pre>
<p>또한 일반 행렬에서 대각 성분만 추출하려면 <code>.diagonal()</code> 함수를 사용할 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d A;
Eigen::Vector3d diag = A.diagonal();
</code></pre>
<h3 id="13">13. 고유값과 고유벡터</h3>
<p>행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>의 고유값(eigenvalue)과 고유벡터(eigenvector)는 다음 조건을 만족하는 <span class="arithmatex"><span class="MathJax_Preview">\lambda \in \mathbb{R}</span><script type="math/tex">\lambda \in \mathbb{R}</script></span> (고유값)과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v} \in \mathbb{R}^n</span><script type="math/tex">\mathbf{v} \in \mathbb{R}^n</script></span> (고유벡터)를 의미한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \mathbf{v} = \lambda \mathbf{v}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \mathbf{v} = \lambda \mathbf{v}
</script>
</div>
<p>이때 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 고유벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>의 방향을 변화시키지 않고 크기만 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>로 조정하는 역할을 한다. 고유값과 고유벡터는 선형 변환의 특성을 분석하는 데 중요한 개념으로, 특히 시스템의 안정성 분석, 진동 모드, 데이터 축소(예: PCA) 등에 활용된다.</p>
<p>Eigen 라이브러리에서는 고유값과 고유벡터를 구하기 위해 <code>Eigen::EigenSolver</code> 클래스를 사용할 수 있다. 예시는 다음과 같다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d A;
Eigen::EigenSolver&lt;Eigen::Matrix3d&gt; solver(A);
Eigen::Vector3cd eigenvalues = solver.eigenvalues();
Eigen::Matrix3cd eigenvectors = solver.eigenvectors();
</code></pre>
<h3 id="14">14. 직교 행렬</h3>
<p>직교 행렬(orthogonal matrix)은 그 행렬의 전치 행렬이 역행렬과 동일한 행렬을 의미한다. 즉, 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{Q} \in \mathbb{R}^{n \times n}</script></span>이 직교 행렬이라면 다음 조건을 만족한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{Q}^T \mathbf{Q} = \mathbf{Q} \mathbf{Q}^T = \mathbf{I}
</div>
<script type="math/tex; mode=display">
\mathbf{Q}^T \mathbf{Q} = \mathbf{Q} \mathbf{Q}^T = \mathbf{I}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{I}</span><script type="math/tex">\mathbf{I}</script></span>는 단위 행렬(identity matrix)이다. 직교 행렬의 중요한 특성 중 하나는 그 열 벡터가 서로 직교하고, 모든 벡터의 크기가 1로 정규화(normalized)되어 있다는 점이다. 즉, 직교 행렬의 열 또는 행 벡터는 모두 단위 벡터(orthonormal)이다.</p>
<p>직교 행렬은 회전 변환과 반사 변환에서 중요한 역할을 하며, 수치 해석에서 정규 직교 기저를 사용하여 계산을 간단하게 할 수 있다.</p>
<p>Eigen 라이브러리에서는 직교 행렬을 생성하거나 검증하기 위해 다양한 방법을 사용할 수 있으며, QR 분해 등의 알고리즘을 활용해 직교 행렬을 얻을 수 있다:</p>
<pre><code class="language-cpp">Eigen::Matrix3d A;
Eigen::HouseholderQR&lt;Eigen::Matrix3d&gt; qr(A);
Eigen::Matrix3d Q = qr.householderQ();
</code></pre>
<h3 id="15-qr">15. QR 분해</h3>
<p>QR 분해는 임의의 행렬을 직교 행렬과 상삼각 행렬로 분해하는 방법이다. 주어진 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>을 다음과 같이 두 행렬의 곱으로 표현한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{Q} \mathbf{R}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{Q} \mathbf{R}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q} \in \mathbb{R}^{m \times m}</span><script type="math/tex">\mathbf{Q} \in \mathbb{R}^{m \times m}</script></span>는 직교 행렬이고, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{R} \in \mathbb{R}^{m \times n}</script></span>은 상삼각 행렬이다. QR 분해는 주로 선형 시스템 해석, 최소자승 문제, 그리고 고유값 계산 등에 사용된다.</p>
<p>Eigen 라이브러리에서는 QR 분해를 다음과 같이 수행할 수 있다:</p>
<pre><code class="language-cpp">Eigen::MatrixXd A;
Eigen::HouseholderQR&lt;Eigen::MatrixXd&gt; qr(A);
Eigen::MatrixXd Q = qr.householderQ();
Eigen::MatrixXd R = qr.matrixQR().triangularView&lt;Eigen::Upper&gt;();
</code></pre>
<h3 id="16-lu">16. LU 분해</h3>
<p>LU 분해는 행렬을 하삼각 행렬과 상삼각 행렬로 분해하는 방법이다. 주어진 정방행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{n \times n}</script></span>을 아래와 같이 두 행렬의 곱으로 나타낸다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{L} \mathbf{U}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{L} \mathbf{U}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>은 하삼각 행렬(lower triangular matrix), <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>는 상삼각 행렬(upper triangular matrix)이다. LU 분해는 선형 시스템 해석, 역행렬 계산, 행렬식 계산 등에 사용된다.</p>
<p>Eigen 라이브러리에서는 LU 분해를 아래와 같이 구현할 수 있다:</p>
<pre><code class="language-cpp">Eigen::MatrixXd A;
Eigen::FullPivLU&lt;Eigen::MatrixXd&gt; lu(A);
Eigen::MatrixXd L = lu.matrixLU().triangularView&lt;Eigen::Lower&gt;();
Eigen::MatrixXd U = lu.matrixLU().triangularView&lt;Eigen::Upper&gt;();
</code></pre>
<h3 id="17-svd">17. SVD (특이값 분해)</h3>
<p>특이값 분해(SVD, Singular Value Decomposition)는 임의의 행렬을 세 개의 행렬 곱으로 분해하는 방법이다. 주어진 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>에 대해 다음과 같은 분해를 한다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^T
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^T
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U} \in \mathbb{R}^{m \times m}</span><script type="math/tex">\mathbf{U} \in \mathbb{R}^{m \times m}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V} \in \mathbb{R}^{n \times n}</span><script type="math/tex">\mathbf{V} \in \mathbb{R}^{n \times n}</script></span>는 직교 행렬이며, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Sigma} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{\Sigma} \in \mathbb{R}^{m \times n}</script></span>는 대각 행렬로 특이값을 포함한다. SVD는 선형 변환의 특성을 분석하고, 데이터 압축이나 차원 축소(PCA) 등의 응용에서 중요한 역할을 한다.</p>
<p>Eigen 라이브러리에서 SVD는 <code>JacobiSVD</code> 클래스를 사용하여 계산할 수 있다:</p>
<pre><code class="language-cpp">Eigen::MatrixXd A;
Eigen::JacobiSVD&lt;Eigen::MatrixXd&gt; svd(A, Eigen::ComputeThinU | Eigen::ComputeThinV);
Eigen::MatrixXd U = svd.matrixU();
Eigen::MatrixXd V = svd.matrixV();
Eigen::VectorXd S = svd.singularValues();
</code></pre>
<p>SVD는 임의의 행렬에 대해 매우 안정적인 분해 방법으로, 특히 고유값이 존재하지 않는 경우에도 유용하게 사용된다.</p>
<h3 id="18-matrix-norm">18. 행렬의 노름 (Matrix Norm)</h3>
<p>행렬의 노름(matrix norm)은 행렬의 크기를 측정하는 수치이다. 노름은 여러 가지 방식으로 정의될 수 있으며, 각 정의는 행렬의 특정 성질을 강조한다. 일반적으로 사용되는 몇 가지 행렬 노름은 다음과 같다.</p>
<h4 id="1-frobenius">1. Frobenius 노름</h4>
<p>Frobenius 노름은 행렬의 모든 성분의 제곱합에 루트를 취한 값으로 정의된다. 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>에 대해 Frobenius 노름은 아래와 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{A}\|_F = \sqrt{\sum_{i=1}^{m} \sum_{j=1}^{n} |\mathbf{A}(i,j)|^2}
</div>
<script type="math/tex; mode=display">
\|\mathbf{A}\|_F = \sqrt{\sum_{i=1}^{m} \sum_{j=1}^{n} |\mathbf{A}(i,j)|^2}
</script>
</div>
<p>Frobenius 노름은 유클리드 거리와 비슷한 방식으로 행렬의 크기를 측정하며, 행렬의 전 성분에 대해 고르게 기여하는 특징이 있다.</p>
<p>Eigen 라이브러리에서는 Frobenius 노름을 <code>norm()</code> 함수로 구할 수 있다:</p>
<pre><code class="language-cpp">Eigen::MatrixXd A;
double frobenius_norm = A.norm();
</code></pre>
<h4 id="2-1-">2. 1-노름</h4>
<p>1-노름은 행렬의 각 열에서 절대값의 합 중 가장 큰 값을 나타낸다. 수학적으로는 다음과 같이 정의된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{A}\|_1 = \max_{1 \leq j \leq n} \sum_{i=1}^{m} |\mathbf{A}(i,j)|
</div>
<script type="math/tex; mode=display">
\|\mathbf{A}\|_1 = \max_{1 \leq j \leq n} \sum_{i=1}^{m} |\mathbf{A}(i,j)|
</script>
</div>
<p>1-노름은 행렬의 각 열의 크기 중 가장 큰 값을 강조하는 방식으로 크기를 측정한다.</p>
<h4 id="3-infinity-norm">3. 무한 노름 (Infinity Norm)</h4>
<p>무한 노름은 행렬의 각 행에서 절대값의 합 중 가장 큰 값을 나타낸다. 이는 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\|\mathbf{A}\|_\infty = \max_{1 \leq i \leq m} \sum_{j=1}^{n} |\mathbf{A}(i,j)|
</div>
<script type="math/tex; mode=display">
\|\mathbf{A}\|_\infty = \max_{1 \leq i \leq m} \sum_{j=1}^{n} |\mathbf{A}(i,j)|
</script>
</div>
<p>무한 노름은 행렬의 각 행에 집중하여, 가장 큰 합을 가지는 행의 크기를 측정하는 방식이다.</p>
<p>Eigen 라이브러리에서는 1-노름과 무한 노름을 직접 계산하려면 행렬의 성분을 순차적으로 합산하고, 그 최대값을 찾는 방식으로 구현할 수 있다.</p>
<h3 id="19-hadamard-product">19. 아다마르 곱 (Hadamard Product)</h3>
<p>아다마르 곱(Hadamard Product)은 두 행렬의 성분별 곱으로 정의된다. 주어진 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}, \mathbf{B} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A}, \mathbf{B} \in \mathbb{R}^{m \times n}</script></span>에 대해 슈어 보곱은 다음과 같이 계산된다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \mathbf{A} \circ \mathbf{B}, \quad \mathbf{C}(i,j) = \mathbf{A}(i,j) \cdot \mathbf{B}(i,j)
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \mathbf{A} \circ \mathbf{B}, \quad \mathbf{C}(i,j) = \mathbf{A}(i,j) \cdot \mathbf{B}(i,j)
</script>
</div>
<p>아다마르 곱은 성분별로 행렬을 곱하는 연산으로, 행렬의 크기가 동일할 때에만 정의된다. 이 연산은 주로 통계 및 신호 처리 분야에서 자주 사용된다.</p>
<p>Eigen 라이브러리에서는 아다마르 곱을 <code>cwiseProduct()</code> 함수를 사용하여 계산할 수 있다:</p>
<pre><code class="language-cpp">Eigen::MatrixXd A, B, C;
C = A.cwiseProduct(B);
</code></pre>
<h3 id="20-block-matrix">20. 블록 행렬 (Block Matrix)</h3>
<p>블록 행렬(block matrix)은 행렬을 더 작은 행렬로 나누어 다루는 방법이다. 이를 통해 행렬의 특정 부분을 효율적으로 처리하거나, 복잡한 행렬 연산을 간단하게 구현할 수 있다. 예를 들어, 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \in \mathbb{R}^{m \times n}</span><script type="math/tex">\mathbf{A} \in \mathbb{R}^{m \times n}</script></span>을 두 개의 작은 행렬로 나눈다면 다음과 같이 표현할 수 있다:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} =
\begin{pmatrix}
\mathbf{A}_{11} &amp; \mathbf{A}_{12} \\
\mathbf{A}_{21} &amp; \mathbf{A}_{22}
\end{pmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} =
\begin{pmatrix}
\mathbf{A}_{11} & \mathbf{A}_{12} \\
\mathbf{A}_{21} & \mathbf{A}_{22}
\end{pmatrix}
</script>
</div>
<p>각각의 블록 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{ij}</span><script type="math/tex">\mathbf{A}_{ij}</script></span>는 더 작은 행렬로, 블록 행렬을 활용하여 행렬의 연산을 효율적으로 처리할 수 있다.</p>
<p>Eigen 라이브러리에서는 <code>block()</code> 함수를 통해 행렬의 특정 블록을 추출하거나 설정할 수 있다:</p>
<pre><code class="language-cpp">Eigen::MatrixXd A(4, 4);
Eigen::MatrixXd B = A.block(0, 0, 2, 2);  // A의 (0,0) 위치에서 2x2 블록 추출
</code></pre>
<h3 id="21-matrix-decomposition">21. 행렬 분해 (Matrix Decomposition)</h3>
<p>행렬 분해(matrix decomposition)은 주어진 행렬을 더 작은 행렬로 분해하여 처리하는 방법이다. 앞서 소개한 LU 분해, QR 분해, SVD 분해 등 다양한 분해 방법을 포함하여, 행렬의 특성에 맞게 최적의 분해 방법을 선택할 수 있다. 분해 방법은 선형 시스템 해석, 고유값 문제, 최적화 등에 널리 사용된다.</p>
<h3 id="_1">대표적인 행렬 분해 방법</h3>
<ol>
<li>
<p><strong>LU 분해</strong>: 행렬을 하삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>과 상삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>로 분해하는 방법. 이 방법은 주로 선형 방정식 해법에서 사용된다.</p>
</li>
<li>
<p><strong>QR 분해</strong>: 행렬을 직교 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>와 상삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>로 분해하는 방법. QR 분해는 고유값 문제를 다루거나 최소자승법(Least Squares)에 유용하다.</p>
</li>
<li>
<p><strong>SVD (Singular Value Decomposition)</strong>: 임의의 행렬을 직교 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}</span><script type="math/tex">\mathbf{V}</script></span>와 대각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Sigma}</span><script type="math/tex">\mathbf{\Sigma}</script></span>로 분해하는 방법. SVD는 행렬의 차원 축소 및 데이터 압축에 사용된다.</p>
</li>
<li>
<p><strong>Cholesky 분해</strong>: 대칭이고 양의 정부호인 행렬을 하삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>과 그 전치 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}^T</span><script type="math/tex">\mathbf{L}^T</script></span>로 분해하는 방법. Cholesky 분해는 수치적으로 매우 안정적이며, 주로 선형 방정식 해법에서 사용된다.</p>
</li>
</ol>
<p>Eigen 라이브러리에서는 다양한 행렬 분해 알고리즘을 쉽게 구현할 수 있다. 예를 들어, Cholesky 분해는 다음과 같이 구현할 수 있다:</p>
<pre><code class="language-cpp">Eigen::MatrixXd A;
Eigen::LLT&lt;Eigen::MatrixXd&gt; llt(A);
Eigen::MatrixXd L = llt.matrixL();  // 하삼각 행렬 L
</code></pre>
<p>각 행렬 분해 방법은 주어진 문제의 특성에 맞춰 선택되며, 연산의 효율성과 안정성을 크게 개선할 수 있다.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../../chapter_03/0301/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../../chapter_03/0301/" class="btn btn-xs btn-link">
        행렬 덧셈과 뺄셈
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../0204/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../0204/" class="btn btn-xs btn-link">
        Eigen의 템플릿 기법
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>