<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://booiljung.github.io/math/linear_algebra/eigen_library/chapter_02/0201/">
    <link rel="shortcut icon" href="../../../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Vector 클래스와 행렬 클래스 소개 - 실험 도서관</title>
    <link href="../../../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../../../css/highlight.css">
    <link href="../../../../../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Vector \ud074\ub798\uc2a4\uc640 \ud589\ub82c \ud074\ub798\uc2a4 \uc18c\uac1c", url: "#_top", children: [
              {title: "Vector \ud074\ub798\uc2a4", url: "#vector_1" },
              {title: "\ud589\ub82c \ud074\ub798\uc2a4", url: "#_1" },
              {title: "Vector \ud074\ub798\uc2a4\uc640 \ud589\ub82c \ud074\ub798\uc2a4\uc758 \ud06c\uae30 \ub3d9\uc801 \ud560\ub2f9", url: "#vector_2" },
              {title: "\ubca1\ud130\uc640 \ud589\ub82c\uc758 \ubcc0\ud658", url: "#_4" },
              {title: "\ubca1\ud130\uc640 \ud589\ub82c\uc758 \uae30\ubcf8 \uc5f0\uc0b0", url: "#_7" },
              {title: "\ube14\ub85d \uc5f0\uc0b0 (Block Operations)", url: "#block-operations" },
              {title: "\ubc30\uc5f4\uacfc \ud589\ub82c\uc758 \uc5f0\uc0b0 \ucc28\uc774", url: "#_17" },
              {title: "\ud6a8\uc728\uc801\uc778 \uba54\ubaa8\ub9ac \uad00\ub9ac", url: "#_19" },
              {title: "\uba54\ubaa8\ub9ac \ub9e4\ud551 (Memory Mapping)", url: "#memory-mapping" },
              {title: "Eigen\uc758 \uace0\uae09 \uae30\ub2a5", url: "#eigen" },
          ]},
        ];

    </script>
    <script src="../../../../../js/base.js"></script>
      <script src="../../../../../js/google_analytics.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      <script src="https://www.googletagmanager.com/gtag/js?id=G-3F4LHCTF88"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <h1 id="vector">Vector 클래스와 행렬 클래스 소개</h1>
<p>Eigen 라이브러리에서 가장 중요한 클래스 중 하나는 벡터와 행렬을 다루는 클래스입니다. 이들은 다양한 수학적 연산을 효율적으로 처리할 수 있도록 설계되어 있으며, 특히 선형대수학적 문제를 해결하는 데 매우 유용합니다. 본 장에서는 Vector 클래스와 Matrix 클래스의 구조, 기능, 사용 방법을 다룹니다.</p>
<h3 id="vector_1">Vector 클래스</h3>
<p>Eigen에서 벡터는 1차원 배열로 표현되며, 선형대수에서 다루는 벡터와 동일한 의미를 가집니다. 벡터는 방향과 크기를 가지며, 2차원, 3차원, 혹은 그 이상의 차원에서도 정의될 수 있습니다. Eigen의 벡터 클래스는 <code>Eigen::VectorXd</code>와 같은 형식으로 사용되며, 이는 차원이 동적으로 할당된 벡터를 의미합니다. 차원이 정해진 벡터는 <code>Eigen::Vector3d</code>와 같은 형식으로 정의됩니다. </p>
<p>예를 들어, 3차원 벡터는 다음과 같이 정의할 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::Vector3d v;
v &lt;&lt; 1, 2, 3;
</code></pre>
<p>이러한 벡터는 수학적으로 다음과 같이 표현됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v} = \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{v} = \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix}
</script>
</div>
<p>이러한 벡터의 기본 연산에는 덧셈, 뺄셈, 스칼라 곱, 내적 등이 포함됩니다. 벡터 간의 덧셈은 다음과 같이 정의됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v_1} + \mathbf{v_2} = \begin{bmatrix} v_{1x} \\ v_{1y} \\ v_{1z} \end{bmatrix} + \begin{bmatrix} v_{2x} \\ v_{2y} \\ v_{2z} \end{bmatrix} = \begin{bmatrix} v_{1x} + v_{2x} \\ v_{1y} + v_{2y} \\ v_{1z} + v_{2z} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{v_1} + \mathbf{v_2} = \begin{bmatrix} v_{1x} \\ v_{1y} \\ v_{1z} \end{bmatrix} + \begin{bmatrix} v_{2x} \\ v_{2y} \\ v_{2z} \end{bmatrix} = \begin{bmatrix} v_{1x} + v_{2x} \\ v_{1y} + v_{2y} \\ v_{1z} + v_{2z} \end{bmatrix}
</script>
</div>
<h3 id="_1">행렬 클래스</h3>
<p>Eigen의 행렬 클래스는 2차원 배열로, 행과 열로 구성되어 있습니다. 행렬은 다양한 형태로 정의될 수 있으며, 차원이 동적으로 할당되거나, 고정된 형태로 정의될 수 있습니다. 기본적인 행렬 클래스는 <code>Eigen::MatrixXd</code>로, 이는 동적으로 할당된 크기의 행렬을 의미합니다. 정해진 크기의 행렬은 <code>Eigen::Matrix3d</code>와 같은 형식으로 정의됩니다.</p>
<p>예를 들어, 3x3 행렬은 다음과 같이 정의됩니다.</p>
<pre><code class="language-cpp">Eigen::Matrix3d m;
m &lt;&lt; 1, 2, 3,
     4, 5, 6,
     7, 8, 9;
</code></pre>
<p>수학적으로, 이는 다음과 같은 행렬로 표현됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{M} = \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{M} = \begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \end{bmatrix}
</script>
</div>
<p>행렬의 기본 연산으로는 덧셈, 뺄셈, 스칼라 곱, 행렬 곱셈 등이 있습니다. 두 행렬의 곱셈은 다음과 같이 정의됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \cdot \mathbf{B} = \begin{bmatrix} a_{11} &amp; a_{12} \\ a_{21} &amp; a_{22} \end{bmatrix} \cdot \begin{bmatrix} b_{11} &amp; b_{12} \\ b_{21} &amp; b_{22} \end{bmatrix} = \begin{bmatrix} a_{11}b_{11} + a_{12}b_{21} &amp; a_{11}b_{12} + a_{12}b_{22} \\ a_{21}b_{11} + a_{22}b_{21} &amp; a_{21}b_{12} + a_{22}b_{22} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \cdot \mathbf{B} = \begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix} \cdot \begin{bmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \end{bmatrix} = \begin{bmatrix} a_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\ a_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22} \end{bmatrix}
</script>
</div>
<p>Eigen의 행렬 클래스는 다양한 크기의 행렬을 매우 효율적으로 처리하며, 이를 통해 대규모 수학적 계산을 빠르게 수행할 수 있습니다.</p>
<h3 id="vector_2">Vector 클래스와 행렬 클래스의 크기 동적 할당</h3>
<p>Eigen 라이브러리에서 Vector와 Matrix 클래스는 동적 크기 할당이 가능합니다. 즉, 프로그램 실행 중에 벡터나 행렬의 크기를 설정할 수 있으며, 이를 통해 더욱 유연한 구조로 사용할 수 있습니다.</p>
<h4 id="_2">동적 크기의 벡터</h4>
<p>동적 크기의 벡터는 <code>Eigen::VectorXd</code>로 정의되며, 크기를 실행 중에 할당할 수 있습니다. 예를 들어, 크기가 5인 벡터를 다음과 같이 정의할 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::VectorXd v(5);
v &lt;&lt; 1, 2, 3, 4, 5;
</code></pre>
<p>이 경우, 벡터의 수학적 표현은 다음과 같습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v} = \begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \\ 5 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{v} = \begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \\ 5 \end{bmatrix}
</script>
</div>
<p>또한, 벡터의 크기는 실행 중에 다시 변경할 수 있습니다. 예를 들어, 벡터의 크기를 10으로 늘리고 값을 초기화하는 코드는 다음과 같습니다.</p>
<pre><code class="language-cpp">v.resize(10);
v.setZero();  // 모든 원소를 0으로 초기화
</code></pre>
<p>이처럼 <code>resize()</code> 함수와 초기화 함수인 <code>setZero()</code>, <code>setOnes()</code> 등을 통해 크기와 내용을 동적으로 조정할 수 있습니다.</p>
<h4 id="_3">동적 크기의 행렬</h4>
<p>동적 크기의 행렬은 <code>Eigen::MatrixXd</code>로 정의되며, 마찬가지로 실행 중에 크기를 설정할 수 있습니다. 예를 들어, 3x4 행렬을 정의하는 코드는 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::MatrixXd m(3, 4);
m &lt;&lt; 1, 2, 3, 4,
     5, 6, 7, 8,
     9, 10, 11, 12;
</code></pre>
<p>이 행렬은 다음과 같이 표현됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{M} = \begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 \\ 5 &amp; 6 &amp; 7 &amp; 8 \\ 9 &amp; 10 &amp; 11 &amp; 12 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{M} = \begin{bmatrix} 1 & 2 & 3 & 4 \\ 5 & 6 & 7 & 8 \\ 9 & 10 & 11 & 12 \end{bmatrix}
</script>
</div>
<p>동적 크기의 행렬 역시 실행 중에 크기를 변경할 수 있습니다. 예를 들어, 이 행렬의 크기를 5x5로 조정하려면 다음과 같이 코딩할 수 있습니다.</p>
<pre><code class="language-cpp">m.resize(5, 5);
m.setIdentity();  // 단위 행렬로 설정
</code></pre>
<p>위 코드에서는 <code>resize()</code> 함수를 사용하여 행렬의 크기를 조정하고, <code>setIdentity()</code> 함수로 단위 행렬을 생성했습니다. 이렇게 Eigen의 행렬 클래스는 크기를 동적으로 조정하면서 다양한 수학적 연산을 효율적으로 수행할 수 있습니다.</p>
<h3 id="_4">벡터와 행렬의 변환</h3>
<p>벡터와 행렬 사이에는 여러 가지 변환이 가능합니다. 예를 들어, Eigen에서는 벡터를 행렬로 변환하거나 그 반대의 작업을 쉽게 수행할 수 있습니다.</p>
<h4 id="_5">벡터를 행렬로 변환</h4>
<p>Eigen의 벡터는 단순히 열 벡터로 간주될 수 있으며, 이를 행렬로 변환하는 것은 자연스럽습니다. 예를 들어, <code>Eigen::Vector3d</code> 타입의 벡터를 3x1 행렬로 변환하려면 별도의 변환 작업이 필요 없습니다. 벡터는 기본적으로 행렬의 한 형태로 취급되기 때문입니다.</p>
<pre><code class="language-cpp">Eigen::Vector3d v(1, 2, 3);
Eigen::MatrixXd m = v;
</code></pre>
<p>이 경우, 행렬 <code>m</code>은 다음과 같이 생성됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{M} = \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{M} = \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix}
</script>
</div>
<h4 id="_6">행렬에서 벡터 추출</h4>
<p>행렬에서 특정 열 또는 행을 추출하여 벡터로 변환할 수도 있습니다. 예를 들어, 3x3 행렬의 첫 번째 열을 벡터로 추출하는 코드는 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix3d m;
m &lt;&lt; 1, 2, 3,
     4, 5, 6,
     7, 8, 9;

Eigen::Vector3d v = m.col(0);
</code></pre>
<p>위 코드에서는 행렬 <code>m</code>의 첫 번째 열을 <code>v</code>에 할당했으며, <code>v</code>는 다음과 같이 나타납니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v} = \begin{bmatrix} 1 \\ 4 \\ 7 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{v} = \begin{bmatrix} 1 \\ 4 \\ 7 \end{bmatrix}
</script>
</div>
<p>이와 같이 벡터와 행렬의 변환은 매우 직관적이며, 이를 통해 다양한 형태의 수학적 계산을 유연하게 처리할 수 있습니다.</p>
<h3 id="_7">벡터와 행렬의 기본 연산</h3>
<p>Eigen 라이브러리에서 벡터와 행렬의 기본 연산은 수학적 정의와 일치하며, 매우 직관적으로 사용할 수 있습니다. 이러한 연산에는 벡터 간 또는 행렬 간의 덧셈, 뺄셈, 스칼라 곱셈, 내적, 외적 등이 포함됩니다.</p>
<h4 id="_8">벡터 덧셈과 뺄셈</h4>
<p>벡터의 덧셈과 뺄셈은 동일한 크기의 벡터끼리만 수행할 수 있습니다. 각 원소는 해당하는 위치의 원소끼리 더하거나 빼는 방식으로 연산됩니다. 예를 들어, 두 3차원 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v_1}</span><script type="math/tex">\mathbf{v_1}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v_2}</span><script type="math/tex">\mathbf{v_2}</script></span>의 덧셈은 다음과 같습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v_1} = \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix}, \quad \mathbf{v_2} = \begin{bmatrix} 4 \\ 5 \\ 6 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{v_1} = \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix}, \quad \mathbf{v_2} = \begin{bmatrix} 4 \\ 5 \\ 6 \end{bmatrix}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v_1} + \mathbf{v_2} = \begin{bmatrix} 1 + 4 \\ 2 + 5 \\ 3 + 6 \end{bmatrix} = \begin{bmatrix} 5 \\ 7 \\ 9 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{v_1} + \mathbf{v_2} = \begin{bmatrix} 1 + 4 \\ 2 + 5 \\ 3 + 6 \end{bmatrix} = \begin{bmatrix} 5 \\ 7 \\ 9 \end{bmatrix}
</script>
</div>
<p>이 연산은 코드로는 다음과 같이 표현됩니다.</p>
<pre><code class="language-cpp">Eigen::Vector3d v1(1, 2, 3);
Eigen::Vector3d v2(4, 5, 6);
Eigen::Vector3d v_sum = v1 + v2;
</code></pre>
<p>벡터 뺄셈의 경우도 유사하게 다음과 같이 정의됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v_1} - \mathbf{v_2} = \begin{bmatrix} 1 - 4 \\ 2 - 5 \\ 3 - 6 \end{bmatrix} = \begin{bmatrix} -3 \\ -3 \\ -3 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{v_1} - \mathbf{v_2} = \begin{bmatrix} 1 - 4 \\ 2 - 5 \\ 3 - 6 \end{bmatrix} = \begin{bmatrix} -3 \\ -3 \\ -3 \end{bmatrix}
</script>
</div>
<h4 id="_9">벡터의 스칼라 곱</h4>
<p>벡터와 스칼라의 곱은 벡터의 각 원소에 스칼라 값을 곱하는 방식으로 이루어집니다. 예를 들어, 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v} = \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix}</span><script type="math/tex">\mathbf{v} = \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix}</script></span>에 스칼라 2를 곱하면 다음과 같은 벡터가 됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
2 \cdot \mathbf{v} = \begin{bmatrix} 2 \cdot 1 \\ 2 \cdot 2 \\ 2 \cdot 3 \end{bmatrix} = \begin{bmatrix} 2 \\ 4 \\ 6 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
2 \cdot \mathbf{v} = \begin{bmatrix} 2 \cdot 1 \\ 2 \cdot 2 \\ 2 \cdot 3 \end{bmatrix} = \begin{bmatrix} 2 \\ 4 \\ 6 \end{bmatrix}
</script>
</div>
<p>코드로는 다음과 같이 작성됩니다.</p>
<pre><code class="language-cpp">Eigen::Vector3d v(1, 2, 3);
Eigen::Vector3d v_scaled = 2 * v;
</code></pre>
<h4 id="dot-product">벡터 내적 (Dot Product)</h4>
<p>내적은 두 벡터의 대응하는 원소를 곱한 뒤 합산하는 연산입니다. 예를 들어, 두 3차원 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v_1}</span><script type="math/tex">\mathbf{v_1}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v_2}</span><script type="math/tex">\mathbf{v_2}</script></span>의 내적은 다음과 같이 계산됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v_1} \cdot \mathbf{v_2} = 1 \cdot 4 + 2 \cdot 5 + 3 \cdot 6 = 4 + 10 + 18 = 32
</div>
<script type="math/tex; mode=display">
\mathbf{v_1} \cdot \mathbf{v_2} = 1 \cdot 4 + 2 \cdot 5 + 3 \cdot 6 = 4 + 10 + 18 = 32
</script>
</div>
<p>이는 코드로 다음과 같이 표현됩니다.</p>
<pre><code class="language-cpp">Eigen::Vector3d v1(1, 2, 3);
Eigen::Vector3d v2(4, 5, 6);
double dot_product = v1.dot(v2);
</code></pre>
<p>내적의 결과는 스칼라 값이 되며, 이는 두 벡터 사이의 방향성을 측정하는 데 사용될 수 있습니다.</p>
<h4 id="cross-product">벡터 외적 (Cross Product)</h4>
<p>외적은 3차원 벡터에서만 정의되며, 두 벡터의 외적은 새로운 3차원 벡터를 생성합니다. 외적은 두 벡터가 이루는 평면에 수직인 벡터를 구하는 연산으로, 다음과 같이 정의됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v_1} \times \mathbf{v_2} = \begin{bmatrix} v_{1y}v_{2z} - v_{1z}v_{2y} \\ v_{1z}v_{2x} - v_{1x}v_{2z} \\ v_{1x}v_{2y} - v_{1y}v_{2x} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{v_1} \times \mathbf{v_2} = \begin{bmatrix} v_{1y}v_{2z} - v_{1z}v_{2y} \\ v_{1z}v_{2x} - v_{1x}v_{2z} \\ v_{1x}v_{2y} - v_{1y}v_{2x} \end{bmatrix}
</script>
</div>
<p>예를 들어, 두 벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v_1} = \begin{bmatrix} 1 \\ 0 \\ 0 \end{bmatrix}</span><script type="math/tex">\mathbf{v_1} = \begin{bmatrix} 1 \\ 0 \\ 0 \end{bmatrix}</script></span>과 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v_2} = \begin{bmatrix} 0 \\ 1 \\ 0 \end{bmatrix}</span><script type="math/tex">\mathbf{v_2} = \begin{bmatrix} 0 \\ 1 \\ 0 \end{bmatrix}</script></span>의 외적은 다음과 같습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{v_1} \times \mathbf{v_2} = \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{v_1} \times \mathbf{v_2} = \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}
</script>
</div>
<p>코드로는 다음과 같이 구현됩니다.</p>
<pre><code class="language-cpp">Eigen::Vector3d v1(1, 0, 0);
Eigen::Vector3d v2(0, 1, 0);
Eigen::Vector3d cross_product = v1.cross(v2);
</code></pre>
<h4 id="_10">행렬 덧셈과 뺄셈</h4>
<p>행렬의 덧셈과 뺄셈은 벡터와 유사하게 같은 차원의 행렬끼리만 가능합니다. 두 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>가 있을 때, 이들의 덧셈은 다음과 같이 정의됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} + \mathbf{B} = \begin{bmatrix} a_{11} &amp; a_{12} \\ a_{21} &amp; a_{22} \end{bmatrix} + \begin{bmatrix} b_{11} &amp; b_{12} \\ b_{21} &amp; b_{22} \end{bmatrix} = \begin{bmatrix} a_{11} + b_{11} &amp; a_{12} + b_{12} \\ a_{21} + b_{21} &amp; a_{22} + b_{22} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} + \mathbf{B} = \begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix} + \begin{bmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \end{bmatrix} = \begin{bmatrix} a_{11} + b_{11} & a_{12} + b_{12} \\ a_{21} + b_{21} & a_{22} + b_{22} \end{bmatrix}
</script>
</div>
<p>예를 들어, 두 행렬을 더하는 코드는 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix2d A, B;
A &lt;&lt; 1, 2, 3, 4;
B &lt;&lt; 5, 6, 7, 8;
Eigen::Matrix2d C = A + B;
</code></pre>
<h4 id="_11">행렬의 스칼라 곱</h4>
<p>행렬의 스칼라 곱은 행렬의 각 원소에 스칼라 값을 곱하는 연산입니다. 예를 들어, 2x2 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 스칼라 값 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>에 대한 곱셈은 다음과 같이 정의됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
k \cdot \mathbf{A} = k \cdot \begin{bmatrix} a_{11} &amp; a_{12} \\ a_{21} &amp; a_{22} \end{bmatrix} = \begin{bmatrix} k \cdot a_{11} &amp; k \cdot a_{12} \\ k \cdot a_{21} &amp; k \cdot a_{22} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
k \cdot \mathbf{A} = k \cdot \begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix} = \begin{bmatrix} k \cdot a_{11} & k \cdot a_{12} \\ k \cdot a_{21} & k \cdot a_{22} \end{bmatrix}
</script>
</div>
<p>예를 들어, 스칼라 3과 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} = \begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix}</span><script type="math/tex">\mathbf{A} = \begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix}</script></span>의 곱은 다음과 같습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
3 \cdot \mathbf{A} = \begin{bmatrix} 3 \cdot 1 &amp; 3 \cdot 2 \\ 3 \cdot 3 &amp; 3 \cdot 4 \end{bmatrix} = \begin{bmatrix} 3 &amp; 6 &amp; \\ 9 &amp; 12 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
3 \cdot \mathbf{A} = \begin{bmatrix} 3 \cdot 1 & 3 \cdot 2 \\ 3 \cdot 3 & 3 \cdot 4 \end{bmatrix} = \begin{bmatrix} 3 & 6 & \\ 9 & 12 \end{bmatrix}
</script>
</div>
<p>이를 코드로 구현하면 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix2d A;
A &lt;&lt; 1, 2, 3, 4;
Eigen::Matrix2d B = 3 * A;
</code></pre>
<h4 id="_12">행렬 곱셈</h4>
<p>행렬 곱셈은 두 행렬의 곱을 계산하는 매우 중요한 연산입니다. 두 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>가 곱해질 수 있으려면, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 열 수와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>의 행 수가 동일해야 합니다. 두 행렬의 곱은 다음과 같이 계산됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \mathbf{A} \cdot \mathbf{B}
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \mathbf{A} \cdot \mathbf{B}
</script>
</div>
<p>예를 들어, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>가 2x3 행렬이고 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>가 3x2 행렬일 때, 이들의 곱은 다음과 같습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \end{bmatrix}, \quad \mathbf{B} = \begin{bmatrix} 7 &amp; 8 \\ 9 &amp; 10 \\ 11 &amp; 12 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}, \quad \mathbf{B} = \begin{bmatrix} 7 & 8 \\ 9 & 10 \\ 11 & 12 \end{bmatrix}
</script>
</div>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{C} = \mathbf{A} \cdot \mathbf{B} = \begin{bmatrix} 1 \cdot 7 + 2 \cdot 9 + 3 \cdot 11 &amp; 1 \cdot 8 + 2 \cdot 10 + 3 \cdot 12 \\ 4 \cdot 7 + 5 \cdot 9 + 6 \cdot 11 &amp; 4 \cdot 8 + 5 \cdot 10 + 6 \cdot 12 \end{bmatrix} = \begin{bmatrix} 58 &amp; 64 \\ 139 &amp; 154 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{C} = \mathbf{A} \cdot \mathbf{B} = \begin{bmatrix} 1 \cdot 7 + 2 \cdot 9 + 3 \cdot 11 & 1 \cdot 8 + 2 \cdot 10 + 3 \cdot 12 \\ 4 \cdot 7 + 5 \cdot 9 + 6 \cdot 11 & 4 \cdot 8 + 5 \cdot 10 + 6 \cdot 12 \end{bmatrix} = \begin{bmatrix} 58 & 64 \\ 139 & 154 \end{bmatrix}
</script>
</div>
<p>이를 코드로 구현하면 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::MatrixXd A(2, 3);
Eigen::MatrixXd B(3, 2);
A &lt;&lt; 1, 2, 3, 4, 5, 6;
B &lt;&lt; 7, 8, 9, 10, 11, 12;
Eigen::MatrixXd C = A * B;
</code></pre>
<h4 id="transpose">전치 행렬 (Transpose)</h4>
<p>전치 행렬은 주어진 행렬의 행과 열을 뒤바꾸는 연산입니다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">2 \times 3</span><script type="math/tex">2 \times 3</script></span> 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 전치 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}^T</span><script type="math/tex">\mathbf{A}^T</script></span>는 다음과 같이 정의됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \end{bmatrix}, \quad \mathbf{A}^T = \begin{bmatrix} 1 &amp; 4 \\ 2 &amp; 5 \\ 3 &amp; 6 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}, \quad \mathbf{A}^T = \begin{bmatrix} 1 & 4 \\ 2 & 5 \\ 3 & 6 \end{bmatrix}
</script>
</div>
<p>코드로는 <code>transpose()</code> 함수를 사용하여 전치 행렬을 구할 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::MatrixXd A(2, 3);
A &lt;&lt; 1, 2, 3, 4, 5, 6;
Eigen::MatrixXd A_T = A.transpose();
</code></pre>
<h4 id="inverse">역행렬 (Inverse)</h4>
<p>정방 행렬 (행과 열의 수가 같은 행렬) <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 역행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}^{-1}</span><script type="math/tex">\mathbf{A}^{-1}</script></span>은 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} \cdot \mathbf{A}^{-1} = \mathbf{I}</span><script type="math/tex">\mathbf{A} \cdot \mathbf{A}^{-1} = \mathbf{I}</script></span>가 성립할 때, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 대해 정의됩니다. 여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{I}</span><script type="math/tex">\mathbf{I}</script></span>는 단위 행렬입니다.</p>
<p>예를 들어, <span class="arithmatex"><span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script></span> 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>가 있을 때, 그 역행렬은 다음과 같이 계산됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}, \quad \mathbf{A}^{-1} = \frac{1}{ad - bc} \begin{bmatrix} d &amp; -b \\ -c &amp; a \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \begin{bmatrix} a & b \\ c & d \end{bmatrix}, \quad \mathbf{A}^{-1} = \frac{1}{ad - bc} \begin{bmatrix} d & -b \\ -c & a \end{bmatrix}
</script>
</div>
<p>코드로는 <code>inverse()</code> 함수를 사용하여 역행렬을 구할 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix2d A;
A &lt;&lt; 1, 2, 3, 4;
Eigen::Matrix2d A_inv = A.inverse();
</code></pre>
<h4 id="determinant">행렬식 (Determinant)</h4>
<p>행렬식은 정방 행렬에 대해 정의되며, 주어진 행렬이 역행렬을 가질 수 있는지 여부를 결정하는 데 사용됩니다. 예를 들어, <span class="arithmatex"><span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script></span> 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 행렬식은 다음과 같이 계산됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{det}(\mathbf{A}) = ad - bc
</div>
<script type="math/tex; mode=display">
\text{det}(\mathbf{A}) = ad - bc
</script>
</div>
<p>코드로는 <code>determinant()</code> 함수를 사용하여 행렬식을 구할 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix2d A;
A &lt;&lt; 1, 2, 3, 4;
double det = A.determinant();
</code></pre>
<h4 id="_13">단위 행렬과 영 행렬</h4>
<p>단위 행렬은 주대각선에 1이 있고, 나머지 원소가 모두 0인 정방 행렬입니다. <span class="arithmatex"><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> 단위 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{I}</span><script type="math/tex">\mathbf{I}</script></span>는 다음과 같습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{I} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{I} = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}
</script>
</div>
<p>Eigen에서는 <code>setIdentity()</code> 함수를 사용하여 단위 행렬을 만들 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix3d I;
I.setIdentity();
</code></pre>
<p>영 행렬은 모든 원소가 0인 행렬입니다. <span class="arithmatex"><span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script></span> 영 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{O}</span><script type="math/tex">\mathbf{O}</script></span>는 다음과 같이 나타냅니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{O} = \begin{bmatrix} 0 &amp; 0 \\ 0 &amp; 0 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{O} = \begin{bmatrix} 0 & 0 \\ 0 & 0 \end{bmatrix}
</script>
</div>
<p>코드로는 <code>setZero()</code> 함수를 사용하여 영 행렬을 만들 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix2d O;
O.setZero();
</code></pre>
<h3 id="block-operations">블록 연산 (Block Operations)</h3>
<p>Eigen 라이브러리에서는 행렬의 일부를 추출하거나 특정 영역에 대해 연산을 수행할 수 있는 블록 연산을 제공합니다. 이를 통해 행렬의 부분적인 조작이 가능합니다. 블록 연산은 행렬의 부분 집합을 참조하거나 변경할 때 유용하게 사용됩니다.</p>
<h4 id="_14">블록 추출</h4>
<p>블록 연산을 사용하여 행렬의 일부를 추출할 수 있습니다. 블록은 <code>block(i, j, p, q)</code> 함수를 사용하여 추출할 수 있으며, 이 함수는 행렬의 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>번째 행, <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>번째 열부터 시작하여 <span class="arithmatex"><span class="MathJax_Preview">p \times q</span><script type="math/tex">p \times q</script></span> 크기의 블록을 반환합니다.</p>
<p>예를 들어, 4x4 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에서 2x2 블록을 추출하는 코드는 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix4d A;
A &lt;&lt; 1, 2, 3, 4,
     5, 6, 7, 8,
     9, 10, 11, 12,
     13, 14, 15, 16;

Eigen::Matrix2d block = A.block(1, 1, 2, 2);
</code></pre>
<p>위 코드에서 <code>A.block(1, 1, 2, 2)</code>는 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 두 번째 행, 두 번째 열에서 시작하여 2x2 크기의 블록을 추출합니다. 추출된 블록은 다음과 같습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{block} = \begin{bmatrix} 6 &amp; 7 \\ 10 &amp; 11 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\text{block} = \begin{bmatrix} 6 & 7 \\ 10 & 11 \end{bmatrix}
</script>
</div>
<h4 id="_15">블록 삽입</h4>
<p>블록 연산은 행렬의 일부분을 변경하는 데도 사용될 수 있습니다. 특정 위치에 새로운 값을 삽입하는 방식으로 행렬의 일부를 변경할 수 있습니다. 예를 들어, 2x2 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>를 4x4 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 한 부분에 삽입하는 코드는 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix4d A;
A.setZero();  // 4x4 영 행렬로 초기화

Eigen::Matrix2d B;
B &lt;&lt; 1, 2, 3, 4;

A.block(1, 1, 2, 2) = B;
</code></pre>
<p>이 코드는 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 두 번째 행, 두 번째 열에서 시작하는 위치에 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>를 삽입합니다. 삽입 후의 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 다음과 같습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 2 &amp; 0 \\ 0 &amp; 3 &amp; 4 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 1 & 2 & 0 \\ 0 & 3 & 4 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix}
</script>
</div>
<h4 id="_16">행과 열 추출</h4>
<p>Eigen 라이브러리에서는 행렬의 특정 행이나 열을 추출할 수 있습니다. 예를 들어, 3x3 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 첫 번째 열을 추출하는 코드는 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix3d A;
A &lt;&lt; 1, 2, 3,
     4, 5, 6,
     7, 8, 9;

Eigen::Vector3d col = A.col(0);
</code></pre>
<p>추출된 첫 번째 열은 다음과 같이 나타납니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{col} = \begin{bmatrix} 1 \\ 4 \\ 7 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{col} = \begin{bmatrix} 1 \\ 4 \\ 7 \end{bmatrix}
</script>
</div>
<p>마찬가지로, 특정 행을 추출하려면 <code>row()</code> 함수를 사용할 수 있습니다. 예를 들어, 두 번째 행을 추출하는 코드는 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::Vector3d row = A.row(1);
</code></pre>
<p>추출된 두 번째 행은 다음과 같습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{row} = \begin{bmatrix} 4 &amp; 5 &amp; 6 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{row} = \begin{bmatrix} 4 & 5 & 6 \end{bmatrix}
</script>
</div>
<h3 id="_17">배열과 행렬의 연산 차이</h3>
<p>Eigen 라이브러리에서 행렬 클래스는 수학적 행렬 연산을 수행할 때 사용됩니다. 그러나 때로는 원소별 연산이 필요한 경우가 있습니다. 이때 <code>Array</code> 클래스를 사용하면 원소별 연산을 쉽게 수행할 수 있습니다. </p>
<h4 id="_18">원소별 연산</h4>
<p>행렬 연산과 배열 연산의 주요 차이점은 배열 연산에서는 원소별로 연산이 수행된다는 점입니다. 예를 들어, 두 2x2 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>의 원소별 곱셈은 다음과 같이 수행됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix}, \quad \mathbf{B} = \begin{bmatrix} 5 &amp; 6 \\ 7 &amp; 8 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix}, \quad \mathbf{B} = \begin{bmatrix} 5 & 6 \\ 7 & 8 \end{bmatrix}
</script>
</div>
<p>행렬 곱셈이 아닌 원소별 곱셈은 다음과 같이 계산됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \circ \mathbf{B} = \begin{bmatrix} 1 \cdot 5 &amp; 2 \cdot 6 \\ 3 \cdot 7 &amp; 4 \cdot 8 \end{bmatrix} = \begin{bmatrix} 5 &amp; 12 \\ 21 &amp; 32 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \circ \mathbf{B} = \begin{bmatrix} 1 \cdot 5 & 2 \cdot 6 \\ 3 \cdot 7 & 4 \cdot 8 \end{bmatrix} = \begin{bmatrix} 5 & 12 \\ 21 & 32 \end{bmatrix}
</script>
</div>
<p>이를 코드로 표현하면 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix2d A, B;
A &lt;&lt; 1, 2, 3, 4;
B &lt;&lt; 5, 6, 7, 8;
Eigen::Matrix2d result = A.array() * B.array();
</code></pre>
<p>여기서 <code>.array()</code>를 사용하여 행렬을 배열로 변환하고, 원소별 연산을 수행합니다. 이 방식은 덧셈, 뺄셈, 곱셈, 나눗셈 등 다양한 원소별 연산에 적용할 수 있습니다.</p>
<h3 id="_19">효율적인 메모리 관리</h3>
<p>Eigen 라이브러리는 메모리 관리 측면에서도 매우 효율적으로 설계되었습니다. 특히, 행렬 크기가 커질수록 메모리 할당과 관련된 최적화가 중요한데, Eigen은 이를 잘 지원합니다. Eigen의 다양한 메모리 관리 기법을 통해 고성능 계산을 지원합니다.</p>
<h4 id="pass-by-reference">참조에 의한 전달 (Pass by Reference)</h4>
<p>행렬을 함수에 전달할 때 복사가 발생하면 성능에 큰 영향을 미칠 수 있습니다. 따라서 큰 행렬을 함수에 전달할 때는 참조로 전달하는 것이 좋습니다. 예를 들어, 다음과 같이 참조를 통해 행렬을 전달할 수 있습니다.</p>
<pre><code class="language-cpp">void processMatrix(const Eigen::MatrixXd&amp; mat) {
    // 행렬을 처리하는 코드
}
</code></pre>
<p>여기서 <code>const Eigen::MatrixXd&amp;</code>는 복사가 아닌 참조를 사용하여 성능을 최적화하는 방식입니다.</p>
<h4 id="lazy-evaluation">메모리 보존 (Lazy Evaluation)</h4>
<p>Eigen은 지연 평가(lazy evaluation)를 통해 불필요한 계산을 줄이는 메커니즘을 가지고 있습니다. 이로 인해 다중 연산을 수행할 때 중간 결과를 저장하지 않고, 최종 결과만 계산하는 방식으로 메모리 사용을 줄일 수 있습니다.</p>
<p>예를 들어, 다음과 같은 코드에서:</p>
<pre><code class="language-cpp">Eigen::Vector3d v1, v2, v3;
Eigen::Vector3d result = v1 + v2 + v3;
</code></pre>
<p>Eigen은 내부적으로 <span class="arithmatex"><span class="MathJax_Preview">v1 + v2</span><script type="math/tex">v1 + v2</script></span>의 중간 결과를 저장하지 않고, 한 번의 계산으로 최종 결과를 구하도록 최적화합니다.</p>
<h3 id="memory-mapping">메모리 매핑 (Memory Mapping)</h3>
<p>Eigen에서는 외부 데이터 배열을 행렬이나 벡터로 직접 매핑하여 사용하는 기능을 제공합니다. 이는 메모리를 복사하지 않고 외부 데이터에 직접 접근할 수 있어 메모리 사용량과 계산 성능을 최적화하는 데 매우 유용합니다.</p>
<h4 id="_20">외부 데이터 매핑</h4>
<p>Eigen에서 제공하는 <code>Map</code> 클래스를 사용하면 외부에 정의된 배열을 직접 Eigen 객체로 매핑할 수 있습니다. 이를 통해 복사 없이 원본 데이터에 접근하여 연산을 수행할 수 있습니다.</p>
<p>예를 들어, C++에서 이미 존재하는 배열을 Eigen의 행렬로 매핑하는 방법은 다음과 같습니다.</p>
<pre><code class="language-cpp">double data[6] = {1, 2, 3, 4, 5, 6};
Eigen::Map&lt;Eigen::Matrix&lt;double, 2, 3&gt;&gt; mat(data);
</code></pre>
<p>이 코드는 배열 <code>data</code>를 <code>2x3</code> 행렬로 매핑합니다. 여기서 중요한 점은, <code>mat</code>은 배열 <code>data</code>를 복사하지 않고 그 데이터를 참조한다는 것입니다. 수학적으로, 이 행렬은 다음과 같이 나타납니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{M} = \begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\mathbf{M} = \begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}
</script>
</div>
<p>이처럼 <code>Map</code>을 통해 배열을 직접 참조하면 불필요한 메모리 할당을 피할 수 있으며, 이는 대규모 데이터를 처리할 때 매우 유용합니다.</p>
<h4 id="_21">행렬을 부분적으로 매핑</h4>
<p>또한 <code>Map</code> 클래스를 사용하면 행렬의 일부분만을 참조할 수도 있습니다. 예를 들어, 4x4 행렬에서 특정 2x2 블록만을 매핑하는 것은 다음과 같습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix4d A;
A &lt;&lt; 1, 2, 3, 4,
     5, 6, 7, 8,
     9, 10, 11, 12,
     13, 14, 15, 16;

Eigen::Map&lt;Eigen::Matrix2d&gt; block(A.data() + 5);
</code></pre>
<p>여기서 <code>A.data() + 5</code>는 4x4 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>의 특정 위치를 참조합니다. 매핑된 2x2 블록은 다음과 같습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\text{block} = \begin{bmatrix} 6 &amp; 7 \\ 10 &amp; 11 \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\text{block} = \begin{bmatrix} 6 & 7 \\ 10 & 11 \end{bmatrix}
</script>
</div>
<h4 id="_22">메모리 정렬과 벡터화</h4>
<p>Eigen은 성능 최적화를 위해 메모리 정렬(memory alignment)과 벡터화(vectorization)를 적극적으로 활용합니다. 이를 통해 현대 CPU의 SIMD(single instruction, multiple data) 명령어 세트를 사용하여 병렬 연산을 수행할 수 있습니다. </p>
<p>Eigen은 기본적으로 메모리를 16바이트 단위로 정렬하여, 벡터 연산을 최적화합니다. 이는 대규모 연산을 수행할 때 CPU 캐시와 메모리 접근 속도를 최적화하는 데 기여합니다.</p>
<p>메모리 정렬을 수동으로 조정하려면 Eigen의 <code>aligned_allocator</code>를 사용할 수 있습니다. 예를 들어, 다음과 같이 정렬된 벡터를 정의할 수 있습니다.</p>
<pre><code class="language-cpp">std::vector&lt;Eigen::Vector3d, Eigen::aligned_allocator&lt;Eigen::Vector3d&gt;&gt; vecs;
</code></pre>
<p>이 방식은 대규모 벡터나 행렬을 사용할 때 특히 성능 향상을 제공합니다.</p>
<h3 id="eigen">Eigen의 고급 기능</h3>
<p>Eigen은 기본적인 선형대수 연산 외에도 다양한 고급 기능을 제공합니다. 이러한 기능에는 행렬 분해, 특이값 분해(SVD), 고유값 분해(Eigenvalue Decomposition) 등이 포함됩니다. 이 섹션에서는 이러한 고급 기능에 대해 간략히 살펴봅니다.</p>
<h4 id="lu">LU 분해</h4>
<p>LU 분해는 정방 행렬을 하삼각 행렬(Lower triangular matrix)과 상삼각 행렬(Upper triangular matrix)의 곱으로 분해하는 방법입니다. LU 분해는 선형 방정식 시스템을 푸는 데 사용됩니다. </p>
<p>행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 대한 LU 분해는 다음과 같이 나타낼 수 있습니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{L} \cdot \mathbf{U}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{L} \cdot \mathbf{U}
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>은 하삼각 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>는 상삼각 행렬입니다.</p>
<p>Eigen에서 LU 분해는 <code>FullPivLU</code> 클래스를 사용하여 수행할 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix3d A;
A &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9;
Eigen::FullPivLU&lt;Eigen::Matrix3d&gt; lu(A);

Eigen::Matrix3d L = lu.matrixL();
Eigen::Matrix3d U = lu.matrixU();
</code></pre>
<h4 id="qr">QR 분해</h4>
<p>QR 분해는 행렬을 직교 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span>와 상삼각 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>의 곱으로 분해하는 방법입니다. QR 분해는 행렬의 고유값을 구하거나 최소제곱 문제를 해결하는 데 유용하게 사용됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{Q} \cdot \mathbf{R}
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{Q} \cdot \mathbf{R}
</script>
</div>
<p>Eigen에서 QR 분해는 <code>HouseholderQR</code> 클래스를 사용하여 수행할 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::MatrixXd A(3, 3);
A &lt;&lt; 12, -51, 4,
     6, 167, -68,
     -4, 24, -41;
Eigen::HouseholderQR&lt;Eigen::MatrixXd&gt; qr(A);

Eigen::MatrixXd Q = qr.householderQ();
Eigen::MatrixXd R = qr.matrixQR().triangularView&lt;Eigen::Upper&gt;();
</code></pre>
<h4 id="svd">특이값 분해 (SVD)</h4>
<p>특이값 분해(SVD, Singular Value Decomposition)는 임의의 행렬을 세 개의 행렬로 분해하는 강력한 기법입니다. 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>는 다음과 같이 분해됩니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} = \mathbf{U} \cdot \mathbf{\Sigma} \cdot \mathbf{V}^T
</div>
<script type="math/tex; mode=display">
\mathbf{A} = \mathbf{U} \cdot \mathbf{\Sigma} \cdot \mathbf{V}^T
</script>
</div>
<p>여기서 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{U}</span><script type="math/tex">\mathbf{U}</script></span>와 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{V}</span><script type="math/tex">\mathbf{V}</script></span>는 직교 행렬, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\Sigma}</span><script type="math/tex">\mathbf{\Sigma}</script></span>는 대각 행렬입니다. SVD는 행렬의 순위(rank)를 구하거나 차원 축소(dimensionality reduction) 문제에 매우 유용하게 사용됩니다.</p>
<p>Eigen에서 SVD는 <code>JacobiSVD</code> 클래스를 사용하여 수행할 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::MatrixXd A(3, 2);
A &lt;&lt; 1, 0, 0, 1, 0, 0;
Eigen::JacobiSVD&lt;Eigen::MatrixXd&gt; svd(A, Eigen::ComputeThinU | Eigen::ComputeThinV);

Eigen::MatrixXd U = svd.matrixU();
Eigen::MatrixXd V = svd.matrixV();
Eigen::VectorXd S = svd.singularValues();
</code></pre>
<h4 id="eigenvalue-decomposition">고유값 분해 (Eigenvalue Decomposition)</h4>
<p>고유값 분해는 행렬을 고유값(eigenvalue)과 고유벡터(eigenvector)로 분해하는 방법입니다. 정방 행렬 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>에 대해, 고유값 <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>와 고유벡터 <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}</span><script type="math/tex">\mathbf{v}</script></span>는 다음 관계를 만족합니다.</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\mathbf{A} \mathbf{v} = \lambda \mathbf{v}
</div>
<script type="math/tex; mode=display">
\mathbf{A} \mathbf{v} = \lambda \mathbf{v}
</script>
</div>
<p>Eigen에서 고유값 분해는 <code>EigenSolver</code> 클래스를 사용하여 수행할 수 있습니다.</p>
<pre><code class="language-cpp">Eigen::Matrix3d A;
A &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9;
Eigen::EigenSolver&lt;Eigen::Matrix3d&gt; es(A);

Eigen::Vector3d eigenvalues = es.eigenvalues().real();
Eigen::Matrix3d eigenvectors = es.eigenvectors().real();
</code></pre>
<p>고유값 분해는 행렬의 성질을 이해하거나 시스템의 안정성을 분석하는 데 유용합니다.</p>

  <br>
    

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>